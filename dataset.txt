Describe the mechanics of the following Ludii game
(game "Susan" 
    (players 2) 
    (equipment { 
        (board (hex 5)) 
        (piece "Marker" Each "StepOrthogonalToEmpty")
    }) 
    
    (rules 
        (play (or
                (move Add 
                    (to (sites Empty)) 
                    (then (set Counter)) 
                )
                (forEach Piece)
                (then 
                    (priority 
                        ("SurroundedOf" Friend (trigger "Surrounded" (mover)))
                        ("SurroundedOf" Enemy (trigger "Surrounded" (next)))
                    )
                )
            )
        )
        
        (end {
            (if "ThreeSlideInARow" (result Mover Draw))
            (if "SurroundedMySelf" (result Next Win))
            (if ("SurroundedOver" P1) (result P2 Win)) 
            (if ("SurroundedOver" P2) (result P1 Win)) 
        }) 
    )
)
Susan was invented by Stephem Linhart in 1991. It is played on a hexagonal board.Players alternate turns. A player's turn consists on either placing piece on an empty field on board, or sliding one of their pieces into an empty one on the board. Players cannot pass. If each player performs three slides in a row then the game ends immediately as a draw. A player wins when any of the opponent's pieces are surrounded and cannot move. If one of a player's own pieces is surrounded on their turn, they lose even if an opponent's stone is surrounded at the same time. 

Construct a Ludii game based on the following description
Dama is the version of Draughts as played in Italy. These rules have been documented since at least the sixteenth century.8x8 Draughts board. Twelve pieces per player, arranged on the three rows closest to the players. Players alternate turns moving a piece forward diagonally to an adjacent empty space. Pieces capture an opponent's piece by hopping over it to an empty space on the opposite side of it, in a forward direction only. Captures are mandatory, and the maximum number of captures is required.  Kings are made when a piece reaches the opposite edge of the board from where it started. Kings may move one space diagonally in either direction, and capture rules are the same as for pieces, except when different capturing routes are available with the same number of captures, the one which takes the most kings must be taken. In addition, if a sequence of captures can be made by a king or a regular piece, it must be made with the king. Kings cannot be captured by regular pieces. When a piece does not capture the maximum number of captures and the opponent catches it, the opponent captures the opponent's piece. The first player to capture all of the opponent's pieces wins. 
(game "Dama (Italy)" 
    (players 2) 
    ("DraughtsEquipment" (square 8)) 
    (rules 
        ("BlackCellsSetup" 3)
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves 
                        ("HopOnlyCounters" (from (last To)) (directions {FR FL})
                            (then 
                                ("PromoteIfReach" (sites Next) "DoubleCounter"
                                    ("ReplayIfCanMove" ("HopOnlyCounters" (from (last To)) (directions {FR FL}))) 
                                ) 
                            ) 
                        )
                    )
                    (max Moves ("HopDiagonalSequenceCaptureAgain"))
                )
                (priority {
                    (max Moves
                        (priority {
                            (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture"))
                            (forEach Piece "Counter" 
                                ("HopOnlyCounters" (from) (directions {FR FL}) 
                                    (then 
                                        ("PromoteIfReach" (sites Next) "DoubleCounter"
                                            ("ReplayIfCanMove" ("HopOnlyCounters" (from (last To)) (directions {FR FL}))) 
                                        ) 
                                    ) 
                                ) 
                            )
                        })
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL})) 
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" "StepDiagonalToEmpty")
                    )
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "Wari" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6
            {
            (track "Track" "1,E,N,W" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play
            (move Select
                (from 
                    (sites Mover)
                    if:(> (count at:(from)) 0)		
                )
                (then
                    (sow
                        apply:(if (= 6 (count at:(to)))
                            (fromTo
                                (from (to))
                                (to (mapEntry Mover))
                                count:6
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)
Wari is a two-row mancala-style board game played by the Ashanti people of West Africa.2x6 board with two stores. Four counters in each hole. Players alternate turns sowing from one of the holes on their side of the board in an anticlockwise direction. When a counter lands in one of the opponent's holes, making it contain six counters, those counters are captured. The player who captures the most counters wins.
         

Construct a Ludii game based on the following description
Um el-Bagara is a two-row mancala-style game board from Sudan. It was documented in the early twentieth century but is probably much older. The game is usually played as holes dug into the sand.2x5 board. Play begins with five counters in each hole. Players sow from any one of their holes. Sowing can occur in the following directions: From the leftmost two holes: clockwise. From the rightmost two holes: anti-clockwise. from the center hole: the player may choose either direction. If the final counter falls into a hole in the opponent's row containing either one or three counters, making it now contain two or four, these are taken. If the holes before them also contain two or four, in an unbroken sequence, they may all be captured. Single counters cannot be sown. When neither player can move, the single counters in each player's rows are taken by the player belonging to those rows. The player with the most counters wins. 
(game "Um el-Bagara" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 5 store:None
            { 
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "4,W,N,E" loop:True)
            }
        )
        (regions "Home1" P1 (sites Bottom))    
        (regions "Home2" P2 (sites Top))    
        (regions "Left1" P1 (sites {0..2}))   
        (regions "Left2" P2 (sites {9..7}))   
        (regions "Right1" P1 (sites {2..4}))   
        (regions "Right2" P2 (sites {7..5}))   
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 5 to:(sites Track))) 
        
        (play (or 
                ("Sow" "Left" "TrackCW")
                ("Sow" "Right" "TrackCCW")
            )
        )
        
        (end ("MancalaByScoreWhen" (all Passed)))
    )
)

Construct a Ludii game based on the following description
This game was played in during the sixteenth century by the Mapuche people of South America, but its name is not given in the sources. It is a race game with captures that is similar to other games from South America which were played in the nineteenth and twentieth centuries.21 holes, arranged in an arc, the central hole larger than the others. Ten pieces per player, each player's pieces beginning on one side of the board, one in each hole. Four beans used as dice, with a black side and a white side. The throws are as follows: Four white sides up = 4; four black sides up = 3; two white/two black up = 2; three white or three black = player loses their turn. Players continue to throw until they lose their turn. If a piece lands in the central hole, and it cannot move from it on its next opportunity, it is removed from the game. Pieces moving into the opponent's side of the board capture any of the opponent's pieces which occupy a space on which they land. When a piece reaches the end of the track, they proceed back in the other direction. The player who captures all ten of the opponent's pieces wins. 
(game "Mapuche Game"
    (players 2)
    (equipment {
        (board
            (remove
                (concentric {26})
                vertices:{0..4}
            )
            {
            (track "TrackCW1" {0 2 4 6 8 10 12 14 16 18 20 19 17 15 13 11 9 7 5 3 1} P1 directed:True)
            (track "TrackCCW1" {1 3 5 7 9 11 13 15 17 19 20 18 16 14 12 10 8 6 4 2 0} P1 directed:True)
            (track "TrackCW2" {0 2 4 6 8 10 12 14 16 18 20 19 17 15 13 11 9 7 5 3 1} P2 directed:True)
            (track "TrackCCW2" {1 3 5 7 9 11 13 15 17 19 20 18 16 14 12 10 8 6 4 2 0} P2 directed:True)
            }
            use:Vertex
        )
        (regions "AllSitesExceptTop" (difference (sites Board) "BigHole"))
        (piece "Marker" Each
            (if ("IsNotOffBoard" "SiteToMoveOnTrack")
                (if (or
                        (is In "SiteToMoveOnTrack" (sites Empty))
                        ("IsEnemyAt" "SiteToMoveOnTrack")
                    )
                    (move 
                        (from)
                        (to 
                            "SiteToMoveOnTrack" 
                            "CaptureEnemyPiece"
                        )
                    )
                )
            )
        )
        ("StickDice" 4)
        (map "ThrowDiceValue" {(pair 0 4) (pair 1 0) (pair 2 2) (pair 3 0) (pair 4 3)})
        (hand Each)
    })
    (rules 
        (start {
            (place "Marker1" (sites {0 2 4 6 8 10 12 14 16 18}))
            (place "Marker2" (sites {1 3 5 7 9 11 13 15 17 19}) state:1)
        })
        (play 
            ("RollMove"
                (if (can Move (if (!= ("ThrowValue") 0) (forEach Piece)))
                    (forEach Piece (then (if (!= ("ThrowValue") 0) (moveAgain))))
                    (move Pass (then (if (!= ("ThrowValue") 0) (moveAgain))))
                )
                (then 
                    (and
                        (if (and (is Occupied "BigHole") (!= "BigHole" (last To)))
                            (remove "BigHole")
                        )
                        (if (= (last To) ("EndSiteOfTrack"))
                            ("ChangeOfTrack")
                        )
                    )
                )
            )
        )
        (end {
            ("CaptureAll" P1)
            ("CaptureAll" P2)
        })
    )
)

Construct a Ludii game based on the following description
Breakthru is a modern member of the Hnefatafl family of games, where the players have unequal forces and different objectives. Objectives
            One player has a gold fleet consisting of one large flagship and twelve escorts, with the objective of evading capture while breaking through his or her opponent's blockade to transport the flagship to the perimeter of the board. The other player has a silver fleet of twenty ships, and forms a blockade to trap the gold flagship and destroy the gold fleet's escorts with the objective of capturing the flagship.
            
            Setup
            Gold player places the flagship on the center square of the game board, and positions the rest of the ships anywhere within the boldly ruled central area of the board.
            
            Silver player then positions the silver ships on twenty squares in the lightly ruled peripheral area of the board.
            
            Play
            Gold player chooses who goes first. Players move alternately by making two moves or one capture anywhere on the board. When the flagship is moved, only one move or capture is made (thus only the flagship).
            
            Moves
            A player may move two of the smaller playing pieces any number of vacant squares either horizontally or vertically on the board (as a rook in Chess, except that no captures can be made with this move), although if the flagship is moved, the gold player may not move another playing piece.
            
            Captures
            A player may move any playing piece (including the flagship) one square diagonally to capture one of his opponent's playing pieces. (This move is similar to the capture-move of the pawn in Chess, except that captures can be made on any of the four diagonals.)
            
            This game uses displacement capture (like Chess), rather than custodial capture (like Hnefatafl), thus when a capture is made, the captured piece is removed from the board and the vacated square is occupied by the captor.
            
        Play continues until one player achieves his or her objective. If the flagship of the gold fleet reaches one of the outermost squares on the board, gold player wins. If the flagship is captured before it reaches the outer edge of the board, silver player wins. 
(game "Breakthru"
    (players 2)
    (equipment {
        (board (square 11))
        (piece "Disc" Each 
            (or 
                (if ("NewTurn") ("StepToEnemy" Diagonal))
                (move Slide Orthogonal (then (if ("NewTurn") (moveAgain))))
            )
        )
        (piece "Commander" P1 
            (if ("NewTurn") 
                (or 
                    ("StepToEnemy" Diagonal)
                    (move Slide Orthogonal)
                )
            )
        )
        (hand Each)
        (regions "CentreSites" (expand (sites Centre) steps:2))
    })
    (rules
        (start {
            (place "Commander1" (sites Centre))
            (place "Disc1" (handSite P1) count:12)
            (place "Disc2" (handSite P2) count:20)
        })
        phases:
        {
        (phase "PlacementP1"
            (play 
                (move 
                    (from (handSite P1))
                    (to (intersection (sites "CentreSites") (sites Empty)))
                    (then (if (is Occupied (handSite P1)) (moveAgain)))
                )
            )
            (nextPhase (is Empty (handSite P1)) "PlacementP2")
        )
        
        (phase "PlacementP2"
            (play 
                (move 
                    (from (handSite P2))
                    (to (difference (sites Empty) (sites "CentreSites")))
                    (then (if (is Occupied (handSite P2)) (moveAgain)))
                )
            )
            (nextPhase (is Empty (handSite P2)) "Movement")
        )
        
        ("PhaseMovePiece" "Movement"
            (end {
                ("PieceTypeReachWin" "Commander1" (sites Outer) P1)
                (if ("IsOffBoard" (where "Commander" P1)) (result P2 Win))
            })
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Shodra"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (hand Each size:5)
        ("ChessKing" "King_noCross")
        ("ChessRook" "Rook")
        (piece "Camel" Each
            (move Hop Diagonal 
                (between if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        ("IsEnemyAt" (to))
                    ) 
                    (apply (remove (to)))
                ) 
            )			
        )
        ("ChessKnight" "Knight")
        ("ChessPawn" "Pawn"
            (if (is In (from) (sites Start (piece (what at:(from)))))
                ("DoubleStepForwardToEmpty")
            )
            (then ("PromoteIfReach" (sites Mover "Promotion") "Dog"))
        )
        (piece "Dog" Each ("StepToNotFriend" Diagonal))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Camel1" {"C1" "F1"}) (place "Dog1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Camel2" {"C8" "F8"}) (place "Dog2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        (play 
            (do
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        (end 
            (if (and 
                    ("IsInCheck" "King_noCross" Next)
                    ("NextCanNotMove")
                ) 
                {
                (if (no Pieces Next "Pawn") (result Mover Win))
                (if (!= (count Pieces Next "Pawn") 0) (result Mover Draw))
                }
            ) 
        )
    )
)
Shodra is a game related to others which are derived from Indian Chaturanga played by the Soyot people of eastern Russia. It involves the stipulation that to win, a player must capture all of the opponent's pawns.8x8 checkered board, with the left corner black for each player. Pieces with specialized moves, as follows: Noyion (x1): moves one space in any direction; Merzé (x1, \ 

Construct a Ludii game based on the following description
So Long Sucker is a board game invented in 1950 by John Forbes Nash, Mel Hausner, Lloyd S. Shapley and Martin Shubik. It is a four-person bargaining/economic strategy game. Each player begins the game with 7 chips, and in the course of play, attempts to acquire all the other players' chips.The rules are as follows:
            
            1. Starting a game:
            - Each player takes 7 chips of one color.
            - No two players may start with the same color chips.
            - This player places a chip onto the playing area, and selects any other player to be the next person to move.
            
            2. Playing the game:
            - Move by playing a chip of any color onto the playing area (starting a new pile), or on top of any existing chip(s) in the playing area.
            - If no chips are captured (see below), the player selects the next person to move, so long as that person's starting chip color is not in the stack just played on (this may be the same person, if that person used a captured chip). However, if all four colors are in the stack just played on, the next person must be the player whose most-recently played chip (by color) is furthest down in the stack
            - Chips are captured by playing two chips of the same color consecutively on one pile. The player designated by that color must kill one chip of their choice out of that pile, and take the rest. Then they get the next move. Killed chips are taken out of the game.
            - A chip is a prisoner when held by a player other than the original owner.
            - Any prisoner in a player's possession may be killed or transferred to another player at any time. Such transfers are unconditional and cannot be retracted. A player may not transfer or kill chips of their own color.
            - A player is defeated when given the move, but has no chips in their possession (and hence is unable to play).
            a. Defeat is not final until every player holding prisoners has refused to rescue the defeated player by transferring chips.
            b. After defeat, the move returns to the player who gave the defeated player the move.
            c. The defeated player's chips remain in play as prisoners, but are ignored in determining the order of play.
            d. If a pile is captured by the chips of a defeated player, the entire pile is killed, and the move rebounds to the capturing player.
            
            3. Order of play:
            - If a capture occurs: the player whose color made the capture gets the next move.
            - If a player is defeated: move returns to the player who gave the defeated player the move. If this should also defeat that player in turn, whoever gave that player the move will get the next turn, etc.
            - Otherwise, the next player to move is decided by last player to have moved as follows:
            a. They may give the move to any player (including themselves) whose color is not represented in the pile just played upon.
            b. If all players are represented in that pile, the move goes to the player whose most-recently played chip is furthest down in the pile.
            
            4.Winning the game:
            - The winner is the last surviving player (after the others have been defeated).
        - A player can win even if they hold no chips and all of their chips have been killed. 
(game "So Long Sucker" 
    (players 4) 
    (equipment { 
        (board (rectangle 4 7))
        (hand Each size:5)
        (piece "Marker" Each)
    }) 
    (rules
        (start {
            (place Stack "Marker1" (handSite P1) count:7)
            (place Stack "Marker2" (handSite P2) count:7)
            (place Stack "Marker3" (handSite P3) count:7)
            (place Stack "Marker4" (handSite P4) count:7)
        })
        
        (play 
            (if ("APlayerCanLose")
                (or 
                    (move Set NextPlayer (player (next)) (then (note "Fuck You Buddy!")))
                    (move
                        (from
                            (forEach (sites Hand Mover) 
                                if:(and 
                                    (!= (site) (handSite Mover 0))
                                    (is Occupied (site))
                                )
                            )
                        )
                        (to (handSite Player (var "CanBeDefeated")))
                        (then
                            (and {
                                (set NextPlayer (player (var "CanBeDefeated")))
                                (set Var "CanBeDefeated" Undefined)		
                                (set Var "PrevWas" Undefined)
                            })
                        )
                    )
                )
                (if ("ACaptureWasMade")
                    (forEach Level (last To)
                        (move Remove (last To) level:(level))
                        (then
                            (and {
                                (forEach Level (last To)
                                    (fromTo
                                        (from (last To) level:(level))
                                        (to 
                                            (if (is Mover (who at:(last To) level:(level)))
                                                (handSite Mover 0)
                                                (handSite Mover (who at:(last To) level:(level)))
                                            )
                                        )
                                    )
                                )
                                (moveAgain)
                                (set Pending)
                                (set Var "CaptureWasMade" 0)
                            })
                        )
                    )
                    (if (and (not (is Pending)) ("SameTurn"))
                        (if ("AllActivePlayersInLastStack")
                            (move Set NextPlayer (player ("OwnerMostRecentPlayedChip")))
                            (forEach Player
                                (if (and (is Active (player)) (not (is In (player) ("OwnerInLastStack"))))
                                    (move Set NextPlayer (player (player)))
                                )
                            )
                            (then (set Pending))
                        )
                        (if ("NoChip")
                            (if (= Undefined (var "CanBeDefeated"))
                                (move Pass 
                                    (then
                                        (and
                                            (set Var "CanBeDefeated" (mover))
                                            (set Var "PrevWas" (prev))
                                        )
                                    )
                                )
                                (move Pass 
                                    (then 
                                        (and {
                                            (set Var "Defeat" (mover))
                                            (set Var "CanBeDefeated" Undefined)
                                            (if (is Active (var "PrevWas"))
                                                (set NextPlayer (player (var "PrevWas")))
                                                (set NextPlayer (player (next)))
                                            )
                                            (set Var "PrevWas" Undefined)
                                        })
                                    )
                                )
                            )
                            (or {
                                (move 
                                    (from (sites Hand Mover))
                                    (to (sites Board))
                                    (then
                                        (if ("ACaptureIsMade")
                                            (if (is Active (who at:(last To) level:(- (size Stack at:(last To)) 1)))
                                                (and
                                                    (set Var "CaptureWasMade" 1)
                                                    (set NextPlayer (player (who at:(last To))))
                                                )
                                                (and {
                                                    (forEach Level (last To)
                                                        (remove (last To) level:(level))
                                                    )
                                                    (moveAgain)
                                                    (set Pending)
                                                })
                                            )
                                            (moveAgain)
                                        )
                                    )
                                ) 
                                (move Remove
                                    (forEach (sites Hand Mover) 
                                        if:(and 
                                            (!= (site) (handSite Mover 0))
                                            (is Occupied (site))
                                        )
                                    )
                                )
                                (forEach Player 
                                    (if (not (is Mover Player))
                                        (move
                                            (from
                                                (forEach (sites Hand Mover) 
                                                    if:(and 
                                                        (!= (site) (handSite Mover 0))
                                                        (is Occupied (site))
                                                    )
                                                )
                                            )
                                            (to (handSite Player (who at:(from))))
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
        )
        
        (end 
            (if (is Mover (var "Defeat")) (result Mover Loss))
        )
    )
)

Construct a Ludii game based on the following description
Spartan Chess is a chess variant played on a standard 8x8 chess board. The two sides have pieces and pawns with different characteristics and capabilities. Such differences you would expect between opponents on an actual ancient battlefield.The Black side represents the Spartans and the White the Persians. The Persians have pawns, pieces, an initial placement and move in accord with the rules of orthodox chess. The Spartans have two Kings and with the exception of their Kings, every Spartan playing piece moves differently from any piece found in orthodox chess.<b>The Pieces</b>
            - <i>White</i> (the Persians) has orthodox chess pieces in standard spaces: 2 Rooks (A1, H1); 2 Knights (B1, G1); 2 Bishops (C1, F1); 1 Queen (D1); 1 King (E1); 8 Pawns (A2-H2).
            - <i>Black</i> (the Spartans) has: 2 Lieutenants (A8, H8); 1 General (B8); 1 Warlord (G8); 2 Kings (C8, F8); 2 Captains (D8, E8); 8 Hoplites (A7-H7).
            <b>The Moves</b>
            - <i>Pawns</i> can move (but not capture) one space forward. On their first move they can move two spaces forward. They capture one space diagonally forward. There is no en passant rule.
            - <i>Rooks</i> can move and capture any number of spaces orthogonally.
            - <i>Bishops</i> can move and capture any number of spaces diagonally.
            - <i>Knights</i> can move one space orthogonally with one space forward diagonally leaping over intervening pieces and capturing what they land on.
            - The <i>Queen</i> can move and capture any number of spaces orthogonally or diagonally.
            - <i>Kings</i> can move and capture one space orthogonally or diagonally.
            - <i>Lieutenants</i> (shown as crosses) can move and capture diagonally upto two spaces, jumping over any piece if necessary. They can also move (but not capture) one space sideways.
            - The <i>General</i> (shown as an upside-down rook) can move and capture any number of spaces orthogonally or one space diagonally.
            - The <i>Warlord</i> (shown as an upside-down bishop) can move and capture any number of spaces diagonally or like a knight.
            - <i>Captains</i> (shown as squares) can move and capture upto spaces orthogonally and may jump if necessary.
            - <i>Hoplites</i> (shown as an upside-down pawns) can move (but not capture) one space diagonally forward. On their first move they can move two spaces diagonally forward, jumping if necessary. They capture one space forward.
            <b>Winning</b>
            The Spartan and Persian have different victory conditions.
            <i>Spartan Victory</i>: The Spartan wins when the Persian King is checkmated as in orthodox chess.
            <i>Persians Victory</i>: The Persian wins once one of the Spartan Kings is captured and the remaining Spartan King is checkmated or when both Spartan Kings are placed under simultaneous attack (duple-check) and neither King can be removed from attack on the next move (Duple-Check and Mate).
            <b>First Move</b>
            The Persians, being the aggressors historically and White, always move first.
            <b>Check Immunity</b>
            When the Spartan has two Kings in play a Spartan King is immune from check. Thus, the Spartan may move a King onto an enemy attacked square, leave a King under attack or move a piece that would expose a King to attack.
            <b>Duple-Check & Mate</b>
            If both Spartan Kings are placed under simultaneous attack this is a form of check called duple-check. It is illegal for the Spartan to make a move that will place both of his Kings underattack. With both Kings under attack, the Spartan loses if on his move he is unable to remove at least one King from attack. In such case the game ends in checkmate.
            <b>Promotion</b>
            A hoplite, upon reaching its 8th rank, may promote to any Spartan piece including a King but only if the Spartan has only one king in play.
            A pawn, upon reaching its 8th rank, may promote to any Persian piece apart from the King.
            <b>Capturing en passant</b>
            There is no capturing en passant in Spartan Chess.
            <b>Castling</b>
        Spartan Kings may not castle. Persian Kings may castle as normal. 
(game "Spartan Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        (piece "Pawn" P1 
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("PawnDoubleMove" Forward (between if:(is Empty (between))))
                )
                ("PawnMove" Forward) 
                ("PawnCapture" ("PawnDirections"))
                }
                ("PawnPromotion")
            )
        )
        (piece "Hoplite" P2
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("PawnDoubleMove" ("PawnDirections"))
                )
                ("PawnMove" ("PawnDirections")) 
                ("PawnCapture" Forward)
                }
                ("PawnPromotion")
            )
        )
        
        (piece "Rook" P1
            ("SlideMove" Orthogonal "RememberPieceHasMoved")
        )
        (piece "General" P2
            (or
                ("SlideMove" Orthogonal)
                ("StepMove" Diagonal) 
            )
        )
        (piece "Warlord" P2
            (or
                ("SlideMove" Diagonal)
                ("KnightMove") 
            )
        )
        (piece "Lieutenant" P2
            (or {
                ("StepMove" Diagonal) 
                ("HopMove" Diagonal)
                (move
                    Step 
                    (directions { W E }) 
                    (to 
                        if:(is Empty (to))
                    ) 
                )
            })
        )
        (piece "Captain" P2
            (or
                ("StepMove" Orthogonal) 
                ("HopMove" Orthogonal)
            )
        )
        
        (piece "King" Each
            ("StepMove" Adjacent ("RememberPieceHasMoved")) 
        )
        (piece "Bishop" P1 
            ("SlideMove" Diagonal)
        )
        (piece "Knight" P1
            ("KnightMove")
        )
        (piece "Queen" P1 
            ("SlideMove")
        )
        
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
        }
    ) 
    (rules 
        (start
            { 
            (place "Pawn1" (sites Row 1))
            (place "Hoplite2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1)
            (place "Knight1" {"B1" "G1"})
            (place "Bishop1" {"C1" "F1"})
            (place "Queen1" coord:"D1")
            (place "King1" coord:"E1" state:1) 
            (place "Lieutenant2" {"A8" "H8"})
            (place "Warlord2" {"G8"})
            (place "General2" {"B8"})
            (place "King2" {"C8" "F8"} state:0)
            (place "Captain2" {"D8" "E8"})
            }
        )
        
        (play 
            (if "SameTurn"
                (if (= (mover) (id P1))
                    (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                    (if (= 1 ("CountSpartanKings"))
                        (move Promote (last To) (piece {"King" "Captain" "General" "Warlord" "Lieutenant"}) Mover)
                        (move Promote (last To) (piece {"Captain" "General" "Warlord" "Lieutenant"}) Mover)
                    )
                )	
                (do 
                    (or 
                        (forEach Piece)
                        (if (and {
                                "KingInTheInitialPlace" 
                                ("HasNeverMoved" "KingPosition")
                                (not ("IsInCheck" "King" Mover)) 
                            })
                            (or
                                (if (and 
                                        ("HasNeverMoved" "RookLeft")
                                        (can Move ("DoCastle" "RookLeft" E 3 (is Empty (to))))
                                    )
                                    "BigCastling"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookRight")
                                        (can Move ("DoCastle" "RookRight" W 2 (is Empty (to))))
                                    )
                                    "SmallCastling"
                                )
                            )
                        )
                    )
                    ifAfterwards:(not ("IsInOmnicheck" Mover))
                )
            )
        )
        
        (end
            {
            (if (and 
                    ("IsInOmnicheck" Next)
                    ("NextCanNotMove")
                ) 
                (result Mover Win)
            ) 
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
            }
        )
    )
)

Construct a Ludii game based on the following description
Wöré was observed in the early twentieth century in St. Louis, Senegal. It was considered a game for women, and in some families it is forbidden for young girls and uncircumcised boys to play it.Counters are placed in piles: two rows of four piles. Six counters in each pile. A player sows from any of the piles in the player's row in an anti-clockwise direction. Any pile which contains 2, 4, or 6 counters is captured. The player with the most counters captured wins. 
(game "Wore" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 4 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    
    (rules 
        (start (set Count 6 to:(sites Track)))		 
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(< 0 (count at:(from)))
                )
                (then 
                    (sow 
                        if:(or { 
                            (= (count at:(to)) 2) 
                            (= (count at:(to)) 4) 
                            (= (count at:(to)) 6) 
                        })
                        apply:(fromTo 
                            (from (to)) 
                            (to (handSite Mover)) 
                            count:(count at:(to))
                        )
                    )
                )
            )
        )
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
T'uk T'uk is a blocking game played in West Africa. Unlike most other blocking games, it is played on a grid. According to tradition, it is a griot, or storyteller, who challenges a shepherd to the game, but the griot knows the trick of how to win every time. Square grid of 36, 64, 100, or 144 squares. Each player has one piece lined up in each square on opposite sides of the square. Players may move their piece forward or backwards orthogonally. The player who blocks the opponent from being able to move wins. The board is 6x6.
(game "T'uk T'uk"
    (players 2)
    (equipment {
        (board (square <Board:size>))
        (piece "Marker" Each "StepOrthogonalToEmpty")
    })
    (rules 
        (start { 
            (place "Marker1" (sites Bottom))
            (place "Marker2" (sites Top))
        })
        (play (forEach Piece))
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Odd was invented in 2007 by Nick Bentley. It is played on a hexagonal board.Players take turns placing one stone of either color on the board, until it is full. Player One wins if there is an odd number of groups with at least five pieces on the board, Player Two wins otherwise. Played on a size 3 board. Min group size 3.
(game "Odd" 
    (players 2) 
    (equipment { 
        (board (rotate 90 (hex <Board>))) 
        (piece "Marker" Each)
        (hand Shared size:2)
    }) 
    (rules 
        (start {
            (place "Marker1" (handSite Shared)) 
            (place "Marker2" (handSite Shared 1))
        })
        (play 
            (move 
                (from (sites Hand Shared)) 
                (to (sites Empty))
                copy:True
            )
        )
        (end 
            (if (is Full) 
                (if 
                    (is Odd 
                        (+ 
                            (count Groups if:(= (who at:(to)) P1) min:<Group>) 
                            (count Groups if:(= (who at:(to)) P2) min:<Group>)
                        )
                    ) 
                    (result P1 Win)
                )
                (result P2 Win)
            ) 
        )
    )
)

Construct a Ludii game based on the following description
Dara is a game that is said to be played in West Africa, particularly among the Dakarkari people of Nigeria and the Zarma of Niger. It is also known as \5x6 board. Players have 12 pieces each. They take turns placing pieces on an empty board.Once all pieces are placed, players can move pieces orthogonally to an adjacent space, attempting to make three in a row. When three in a row are made, an opponent's piece is removed from the board that is not in a three in a row pattern. Placing more than three in a row is not allowed. Three in a row during the initial phase of the game does not count. When a player has only two pieces left, they lose. Lines of 4 cannot be made during the drop phase.
(game "Dara"
    (players 2)
    (equipment {
        (board (rectangle 5 6))
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" Orthogonal 
                (then ("ReplayIfLine3" Orthogonal))
            )
        )
    })
    (rules
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            <Rules>
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        (phase "Movement"
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (do 
                        (forEach Piece)
                        ifAfterwards:(not (is Line 4 Orthogonal))
                    )
                )
            )
        )
        }
        
        (end ("HavingLessPiecesLoss" Next 2))
    )	
)

Construct a Ludii game based on the following description
Yahoudieh is a children's race game played in Syria and Lebanon. It is a simplified version of Tawulat ul-Zahr games that are popular among adults.2x12 board, with spaces as points, divided in two. Fifteen pieces per player, which start stacked, two on the players' first three points and three in the next three points. Two six-sided dice. Players unstack the pieces by moving pieces off of the stack, but remaining on the same point, according to the throws of the dice. The value of the throw indicates the number of the point which can be unstacked. For example, a throw of 1 and 4 allows the player to unstack the pieces on points 1 and 4.  When all of a player's pieces are unstacked, they must be restacked, in the same way. When they have been successfully restacked, the player then bears off the pieces from this quadrant of the board. When bearing off, players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The first player to bear off all their pieces wins.
         
(game "Yahoudieh"
    (players 2)
    (equipment {
        ("BackgammonBoard"
            {
            (track "Track1" {7..12} P1 directed:True)
            (track "Track2" {18..13} P2 directed:True)
            } 
        ) 
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" "SiteToMoveOnTrack")
                    "RemoveAPiece"
                    (move 
                        (from) 
                        (to 
                            "SiteToMoveOnTrack" 
                        )
                    )
                )
            )
        )
        (map "StartTrack" {(pair P1 7) (pair P2 18)})
    })
    (rules 
        (start {
            (place Stack "Disc1" (sites {7..9}) count:2)
            (place Stack "Disc1" (sites {10..12}) count:3)
            (place Stack "Disc2" (sites {13..15}) count:3)
            (place Stack "Disc2" (sites {16..18}) count:2)
        })
        phases:{
        (phase "UnStacking" 
            (play
                ("RollEachNewTurnMove"
                    (forEach Die 
                        if:("DieNotUsed")
                        (or
                            (if ("PieceFullStacked" "SiteToSelect")
                                (move Select (from ("SiteToSelect"))
                                    (then 
                                        (and 
                                            (if (= 3 (size Stack at:(last To))) ("UnstackHalf") ("UnstackFull"))
                                            ("ReplayNotAllDiceUsed")
                                        )
                                    )
                                )
                            )
                            (if ("PieceHalfStacked" "SiteToSelect")
                                (move Select (from ("SiteToSelect"))
                                    (then 
                                        (and 
                                            ("UnstackFull")
                                            ("ReplayNotAllDiceUsed")
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover 
                (all Sites (sites Occupied by:Mover) if:(not ("PieceStacked" (site)))) 
                "Stacking"
            )
        )
        (phase "Stacking" 
            (play 
                ("RollEachNewTurnMove"
                    (forEach Die 
                        if:("DieNotUsed")
                        (or
                            (if ("PieceUnstacked" "SiteToSelect")
                                (move Select (from ("SiteToSelect"))
                                    (then 
                                        (and {
                                            (if (= 3 (size Stack at:(last To))) ("UnstackHalf") ("Stack"))
                                            ("ReplayNotAllDiceUsed")
                                        })
                                    )
                                )
                            )
                            (if ("PieceHalfStacked" "SiteToSelect")
                                (move Select (from ("SiteToSelect"))
                                    (then 
                                        (and 
                                            ("Stack")
                                            ("ReplayNotAllDiceUsed")
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover 
                (all Sites (sites Occupied by:Mover) if:(not ("PieceUnstacked" (site)))) 
                "BearingOff"
            )
        )
        (phase "BearingOff" 
            (play 
                (do 
                    (if (or (all DiceEqual) ("NewTurn")) (roll)) 
                    next:(forEach Piece top:True)
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
            (end ("EscapeWin"))
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Raja Pasu Mandiri"
    (players 3)
    (equipment {
        (board 
            (merge {
                (rectangle 1 7)
                (shift 0 2 (rectangle 1 7))
                (shift 3 1 (square 1))
                (shift 1 1 (square 1))
                (shift 5 1 (square 1))
            })
            {
            (track "Track" "6,W,7,E" loop:True)
            }
            use:Vertex
        )
        (piece "Seed" Shared)
        (map {(pair P1 15) (pair P2 14) (pair P3 16)}) 
    })
    (rules
        (start { 
            (set Count 7 to:(difference (sites Board) (sites Row 1)))
            (set RememberValue "Playable" (difference (sites Board) (sites Row 1)))
        })
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from 
                            (if ("SameTurn") (sites {(var "Replay")}) ("HomeMover"))
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (do
                                (set Var "NumSowed" (count at:(last To)))
                                next:(sow
                                    apply:(if (< 1 (count at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                        (if (is Occupied ("NextHole" (to)))
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:(count at:(to))
                                            )
                                        )
                                    )
                                    skipIf:(not (is In (to) ("PlayableSites")))
                                )
                                (then
                                    (and
                                        (forEach Site (sites Track from:(last From) to:("NextSiteOnTrack" (var "NumSowed") from:(last From) "Track"))
                                            (if (= 4 (count at:(site)))
                                                (fromTo
                                                    (from (site))
                                                    (to (mapEntry Mover))
                                                    count:4
                                                )
                                            )
                                        )
                                        (set Var "NumSowed" 0)
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then 
                        (if ("FourOrLessPieceOnBoard")
                            (and { 
                                (forEach Site (difference (sites Board) (sites Row 1))
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry Mover))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (if (and (= 6 (count Sites in:("HomeP1"))) (< 2 (count at:(mapEntry P1))))
                                    (and
                                        (fromTo
                                            (from (mapEntry P1))
                                            (to (mapEntry P2))
                                            count:1
                                        )
                                        (fromTo
                                            (from (mapEntry P1))
                                            (to (mapEntry P3))
                                            count:1
                                        )
                                    )
                                    (if (and (= 6 (count Sites in:("HomeP2"))) (< 2 (count at:(mapEntry P2))))
                                        (and
                                            (fromTo
                                                (from (mapEntry P2))
                                                (to (mapEntry P1))
                                                count:1
                                            )
                                            (fromTo
                                                (from (mapEntry P2))
                                                (to (mapEntry P3))
                                                count:1
                                            )
                                        )
                                        (if (and (= 6 (count Sites in:("HomeP3"))) (< 2 (count at:(mapEntry P3))))
                                            (and
                                                (fromTo
                                                    (from (mapEntry P3))
                                                    (to (mapEntry P1))
                                                    count:1
                                                )
                                                (fromTo
                                                    (from (mapEntry P3))
                                                    (to (mapEntry P2))
                                                    count:1
                                                )
                                            )
                                        )
                                    )
                                )
                                (set Var "Round" (+ 1 (var "Round")))
                                (forget Value "Playable" All)
                            })
                        )
                    )
                )
            )
            
            (end {
                (if ("FourOrLessPieceOnBoard")
                    {
                    (if (> 7 (count at:(mapEntry P1))) (result P1 Loss))
                    (if (> 7 (count at:(mapEntry P2))) (result P2 Loss))
                    (if (> 7 (count at:(mapEntry P3))) (result P3 Loss))
                    }
                )
            })
            
            (nextPhase ("FourOrLessPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites ("HomeMover") if:(is Occupied (site))))
                    (if (<= 7 (count at:(mapEntry Mover)))
                        (move
                            (from (mapEntry Mover))
                            (to ("HomeMover"))
                            count:7
                            (then (remember Value "Playable" (last To)))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)
Raja Pasu Mandiri is a three-player mancala-style board game played in Sri Lanka.2x7 board, with three store holes. Three players. One player, the Raja, owns the three central holes in each row, one player owns the holes to the left and the other player the holes to the right. Seven counters in each hole. Players alternate turns sowing the counters in an anti-clockwise direction. When the final counter lands in a hole, the contents of the following hole are picked up, and sowing continues. If the following hole is empty, the contents of the next hole after that one are captured. Also, if at any point during the sowing a hole contains four counters, they are immediately captured. Play continues until all of the counters have been captured. If a player cannot play, they pass their turn, until captures are no longer possible, at which point the last person who played captures the remaining counters. A new round begins. The Raja gives each of the other players one counter. Players fill their holes with their captured counters, seven per hole. Any holes which can not be filled with seven counters are out of play. Play continues as before. A player plays as the Raja for three turns in a row, after which point it rotates to the next player. Play continues until only one player can fill holes on the board, this player becoming the winner. 

Construct a Ludii game based on the following description
A chess variant played on the intersections of the chess board. The key feature is that only the dark squares may be crossed diagonally.    To make up for this limitation, all of the pieces are more powerful than in standard chess and the width of the board is reduced to eliminate the rooks, and keep the game from becoming too complex.     The power of the King is enhanced by giving it double moves. -- And the other pieces are enhanced enough to checkmate with only the support of a king.    Tactical differences:  -- Pawns are more mobile and easier to promote. They can form mutually suportive chains like in chess, but only in crossing formations that don't lead to the obstruction of major pieces. Alternatively, they can be supported by other pieces and placed so as to attack in front and defend in back. They can open and close columns.  -- The queen-like Bishops can be released along their own columns by 2 pawn moves, or on the Knight column by a pawn and Bishop move after the Knight has been moved; or they can be opened to their own diagonal by a single pawn move.  -- The Queen is not the most powerful piece: It has the capacity to attack almost half the board from protected locations in the mid-game, but is easily blocked. -- Tightly surrounding the King is bad defense as it restricts its movement options. The Knights are good King defenders, and paired Knights are mutually supporting in many positions.-- Attacks can be lead by a brave King advancing into the board.Played on an 8x6 board with pieces with specialized moves. White moves first:
            
            Pawns (6): can move one space forwards (orthogonally or diagonally across dark squares) and can capture an enemy located diagonally across either of the adjacent dark squares (diagonal forwards and diagonal backwards). Upon reaching the last rank, Pawns promote to any major piece except a king.
            -- There are no initial double moves, nor enpassant.
            
            Bishops (2): Can move like chess queens - any orthogonal direction or allowed diagonal direction (but not across light squares).
            
            Knights (2) move one space orthogonally and one space diagonally, in either order to reach a non-adjacent destination. The intermediate position may be occupied. Knights capture at their destination, but if the destination is empty, they capture an enemy along their path.
            
            Queen (1): can move any number of spaces diagonally only, but once per turn, may change direction while crossing a dark square. They capture an enemy at the destination.
            
            Kings (1): can move one space orthogonally or diagonally. The King can move twice per turn, but not in the same direction nor back to the same place. A King may capture on both parts of its turn, but only if the piece(s) captured is not defended. 
            
            Checks:  A check is a threat to take a king, or a threat on a site that the king passes through.
            -- The King may not move across- nor to- a position that remains in check at the completion of its full turn. Nor may a king be put into check by the movement of another friendly piece, including by the opening of a space that allows a knight to jump across the king, or opening a space between opposing kings.
            
            Note: While a king may not move across an open site under check, it may still threaten check across it, thus preventing the opposing king from occupying those sites -- because if the opposing king were captured at those sites, the game would be over and all checks would be null, including those on the intervening site. 
            A king does not threaten check across an occupied site.
            
            In no case may a King put the other king directly into check, because in all such cases both the kings would be put into check, and movement into check is forbidden.
            
            A King must move when in check.
            
            The game is won when the ememy king must move, but cannot. 
            
        Not implemented yet and still under consideration: 13 continuous ckeck moves is also a win. the last player to move a pawn or capture a piece loses after 20 moves per player: Note that bare kings will normally end in a stalemate win before this limit is reached. No move exclusion in move limit count
(game "Nodal Chess" 
    (players {(player N) (player S)}) 
    (equipment { 
        (board
            (add
                (remove
                    (rectangle 8 6) 
                    cells:{1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33}
                )
                edges:{ { 1 2 }{ 3 4 }{ 6 12}{11 17}{18 24}{23 29} {30 36}{35 41}{43 44}{45 46} }
            ) 
            use:Vertex
        ) 
        
        ("NodalPawn" "Pawn"
            (then
                (and
                    (set Score Mover 0)
                    (if
                        (is In (last To) (sites Mover "Promotion")) 
                        (moveAgain)
                    )
                )
            )
        )
        ("NodalKing" "King" )
        ("NodalBishop" "Bishop" (then (set Score Mover 0)))
        ("NodalKnight" "Knight" (then (set Score Mover 0)))
        ("NodalQueen" "Queen" (then (set Score Mover 0)))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Knight1" {"B1" "E1"}) 
            (place "Bishop1" {"A1" "F1"}) 
            (place "Queen1" coord:"C1") 
            (place "King1" coord:"D1" state:1) 
            (place "Knight2" {"B8" "E8"}) 
            (place "Bishop2" {"A8" "F8"}) 
            (place "Queen2" coord:"C8") 
            (place "King2" coord:"D8" state:1) 
        })
        
        (play 
            (if 
                ("NewTurn")
                
                (if 
                    (and {
                        (not ("IsInCheck" "King" Mover ~))
                        (not ("IsInCheck" "King" Mover ("CheckWorkAroundForKnight")))
                    })
                    ("MakeAMove")
                    <MoveLimitCounter:escapeExclusion>
                )    
                
                
                (if
                    (= (id "King" Mover) (what at:(last To)))
                    (do 
                        (forEach Piece "King" Mover) 
                        ifAfterwards:(and {
                            (not ("IsInCheck" "King" Mover ~)) 
                            (not ("IsInCheck" "King" Mover ("CheckWorkAroundForKnight")))
                        })
                    )
                    (move Promote (last To) (piece {"Queen" "Knight" "Bishop"}) Mover)
                )
                
                (then
                    (if 
                        (and {
                            (not ("IsInCheck" "King" Prev ~))
                            (not ("IsInCheck" "King" Prev ("CheckWorkAroundForKnight")))
                        })
                        (addScore Mover 0)
                        <MoveLimitCounter:checkExclusion>
                    )
                )
            )
        )  
        (end {
            (if (no Moves Next) (result Mover Win)) 
            (if (< "MoveStallingLimit" (score Mover)) (result Mover Loss))
        })
    )
)

Construct a Ludii game based on the following description
Pachgarhwa is a two-row mancala-style board game played in central India during the early twentieth century.2x5 board. Five counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counters of a sowing lands in a hole, the contents of the next hole are picked up and sowing continues. When the final counter lands in a hole, and the next hole, from which sowing would normally continue, is empty, the player captures any counters in the next hole after the empty one. and the turn ends. Play continues until no more captures are possible, and the player who captured the most counters wins. 
(game "Pachgarhwa" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 5 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        (start (set Count 5 to:(sites Track)))
        
        (play (move Select 
                (from 
                    (if ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover) 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        if:True
                        apply:(if (is Occupied ("NextHole"))
                            (and {
                                (set Pending (to))
                                (fromTo 
                                    (from ("NextHole")) 
                                    (to (handSite Mover)) 
                                    count:(count at:("NextHole"))
                                )
                                (moveAgain)
                            })
                            (if (is Occupied ("NextNextHole"))
                                (fromTo 
                                    (from ("NextNextHole")) 
                                    (to (handSite Mover)) 
                                    count:(count at:("NextNextHole"))
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (= 1 (count in:(sites Board)))))
    )
)

Describe the mechanics of the following Ludii game
(game "Mwendo" 
    (players 4) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            <Board:track>
        )
        (piece "Seed" Each)
        <Board:regions>
    }) 
    (rules 
        (start {
            (place "Seed1" (sites P1) counts:{3})
            (place "Seed2" (sites P2) counts:{3})
            (place "Seed3" (sites P3) counts:{3})
            (place "Seed4" (sites P4) counts:{3})
        })
        
        (play 
            (if (!= 1 (count Pieces Mover))
                (or
                    (move Select 
                        (from ("RightMost"))
                        (then 
                            (sow
                                numPerHole:(if (is Empty (to)) 2 1)
                                sowEffect:(if (and (!= (mover) (what at:(to))) (is Occupied (to)))
                                    (and
                                        (remove (to) count:(count at:(to)))
                                        (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to)))
                                    )
                                )
                                apply:(if (= 2 (count at:(to)))
                                    (moveAgain)
                                )
                            )
                        )
                    )
                    (if ("NewTurn")
                        (move
                            (from ("RightMost"))
                            (to ("NextHoleFrom" ("RightMost") 1)
                                (apply 
                                    (if (and (!= (mover) (what at:(to))) (is Occupied (to)))
                                        (and
                                            (remove (to) count:(count at:(to)))
                                            (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to)))
                                        )	
                                    )
                                )
                            )
                            count:(count at:("RightMost"))
                        )
                    )
                )
                (move
                    (from ("RightMost"))
                    (to 
                        (trackSite FirstSite from:(from) if:("IsEnemyAt" (to)))
                        (apply
                            (and
                                (remove (to) count:(count at:(to)))
                                (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to)))
                            )	
                        )	
                    )
                )
            )
        )
        
        (end 
            (forEach NonMover 
                if:(no Pieces Player) 
                (result Player Loss)
            )
        )
    )
)
Mwendo is a board game played among children of the Luenda and Bunda people of Angola. It is similar to mancala-style games, but the ownership of holes is determined by whether a player's counters are in the hole, rather than being fixed.4x4-16 board, played only along the perimeter. Three counters per hole. Any number of players. Holes are distributed equally among the players. Sowing occurs in a clockwise direction. Counters are sown one per occupied hole, two per empty hole. Each player owns the holes in which their counters are located at the beginning of their turn, and they must sow from the rightmost hole. If the final counter of a sowing falls into an empty hole, the player sows again from the rightmost hole. Alternatively, a player may place all of the counters from the rightmost counter into the next hole, but this cannot be done after a move. When counters fall into holes belonging to an opponent, these hole and the counters in it are captured by the player, but remain in play. When a player has a single counter and empty holes in from of it, this counter leaps to the next hole occupied by the opponent. The player who captures all of the opponent's holes wins. Each row has 4 holes.

Construct a Ludii game based on the following description
Allemande is a drawless, square board-crossing game that does not allow diagonal connections.    It evolved from an idea similar to 'Connecticut' by Corey Clark, with comments and suggestions from Luis Bolaños Mures    based on an unpublished polyomino connection game of his.        The principle is that for a crossing connection game on a square board, where diagonal connections are not counted for the win condition, they must be disallowed to avoid stalemates. - But may be allowed in the case where a true connection between those pieces has been established.    In such a case, four simultaneous placements are the minimum required to avoid any conceivable stalemate position.        Thus, in this game up to 4 sequential placements are allowed per turn.          At the end of the turn, no same-color diagonal relationships may remain between pieces that are not otherwise connected orthogonally.          During the turn, however, diagonal placement is allowed, as long as it is resolved before the turn ends.         The name Allemande comes from the dance, which is stately and in 4 steps.          Implementation:    I implemented the 4 placements by using play from a hand of 4. The hand is replenished before a player's turn. This works well as a way to visually keep track of how many pieces have been played. Select moves are used to make each move a single decision, despite the movements.           Connection is determined by whether the lowest left-edge stone can step a continuous path to the upper rightmost stone.          Issues with implementing this game in Ludii:          1. Ludii does not have a turn structure which would allow filtering for illegal diagonals at the end of 4 placements and reversing the entire move. (and that approach would be very inefficient anyway.)           Therefore each diagonal placement is being resolved on the next placement, and is not allowed as the forth placement.     And voluntary passing is not allowed when the board is in an illegal state.           This has the side effect that the placement sequence is not entirely arbitrary; but it also reduces AI load.          2. However, when this approach is taken and the placement cannot be resolved, Ludii supplies an automatic pass that does not allow post processing, leaving the board in an illegal condition of having a diagonal placement.          My work-around is to create a reversing move for diagonal placements, but this allows endless cycles.          3. Thus (meta (no Repeat PositionalInTurn)) is needed.     To allow the reversal, the piece states are not returned to the original values.      This solution also prevents endless replay variants, by limiting the choices available.     It also gives a Human the choice to use 'Undo' in order to explore other placement sequences.          4. A forced pass can happen after the removal, but leaves the board in a legal position.          The AI tends to play out these reversals, and can get caught by the lost opportunities.          Human players will quickly become familiar with what sequence of placements is needed for their purpose, and, if necessary reverse their moves with the undo button until they achieve the desired goal.          In any case, with 4 placements per turn, the AI's are not very good at the game.Goal: To Win, connect the groups of stones at opposite edges.
            
            On your turn place up to 4 stones.
            
            Restriction:
            You may not place a stone diagonally from another stone of your color, UNLESS the stone is connected through othogonal links after you have placed your next stone in the same turn. 
            
            If you place in the wrong sequence use the Undo button to go back.
            
            Do not select the stone to reverse the move as this limits your options to move elsewhere. 
            That option is just there as a work-around for the Ludii system.
            
            There are 2 versions:
            1. Placing pieces on any empty spaces allowed in the above rules.
            2. Restricting successive placements in the turn to locations around the previous placement.
        This keeps all the pieces played in one turn, as a group. The pieces may be placed anywhere that leave all crosscuts connected Order 5 Board
(game "Allemande"
    (players 2)
    (equipment {
        (board
            (remove
                (square (+ 2 "Order")) 
                cells:{0 (+ "Order" 1) (* (+ "Order" 2) (+ "Order" 1)) (- (^ (+ "Order" 2) 2) 1)} 
            ) 
            use:Cell
        )
        (regions "EW"
            P1
            (union
                (sites Column (+ "Order" 1))
                (sites Column 0)
        ))
        (regions "NS"
            P2
            (union 
                (sites Row (+ "Order" 1))
                (sites Row 0)
        ))
    (piece "Square" Each) 
    (hand Each size:4)
})
(rules
    (start {
        (place "Square1"
            (union
                (sites Column (+ "Order" 1))
                (sites Column 0) 
        ))
        
        (place "Square2" 
            (union
                (sites Row (+ "Order" 1))
                (sites Row 0) 
            )
        )
    })
    (play
        "GamePlay"
    )
    (end
        (if
            "Goal"
            (result Mover Win)
        )
    )
)
)

Describe the mechanics of the following Ludii game
(game "Crossway" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each)
        (regions P1 {(sites Side N) (sites Side S)})
        (regions P2 {(sites Side W) (sites Side E)})
    })
    
    (rules 
        (meta (swap))
        (play 
            (do
                (move Add
                    (to (sites Empty))
                )
                ifAfterwards:"IsNotCut"
            )
        )
        
        (end (if (is Connected All Mover) (result Mover Win))) 
    )
)
The most elegant drawless square connection game. Stones possess orthodiagonal connectivity, and crosscuts are disallowed.Crossway is played with a Go set. The board starts out empty. Each player takes possession of all of the stones of one color. Players take turns adding their stones to the board, one stone per turn. A player must never create a crosscut formation. Black makes the first placement of the game. If you have no more available placements, you forfeit your turn and your opponent can continue making placements until completing his goal connection. For White to win, White must form a contiguous sequence of white stones connecting the West edge to the East edge of the board. Each stone in the sequence must be connected to neighboring stones in the sequence by horizontal, vertical, or diagonal adjacencies. Likewise for Black and the North and South edges. A corner is considered to be part of both adjoining edges. Crossway makes use of the pie rule. This means Black makes the first placement, and White has the option of switching colors with Black, and claiming Black's first move as his own. If White chooses to exercise the pie rule, Black then becomes White and now makes the second placement of the game. The pie rule can only be used once and on the second move of the game. The game is played on a 9x9 board

Construct a Ludii game based on the following description
Chessence is a chess variant invented by Jim Winslow in 1989. The board is a 6×9 rectangle of squares with eight squares missing. Each player has a king and nine men with initial setup as shown, including three men initially not yet in play at the side of the board. In Chessence, kings do not move and must remain fixed on their starting squares the entire game. (Thus, a king is unable to move out of check.) 
            
            A man has capability to move based on its relative position to other friendly men on the board, as follows:
            - If a man is orthogonally adjacent to a friendly man, then both have the ability to move as a rook in chess.
            - If a man is diagonally adjacent to a friendly man, then both have the ability to move as a chess bishop.
            - If a man is a knight's move away from a friendly man, then both have the ability to move as a knight.
            
            A man with more than one position relationship has the ability to move in more than one way. Likewise, if a man has no position relationship defined above, that man cannot move. The king has no bearing on how the other men may move.
            
            A man may not move to, nor through, a non-existent (blackened-out) square; except that a man moving as a knight may jump over a non-existent square. For a turn, a player may move a man on the board, or alternatively, they may put one of their reserve men in play by placing it on any of their six initial starting squares that are currently open.
            
        Checks, checkmate, and captures are as in standard chess. If a player has no legal moves, they lose the game. 
(game "Chessence" 
    (players 2) 
    (equipment { 
        (board (rectangle 9 6)) 
        (piece "Pawn" Each
            (or {
                (if (not (all Sites (sites Around (from) Orthogonal) if:(not ("IsPieceAt" "Pawn" Mover (site)))))
                    (move Slide 
                        Orthogonal 
                        (between
                            if:(and (is Empty (between)) (not (is In (between) (sites "BlackenedSquares"))))
                        )
                        (to 
                            if:("IsEnemyAt" (to)) 
                            "CaptureToPiece"
                        ) 
                    )
                )
                (if (not (all Sites (sites Around (from) Diagonal) if:(not ("IsPieceAt" "Pawn" Mover (site)))))
                    (move Slide 
                        Diagonal 
                        (between
                            if:(and (is Empty (between)) (not (is In (between) (sites "BlackenedSquares"))))
                        )
                        (to 
                            if:("IsEnemyAt" (to)) 
                            "CaptureToPiece"
                        ) 
                    )
                )
                
                (if (not 
                        (all Sites
                            (forEach
                                (sites Around 
                                    (sites To (hop Orthogonal (between if:True) (to if:True))) 
                                    Orthogonal
                                )
                                if:(= 2 (count Steps (from) (site)))
                            )
                            if:(!= (what at:(site)) (id "Pawn" Mover))
                        )
                    )
                    (move Leap 
                        "KnightWalk" 
                        (to 
                            if:(and (not ("IsFriendAt" (to))) (not (is In (to) (sites "BlackenedSquares"))))
                            "CaptureToPiece"
                        ) 
                    )
                )
            })
        )
        (piece "King" Each)
        (hand Each)
        (regions "BlackenedSquares" (sites {"A2" "B3" "B5" "C6" "D4" "E5" "E7" "F8"}))
        (regions "PawnStart" P1 (sites {"E1" "E2" "F2" "D2" "D3" "E3"}))
        (regions "PawnStart" P2 (sites {"B9" "B8" "A8" "C8" "C7" "B7"}))
    }) 
    (rules 
        (start { 
            (place "Pawn" "Hand" count:3)
            (place "Pawn1" (sites P1 "PawnStart"))
            (place "Pawn2" (sites P2 "PawnStart"))
            (place "King1" coord:"F1") 
            (place "King2" coord:"A9") 
        })
        
        (play 
            (or
                (do 
                    (forEach Piece)
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
                (if (is Occupied (handSite Mover))
                    (move
                        (from (sites Hand))
                        (to (sites Mover "PawnStart") if:(is Empty (to)))
                    )
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (no Moves Mover) (result Mover Loss)) 
        })
    )
)

Describe the mechanics of the following Ludii game
(games (subgame "MughrabiehSubgame" result:(score Mover)))
Mughrabieh is a race game played in Southwest Asia, one of the different types which are called Tawulat ul-Zahr. It is said to have originated in Morocco.The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. Each player's fifteen pieces begin on the first point of their track. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. A piece cannot land on a space occupied by one of the opponent's pieces. A player must first move a single one of their pieces around the board and onto one of the final six points of their track before moving any of the other pieces. When all of the player's pieces are on the final six points, they may be borne off the board. The player who bears off all of their pieces wins. The winning player's score equals the number of the opponent's pieces which are left on the board. Play continues until one player's score reaches 31. 

Construct a Ludii game based on the following description
Lam Turki is a solitaire game played in India. Played on a board shaped like a five-pointed star, the player attempts to remove all of the pieces from the board,The board is a five-pointed star. The player has nine pieces. In the first phase, the player attempts to place all the pieces on the board. The player choses a point, then moves the piece two spaces in a straight line. The piece may move through a spot occupied by another piece, but must land on an empty space. Once all of the pieces are placed in this way, the player captures a piece on the board by hopping over with with another one of the pieces to an empty space on the opposite side of the piece to be captured. The goal is to capture all of the pieces except one. 
(game "Lam Turki"
    (players 1) 
    (equipment { 
        ("StarBoard" 5)
        (hand Each) 
        (piece "Marker" P1 ("HopFriendCapture"))
    })
    (rules 
        (start {
            (place "Marker" (handSite P1) count:9)
        })
        
        phases:{
        (phase "Placement"
            (play 
                (if (is Even (count Moves))
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty))
                        (then (moveAgain))
                    ) 
                    (forEach Piece
                        (if (= (from) (last To))
                            (move Hop 
                                (between 
                                    if:(or ("IsFriendAt" (between)) (is Empty (between)))
                                )
                                (to if:(is Empty (to)))
                            )
                        )
                    )
                )
            )
            (end 
                (if (no Moves Next) (result Mover Loss))
            )
            (nextPhase Mover (and (is Even (count Moves)) ("HandEmpty" Mover)) "Movement")
        )
        
        ("PhaseMovePiece" "Movement"
            (end {
                (if (= (count Pieces) 1) (result Mover Win))
                (if (no Moves Next) (result Mover Loss))
            })
        )
        }
    )		
)

Construct a Ludii game based on the following description
Redstone is a variation of Go in which red stones are used to capture. Red stones are permanent. They cannot themselves be captured. Draws cannot occur in Redstone. Mark Steere designed Redstone in February, 2012.Starting with Black, the two players take turns placing stones onto unoccupied points on the board, subject to restrictions, one stone per turn.
            Passing is not allowed in Redstone. Players will always have a placement available and must make one.
            
            GROUPS AND LIBERTIES: 
            A group is an orthogonally interconnected collection of one or more like-colored stones. 
            Only black groups and white groups will be discussed here, not red groups. 
            A liberty is an unoccupied point adjacent to a (black or white) group
            
            CAPTURES:
            A capturing placement results in one or more groups, of either or both colors, having no liberties. 
            Such a placement can only be made with a red stone. 
            Conversely, a red stone can only be placed if it bounds (completely deprives of liberties) one or more groups of either or both colors. Red stones are permanent. They cannot themselves be captured.
            Self capture is allowed.
            
            When multiple groups without liberties result from a placement, all such groups are removed immediately following said placement, regardless of the groups' colors. Unlike Go, if you unbound your own temporarily bounded group by removing a neighboring enemy group, you must still remove your own temporarily bounded group.
            
            PIE RULE:
            Since Redstone is a game of annihilation, not of point score, Go’s komi can’t be used.
            Instead, Redstone uses the pie rule for balance. 
            
            OBJECT OF THE GAME:
            You must annihilate your opponent, removing all of his stones from the board. 
            If your placement eliminates all black and white stones from the board, you win. 
        If your placement eliminates all of your own stones while enemy stones remain on the board, you lose. A size 5 board is currently selected
(game "Redstone"
    (players 2)
    (equipment {
        (board (square <Size>) use:Vertex)
        (piece "Disc" Each)
        (piece "Disc" Neutral)
    })
    (rules
        (meta (swap))
        (play
            (or
                ("PlaceRed")
                ("PlaceNonRed")
            )
        )
        (end {
            (if 
                (and (> (count Moves) 2) (no Pieces Next))
                (result Next Loss)
            )
            (if 
                (and {(> (count Moves) 2) (no Pieces Mover) (not (no Pieces Next))})
                (result Mover Loss)
            )
        })
    )
)

Construct a Ludii game based on the following description
Chaturanga is a game with replacement captures played in India since the early centuries CE. This version was played in the nineteenth century on a 14x14 board.14x14 board. Pieces move as follows: Raja (King, x1): moves one space in any direction; Mantri (Minister, placed to the left of the Raja, x1): moves any distance orthogonally or diagonally; Queen (x1, placed to the right of the Raja); moves orthogonally one space; Prince (placed to the left of the Minister, x1), moves orthogonally or diagonally any distance; Ushtra (Camel, x2): moves diagonally any distance; Chariot (x2), moves orthogonally any distance; Flagcar (x2), moves diagonally any distance; Vaha (Horse, x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (Elephant, x2): moves orthogonally any distance. Padati (Pawn, x14): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja).
         
(game "Chaturanga (Kridakausalya 14x14)"
    ("TwoPlayersNorthSouth")
    (equipment { 
        (board (square 14)) 
        ("ChessPawn" "Pawn" ~
            (then
                (if (is In (last To) (sites Mover "Promotion")) 
                    (and
                        (promote (last To) (piece "Ferz_noCross") Mover)	
                        (fromTo (from (last To)) (to (last From)))
                    )
                )
            )
        )
        ("ChessRook" "Rook")
        ("ChessBishop" "Camel")
        ("ChessKing" "King_noCross")
        ("ChessBishop" "Bishop_noCross")
        (piece "Queen" Each ("StepToNotFriend" Orthogonal)) 
        ("ChessQueen" "Commoner")
        ("ChessRook" "Elephant")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Ferz_noCross")
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Elephant1" {"A1" "N1"}) 
            (place "Knight1" {"B1" "M1"}) 
            (place "Bishop_noCross1" {"C1" "L1"}) 
            (place "Rook1" {"D1" "K1"}) 
            (place "Camel1" {"E1" "J1"}) 
            (place "Commoner1" coord:"F1") 
            (place "Ferz_noCross1" coord:"G1") 
            (place "King_noCross1" coord:"H1") 
            (place "Queen1" coord:"I1") 
            
            (place "Pawn2" (sites Row 12))
            (place "Elephant2" {"A14" "N14"}) 
            (place "Knight2" {"B14" "M14"}) 
            (place "Bishop_noCross2" {"C14" "L14"}) 
            (place "Rook2" {"D14" "K14"}) 
            (place "Camel2" {"E14" "J14"})
            (place "Commoner2" coord:"I14") 
            (place "Ferz_noCross2" coord:"H14") 
            (place "King_noCross2" coord:"G14") 
            (place "Queen2" coord:"F14") 
        })
        (play
            (if (no Moves Mover)
                (move Remove
                    (difference (sites Occupied by:Next) (where "King_noCross" Next))
                )
                (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (and {
                    (no Pieces Next "Ferz_noCross")
                    (no Pieces Next "Knight")
                    (no Pieces Next "Bishop_noCross")
                    (no Pieces Next "Elephant")
                    (no Pieces Next "Rook")
                    (no Pieces Next "Camel")
                    (no Pieces Next "Commoner")
                    (no Pieces Next "Queen")
                })
                (result Mover Win) 
            ) 
        })
    )
)

Construct a Ludii game based on the following description
Hoyito is a two-row mancala-style board game that is played in the Dominican Republic. It is similar to other games from the Caribbean, which were likely brought to the region by enslaved African people during European colonisation.2x6-12 board, six is the most common. Four counters in each hole. A player moves by picking up the contents of one of their holes and sowing them in an anti-clockwise direction. If the final counter lands in an occupied hole, the contents of this hole are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends. If the final counter falls into a hole containing three counters, making it four after the sowing, then these counters are captured and the turn ends. If at any time during sowing a player drops a counter into a hole to make it contain four, these are captured. If a player cannot move because there are no counters in their holes, they pass. When eight counters are left, the player to first capture a group of four also takes the remaining four counters on the board. Each player has 6 holes.
(game "Hoyito" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 <Board> store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (if 
                        ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover) 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        apply:(if (= (count at:(to)) 4)
                            (if (<= (count in:(sites Board)) 8)
                                (forEach Site (sites Board)
                                    (if (> (count at:(site)) 0)
                                        (fromTo 
                                            (from (site))
                                            (to (handSite Mover)) 
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (fromTo 
                                    (from (to)) 
                                    (to (handSite Mover)) 
                                    count:(count at:(to))
                                )
                            )
                            (if (< (count at:(to)) 1)
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Altan Xaraacaj (Golden swallows) is an alignment game played in Mongolia. One player plays as golden swallows (the black pieces) and the other plays as spotted swallows (the white pieces).5x5 intersecting lines, with diagonals in each quadrant. Six pieces per player. Players alternate turns placing one of their pieces on an empty spot on the board. When all of the pieces are placed, they alternate turns moving one of their pieces to an empty adjacent spot along the lines of the board. During either phase, when a player places three of their pieces in a row, they may remove one of the opponent's pieces from the board. Pieces which are in a three-in-a-row arrangement cannot be removed from the board. The player who captures all of the opponent's pieces wins.  
(game "Altan Xaraacaj"
    (players 2) 
    
    (equipment { 
        ("AlquerqueBoard" 5 5) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ 
                (then ("ReplayIfLine3" Orthogonal exact:True))
            )
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:6))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True))
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
A 3-player chess variant played on a board made of hexagons invented by Siegmund Wellisch.Wellisch Chess is played on a hexagonal board with each side having length 6 and each space oriented vertically. The board has 91 spaces. The board spaces are traditionally coloured red, yellow, and either gray or black.
            
            Capture and Pawn Promotion:
            * When pieces other than Kings and Pawns are captured, they are set aside for later Pawn promotion. When a Pawn reaches the side of the board opposite its starting side, it is eligible for promotion.
            * When a Pawn is eligible for promotion, and there are pieces of that colour available from previous capture, then the Pawn is promoted to one of the captured pieces, as the player chooses.
            * If there are no pieces of the given colour when a Pawn reaches the far side, then the Pawn remains where it is (unless captured) until a piece of the given colour is captured. Then, on the player's next turn, the Pawn is promoted.
            
            Piece Movement:
            * Rooks move as in Glinski Chess.
            - They slide in any of the 6 adjacent direction.
            * There are no Bishops in Wellisch Chess.
            * Kings can move one space in any of the six adjacent directions from their current space---West, East, or 60 degrees off either of those. They castle by swapping locations with one of the Rooks belonging to the same player. Castling can only take place when neither the King nor the Rook being moved have moved before.
            * Knights move one space 'diagonally' (i.e., along an edge, to any of the six nearest spaces of the same colour). Note that a Knight always moves to a space of the same colour as the space it moved from.
            * Queens can make any move that would be available to a Rook or a Knight on the current space.
            * Pawns can advance with or without capturing by moving one space forward to an adjacent space slightly left or right of forward. Pawns can never advance more than one space. There is no en passant capture. As mentioned above, Pawns can be promoted upon reaching the side of the board farthest from their starting side, but can only be promoted to a piece (Queen, Rook, or Knight) of the same colour that has already been captured. If a Pawn reaches the farthest side without any captured pieces available, then it remains in that position until a piece becomes available for its delayed promotion, on the player's next turn. (Note: Currently, on a turn where the delayed promotion takes place, the possible post-promotion movement of the Pawn is displayed before the promotion visually takes place.)
            
            The game ends when a King is captured, or there is a stalemate due to turns elapsed without a capture or Pawn move.
            * When the game ends in checkmate, the checkmating player wins, the checkmated player loses, and the remaining player draws.
            * When the game ends in stalemate, all players draw. (Note: A player not being able to escape check passes the current move, This does not result in a stalemate.)
            
        Variations: In Wellisch's version of the game, the first player to capture another's King takes possession of the other player's pieces. (The Pawns keep their direction of movement.) In another variant, some people play with a rule that if Player 1's move exposes a threat by Player 2 against Player 3's King, then Player 2 may not capture Player 3's King until Player 3 has had a chance to move. 
(game "Wellisch Chess"
    (players {(player N) (player ESE) (player WSW)})
    (equipment {
        (board (hex 6))
        
        (piece "King" Each 
            (or {
                ("StepGrabMove" Orthogonal "History_SaveMovementChange")
                (if "Castle_PreCheck"
                    (or {
                        "Castle_KingSide"
                        "Castle_QueenSide"
                    })
                )
            })
        )
        (piece "Queen" Each 
            (or
                ("SlideGrabMove" Orthogonal ~) 
                ("StepGrabMove" Diagonal ~) 
            )
        )
        (piece "Rook" Each ("SlideGrabMove" Orthogonal ~))
        (piece "Knight" Each 
            ("StepGrabMove" Diagonal ~)
        )
        
        (piece "Pawn" Each
            (or {
                "StepOrthoToEmpty"
                "PawnGrab"
                }
                (then
                    (and
                        ("ReplayInMovingOn" (sites Mover "PromotionZone"))
                        (set Counter)
                    )
                )
            )
        )
        
        (map "King"  {(pair 1 "D1") (pair 2 "C8") (pair 3 "K9")})
        (map "RookLeft" {(pair 1 "B1") (pair 2 "E10") (pair 3 "K7")})
        (map "RookRight" {(pair 1 "E1") (pair 2 "B7") (pair 3 "K10")})
        
        (map "Queen" {(pair 1 2) (pair 2 70) (pair 3 69)})
        
        (hand Each size:3) 
        
        (map "HandIndex" {
            (pair 4 0) (pair 7 1) (pair 10 2) 
            (pair 5 0) (pair 8 1) (pair 11 2) 
            (pair 6 0) (pair 9 1) (pair 12 2) 
        })
        
        (regions "PromotionZone" P1 (sites Top))
        (regions "PromotionZone" P2 (sites {"K6" "J5" "I4" "H3" "G2" "F1"})) 
        (regions "PromotionZone" P3 (sites {"A1" "A2" "A3" "A4" "A5" "A6"})) 
        
        (regions "Region-Grey" (sites Phase 1))
        (regions "Region-Red" (sites Phase 2))
        (regions "Region-Yellow" (sites Phase 0))
    })
    
    (rules
        (start {
            (place "King1" coord:"D1" state:1)
            (place "Queen1" coord:"C1")
            (place "Rook1" {"B1" "E1"} state:1)
            (place "Knight1" {"A1" "D2" "F1"})
            
            (place "King3" coord:"K9" state:1)
            (place "Queen3" coord:"K8")
            (place "Rook3" {"K10" "K7"} state:1)
            (place "Knight3" {"K11" "J8" "K6"})
            
            (place "King2" coord:"C8" state:1)
            (place "Queen2" coord:"D9")
            (place "Rook2" {"B7" "E10"} state:1)
            (place "Knight2" {"A6" "D8" "F11"})
            
            (place "Pawn1" {"A2" "B2" "C2" "D3" "E3" "E2" "F2" "G2"})
            (place "Pawn3" {"J11" "J10" "J9" "I8" "I7" "J7" "J6" "J5"})
            (place "Pawn2" {"A5" "B6" "C7" "D7" "E8" "E9" "F10" "G11"})
        })
        phases:{
        (phase "Movement"
            (play
                (if ("SameTurn")
                    (if ("HandOccupied" Mover)
                        "PromoteFromHand"
                    )
                    (do
                        
                        (if (> (count in:(sites Hand Mover)) 0) 
                            "PromoteFromHandDelayed"
                        )
                        next:(do
                            (forEach Piece)
                            ifAfterwards:(not ("IsInCheck" "King" Mover))
                        )
                    )
                )
            )
            (end {
                (if (is Triggered "CapturedEnemyKing" P1) (result P1 Win))
                (if (is Triggered "CapturedEnemyKing" P2) (result P2 Win))
                (if (is Triggered "CapturedEnemyKing" P3) (result P3 Win))
                
                (if ("IsOffBoard" (where "King" P1)) (result P1 Loss))
                (if ("IsOffBoard" (where "King" P2)) (result P2 Loss))
                (if ("IsOffBoard" (where "King" P3)) (result P3 Loss))
                
                (if (= (counter) 100) (result Mover Draw)) 
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Leyla Gobale is a name that refers to mancala-style board games in the Horn of Africa. This is a two-row game that was played in the Gabradarre area of Ethiopia.2x6 board. Five counters in each hole. Play begins from any hole in a player's row and sown anti-clockwise. When the final counter falls into an occupied hole, the counters in that hole are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends; if this hole is in the player's own row, the contents of the opponent's hole are captured if they contain one, two, four, or more counters. If it contains three counters, one of the opponent's counters is taken and placed into the hole where sowing ended, so that each now has two counters. These holes cannot be sown from for the rest of the game and are owned by the player whose turn created them. Players cannot change their move mid-turn and counting of counters is forbidden. Play ends when one player can no longer play. The opponent then takes all of the counters in their own row, and each player takes the counters that have accumulated in their captured holes. A new game begins. The player with the fewest counters arranges them in their holes, distributing them as equally as possible. The opponent then mirrors this arrangement in their holes, placing aside any extras for use in subsequent games. If the player is reduced to four counters or less, these are arranged one to a hole and any empty holes are not used for the game (by either player). The player who captures all the counters wins. 
(game "Leyla Gobale (Gabradarre)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "TrackCCW" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (hand Each)
        (map "CorrespondingHoles" {
            (pair 0 11) (pair 1 10) (pair 2 9) (pair 3 8) (pair 4 7) (pair 5 6) 
            (pair 6 5) (pair 7 4) (pair 8 3) (pair 9 2) (pair 10 1) (pair 11 0)
        })
    }) 
    (rules 
        
        (start {
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
            (set Count 5 to:(sites Track)) 
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover) 
                            )
                            if:(and {
                                (is Occupied (from)) 
                                (= 0 (state at:(from)))
                                (is In (from) ("PlayableSites"))
                            })
                        )
                        (then
                            (sow
                                apply:(if (< 1 (count at:(to)))
                                    (if (= 0 (state at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                    (if (is In (to) (sites Mover))
                                        (if (!= 3 (count at:("OppositePitTwoRows" (to))))
                                            (if (!= 0 (count at:("OppositePitTwoRows" (to))))
                                                (fromTo
                                                    (from ("OppositePitTwoRows" (to)))
                                                    (to (handSite Mover))
                                                    count:(count at:("OppositePitTwoRows" (to)))
                                                )
                                            )
                                            (and {
                                                (fromTo
                                                    (from ("OppositePitTwoRows" (to)))
                                                    (to (to))
                                                    count:1
                                                )
                                                (set State at:(to) (mover))
                                                (set State at:("OppositePitTwoRows" (to)) (mover))
                                            })
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("APlayerCanNotMove")
                            (and { 
                                (forEach Site 
                                    (sites P1)
                                    (if (= 0 (state at:(site)))
                                        (fromTo
                                            (from (site))
                                            (to (handSite P1))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site 
                                    (sites P2)
                                    (if (= 0 (state at:(site)))
                                        (fromTo
                                            (from (site))
                                            (to (handSite P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site 
                                    (sites Board)
                                    (if (= (state at:(site)) P1)
                                        (fromTo
                                            (from (site))
                                            (to (handSite P1))
                                            count:(count at:(site))
                                        )
                                        (if (= (state at:(site)) P2)
                                            (fromTo
                                                (from (site))
                                                (to (handSite P2))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                )
                                (if (< ("CapturedPiece" P1) ("CapturedPiece" P2))
                                    (set NextPlayer (player 1))
                                    (set NextPlayer (player 2))
                                )
                                (forget Value "Playable" All)
                            })
                        )
                    )
                )
            )	
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
            
        )
        
        (phase "BetweenRounds"
            (play
                (move
                    (from (handSite Mover)) 
                    (to 
                        (forEach (sites Mover) 
                            if:(= (count at:(site)) 
                                (min 
                                    (results 
                                        from:(sites Mover)
                                        to:(sites Mover)
                                        (count at:(to))
                                    )
                                )
                            )
                        )
                    )
                    count:1
                    (then 
                        (and
                            (remember Value "Playable" (last To) unique:True)
                            (if 
                                (< 0 (count Cell at:(handSite Mover))) 
                                (moveAgain)
                                (forEach Site (sites Mover)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (handSite Next))
                                            (to (mapEntry "CorrespondingHoles" (site)))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                            )
                        )
                    )
                ) 
            )
            (nextPhase (or (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Phantom Go is a variant of Go for two players and a referee. The players only see their own stones, but they don't know where the opponent plays. The referee sees the moves of both players and takes care that they only play legal moves.Each player has his own board, set up so that the opponent cannot see it. The referee has a board of his own on which he plays the moves of both players. He can see both player's boards.
            
            To make a move, a player plays a stone on his own board. The referee then checks on his board whether the move is legal and informs both players about the tried move. How exactly the refereee comments on the move depends on the rule variant.
            
        As long as a player tries to play an illegal move, it's still his turn and he may try another move. After the player has made a legal move, the referee copies the move to his own board. Then, it's the other player's turn. The game is played on a 9x9 board
(game "Phantom Go" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each)
    })
    
    (rules 
        (play 
            (or 
                (move Select
                    (from
                        (union 
                            (sites Empty) 
                            (sites Hidden to:Mover)
                        )
                    )
                    (then 
                        (priority {
                            (if ("NotEmpty")
                                ("IllegalMove")
                            )
                            
                            ("MadeALegalMove")
                            
                            ("IllegalMove")
                        })
                    )
                )
                (move Pass)
            )
        )
        
        (end
            (if (all Passed)
                (byScore {
                    (score P1 (+ (score P1) (size Territory P1))) 
                    (score P2 (+ (score P2) (size Territory P2)))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Persian Chess with a Queen—its indigenous name was not recorded—is a game that was played in the nineteenth century in Samarkand, Uzbekistan.8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): Any distance orthogonally or diagonally.]. 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Any distance diagonally. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. The first move must be the Fers's Sarbaz, which moves two spaces forward. Castling can happen in three moves, moving the Shah forward or backward once orthogonally and once with the Asb's  move, and moving the Rukh to the Shah's former space. Castling can also be done on the Fers's side, but moving the Rukh to the Fers's space. When a piece moves to a space occupied by an opponent's piece, the opponent's piece is captured. If the Shah can be captured on the opponent's next turn, it is in check. A player's Shah must not be in check at the end of their turn. If this is impossible, it is checkmate and the opponent wins.
         
(game "Persian Chess with a Queen"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        (piece "King_noCross" Each
            (or {
                ("StepToNotFriend" ~
                    (then 
                        (if (and
                                (= 1 (state at:(last To)))
                                (= (last To) (mapEntry "AheadKing" Mover))
                            )
                            (set State at:(last To) 2)
                            (if 
                                (!= (state at:(last To)) 0) 
                                ("PieceHasMoved" (last To))
                            ) 	
                        )
                    )
                )
                (if (and {
                        (= 1 (state at:(from)))
                        (= 1 (state at:(mapEntry "RookRight" Mover)))
                        (is Empty (mapEntry "KnightKingRightForward" Mover))
                    })
                    (move 
                        (from)
                        (to (mapEntry "KnightKingRightForward" Mover))
                        (then
                            (if 
                                (!= (state at:(last To)) 0) 
                                ("PieceHasMoved" (last To))
                            ) 		
                        )
                    )
                )
                (if (and {
                        (= 1 (state at:(from)))
                        (= 1 (state at:(mapEntry "RookLeft" Mover)))
                        (is Empty (mapEntry "KnightKingLeftForward" Mover))
                    })
                    (move 
                        (from)
                        (to (mapEntry "KnightKingLeftForward" Mover))
                        (then
                            (if 
                                (!= (state at:(last To)) 0) 
                                ("PieceHasMoved" (last To))
                            )
                        )
                    )
                )
                (if (and {
                        (= 2 (state at:(from)))
                        (= 2 (state at:(regionSite (sites Start (piece (id "King" Mover))) index:0)))
                    })
                    (move 
                        (from)
                        (to (mapEntry "KnightKingLeftBackward" Mover))
                        (then
                            ("PieceHasMoved" (last To))
                        )
                    )
                )
                (if (and {
                        (= 2 (state at:(from)))
                        (= 3 (state at:(regionSite (sites Start (piece (id "King" Mover))) index:0)))
                    })
                    (move 
                        (from)
                        (to (mapEntry "KnightKingRightBackward" Mover))
                        (then
                            ("PieceHasMoved" (last To))
                        )
                    )
                )
                }
            )
        )
        (piece "Rook" Each
            (move Slide 
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    (apply (remove (to)))
                ) 
                (then 
                    (if 
                        (= (state at:(last To)) 1) 
                        (if (and
                                (is In (last To) (sites Start (piece (id "King" Mover))))
                                (= 2 (state at:(where "King" Mover)))
                            )
                            (if (= (last From) (mapEntry "RookLeft" Mover)) (set State at:(last To) 2) (set State at:(last To) 3))
                            ("PieceHasMoved" (last To))
                        )
                    ) 
                ) 
            )	
            maxState:3
        )
        ("ChessBishop" "Bishop_noCross")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Ferz_noCross")
        ("ChessPawn" "Pawn")
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (map "AheadKing" {(pair 1 "E2") (pair 2 "E7")})
        (map "KnightKingRightForward" {(pair 1 "G2") (pair 2 "G7")})
        (map "KnightKingLeftForward" {(pair 1 "C2") (pair 2 "C7")})
        (map "KnightKingRightBackward" {(pair 1 "G1") (pair 2 "G8")})
        (map "KnightKingLeftBackward" {(pair 1 "C1") (pair 2 "C8")})
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8" state:1) 
        })
        
        (play 
            (do (forEach Piece) 
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        
        (end ("Checkmate" "King_noCross"))
    )
)

Describe the mechanics of the following Ludii game
(game "Tokkadille"
    (players 2)
    (equipment {
        ("BackgammonBoard"
            {
            (track "Track1" {12..7 5..0 13..18 20..25} P1 directed:True)
            (track "Track2" {25..20 18..13 0..5 7..12} P2 directed:True)
            (track "ReverseHuckeTrack1" {0..5 7} P1 directed:True)
            (track "ReverseHuckeTrack2" {13..18 20} P2 directed:True)
            } 
        ) 
        (dice d:6 num:2)
        (piece "Disc" Each
            (if (is In (from) (sites Mover "BeforeHucke"))
                (forEach Die 
                    if:("DieNotUsed")
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) "Track" (pips))
                            if:(and 
                                (is In (to) (sites Mover "BeforeHucke")) 
                                (not ("IsEnemyAt" (to)))
                            )
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
                (if (!= (from) ("HuckeSite"))
                    (forEach Die 
                        if:("DieNotUsed")
                        (if ("IsOffBoard" ("NextSiteFrom" (from) "Track" (pips)))
                            (move Remove (from))
                            (move 
                                (from (from))
                                (to 
                                    ("NextSiteFrom" (from) "Track" (pips))
                                    if:(not ("IsEnemyAt" (to)))
                                )
                            )
                        )
                        (then ("ReplayNotAllDiceUsed"))
                    )	
                )
            )
        ) 
        (regions "BeforeHucke" P1 (sites {12..7 5..1}))
        (regions "BeforeHucke" P2 (sites {25..20 18..14}))
        (map "Hucke" {(pair P1 0) (pair P2 13)})
    })
    (rules 
        (start {
            (place Stack "Disc1" 12 count:<Pieces:num>) 
            (place Stack "Disc2" 25 count:<Pieces:num>) 
        })
        (play 
            ("RollEachNewTurnMove"
                (do (if ("NewTurn") ("UpdateScore"))
                    next:(or { 
                        (if (and (>= 0 (var "MovingFromHucke")) (>= 0 (var "MovingToHucke"))) (forEach Piece))
                        
                        (if (>= 0 (var "MovingFromHucke"))
                            (if (or (< 0 (var "MovingToHucke")) ("CanMove2PiecesToHucke"))
                                (or 
                                    (if (and (!= 26 (var "MovingToHucke")) ("IsFriendAt" ("NextSiteFrom" ("HuckeSite") "ReverseHuckeTrack" ("Die1"))))
                                        (move 
                                            (from ("NextSiteFrom" ("HuckeSite") "ReverseHuckeTrack" ("Die1")))
                                            (to ("HuckeSite"))
                                            (then (if (= 0 (count MovesThisTurn)) (and (moveAgain) (set Var "MovingToHucke" 26)) (set Var "MovingToHucke" 0)))
                                        )
                                    )
                                    (if (and (!= 27 (var "MovingToHucke")) ("IsFriendAt" ("NextSiteFrom" ("HuckeSite") "ReverseHuckeTrack" ("Die2"))))
                                        (move 
                                            (from ("NextSiteFrom" ("HuckeSite") "ReverseHuckeTrack" ("Die2")))
                                            (to ("HuckeSite"))
                                            (then (if (= 0 (count MovesThisTurn)) (and (moveAgain) (set Var "MovingToHucke" 27)) (set Var "MovingToHucke" 0)))
                                        )
                                    )
                                )
                            )
                        )
                        
                        (if (>= 0 (var "MovingToHucke"))
                            (if (or (< 0 (var "MovingFromHucke")) ("CanMove2PiecesFromHucke"))
                                (or 
                                    (if (and (!= 26 (var "MovingFromHucke")) (not ("IsEnemyAt" ("NextSiteFrom" ("HuckeSite") "Track" ("Die1")))))
                                        (move 
                                            (from ("HuckeSite"))
                                            (to ("NextSiteFrom" ("HuckeSite") "Track" ("Die1")))
                                            (then (if (= 0 (count MovesThisTurn)) (and (moveAgain) (set Var "MovingFromHucke" 26)) (set Var "MovingFromHucke" 0)))
                                        )
                                    )
                                    (if (and (!= 27 (var "MovingFromHucke")) (not ("IsEnemyAt" ("NextSiteFrom" ("HuckeSite") "Track" ("Die2")))))
                                        (move 
                                            (from ("HuckeSite"))
                                            (to ("NextSiteFrom" ("HuckeSite") "Track" ("Die2")))
                                            (then (if (= 0 (count MovesThisTurn)) (and (moveAgain) (set Var "MovingFromHucke" 27)) (set Var "MovingFromHucke" 0)))
                                        )
                                    )
                                )
                            )
                        )
                    })
                )
                (then
                    (if (no Pieces Mover) (addScore Mover 2))
                )
            )
        )
        (end (if (<= 12 (score Mover)) (result Mover Win)))
    )
)
Tokkadille is a race game similar to other European Tables games, which is known from nineteenth century Germany, but which may be older.2x12 board, with spaces as points, divided in two. Fifteen or sixteen pieces per player, which begin on one of the points, the furthest to the right of one player and the furthest to the left of the other (they will be opposite each other). The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Doubles are only played once. Pieces may not land on a space occupied by an opponent's piece. Pieces may only move into the twelfth point on their side of the board (Hucke) with a throw that allows two pieces to move there at once. A player cannot move into or hit pieces in the opponent's Hucke. Players may move beyond their Hucke only on a throw that allows them, to move two pieces from the Hucke onto the opposite side of the board. Each player has another piece, placed at the tip of their point. The player moves this piece to mark the score they earn. Points are awarded as follows: When it is possible for a player to land on a space occupied by a single piece belonging to the opponent (a hit), a player gains one point. Hitting the opponent's Hucke is only possible by throwing two 1s with at least four pieces on the player's own Hucke. For a given throw, all possible hits made by any legal move are counted. Players move their pieces after the possible hits are calculated. A player gains two points by bringing all of their pieces into the final section of the board and bearing all of their pieces off by throwing more than the number of remaining spaces. The player who obtains twelve points wins.  Each player has 15 pieces.

Construct a Ludii game based on the following description
Bagh Batti is a hunt game played in the Garhwal region of India. It it closely similar to the games Bagh Guti and Sher Bakar, in which the hunted goats begin in a stack.5x5 board, played on intersections, with diagonals for each quadrant of the board. One player plays with two tiger pieces, placed on the midpoints of two opposite sides. The other player plays with twenty goats, divided into four stacks of five, placed in the center of each quadrant. The goats move first. Goats may move one at a time to any adjacent vacant spot. More than one goat can be placed on the goats' starting spots, but not elsewhere. The tiger moves in the same manner, but also may capture a piece by hopping over it. Multiple captures can be made on the same turn with subsequent hops, but only the top goat in a stack is captured when a tiger leaps over it. The goal of the goats is to surround the tigers so they cannot move; when one tiger is blocked the other must be blocked on the next turn. The goal of the tigers is to capture all the goats.
         
(game "Bagh Batti" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Goat" P1 "StepToEmpty")
        (piece "Tiger" P2
            (or
                ("StepToEmpty")
                ("HopSequenceCapture")
            )
        )
    }) 
    
    (rules 
        (start { 
            (place Stack "Goat1" (sites {"B2" "D2" "B4" "D4"}) counts:{5 5 5 5})
            (place "Tiger2" (sites {"C1" "C5"}))
        })
        
        (play 
            (if ("SameTurn")
                (or
                    (move Pass)
                    ("HopSequenceCaptureAgain")
                )
                (forEach Piece top:True)
            )
            
        )
        
        (end ("NoMovesP2NoPiecesP1")) 
    )
)

Construct a Ludii game based on the following description
Caturvimsatikosthakatmiki Krida is a capturing game played during the nineteenth century in India. It is documented in the Kridakausalya by Harikrsna. 3x8 board. The second space from the left and from the right in the center row are marked with an X. Eight pieces per player, which begin in the row closest to the player. Players alternate turns moving a piece to an empty adjacent space in an orthogonal direction. On the first move of a piece, that piece may move two spaces in one direction. A player may capture an opponent's piece in the central row by hopping over it to an empty space on the opposite side of it. The player who reduces their opponent to fewer than four pieces wins. 
(game "Caturvimsatikosthakatmiki Krida"
    (players 2) 
    (equipment { 
        (board (rectangle 3 8))
        (piece "Marker" Each
            (or {
                (move Hop 
                    Orthogonal
                    (between 
                        if:(and 
                            ("IsEnemyAt" (between)) 
                            (not (is In (between) (union (sites Bottom) (sites Top))))
                        )
                        (apply (remove (between)))
                    )
                    (to if:(is Empty (to)))
                )
                ("StepOrthogonalToEmpty")
                (if (= 1 (state at:(from)))
                    (move 
                        Slide
                        Orthogonal
                        (between
                            (exact 2)
                            if:(is Empty (between))
                        )
                        (then (set State at:(last To) 0))
                    )
                )
            })			
        )
    }) 
    
    (rules 
        (start {
            (place "Marker1" (sites Bottom) state:1)
            (place "Marker2" (sites Top) state:1)
        })
        (play (forEach Piece))
        (end ("HavingLessPiecesLoss" Next 3))
    )
)

Construct a Ludii game based on the following description
Cavity is a finite Go variant with an elimination goal – a bit like Mark Steere's Redstone, but without red stones. This game inspired Lifeline.Like Go, Cavity is played on the points of a square grid, and groups (chains, more precisely) and liberties are defined the same way. 
            An empty region is a group (chain) of empty points, and it is said to be adjacent to a stone if any of its points are.
            
            Setup: 
            Starting with Black, place one stone each on any empty point. 
            The setup is over as soon as the players have one stone each on the board.
            
            Play: 
            On your turn, place a stone of your color on any point in an empty region that's adjacent to a stone of your color.
            After placement, first remove all enemy groups that have no liberties, then remove all friendly groups that have no liberties.
            In this phase, as soon as one player is the only one with stones on the board, the game is over and that player is the winner.
            
        The game is balanced with the pie rule. The game is played on a 4x4 board
(game "Cavity" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each)
    })
    (rules 
        (meta (swap))
        phases:{
        (phase "Opening"
            (play (move Add (to (sites Empty))))
            (nextPhase 
                (and
                    (= 1 (count Sites in:(sites Occupied by:P1)))
                    (= 1 (count Sites in:(sites Occupied by:P2)))
                )
                "Play"
            )
        )
        (phase "Play"
            (play 
                (move Add
                    (to 
                        (sites Empty)
                        if:("ReachesRegion" 
                            (to)
                            (sites Occupied by:Mover)
                        )
                    )
                    (then 
                        (if 
                            (can Move ("CaptureSurroundedGroup" Enemy))
                            ("CaptureSurroundedGroup" Enemy)
                            ("CaptureSurroundedGroup" Mover)
                        )
                    )
                )
            )
        )
        }
        
        (end 
            (forEach Player
                if:(and
                    (< 2 (count Moves))
                    (no Pieces Player) 
                )
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Lobuduok is a four-row mancala-style board game played by the Bari people in South Sudan. The holes are scooped out of the ground and the coutners are usually seeds or pebbles, which represent cows. It is an unusual mancala-style game because certain holes are out of play during portions of the game.4x8 board. The counters begin in the following arrangement, starting from a player's left most hole in the outer row and proceeding anticlockwise: 0,0,1,0,0,1,6,0,8,0,1,0,0,1,6,8. To start, players may not sow into or sow from the leftmost and rightmost holes in both of their rows. When it is no longer possible for the player to make a legal move using only these twelve holes, they may then play using all of the holes. The opponent must continue using only twelve holes until they also cannot make a legal move with them. Sowing proceeds in an anti-clockwise direction. When the final counter falls into an occupied hole in the player's inner row and both of the opposite holes on the opponent's side of the board are occupied, the counters in the opposite holes are captured and sown beginning in the first hole that was sown into to begin the sowing that caused the capture. When the final counter falls into an occupied hole and a capture is not possible, the contents of the hole are picked up and sowing continues. When the final counter lands in an empty hole, the turn ends. Players cannot sow from a hole containing a single counter. The player who captures all of their opponent's counters wins.
         
(game "Lobudok" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "16,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (regions "SideHoles" P1 (intersection (sites Track "Track1") (union (sites Left) (sites Right)))) 
        (regions "SideHoles" P2 (intersection (sites Track "Track2") (union (sites Right) (sites Left)))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start {
            (set Count 1 to:(sites {2 5 13 10 29 26 18 21})) 
            (set Count 8 to:(sites {15 16 8 23})) 
            (set Count 6 to:(sites {6 9 22 25})) 
        })
        
        (play
            (or
                (move Select
                    (from 
                        (if ("SameTurn") 
                            "LastHoleSowed" 
                            (difference (sites Mover "Home") (sites Mover "SideHoles"))
                        ) 
                        if:(> (count at:(from)) 1)
                    )
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if 
                                (and {
                                    (is In (to) (sites Mover "Inner"))
                                    (< 1 (count at:(to)))
                                    (is Occupied ("OppositeOuterPit" (to)))
                                    (is Occupied ("OppositePit" (to)))
                                })	
                                (and {
                                    (fromTo
                                        (from ("OppositeOuterPit" (to)))
                                        (to (last From))
                                        count:(count at:("OppositeOuterPit" (to)))
                                    )
                                    (fromTo
                                        (from ("OppositePit" (to)))
                                        (to (last From))
                                        count:(count at:("OppositePit" (to)))
                                    )
                                    (sow
                                        (last From)
                                        count:(+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))))
                                        "Track"
                                        owner:(mover)	
                                        skipIf:(and (!= 1 (value Player Mover)) (is In (to) (sites "SideHoles")))
                                    )
                                })
                                (if (< 1 (count at:(to)))
                                    (moveAgain)
                                )
                            )
                            skipIf:(and (!= 1 (value Player Mover)) (is In (to) (sites "SideHoles")))
                        )
                    )
                )
                (if 
                    (if (= 1 (value Player Mover))
                        True
                        (all Sites (difference (sites Mover "Home") (sites Mover "SideHoles")) if:(<= (count at:(site)) 1))
                    )
                    (move Select
                        (from 
                            (if ("SameTurn") 
                                "LastHoleSowed" 
                                (sites Mover "SideHoles")
                            ) 
                            if:(> (count at:(from)) 1)
                        )
                        (then
                            (and
                                (sow
                                    "Track"
                                    owner:(mover)
                                    apply:(if 
                                        (and {
                                            (is In (to) (sites Mover "Inner"))
                                            (< 1 (count at:(to)))
                                            (is Occupied ("OppositeOuterPit" (to)))
                                            (is Occupied ("OppositePit" (to)))
                                        })	
                                        (and {
                                            (fromTo
                                                (from ("OppositeOuterPit" (to)))
                                                (to (last From))
                                                count:(count at:("OppositeOuterPit" (to)))
                                            )
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (last From))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (sow
                                                (last From)
                                                count:(+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))))
                                                "Track"
                                                owner:(mover)	
                                            )
                                        })
                                        (if (< 1 (count at:(to)))
                                            (moveAgain)
                                        )
                                    )
                                )
                                (if (= 0 (value Player Mover))
                                    (set Value Mover 1)
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end ("ForEachPlayerNoMovesLoss"))
    )
)

Construct a Ludii game based on the following description
Order and Chaos is an asymmetric variant of the game tic-tac-toe on a 6×6 gameboard.The game starts with the board empty. Order plays first, then turns alternate. On each turn, a player places either an X or an O on any open square. Order aims to get five like pieces in a row either vertically, horizontally, or diagonally. Chaos aims to fill the board without completion of a line of five like pieces. 
(game "Order and Chaos" 
    (players 2) 
    (equipment { 
        (board (square 6)) 
        (piece "Disc" Shared) 
        (piece "Cross" Shared)
        (hand Shared size:2) 
    }) 
    (rules 
        (start {
            (place "Disc" (handSite Shared)) 
            (place "Cross" (handSite Shared 1))
        })
        (play 
            (move 
                (from (sites Hand Shared)) 
                (to (sites Empty))
                copy:True
            )
        )
        (end {
            (if (is Line 5) (result P1 Win))
            (if (no Moves Next) (result P2 Win))
        })
    )
)

Construct a Ludii game based on the following description
Julbahar is a race game played in Southwest Asia, one of the different types which are called Tawulat ul-Zahr. It is unique because in the first move, a player moves the opponent's pieces.The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Two six-sided die. Each player has 15 pieces. Each player's fifteen pieces begin on the first point of their track. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. Play begins with each player throwing the dice. The player who obtains the higher number goes first, except when doubles are thrown, then the opponent must throw higher doubles. The player who wins the opening throw moves the opponent's pieces according to the value of this throw. Play then continues as usual. A piece cannot land on a space occupied by one of the opponent's pieces. Pieces move around the board to the opposite quadrants from the player's starting position. Players may bear a piece off the board once it reaches one of the final six points on the board. Until all of the player's remaining pieces are on the final six points, the player may only bear off a piece on one of the final six spaces by throwing exactly one more than the number of remaining points. The player who bears off all of their pieces wins. The winning player's score equals the number of the opponent's pieces which are left on the board. In addition, whenever a player is unable to move and the opponent is able to, the opponent gains five points. Play continues until one player's score reaches 31.
             
(games (subgame "JulbaharSubgame" result:(score Mover)))

Construct a Ludii game based on the following description
Ngrin is an alignment game played by children in the Republic of Congo.Square with diagonals and lines connecting the midpoints of the sides. Three pieces per player. The first player places their piece in the center. Players alternate turns placing a piece on an empty spot on the board. The first player to make three in a row wins. 
(game "Ngrin"
    (players 2) 
    (equipment {
        (board (square 3 diagonals:Alternating) use:Vertex)
        (piece "Marker" Each)
    }) 
    (rules 
        phases:{
        (phase "Opening" (play (move Add (to (centrePoint)))) (nextPhase "Playing"))
        (phase "Playing" (play (move Add (to (sites Empty)))))
        }
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
Amazon Chess is a version of Chess where the queen also has the movement ability of a Chess knight. The queen is known instead as an \The rules are exactly the same as in Chess, except the Queen also has the ability to move as a knight. 
(game "Amazon Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        (piece "Queen" Each
            (or
                ("SlideCapture" ~ ~ (then (set Counter)))
                ("LeapCapture" "KnightWalk" (then (set Counter)))
            )
        )
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start
            { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
            }
        )
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        ("Castling")
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Tobi Shogi is a game with leaping captures that was played in Japan during the early twentieth century. It uses the Shogi board and pieces, but adapts them to a different game entirely.9x9 board. Played with the full complement of Shogi pieces, placed in the first and second rows. All pieces move only one space orthogonally forward or laterally. Pieces capture by hopping over an opponent's piece. The player to capture all of the opponent's pieces wins. 
(game "Tobi Shogi" 
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 9))
        (piece "Osho" Each "PieceMove")
        (piece "Kinsho" Each "PieceMove")
        (piece "Ginsho" Each "PieceMove")
        (piece "Keima" Each "PieceMove")
        (piece "Kyosha" Each "PieceMove")
        (piece "Fuhyo" Each "PieceMove")
    })
    (rules 
        (start { 
            (place "Osho1" coord:"E1") (place "Kinsho1" {"D1" "F1"}) (place "Ginsho1" {"C1" "G1"}) (place "Keima1" {"B1" "H1"}) (place "Kyosha1" {"A1" "I1"}) (place "Fuhyo1" (sites Row 1))
            (place "Osho2" coord:"E9") (place "Kinsho2" {"D9" "F9"}) (place "Ginsho2" {"C9" "G9"}) (place "Keima2" {"B9" "H9"}) (place "Kyosha2" {"A9" "I9"}) (place "Fuhyo2" (sites Row 7))
        })
        
        (play (forEach Piece))
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
This pattern was found on an object from Roman Coriovallum, in the Netherlands. The objet appears to be a game based on its manufacture and the wear patterns on the stone.The board has no extension and joined diagonals. Haretavl rules. The board has no extension and joined diagonals. Haretavl rules.
(game "Ludus Coriovalli"
    <Variant>
)

Construct a Ludii game based on the following description
Muvalavala is a four-row mancala-style board game that is played in different ways in what is now Angola. This version is played by the Quioco people.4x6-16 board. Number of counters per player is four times the number of holes in a row minus two. Counters are distributed only in the outer row, with two counters in each hole, except the hole on the far left which contains the rest. The counters are then redistributed so that there is one in every hole, except the one on the extreme left in the inner and outer hole. The one on the left in the inner hole remains empty and the one in the outer row retains the same number initially placed there. Play begins from any of the player's holes, sowing anti-clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues, unless a capture can be made. Captures are made when the final counter falls into an occupied hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. These are then sown from the hole following the one from which the capture occurred. If the final counter falls into an empty hole, the turn is over. Single counters cannot be sown. Play ends when one player cannot move. Each row has 6 holes.
(game "Muvalavala (Quioco)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            <Board:track2>
            }
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))          
        (regions "Outer" P2 (sites Top))           
    }) 
    (rules 
        
        (start { 
            (set Count 1 
                to:(union { 
                    (difference (sites P1 "Home") (sites Left)) 
                    (difference (sites P2 "Home") (sites Right)) 
                }) 
            ) 
            (set Count (- (- (* 4 "Columns") 2) (* 2 (- "Columns" 1))) 
                to:(union 
                    (intersection (sites Left) (sites P1 "Outer"))
                    (intersection (sites Right) (sites P2 "Outer"))
                )
            )
        })
        
        (play 
            (move
                Select
                (from 
                    (if ("SameTurn") 
                        ("LastHoleSowed")
                        (sites Mover "Home") 
                    ) 
                    if:(> (count at:(from)) 1)
                )
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (and {
                                (> (count at:(to)) 1)
                                (is In (to) (sites Mover "Inner")) 
                                (> (count at:("OppositePit" (to))) 0) 
                            })
                            (and
                                {
                                (fromTo 
                                    (from ("OppositePit" (to))) 
                                    (to (to)) 
                                    count:(count at:("OppositePit" (to)))
                                ) 
                                (if (> (count at:("OppositeOuterPit" (to))) 0)
                                    (fromTo 
                                        (from ("OppositeOuterPit" (to))) 
                                        (to (to)) 
                                        count:(count at:("OppositeOuterPit" (to)))
                                    )
                                )
                                (sow 
                                    (to)
                                    count:(+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))))
                                    "Track"
                                    owner:(mover)
                                )
                                }
                            )
                            (if (> (count at:(to)) 1) (moveAgain))
                        )
                    )
                )
            )
        )
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Make Muster is one of several unification games that can be played on the Muster board. The Muster board is a rotated square board with ragged edges and 8 directions of connectivity. Standard sizes are order 2 through order 6. Each order board has 5 x the order squared playing positions.On your turn, place a single piece of your color on an empty position that is not next to another friendly piece. This is compulsory whenever it is possible to do so.
            
            When it is not possible to place a piece; then instead, step one of your pieces to an adjacent empty position. 
            
            You win either:
            -- when all your pieces become connected, or
        -- when you cut-off your opponent from being able to connect theirs. Board: Muster order 2 board - 20 positions Orthogonal
(game "Make Muster"
    (players 2)
    (equipment {
        (board 
            (rotate (- 90 <Orient:amount>)
                (square <Board:poly>)
            ) 
            use:Cell 
        )
        (piece "Disc" Each ("StepToEmpty"))
    })
    (rules
        (play
            (priority
                (move Add
                    (to (sites Empty)
                        if:(no Pieces Mover in:(sites Around (to) Adjacent))
                    )
                )
                (forEach Piece)
            )
        )
        (end 
            (if 
                (or
                    (and { 
                        ("IsSingleGroup" Mover All)
                        (< 1 (count Pieces Mover))
                        
                        
                    })
                    (< 1 (count Groups All if:(!= (mover) (who at:(to)))))
                )
                (result Mover Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Permainan-Tabal" 
    ("TwoPlayersNorthSouth")
    (equipment { 
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (piece "Counter" P1 N)
        (piece "Counter" P2 S) 
        (piece "DoubleCounter" Each)
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    
    (rules 
        (start {
            (place "Counter1" (difference (expand (sites Bottom) steps:4) (sites Row 4)))
            (place "Counter2" (difference (expand (sites Top) steps:4) (sites Row 4)))
        })
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    ("HopStyle" (from (last To)) Adjacent
                        (then 
                            ("ReplayIfCanMove" ("HopStyle" (from (last To)) Adjacent)
                                ("PromoteIfReach" (sites Next) "DoubleCounter")
                            )
                        ) 
                    )
                    ("HopSequenceCaptureAgain" before:(count Rows) after:(count Rows))
                )
                (priority {
                    (or 
                        (forEach Piece "Counter"
                            ("HopStyle" (from) Adjacent
                                (then 
                                    ("ReplayIfCanMove" ("HopStyle" (from (last To)) Adjacent) 
                                        ("PromoteIfReach" (sites Next) "DoubleCounter")
                                    )
                                ) 
                            ) 
                        )
                        (forEach Piece "DoubleCounter" ("HopSequenceCapture" before:(count Rows) after:(count Rows)))
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {Forwards Rightward Leftward}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Adjacent))
                    )
                })
            )
        )
        
        (end ("BlockWin"))
    )
)
Permainan-Tabal is a two-player abstract strategy board game from Indonesia.Players alternate their turns using one piece to either move or capture exclusively per turn.
            Pieces may only move one space per turn either straight forward, diagonally forward, or sideways along a line onto a vacant adjacent intersection point. They cannot move backwards in any direction until they are promoted to Kings. However, pieces can make capturing moves backward.
            Captures are compulsory.
            Captured pieces are removed from the board.
            For pieces that have not yet been promoted to King, their captures are done by the short leap as in draughts and Alquerque. A piece leaps over an adjacent enemy piece onto a vacant adjacent intersection point on the other side. The leap must be in a straight line following the pattern on the board. Even pieces that are not yet promoted to King can capture enemy pieces backwards. A player's piece must continue to capture within a turn provided each capture meets the criteria of the short leap.
            A piece is promoted to King when it reaches the other player's first rank.
            Kings can move any number of unoccupied spaces in any available direction following the pattern of the board like the King in international draughts.
            Kings can leap over an enemy piece (and only one enemy piece per leap) from any distance and land any distance behind it onto a vacant intersection point as in the King in international draughts. The King must continue to capture within the turn if it is able to do so.
        The player who captures all of their opponent's pieces is the winner. 

Construct a Ludii game based on the following description
Minishogi was invented in 1970 by Shigenobu Kusumoto. It is a Shogi variant with fewer pieces nd played on a 5x5 board.The rules are identical to those of standard Shogi, except that it is played with a reduced number of pieces on a 5x5 board, and each player's promotion zone consists only of the rank furthest from the player. 
(game "Minishogi" 
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        (board (square 5))
        
        
        (piece "Osho" Each ("StepMove"))
        
        
        (piece "Fuhyo" Each ("StepMove" Forward "ForcePromote"))
        
        
        (piece "Ginsho" Each ("StepMove" (directions {Forward BL BR FL FR}) "CanPromote"))
        
        
        (piece "Hisha" Each ("SlideMove" Orthogonal "CanPromote"))
        
        
        (piece "Kakugyo" Each ("SlideMove" Diagonal "CanPromote"))
        
        
        ("ShogiGold" "Kinsho" "CapturePiece")
        
        
        ("ShogiGold" "Tokin" "CapturePiece")
        
        
        ("ShogiGold" "Narigin" "CapturePiece")
        
        
        (piece "Ryuo" Each (or ("SlideMove" Orthogonal) ("StepMove" Diagonal)))
        
        
        (piece "Ryuma" Each (or ("SlideMove" Diagonal) ("StepMove" Orthogonal)))
        
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
        (map "Where" { 
            (pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) 
            (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) 
            (pair (id "Hisha" P1) (handSite P2 2)) (pair (id "Hisha" P2) (handSite P1 2)) 
            (pair (id "Kakugyo" P1) (handSite P2 3)) (pair (id "Kakugyo" P2) (handSite P1 3)) 
            (pair (id "Kinsho" P1) (handSite P2 4)) (pair (id "Kinsho" P2) (handSite P1 4)) 
            (pair (id "Tokin" P1) (handSite P2)) (pair (id "Tokin" P2) (handSite P1)) 
            (pair (id "Narigin" P1) (handSite P2 1)) (pair (id "Narigin" P2) (handSite P1 1)) 
            (pair (id "Ryuo" P1) (handSite P2 2)) (pair (id "Ryuo" P2) (handSite P1 2)) 
            (pair (id "Ryuma" P1) (handSite P2 3)) (pair (id "Ryuma" P2) (handSite P1 3)) 
        })
        (map "Captured" { 
            (pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) 
            (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) 
            (pair (id "Hisha" P1) (id "Hisha" P2)) (pair (id "Hisha" P2) (id "Hisha" P1)) 
            (pair (id "Kakugyo" P1) (id "Kakugyo" P2)) (pair (id "Kakugyo" P2) (id "Kakugyo" P1)) 
            (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) 
            (pair (id "Tokin" P1) (id "Fuhyo" P2)) (pair (id "Tokin" P2) (id "Fuhyo" P1)) 
            (pair (id "Narigin" P1) (id "Ginsho" P2)) (pair (id "Narigin" P2) (id "Ginsho" P1)) 
            (pair (id "Ryuo" P1) (id "Hisha" P2)) (pair (id "Ryuo" P2) (id "Hisha" P1)) 
            (pair (id "Ryuma" P1) (id "Kakugyo" P2)) (pair (id "Ryuma" P2) (id "Kakugyo" P1)) 
        })
        (map "Promoted" { 
            (pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) 
            (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) 
            (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) 
            (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2)) 
        })
        
        (hand Each size:5)
    })
    
    (rules 
        (start { 
            (place "Osho1" coord:"A1") (place "Kinsho1" coord:"B1") (place "Ginsho1" coord:"C1") (place "Kakugyo1" coord:"D1") (place "Hisha1" coord:"E1") (place "Fuhyo1" coord:"A2")
            (place "Osho2" coord:"E5") (place "Kinsho2" coord:"D5") (place "Ginsho2" coord:"C5") (place "Kakugyo2" coord:"B5") (place "Hisha2" coord:"A5") (place "Fuhyo2" coord:"E4")
        })
        
        (play
            (if ("SameTurn")
                (or
                    ("Promote")
                    (move Pass)
                )
                (do 
                    (or {
                        (move 
                            (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) 
                            (to (sites Empty))
                        ) 
                        (do 
                            (move 
                                (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) 
                                (to (difference (sites Empty) (sites Mover "Promotion"))
                                    if:("OnePawnPerColumn" Mover)
                                ) 
                            ) 
                            ifAfterwards:(not (and ("IsInCheck" "Osho" Next) ("NextCannotMove")))
                        )
                        (forEach Piece) 
                    })
                    ifAfterwards:(not ("IsInCheck" "Osho" Mover))
                )
            )
        )
        
        (end {
            (if (and ("IsInCheck" "Osho" Next) ("NextCannotMove")) (result Mover Win)) 
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
Xiangqi, or \Played on a board with 9x10 intersecting lines. Pieces are placed on the intersections of the lines. Centered on opposite sides of the boards are two areas, known as the gong (\ 
(game "Xiangqi" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (rectangle 10 9) use:Vertex) 
        
        
        (piece "Jiang" Each ("StepMoveOnThePalace" Orthogonal)) 
        
        
        (piece "Shi" Each ("StepMoveOnThePalace" Diagonal)) 
        
        
        (piece "Xiang" Each 
            (move Slide
                Diagonal 
                (between 
                    (exact 2) 
                    if:(and { 
                        (is In (between) (sites Mover "Home")) 
                        (is Empty (between)) 
                    })
                )
                (to 
                    if:("IsEnemyAt" (to)) 
                    (apply (remove (to)))
                ) 
            )
        ) 
        
        
        (piece "Ma" Each 
            (forEach Direction 
                Orthogonal 
                (to 
                    if:(is Empty (to)) 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL} of:All) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (remove (to))
                                        )
                                    )
                                )
                            )
                        ) 
                    )
                )
            ) 
        )
        
        
        (piece "Ju" Each ("SlideCapture" Orthogonal))
        
        
        (piece "Pao" Each 
            (or 
                (move Slide Orthogonal) 
                (move Hop
                    Orthogonal 
                    (between 
                        before:(count Rows) 
                        after:(count Rows) 
                        if:(is Occupied (between))
                    )
                    (to 
                        if:(is Empty (to)) 
                        (apply 
                            if:("IsEnemyAt" (to)) 
                            (remove (to))
                        )
                    ) 
                ) 
            )
        )
        
        
        (piece "Zu" Each
            ("StepToNotFriend"
                (if 
                    (is In (from) (sites Mover "Home")) 
                    Forward 
                    (directions {Forward Rightward Leftward})
                ) 
            )
        )
        
        (regions "PalaceP1" P1 { 3..5 12..14 21..23 })
        (regions "PalaceP2" P2 { 66..68 75..77 84..86 })
        (regions "Home" P1 (expand (sites Bottom) steps:4))
        (regions "Home" P2 (expand (sites Top) steps:4))
    }) 
    
    (rules 
        (start { 
            (place "Jiang1" coord:"E1") (place "Shi1" {"D1" "F1"}) (place "Xiang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Ju1" {"A1" "I1"}) (place "Pao1" {"B3" "H3"}) (place "Zu1" {"A4" "C4" "E4" "G4" "I4"})
            (place "Jiang2" coord:"E10") (place "Shi2" {"D10" "F10"}) (place "Xiang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Ju2" {"A10" "I10"}) (place "Pao2" {"B8" "H8"}) (place "Zu2" {"A7" "C7" "E7" "G7" "I7"})
        })
        
        (play (do 
                (forEach Piece) 
                ifAfterwards:(and 
                    ("JiangSameColumnWithNoPieceBetween")
                    (not ("IsInCheck" "Jiang" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "Jiang")
            ("BlockWin")
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Tic-Tac-Mo" 
    (players 3) 
    (equipment { 
        (board (rectangle 3 5)) 
        (piece "Disc" P1) 
        (piece "Cross" P2) 
        (piece "Y" P3) 
    }) 
    (rules 
        (play (move Add (to (sites Empty))))
        (end ("Line3Win"))
    )
)
Tic-Tac-Mo is a three player version of Tic-Tac-Toe using \Tic-Tac-Mo uses the same rules as Tic-Tac-Toe, but the third player plays with a \ 

Construct a Ludii game based on the following description
Lelac is a two-player strategy game related to mancalas.The game is played on a board with ten round pits arranged in a circle. Each player owns the semicircle closest to him. The game requires ten seeds and one standard six-faced die. At the start of the game, each pit contains one seed.
            
            During their turn, a player rolls a die. He then chooses one of his nonempty pits to sow. They take one seed from the sown pit, and move it counterclockwise according to the die value rolled. Then, they must roll to move each remaining seed from the sown pit. The turn only ends once the sown pit is empty. So, for example, if a player chooses to sow a pit with 4 seeds after his initial roll, 3 additional rolls will be needed.
            
        A player wins when all ten seeds are on their part of the board at the end of their turn. 
(game "Lelac"
    (players 2)
    (equipment {
        (board 
            (concentric {0 10}) 
            (track "Track" {0..9} loop:True)
            use:Vertex
        )
        (piece "Square" Shared)
        (dice d:6 num:1)
        (regions P1 (expand (sites Bottom) steps:2)) 
        (regions P2 (expand (sites Top) steps:2)) 
    })
    (rules
        (start (set Count 1 to:(sites Board)))
        (play
            ("RollMove"
                (move 
                    (from 
                        (if ("SameTurn")
                            (sites {(last From)})
                            (forEach (sites Mover) if:(is Occupied (site)))
                        )
                    )
                    (to ("NextHoleFrom" (from) (count Pips)))
                    (then (if (is Occupied (last From)) (moveAgain)))
                )
            )
        )
        (end 
            (forEach Player
                if:(all Sites (sites Player) if:(and (is Next Player) (is Empty (site))))
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Li'b al-Ghashim (\2x6 board. 72 counters are distributed unevenly into the holes by one player in both rows, placing at least four in each hole. The opponent moves first, but may flip the board around if they prefer that arrangement. Each move must begin from the rightmost hole in a player's row or the next closest hole to it from which it is possible to move. Counters are sowed in an anti-clockwise direction. If the last counter falls into a hole making it odd, these are picked up and sowing continues. If it lands in a hole making it even, these counters are captured as are the ones in the opposite hole. If the previous hole also has an even number, these and the ones in the opposite hole are captured. If the last counter falls into an empty hole, the turn ends. If a player has no counters in their holes, the opponent must give them one counter, to be placed in the leftmost hole and played from there. Play ends when the board is cleared of counters. Each player counts the number of counters they captured. The player with more counters is given a score equal to the difference in the number of counters. Another round begins as before, with the loser distributing the counters and the winner playing first.. The game is won when a player accumulates sixty points. 
(game "Li'b al-Ghashim" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightMost" {(pair P1 5) (pair P2 6)})
    }) 
    (rules 
        (start (place "Seed" (handSite P1) count:72))
        
        phases:{
        (phase "Opening1"
            (play 
                (or {
                    (if (is Occupied Cell (handSite P1))
                        (forEach Value min:1 max:(count Cell at:(handSite P1))
                            (move 
                                (from (handSite P1))
                                (to (sites Board))
                                count:(value)
                            )
                        )
                        (forEach Site (sites Board)
                            (if (is Occupied (site))
                                (move
                                    (from (site))
                                    (to (sites Board) if:(!= (to) (from)))
                                )
                            )
                        )
                        (then (moveAgain))
                    )
                    (if (and (is Empty (handSite P1)) ("FourInEach"))
                        (move Pass)
                    )
                })
            )
            (nextPhase (was Pass) "Opening2")
        )
        
        (phase "Opening2"
            (play
                (or 
                    (move Pass (then (and (set Pending) (moveAgain))))
                    (move Swap Players P1 P2 (then (and (set NextPlayer (player 1)) (set Pending))))
                )
            )
            (nextPhase "Sowing")
        )
        
        (phase "Sowing"
            (play
                (if (and ("NewTurn") ("NoCounters" Next))
                    (move
                        (from (sites Mover) if:(is Occupied (from)))
                        (to ("RightMostNotEmpty"))
                    )
                    (move Select
                        (from 
                            (if 
                                (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay") })
                                (sites Mover) 
                            ) 
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                "TrackCCW"
                                if:True
                                apply:(if (is Odd (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                    (and
                                        (fromTo
                                            (from (to))
                                            (to (handSite Mover))
                                            count:(count at:(to))
                                        )
                                        (if (is Occupied ("OppositePitTwoRows" (to)))
                                            (fromTo
                                                (from ("OppositePitTwoRows" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePitTwoRows" (to)))
                                            )
                                        )
                                    )
                                )
                                backtracking:(and (is Occupied (to)) (is Even (count at:(to))))
                            )
                        )
                    )
                    (then
                        (if ("EmptyBoardOrOne")
                            (and {
                                (if (< (count Cell at:(handSite P1)) (count Cell at:(handSite P2)))
                                    (addScore P2 (- (count Cell at:(handSite P2)) (count Cell at:(handSite P1))))
                                    (addScore P1 (- (count Cell at:(handSite P1)) (count Cell at:(handSite P2))))
                                )
                                (if (is Occupied Cell (handSite P2))
                                    (fromTo
                                        (from (handSite P2))
                                        (to (handSite P1))
                                        count:(count Cell at:(handSite P2))
                                    )
                                )
                                (forEach Site (sites Board)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to Cell (handSite P1))
                                            count:(count at:(site))
                                        )
                                    )	
                                )	
                            })
                        )
                    )
                )
            )
            (nextPhase ("EmptyBoardOrOne") "Opening1")
        )
        }
        
        (end
            (forEach Player
                if:(<= 60 (score Player))
                (result Player Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Vela" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 9)
        (piece "Marker" Each)
    }) 
    
    (rules 
        (start { 
            (place "Marker1" (union (expand (sites Bottom)) (sites {"B3" "D3" "G3" "I3"})))
            (place "Marker2" (union (sites {"A3" "C3" "F3" "H3"}) (expand (sites Top))))
        })
        
        phases:{
        (phase "CapturingFirstPhase"
            (play
                (priority {
                    (if (is Mover P1)
                        (or 
                            ("MoveIn" (to) SameDirection (last To) ("LastDirection" Vertex))
                            ("MoveIn" (from) OppositeDirection (last From) (directions Vertex from:(last To) to:(last From)))
                        )
                    )
                    (forEach Piece "StepToEmpty")
                })
            )	
            (nextPhase (<= (count Pieces P2) 5) "FanoronaPhase")
        )
        
        (phase "FanoronaPhase"
            (play
                (if "SameTurn"
                    (or 
                        (if (is Occupied (last To)) 
                            ("CaptureFromLast" (last To)) 
                            ("CaptureFromLast" (last From))
                        )
                        (move Pass)
                    )
                    (priority {
                        (or 
                            ("MoveIn" (to) SameDirection (last To) ("LastDirection" Vertex) "MoveAgain")
                            ("MoveIn" (from) OppositeDirection (last From) (directions Vertex from:(last To) to:(last From)) "MoveAgain")
                        )
                        (forEach Piece "StepToEmpty")
                    })
                )
            )	
            (end (if (no Pieces Mover) (result Next Win)))
        )
        }
    )
)
Véla is a form of Fanorona played in Madagascar. This game is played when a player has lost at the standard game of Fanorona, and they may not play the standard game again until they either win at this game or admit inferiority to the winner.9x5 intersecting lines with diagonals in each square formed by 3x3 intersecting lines. Each player has 22 pieces, starting on the intersections of the lines except in the centre position, placed on opposite rows of the board, but alternating in the central row. Pieces move to an adjacent intersection along the lines. In the first phase of play, one player cannot capture until they have been reduced to five pieces. The opponent may only capture, according to the following rules, but only one piece at a time is captured, even when multiple would normally be allowed. When the one player is reduced to five pieces, play continues as follows. Players must capture pieces when possible. Capturing is accomplished by moving to an adjacent intersection to an opposing piece in the continuing direction of the capturing stones movement, or by moving away from an adjacent opposing pieces in such a direction. When an opponent's piece is captured, all other of the opponent's pieces in that line are also captured. Multiple captures can be made, but cannot be done by moving twice in the same direction. Multiple captures are optional. A player wins by capturing all of the other player's pieces. 

Construct a Ludii game based on the following description
Forçado is a version of Chess, played in the medieval period where captures are forced. It is recorded in Alfonso X's Libro de los Juegos.8x8 board. The pieces move as follows, with the number per player: 1 x King: moves one space orthogonally or diagonally. 1 x Queen : One square diagonally. 2 x Rook: Any number of spaces orthogonally. 2 x Fil: Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; 8 x Pawns: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Pawns are promoted to Queen when reaching the eighth rank. No castling. When a piece can be captured, it must be. The highest ranking piece must be captured, and the lowest ranking piece must make the capture if several are able to capture the same piece. The ranking, from highest to lowest, is: King, Rook, Knight, Queen, Fil, Pawn. Stalemate results in a win for player causing it. The player who checkmates the king wins.
         
(game "Forcado" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn" ~ (then ("PromoteIfReach" (sites Mover "Promotion") "Ferz_noCross")))
        ("ChessRook" "Rook")
        ("ChessKing" "King_noCross")
        (piece "Bishop_noCross" Each 
            (move Hop 
                Diagonal 
                (between if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        ("IsEnemyAt" (to))
                    ) 
                    (apply (if ("IsEnemyAt" (to)) (remove (to))))
                )
            )
        )
        ("ChessKnight" "Knight")
        (piece "Ferz_noCross" Each ("StepToNotFriend" Diagonal))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        
        (play 
            
            (priority {
                (do (forEach Piece {"Pawn"}   ("PawnOnlyCapture" (id "Rook" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Bishop_noCross"} ("BishopOnlyCapture" (id "Rook" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Ferz_noCross"} ("QueenOnlyCapture" (id "Rook" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Knight"}   ("KnightOnlyCapture" (id "Rook" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Rook"}   ("RookOnlyCapture" (id "Rook" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"King_noCross"} ("KingOnlyCapture" (id "Rook" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                
                (do (forEach Piece {"Pawn"}   ("PawnOnlyCapture" (id "Knight" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Bishop_noCross"} ("BishopOnlyCapture" (id "Knight" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Ferz_noCross"} ("QueenOnlyCapture" (id "Knight" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Knight"}   ("KnightOnlyCapture" (id "Knight" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Rook"}   ("RookOnlyCapture" (id "Knight" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"King_noCross"} ("KingOnlyCapture" (id "Knight" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                
                (do (forEach Piece {"Pawn"}   ("PawnOnlyCapture" (id "Ferz_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Bishop_noCross"} ("BishopOnlyCapture" (id "Ferz_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Ferz_noCross"} ("QueenOnlyCapture" (id "Ferz_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Knight"}   ("KnightOnlyCapture" (id "Ferz_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Rook"}   ("RookOnlyCapture" (id "Ferz_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"King_noCross"} ("KingOnlyCapture" (id "Ferz_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                
                (do (forEach Piece {"Pawn"}   ("PawnOnlyCapture" (id "Bishop_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Bishop_noCross"} ("BishopOnlyCapture" (id "Bishop_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Ferz_noCross"} ("QueenOnlyCapture" (id "Bishop_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Knight"}   ("KnightOnlyCapture" (id "Bishop_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Rook"}   ("RookOnlyCapture" (id "Bishop_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"King_noCross"} ("KingOnlyCapture" (id "Bishop_noCross" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                
                (do (forEach Piece {"Pawn"}   ("PawnOnlyCapture" (id "Pawn" Next)) Mover) 	ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Bishop_noCross"} ("BishopOnlyCapture" (id "Pawn" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Ferz_noCross"} ("QueenOnlyCapture" (id "Pawn" Next)) Mover) 	ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Knight"}   ("KnightOnlyCapture" (id "Pawn" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"Rook"}   ("RookOnlyCapture" (id "Pawn" Next)) Mover) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                (do (forEach Piece {"King_noCross"} ("KingOnlyCapture" (id "Pawn" Next)) Mover) 	ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                
                (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                
            })
            
        )
        
        (end
            (if 
                (or
                    (and 
                        ("IsInCheck" "King_noCross" Next)
                        ("NextCanNotMove")
                    )
                    (no Moves Next)
                )
                (result Mover Win)
            ) 
        )
    )
)

Construct a Ludii game based on the following description
Korkserschach is a Chess game played in Germany until the nineteenth century. While it was played, it was considered a lesser, or unofficial, version of the game.Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space forward, or one space diagonally forward to capture; Players agree at the beginning of the game whether pawns may move two spaces on their first turn. Two pawns may be moved by a player in their first turn of the game. Pawns may only be promoted to a piece that has already been captured. If none have been captured, the pawn must remain in place until a piece has been captured. Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally, jumping over any intervening pieces; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. A King cannot castle if it has ever been checked. Players capture pieces by moving onto a space occupied by an opponent's piece. A player must say 'Gardez la reine' (Guard the Queen) when the queen is threatened. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. A player who causes a stalemate loses.
         The pawns can double step from the starting positions.
(game "Korkserschach" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        (piece "Pawn" Each 
            (if (!= (last To) (from))
                (or {
                    (if (and ("AtLeastAStrongPieceWasCapture") (is In (from) (sites Mover "Promotion")))
                        ("PromoteMove" (from) (then (set Pending)))
                    )
                    <Play:doubleStep>
                    "StepForwardToEmpty" 
                    "CaptureForwardDiagonal"
                    }
                    (then
                        (and 
                            (if (and
                                    (is In (last To) (sites Mover "Promotion")) 
                                    ("AtLeastAStrongPieceWasCapture")
                                )
                                (moveAgain)
                            )
                            (if (and ("NewTurn") (<= (count Turns) 2))
                                (and
                                    (set Pending)
                                    (moveAgain)
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (piece "Rook" Each 
            (move Slide 
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPiece"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "King" Each 
            (move Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "Bishop" Each 
            (move Slide 
                Diagonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "Knight" Each 
            (move Leap 
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "Queen" Each 
            (move Slide 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPiece"
                ) 
            ) 
        )
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if (and (not (is Pending)) "SameTurn")
                ("PromoteMove" (last To))
                (do 
                    (if (is Pending)
                        (or 
                            (move Pass)
                            (forEach Piece "Pawn" Mover)
                        )
                        (or 
                            (forEach Piece)
                            (if (and 
                                    ("HasNeverMoved" "King")
                                    (not ("IsInCheck" "King" Mover)) 
                                )
                                (or
                                    (if (and 
                                            ("HasNeverMoved" "RookLeft")
                                            (can Move ("CastleRook" "RookLeft" E 3 (is Empty (to))))
                                        )
                                        "BigCastling"
                                    )
                                    (if (and 
                                            ("HasNeverMoved" "RookRight")
                                            (can Move ("CastleRook" "RookRight" W 2 (is Empty (to))))
                                        )
                                        "SmallCastling"
                                    )
                                )
                            )
                        )
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
                (then 
                    (and
                        (if (or ("IsInCheck" "Queen" P1) ("IsInCheck" "Queen" P2))
                            (note "Gardez la reine")
                        )
                        (if (and (= (state at:(where "King" Next)) 1) ("IsInCheck" "King" Next))
                            ("PieceHasMoved" (where "King" Next))
                        )
                    )
                )
            )
        )
        
        (end ("Checkmate" "King"))
    )
)

Construct a Ludii game based on the following description
Atari Go is a simplified version of Go where the first person to capture a stone wins.The rules are identical to Go, except the winning condition is to be the first to capture a stone. The game is played on a 9x9 board.
(game "Atari Go" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each)
    })
    
    (rules 
        (play 
            (do
                (move Add
                    (to (sites Empty))
                    (then ("CaptureSurroundedPiece"))
                )
                ifAfterwards:("HasFreedom" Orthogonal)
            )
        )
        (end (if "HasMadeACapture" (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Tamman is a race game with a spiralling track on a square board that was played in the coastal regions of Somaliland in the early twentieth century.5x5 board; the central row and column being slightly wider than the others. Two to four players. Four pieces per player. Pieces begin on one of the central squares around the perimeter of the squares; if there are two players, they begin from opposite sides. Four cowrie shells are used as dice, with the count of the throw determined by the number of mouths which land face-up, with none facing up equaling 8. A throw of 4 gives the player another throw. Only the first throw matters for winning extra throws. Pieces move anti-clockwise from their origin point around the perimeter of the square, until they come to the final square before returning to the origin point. They then turn left and proceed around the inner perimeter of squares in a clockwise direction, until the space directly between the origin point and the central square, from which the pieces proceed to the center. When a piece overtakes a piece owned by the opponent, and the opponent's piece is not on one of the central squares of the perimeter, the opponent's pieces are sent back to the origin point, and the player is awarded an extra throw for each piece sent back. The first player to place their four pieces in the center wins.
         The game is played with 2 players.
(game "Tamman"
    (players <Players:num>)
    (equipment {
        (board 
            (merge {
                (add
                    (merge {
                        (square 2)
                        (shift 4 0 (square 2))
                        (shift 0 4 (square 2))
                        (shift 4 4 (square 2))
                    })
                    edges:{{2 9} {5 12} {8 15} {6 18} {8 20} {15 27} {17 29} {20 27} {23 30} {26 33} {7 19} {16 28}}
                )
            })
            {
            <Players:tracks>
            }
        )
        ("StickDice" 4)
        (piece "Marker" Each
            (move 
                (from (from) level:(level))
                (to
                    ("SiteToMoveOnTrack" from:(from) ("ThrowValue"))
                    if:True
                    (apply
                        (if (< 1 ("ThrowValue"))
                            (forEach Site (sites Track Mover "Track" from:("SiteToMoveOnTrack" from:(from) 1) to:("SiteToMoveOnTrack" from:(from) (- ("ThrowValue") 1)))
                                (if (not (is In (sites "SafeSites")))
                                    (forEach Level (site) FromTop
                                        (if ("IsEnemyAt" (site) level:(level))
                                            (fromTo
                                                (from (site) level:(level))
                                                (to 
                                                    (mapEntry "Entry" (who at:(site) level:(level)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )	
        )
        (regions "SafeSites" (sites {2 6 14 20}))
        (map "Throw" {(pair 0 8) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)})
        <Players:entries>
    })
    (rules 
        <Players:start>
        (play 
            ("RollMove"
                (forEach Piece)
                (then
                    (if (and ("Throw4") ("NewTurn"))
                        (moveAgain)
                    )
                )
            )
        )
        (end (if ("AllPiecesInCenter") (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
HexDame is a Draughts game played on a Hex board invented by Christian Freeling in 1979.Pieces move one step forward. Otherwise, the rules are the same as International Draughts: Pieces can jump an opponent's adjacent player to capture it. Pieces can move forward or backwards. When a piece reaches the opposite edge of the board from its starting position, it becomes a king and can may move and jump over any number of spaces diagonally. Captures are compulsory and the maximum number of jumps must be made. Winning is achieved by capturing all the opponent's pieces or by blocking them from moving. 
(game "HexDame" 
    (players 2) 
    (equipment { 
        (board (rotate 90 (hex 5))) 
        (piece "Counter" P1 N)
        (piece "Counter" P2 S)
        (piece "DoubleCounter" Each)
        (regions P1 (union (sites Side SW) (sites Side SE)))
        (regions P2 (union (sites Side NW) (sites Side NE)))
    }) 
    
    (rules 
        (start {
            (place "Counter1" (expand (sites Bottom) steps:3))
            (place "Counter2" (expand (sites Top) steps:3))
        })
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves
                        ("HopMan" (last To)
                            (then 
                                ("ReplayIfCanMove" ("HopMan" (last To)) 
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                    )
                    (max Moves ("HopSequenceCaptureAgain" before:10 after:10 at:EndOfTurn))
                )
                (priority {
                    (max Moves
                        (or 
                            (forEach Piece "Counter"
                                ("HopMan" (from) 
                                    (then 
                                        ("ReplayIfCanMove" ("HopMan" (last To))
                                            ("PromoteIfReach" (sites Next) "DoubleCounter")
                                        ) 
                                    ) 
                                ) 
                            )
                            (forEach Piece "DoubleCounter" ("HopSequenceCapture" before:10 after:10 at:EndOfTurn))
                        )
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {Forward FL FR}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide))
                    )
                })
            )
        )
        (end ("BlockWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "L'attaque" 
    (players 2) 
    
    (equipment {
        (board 
            (hole 
                (hole 
                    (hole 
                        (rectangle 10 9)
                        (poly {{2 4} {2 6} {3 6} {3 4}})
                    )
                    (poly {{4 4} {4 6} {5 6} {5 4}})
                )
                (poly {{6 4} {6 6} {7 6} {7 4}})
            )
        ) 
        (hand Each size:12)
        
        (piece "Marshal" Each)
        (piece "General" Each)
        (piece "Colonel" Each)
        (piece "Major" Each)
        (piece "Captain" Each)
        (piece "Lieutenant" Each)
        (piece "Sergeant" Each)
        (piece "Miner" Each)
        (piece "Scout" Each)
        (piece "Spy" Each)
        (piece "Flag" Each)
        (piece "Bomb" Each)
        
        (regions "HomeP1" P1 (expand (sites Bottom) steps:3))
        (regions "HomeP2" P2 (expand (sites Top) steps:3))
        (map {(pair 1 84) (pair 2 96) (pair 3 85) (pair 4 97) (pair 5 86) (pair 6 98) (pair 7 87) (pair 8 99) (pair 9 88)
        (pair 10 100) (pair 11 89) (pair 12 101) (pair 13 90) (pair 14 102) (pair 15 91) (pair 16 103) (pair 17 92) (pair 18 104) (pair 19 93) (pair 20 105) (pair 21 94) (pair 22 106) (pair 23 95) (pair 24 107)})
    }) 
    
    (rules 
        (start { 
            (place "Marshal1" 84 value:10) (place "General1" 85 value:9) (place "Colonel1" 86 count:2 value:8) (place "Major1" 87 count:2 value:7) (place "Captain1" 88 count:4 value:6)
            (place "Lieutenant1" 89 count:4 value:5) (place "Sergeant1" 90 count:4 value:4) (place "Miner1" 91 count:4 value:3) (place "Scout1" 92 count:8 value:2) (place "Spy1" 93 value:1)
            (place "Flag1" 94) (place "Bomb1" 95 count:4)
            (set Hidden (sites Hand P1) to:P2)
            
            (place "Marshal2" 96 value:10) (place "General2" 97 value:9) (place "Colonel2" 98 count:2 value:8) (place "Major2" 99 count:2 value:7) (place "Captain2" 100 count:4 value:6)
            (place "Lieutenant2" 101 count:4 value:5) (place "Sergeant2" 102 count:4 value:4) (place "Miner2" 103 count:4 value:3) (place "Scout2" 104 count:8 value:2) (place "Spy2" 105 value:1)
            (place "Flag2" 106) (place "Bomb2" 107 count:4)
            (set Hidden (sites Hand P2) to:P1)
        })
        
        phases:{
        (phase "Placement" 
            (play 
                (move 
                    (from (sites Occupied by:Mover container:(mover))) 
                    (to 
                        (intersection 
                            (sites Mover "Home") 
                            (sites Empty)
                        )
                    ) 
                    (then 
                        (if 
                            ("HandEmpty" P2) 
                            (and {
                                (set Hidden (sites P2 "Home") False to:P1) 
                                (set Hidden (sites P1 "Home") False to:P2)
                                (set Hidden What (sites P2 "Home") to:P1) 
                                (set Hidden What (sites P1 "Home") to:P2)
                                (set Hidden Value (sites P2 "Home") to:P1) 
                                (set Hidden Value (sites P1 "Home") to:P2)
                            }) 
                        ) 
                    )
                )
            ) 
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        (phase "Movement" 
            (play
                (or 
                    (forEach Piece {"Marshal" "General" "Colonel" "Major" "Captain" "Lieutenant" "Sergeant" "Miner" "Spy"} 
                        (move Step
                            Orthogonal 
                            (to 
                                if:(not ("IsFriendAt" (to))) 
                                "Capture"
                            )
                        )
                    )
                    (forEach Piece "Scout" 
                        (or
                            (move Select
                                (from)
                                (to (sites LineOfSight Empty at:(from) Orthogonal))
                                (then (fromTo (from (last From)) (to (last To))))
                            )
                            (move Select
                                (from)
                                (to 
                                    (sites LineOfSight Piece at:(from) Orthogonal)
                                    if:("IsEnemyAt" (to))
                                )
                                (then 
                                    (and
                                        (if (and 
                                                (not ("IsPieceAt" "Bomb" Next (last To)))
                                                (not ("IsPieceAt" "Flag" Next (last To)))
                                            )
                                            (if (= (value Piece at:(last To)) (value Piece at:(last From)))
                                                (and {
                                                    (set Hidden What at:(last To) False to:Mover) 
                                                    (set Hidden What at:(last From) False to:Next)
                                                    (set Hidden Value at:(last To) False to:Mover) 
                                                    (set Hidden Value at:(last From) False to:Next)
                                                })
                                                (if (< (value Piece at:(last To)) (value Piece at:(last From)))
                                                    (and { 
                                                        (fromTo (from (last To)) (to (mapEntry (what at:(last To))))) 
                                                        (fromTo (from (last From)) (to (last To))) 
                                                        (set Hidden What at:(mapEntry (what at:(last To))) False to:P1) 
                                                        (set Hidden What at:(mapEntry (what at:(last To))) False to:P2) 
                                                        (set Hidden What at:(last To) False to:Next)
                                                        (set Hidden Value at:(mapEntry (what at:(last To))) False to:P1) 
                                                        (set Hidden Value at:(mapEntry (what at:(last To))) False to:P2) 
                                                        (set Hidden Value at:(last To) False to:Next)
                                                    }) 
                                                    (and {
                                                        (fromTo (from (last From)) (to (mapEntry (what at:(last From))))) 
                                                        (set Hidden What at:(mapEntry (what at:(last From))) False to:P1) 
                                                        (set Hidden What at:(mapEntry (what at:(last From))) False to:P2) 
                                                        (set Hidden What at:(last To) False to:Mover)
                                                        (set Hidden Value at:(mapEntry (what at:(last From))) False to:P1) 
                                                        (set Hidden Value at:(mapEntry (what at:(last From))) False to:P2) 
                                                        (set Hidden Value at:(last To) False to:Mover)
                                                    }) 
                                                )
                                            )
                                            (if ("IsPieceAt" "Bomb" Next (last To))
                                                (and {
                                                    (fromTo (from (last From)) (to (mapEntry (what at:(last From))))) 
                                                    (set Hidden What at:(mapEntry (what at:(last From))) False to:P1) 
                                                    (set Hidden What at:(mapEntry (what at:(last From))) False to:P2) 
                                                    (set Hidden What at:(last To) False to:Mover)
                                                    (set Hidden Value at:(mapEntry (what at:(last From))) False to:P1) 
                                                    (set Hidden Value at:(mapEntry (what at:(last From))) False to:P2) 
                                                    (set Hidden Value at:(last To) False to:Mover)
                                                }) 
                                                (and {
                                                    ("CaptureFlag") 
                                                    (remove (last To))
                                                    (fromTo (from (last From)) (to (last To))) 
                                                })
                                            )
                                        )
                                        (note player:Mover "attacks" to:Next)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end (if "FlagWasCaptured" (result Mover Win))) 
        )
        }
    )
)
L'attaque was designed by Hermance Edan in France in 1908, and was an early predecessor of Stratego.Played on a board of 10x10 squares. The board has three 2x2 zones which cannot be entered, represented as water on the battlefield. each player controls 36 pieces which have individual army ranks. The goal is to capture the opponent's flag. Pieces can move only one space orthogonally. the Scout piece can move any number of spaces orthogonally. Pieces may attempt to capture an opposing piece; when doing so the ranks are revealed and the lower ranking piece is captured; if they are of equal rank they are both removed. There are bomb pieces which cannot move. Bombs eliminate other pieces attacking it and can only be removed by a miner. The spy can only attack the Marshall or the Flag. The scouts can not take each other, and winning is only possible in capturing the opponent flag 

Construct a Ludii game based on the following description
J'odu is a two-row mancala-style board game played by the Yoruba people of Nigeria and also in Ghana. It is closely related to other games similar to Oware, but the method of capture is slightly different.2x6 board, which two stores. Four counters in each hole. Sowing proceeds in an anti-clockwise direction. When the final counter of a sowing falls in to an occupied hole, these counters are picked up and sowing continues. When the final hole lands in an empty hole, if the hole is in the player's row, the contents of the opponent's opposite hole are captured. If the empty hole is in the opponent's row, the turn ends. A player must play so that the opponent is able to play on their next turn, if possible. The player who captures the most counters wins.  
(game "J'odu" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))		 
        (play 
            (do 
                (move Select 
                    (from 
                        (if ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover) 
                        ) 
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (sow 
                            apply:(if (> (count at:(to)) 1)
                                (moveAgain)
                                (if (is In (to) (sites Mover)) 
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:("OppositePit" (to)))
                                    ) 
                                )
                            )
                        )
                    )
                )
                ifAfterwards:(< 0 (count in:(if (is Mover P1) (sites P2) (sites P1))))
            )
        )
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Samurai Sudoku is one of the sudoku variation with overlapping sudoku grids.The puzzle consists of five grids, one in the center and the other 4 overlapping each corner grid of the central one. This means that the numbers must be different  for all the five puzzle squares like as 5 different Sudoku. 
(game "Samurai Sudoku" 
    (players 1) 
    (equipment { 
        (board 
            (merge {
                (square 9) 
                (shift 12 0 (square 9)) 
                (shift 0 12 (square 9)) 
                (shift 12 12 (square 9)) 
                (shift 6 6 (square 9)) 
            })
            (values Cell (range 1 9))
        ) 
        
        (regions {0..8})
        (regions {9..17})
        (regions {18..26})
        (regions {27..35})
        (regions {36..44})
        (regions {45..53})
        (regions {54..62})
        (regions {64..72})
        (regions {74..82})
        (regions {0 9 18 27 36 45 54 64 74})
        (regions {1 10 19 28 37 46 55 65 75})
        (regions {2 11 20 29 38 47 56 66 76})
        (regions {3 12 21 30 39 48 57 67 77})
        (regions {4 13 22 31 40 49 58 68 78})
        (regions {5 14 23 32 41 50 59 69 79})
        (regions {6 15 24 33 42 51 60 70 80})
        (regions {7 16 25 34 43 52 61 71 81})
        (regions {8 17 26 35 44 53 62 72 82})
        (regions {0..2 9..11 18..20})
        (regions {3..5 12..14 21..23})
        (regions {6..8 15..17 24..26})
        (regions {27..29 36..38 45..47})
        (regions {30..32 39..41 48..50})
        (regions {33..35 42..44 51..53})
        (regions {54..56 64..66 74..76})
        (regions {57..59 67..69 77..79})
        (regions {60..62 70..72 80..82})
        
        
        (regions {88..96})
        (regions {97..105})
        (regions {106..114})
        (regions {115..123})
        (regions {124..132})
        (regions {133..141})
        (regions {142 144..151})
        (regions {152 154..161})
        (regions {162 164..171})
        (regions {88 97 106 115 124 133 142 152 162})
        (regions {89 98 107 116 125 134 144 154 164})
        (regions {90 99 108 117 126 135 145 155 165})
        (regions {91 100 109 118 127 136 146 156 166})
        (regions {92 101 110 119 128 137 147 157 167})
        (regions {93 102 111 120 129 138 148 158 168})
        (regions {94 103 112 121 130 139 149 159 169})
        (regions {95 104 113 122 131 140 150 160 170})
        (regions {96 105 114 123 132 141 151 161 171})
        (regions {88..90 97..99 106..108})
        (regions {91..93 100..102 109..111})
        (regions {94..96 103..105 112..114})
        (regions {115..117 124..126 133..135})
        (regions {118..120 127..129 136..138})
        (regions {121..123 130..132 139..141})
        (regions {142 144 145 152 154 155 162 164 165})
        (regions {146..148 156..158 166..168})
        (regions {149..151 159..161 169..171})
        
        
        (regions {60 61 62 63 352 143 142 144 145})
        (regions {70 71 72 73 353 153 152 154 155})
        (regions {80 81 82 83 354 163 162 164 165})
        (regions {84 85 86 87 355 173 172 174 175})
        (regions {356..364})
        (regions {182 184 186 188 365 267 264 268 270})
        (regions {183 185 187 189 366 266 265 269 271})
        (regions {196 197 198 199 367 279 278 280 281})
        (regions {206 207 208 209 368 289 288 290 291})
        (regions {60 70 80 84 356 182 183 196 206})
        (regions {61 71 81 85 357 184 185 197 207})
        (regions {62 72 82 86 358 186 187 198 208})
        (regions {63 73 83 87 359 188 189 199 209})
        (regions {352 353 354 355 360 365 366 367 368})
        (regions {143 153 163 173 361 267 266 279 289})
        (regions {142 152 162 172 362 264 265 278 288})
        (regions {144 154 164 174 363 268 269 280 290})
        (regions {145 155 165 175 364 270 271 281 291})
        (regions {63 352 143 73 353 153 83 354 163})
        (regions {84 85 86 356 357 358 182 184 186})
        (regions {87 355 173 359 360 361 188 365 267})
        (regions {172 174 175 362 363 364 264 268 270})
        (regions {189 366 266 199 367 279 209 368 289})
        
        
        (regions {176..181 183 185 187})
        (regions {190..198})
        (regions {200..208})
        (regions {210..218})
        (regions {219..227})
        (regions {228..236})
        (regions {237..245})
        (regions {246..254})
        (regions {255..263})
        (regions {176 190 200 210 219 228 237 246 255})
        (regions {177 191 201 211 220 229 238 247 256})
        (regions {178 192 202 212 221 230 239 248 257})
        (regions {179 193 203 213 222 231 240 249 258})
        (regions {180 194 204 214 223 232 241 250 259})
        (regions {181 195 205 215 224 233 242 251 260})
        (regions {183 196 206 216 225 234 243 252 261})
        (regions {185 197 207 217 226 235 244 253 262})
        (regions {187 198 208 218 227 236 245 254 263})
        (regions {176..178 190..192 200..202})
        (regions {179..181 193..195 203..205})
        (regions {183 185 187 196..198 206..208})
        (regions {210..212 219..221 228..230})
        (regions {213..215 222..224 231..233})
        (regions {216..218 225..227 234..236})
        (regions {237..239 246..248 255..257})
        (regions {240..242 249..251 258..260})
        (regions {243..245 252..254 261..263})
        
        
        (regions {265 269 271..277})
        (regions {278 280..287})
        (regions {288 290..297})
        (regions {298..306})
        (regions {307..315})
        (regions {316..324})
        (regions {325..333})
        (regions {334..342})
        (regions {343..351})
        (regions {265 278 288 298 307 316 325 334 343})
        (regions {269 280 290 299 308 317 326 335 344})
        (regions {271 281 291 300 309 318 327 336 345})
        (regions {272 282 292 301 310 319 328 337 346})
        (regions {273 283 293 302 311 320 329 338 347})
        (regions {274 284 294 303 312 321 330 339 348})
        (regions {275 285 295 304 313 322 331 340 349})
        (regions {276 286 296 305 314 323 332 341 350})
        (regions {277 287 297 306 315 324 333 342 351})
        (regions {265 269 271 278 280 281 288 290 291})
        (regions {272..274 282..284 292..294})
        (regions {275..277 285..287 295..297})
        (regions {298..300 307..309 316..318})
        (regions {301..303 310..312 319..321})
        (regions {304..306 313..315 322..324})
        (regions {325..327 334..336 343..345})
        (regions {346..348 337..339 328..330})
        (regions {331..333 340..342 349..351})
    }) 
    (rules
        (start <Challenge>)
        (play (satisfy (all Different)))
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
Feed the Ducks was invented in 2011 by Néstor Romeral Andrés.It is a game played on a hexagonal board where the goal is to group all of a player's pieces together.The game is played in turns. White starts by placing the breadcrumb on any empty space on the board. Now, any and every duck in the six lines radiating out from the breadcrumb move straight toward the breadcrumb as far as they can. There will never be more than one duck in a space, and the ducks stop just before they reach the breadcrumb (a fish gets it first). Then the turn passes to the next player. From now on, on your turn, you must take the breadcrumb and place it on an empty space of the board that is not on any of the six lines radiating from the breadcrumb's previous location and then move the ducks toward the breadcrumb as usual. The game ends when all the ducks of one colour have gathered into a single connected group. In case of both groups (White and Black) are created simultaneously, the player who placed the game-ending breadcrumb wins. 
(game "Feed the Ducks" 
    (players 2) 
    (equipment { 
        (board (hex 5)) 
        (piece "Marker" Each)
        (piece "Disc" Neutral)
    }) 
    (rules 
        (start {
            (place "Marker1" {"A5" "C7" "D8" "F9" "H9" "I9" "I7" "I5" "F2" "C1" "A1" "A2"}) 
            (place "Marker2" {"A4" "A3" "B1" "D1" "E1" "G3" "H4" "I6" "I8" "G9" "E9" "B6" })
        })
        phases:{
        (phase "Throw Bread" 
            (play 
                (move Add 
                    (piece "Disc0")
                    (to (sites Empty)) 
                    (then (attract (from (last To))))
                )
            ) 
            (nextPhase "Move Bread")
        )
        (phase "Move Bread" 
            (play 
                (move 
                    (from (sites Occupied by:Neutral)) 
                    (to (difference (sites Empty) (sites Direction from:(last To))))
                    (then (attract (from (last To))))
                )
            )
        )
        }
        (end {
            ("SingleGroupWin" P1)
            ("SingleGroupWin" P2)
        }) 
    )
)

Construct a Ludii game based on the following description
Tab is a capturing game that is commonly played in North Africa and Southwest Asia, and in other places which have been in contact with them, such as Comoros. It is typically played in holes in the sand, and is at least several hundred years old. Tab boards are found as graffiti on many monuments throughout the region in which it is played.4x7-15 (odd number only) board. One piece in each hole in the outer row. Four palm branches used as dice, with one side white and the other side yellow. The throws are equal to the number of white sides that fall up; when only yellow sides are up, the score is 6. When a player throws 1, 4, or 6, the player throws again. Players take turns throwing, until one throws 1, and that player begins to play. Each player moves in a boustrophedon path, from left to right in the row closest to them, right to left in the second row, and left to right in the third row. From there, the player may move again into the second row and continue as before, or move into the fourth row, proceeding from right to left, as long as at least one of the opponent's pieces remains there. The piece may enter the third row again upon reaching the end of the fourth row, but only when the player has either no pieces in their first row, or one group of pieces in the same spot (see below). When a piece has moved out of the fourth row, it may not enter it again during the game. When a player's piece lands in the same spot as another piece belonging to the player, the pieces may move as one piece. When a player's piece lands on a space occupied by an opponent's, piece, the opponent's piece is captured. The player who captures all of the opponent's pieces wins. Each row has 7 holes.
(game "Tab"
    (players 2)
    (equipment {
        (board 
            (rectangle 4 <Board:size>) 
            {
            (track "HomeTrack1" "0,E,N1,W" P1 directed:True)
            (track "HomeTrack2" <Board:HomeTrack2> P2 directed:True)
            (track "MiddleTrack" <Board:MiddleTrack> loop:True)
            (track "EnemyTrack1" <Board:EnemyTrack1> P1 directed:True)
            (track "EnemyTrack2" <Board:EnemyTrack2> P2 directed:True)
            }
            use:Vertex
        )
        (piece "Stick" Each)
        (regions "AllSites" (sites Board))
        ("StickDice" 4)
        (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)})
        (regions "Home" P1 (sites Bottom))
        (regions "Home" P2 (sites Top))
    })
    (rules 
        (start { 
            (place "Stick1" (sites Bottom))
            (place "Stick2" (sites Top))
        })
        phases:{
        (phase "InitGame" 
            (play
                ("RollMove"
                    (move Pass)
                    (then 
                        (if ("Tab")
                            (moveAgain)
                        )
                    )
                )
            )
            (nextPhase ("Tab") "Play")
        )
        (phase "Play"
            (play
                ("RollMove"
                    (forEach Site (sites Occupied by:Mover)
                        ("Move")
                    )
                    (then 
                        (if ("SpecialThrows")
                            (moveAgain)
                        )
                    )
                )
            )
        )
        }
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Pente was invented by Gary Gabriel in 1983, and was inspired by Ninuki-Renju.  In Pente, players compete to be the first to form an orthogonal or diagonal line of five stones, or to capture ten opposing stones.  Pente does not have the complex opening protocol or specific positional restrictions of Ninuki-Renju.  The first player has a strong advantage, but the Pro Pente opening variation gives Black more even winning chances.Pente is played on a 19x19 Go board.  White goes first, and plays their first move on the centre point (unless playing Freestyle).  In the Pro Pente variation, White's second move must be at least 3 points away from the centre.  After the opening, players alternate playing one stone of their colour onto any empty point.  If their placement results in a pair of enemy stones being sandwiched between two of their own stones, those enemy stones are captured.  The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 10 enemy stones, wins the game. Played on a 19x19 board. Open at the centre point.
(game "Pente" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Ball" Each) 
    }) 
    (rules 
        (start (set Score Each 0))
        <Play>
        (end 
            {
            (if (is Line 5 All) (result Mover Win))
            (if (> (score Mover) 9) (result Mover Win))
            
            }
        ) 
    )
)

Describe the mechanics of the following Ludii game
(game "Yavalath" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board (rotate 90 (hex <Board>))) 
        (piece "Marker" Each) 
    }) 
    (rules 
        <Version:playRules>
        (end {
            (if (is Line 4) (result Mover Win))
            (if (is Line 3) (result Mover Loss)) 
        }) 
    )
)
Yavalath was invented by Cameron Browne in 2007. It is played on a hexagonal board with five spaces per side. It can be played by two or three players.Players alternate turns placing pieces on one of the spaces. The first player to place four in a row without first making three in a row wins. The version of game with 2 players. The game is played on a 3x3 board.

Describe the mechanics of the following Ludii game
(game "Three-Player Hex" 
    (players 3) 
    (equipment { 
        (board (hex <Board>)) 
        (piece "Marker" Each)
        (regions P1 {(sites Side N) (sites Side S) })
        (regions P2 {(sites Side NW) (sites Side SE) })
        (regions P3 {(sites Side SW) (sites Side NE) }) 
    }) 
    (rules 	
        
        (play (move Add (to (sites Empty)))) 
        (end {
            (forEach NonMover if:(is Blocked Player) (result Player <Result:nonMover>))
            (if (is Connected Mover) (result Mover <Result:mover>))
        }) 
    )
)
Three-Player Hex is played on the Hex board, typically with five cells per side. As in standard Hex, players take turn placing a piece of their color on an empty cell, and the first player to connect the opposite sides of the board marked his color with a chain of his pieces wins. As soon as it it no longer possible for a player to connect his edges, that player is eliminated from the game and may not place any more stones. The game is played on a 2x2 board The first player to connect his two sides wins.

Construct a Ludii game based on the following description
Breakback is a variation of Breakthrough involving forced backward moves.The rules are identical to Breakthrough except that if a player can move any of their pieces one step directly backwards to an empty cell then they must.
        If there is more than one such backward move available then the player chooses which one to make. The board is tiling by square. The game is played on a 4x4 board.
(game "Breakback" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (<Tiling:type> <Board:size>)) 
        (piece "Pawn" Each 
            (or {
                "StepForwardToEmpty" 
                (move Step
                    (directions {FR FL}) 
                    (to if:(or 
                            (is Empty (to)) 
                            ("IsEnemyAt" (to))
                        ) 
                        (apply (remove (to)))
                    )
                )
            })
        )
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (expand (sites Bottom)))
            (place "Pawn2" (expand (sites Top)))
        })
        
        (play 
            (priority	
                (forEach Piece ("StepBackwardToEmpty"))
                (forEach Piece)
            )
        )
        
        (end (if "ReachedTarget" (result Mover Win))) 
    )
)

Construct a Ludii game based on the following description
Tri-It-Out is a 'Pattern Capture', 'Misere' based on equilateral triangle patterns with mixed piece ownership, in which the total piece-count on the board increases with each complete turn. A player's board presence can vary greatly from turn to turn, especially for the variant game, or for other variants that prioritize capturing-placements. 
            
            It demands of players excellent pattern scanning skills, awareness of opportunities to force the opponent to capture, and sensitivity to moves that affect the timing of the game-ending.
            
            The concept arose from consideration of patterns where a piece might be captured but not replaced in the same location, and preferrably patterns that provided a choice of pieces to remove in this fashion. Triangle patterns provided a solution where the affected patterns created restrictions accross the whole board, and a misere game seemed most suitable with that condition.
            
        A game with similar concept but based on local 3-in-a-row patterns called 'FreeChain' was created at the same time. That game uses regular scoring.Tri-It-Out is a 2-player strategy game played on a hex grid.
            Definitions:
            -- A 'Triangle' means a pattern of 3 counters that are equidistant from each other, it may be in any orientation including orientations with edges that do not follow grid lines.
            -- A 'Mixed Triangle' is a triangle made of more than one player's counters.
            -- A 'Restricted Location' is an empty intersection that would form a Mixed Triangle if either player placed a piece there; that is it would form a Triangle that includes a mixed-color pair of counters already on the board.
            
            The goal is to have the FEWEST counters on the board when no further play is possible. In the case of a tie, the player who would have been next to make a placement loses.
            
            Turns consist of:
        -- 1) a Placement of a piece onto an empty site that is not a 'Restricted Location'. 
    -- 2) If any new Mixed Triangles are created, a Capture is made by removing one opponent's piece from one of them.
    
A player must continue to take a series of consecutive turns until a Placement is made that cannot be followed by a Capture. Standard Rules Board & size: Hexhex with edges alternating 2 and 4
(game "Tri-It-Out"
    (players 2)
    (equipment
        {
        (board <Board:size> use:Vertex)
        (piece "Counter" Each)
        }
    )
    (rules 
(meta (no Repeat PositionalInTurn)) 
(start
    {
    (set Score Each 0)
    }   
) 
(play
    (if
        (is Pending)
        (move Remove
            (sites Pending)
            (then
                (and
                    (set Value Mover Infinity)
                    (moveAgain)
        )))
        (move Add
            (to
                (difference
                    (sites Empty) 
                    ("TriangleSites"
                        (sites Empty)  
                        (sites Occupied by:P1) 
                        (sites Occupied by:P2) 
                )) 
                (apply (set Value Mover (to)))
            )
            (then
                (if
                    "OutstandingCaptures"
                    (and
                        (set Pending "Sites2Capture")
                        (moveAgain)
        ))))
        (then
            (set Score  P1 (- (count Pieces  P1))
                (then
                    (set Score P2 (- (count Pieces P2)))
        )))
)) 
(end 
    {
    (if
        (and
            {
            (no Moves Next)
            <Variant:outsandingCaptures>
            }
        )
        (result Mover Loss)
    )
    
    (if
        (and
            (no Moves Next)
            (= (count Pieces P1) (count Pieces P2))
        )
        (result Mover Loss)
    )
    
    (if 
        (and
            (no Moves Next)
            (!= (count Pieces P1) (count Pieces P2))
        )
        (byScore)
    )
    }
)
)
)

Construct a Ludii game based on the following description
Cannon is a two-player board game invented in 2003 by David E. Whitcher.The objective of Cannon is to capture or shoot the opponent's Town.
            
            The player also wins the game if his opponent doesn't have legal moves.
            
            Players move alternately. On their first turns both players put a special piece called \ 
(game "Cannon" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 10) use:Vertex) 
        (piece "Pawn" Each
            (or {
                ("StepToEmptyForwards")
                ("StepCapture")
                ("RetreatMove")
                ("CannonMove")
                ("CannonShoot")
            })
        )
        (piece "Town" Each)
        (hand Each)
        (regions "Home" P1 (sites Bottom))
        (regions "Home" P2 (sites Top))
    })
    
    (rules 
        (start {
            (place "Town" "Hand")
            (place "Pawn1" (forEach (difference (expand (sites Row 2)) (sites Right)) if:(is Even (column of:(site)))))
            (place "Pawn2" (forEach (difference (expand (sites Row 7)) (sites Left)) if:(is Odd (column of:(site)))))
        })
        
        phases:{
        (phase "Placing"
            (play
                (move
                    (from (handSite Mover))
                    (to (difference (sites Mover "Home") (sites Corners)))
                )
            )
            (nextPhase Mover "Moving")
        )
        
        (phase "Moving" 
            (play (forEach Piece))
            (end 
                (if (or 
                        ("IsOffBoard" (where "Town" Next))
                        (no Moves Next)
                    ) 
                    (result Mover Win)
                )
            )
        )
        }
    )
)

Construct a Ludii game based on the following description
Invented in 2000 by Dan Troyka, Breakthrough is a Chess variant played only with pawns.Played on an 8x8 board with a double contingent of chess pawns. Pieces move forward one orthogonally or diagonally. Pieces can capture by moving diagonally. The first player to reach the opponent's edge of the board wins. A player also can win if they capture all of the opponent's pieces. The board is tiling by square. The game is played on a 4x4 board.
(game "Breakthrough" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (<Tiling:type> <Board:size>)) 
        (piece "Pawn" Each 
            (or {
                "StepForwardToEmpty" 
                (move 
                    Step
                    (directions {FR FL}) 
                    (to if:(or 
                            (is Empty (to)) 
                            ("IsEnemyAt" (to))
                        ) 
                        (apply (remove (to)))
                    )
                )
            })
        )
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (expand (sites Bottom)))
            (place "Pawn2" (expand (sites Top)))
        })
        
        (play (forEach Piece))
        
        (end ("ReachWin" (sites Mover) Mover)) 
    )
)

Construct a Ludii game based on the following description
Omangunta Peeta is a two-row mancala-style board game from southern India. It was played in the Madras Presidency during the early twentieth century.2x7 board. Six counters in each hole, except the central hole in each row, which contains one counter. Sowing occurs in an anti-clockwise direction. When the last counter is sown, the player picks up the counters in the next hole in the direction of the sowing and continues sowing with those counters. When the hole after the hole in which the final counter is sown is empty, the counters in the next hole are captured, as well as the counters in the hole opposite this hole, and the turn ends. Sowing cannot begin from the central hole of either row. When a capture would occur from one of these central holes, the counters are not captured until the end of the round. At the end of the round, if both players are eligible to capture from the hole, they split the counters, leaving one in the hole if it is an odd number, or two if it is an even number. If only one player captured from the holes, they leave one counter in each hole. If neither player made a capture from the hole, the counters remain in the hole. 
            
        When the players can no longer play, a new round begins. Each player then fills up as many holes, not counting the central holes, on their side of the board with six counters if possible. Any holes that do not contain counters are out of play. Play continues until one player captures all the counters, and is the winner. 
(game "Omangunta Peeta" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start {
            (set Count 6 to:(difference (sites Track) (sites Centre)))
            (set Count 1 to:(sites Centre))
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "Sowing"
            (play 
                (or {
                    (move Select
                        (from
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (difference (sites Mover) (sites Centre))
                            )
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (sow
                                apply:(if (is Occupied ("NextHole" (to) 1))
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                    (if (is In ("NextHole" (to) 2) (sites Centre))
                                        (set Value Mover 1)
                                        (and 
                                            (if (is Occupied ("NextHole" (to) 2))
                                                (fromTo
                                                    (from ("NextHole" (to) 2))
                                                    (to (handSite Mover))
                                                    count:(count at:("NextHole" (to) 2))
                                                )
                                            )
                                            (if (is Occupied ("OppositePit" ("NextHole" (to) 2)))
                                                (fromTo
                                                    (from ("OppositePit" ("NextHole" (to) 2)))
                                                    (to (handSite Mover))
                                                    count:(count at:("OppositePit" ("NextHole" (to) 2)))
                                                )
                                            )
                                        )
                                    )
                                )
                                skipIf:(and (not (is In (to) (sites Centre))) (not (is In (to) ("PlayableSites"))))
                            )
                        )
                    )
                    }
                    (then (if ("NoPiecesOnBoardExceptCentre")
                            (and {
                                (forget Value "Playable" All)
                                (if (!= 0 ("SumCentreSites"))
                                    (if (and (= 1 (value Player P1)) (= 1 (value Player P2)))
                                        (if (is Even ("SumCentreSites"))
                                            (and {
                                                (fromTo 
                                                    (from ("BottomCentre"))
                                                    (to Cell (handSite P1))
                                                    count:(- (count at:("BottomCentre")) 1)
                                                )
                                                (fromTo 
                                                    (from ("TopCentre"))
                                                    (to Cell (handSite P1))
                                                    count:(- (count at:("TopCentre")) 1)
                                                )
                                                (fromTo 
                                                    (from Cell (handSite P1))
                                                    (to Cell (handSite P2))
                                                    count:(/ (- ("SumCentreSites") 2) 2)
                                                )
                                            })
                                            (and {
                                                (fromTo 
                                                    (from ("BottomCentre"))
                                                    (to Cell (handSite P1))
                                                    count:(- (count at:("BottomCentre")) 1)
                                                )
                                                (fromTo 
                                                    (from ("TopCentre"))
                                                    (to Cell (handSite P1))
                                                    count:(count at:("TopCentre"))
                                                )
                                                (fromTo 
                                                    (from Cell (handSite P1))
                                                    (to Cell (handSite P2))
                                                    count:(/ (- ("SumCentreSites") 1) 2)
                                                )
                                            })
                                        )
                                        (if (= 1 (value Player P1))
                                            (and
                                                (fromTo 
                                                    (from ("BottomCentre"))
                                                    (to Cell (handSite P1))
                                                    count:(- (count at:("BottomCentre")) 1)
                                                )
                                                (fromTo 
                                                    (from ("TopCentre"))
                                                    (to Cell (handSite P1))
                                                    count:(- (count at:("TopCentre")) 1)
                                                )
                                            )
                                            (if (= 1 (value Player P2))
                                                (and
                                                    (fromTo 
                                                        (from ("BottomCentre"))
                                                        (to Cell (handSite P2))
                                                        count:(- (count at:("BottomCentre")) 1)
                                                    )
                                                    (fromTo 
                                                        (from ("TopCentre"))
                                                        (to Cell (handSite P2))
                                                        count:(- (count at:("TopCentre")) 1)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPiecesOnBoardExceptCentre")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPiecesOnBoardExceptCentre") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites (difference (sites Mover) (sites Centre)) if:(is Occupied (site))))
                    (if (<= 6 (count Cell at:(handSite Mover)))
                        (move
                            (from Cell (handSite Mover))
                            (to (difference (sites Mover) (sites Centre)) if:(is Empty (to)))
                            count:6
                            (then (remember Value "Playable" (last To)))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Yavalade was invented in 2012 by Néstor Romeral Andrés. It is a derivative of Yavalath.White player takes a red piece and places a white piece on top of it, placing the stack before them. Black player takes a white piece and places a black piece on top of it, placing the stack before them. Red player takes a black piece and places a red piece on top of it, placing the stack before them. Starting with White, players take turns placing a piece of their colour on an empty space of the board until the victory condition is reached. The aim of the game is to create a 5-in-a-row containing both and only both colours of your stack. 
(game "Yavalade" 
    (players 3) 
    (equipment { 
        (board (rotate 90 (hex 5))) 
        (piece "Marker" Each)
    }) 
    (rules 
        (play (move Add (to (sites Empty))))
        (end {
            (if (is Line 5 whats:{1 3}) (result P1 Win))
            (if (is Line 5 whats:{1 2}) (result P2 Win))
            (if (is Line 5 whats:{2 3}) (result P3 Win))
        }) 
    )
)

Construct a Ludii game based on the following description
Nsumbi is a four-row mancala-style board game played by the Taabwa people of central Africa.4x8 board. Two counters in each hole. Players sow in an anti-clockwise direction from any of their holes. Singletons may not be sowed. Players capture when the sowing ends in a player's inner row and the opponent's inner and outer row holes opposite contain counters; these are captured and sown in the player's rows starting from the same hole that the previous sowing began. If the final counter lands in an occupied hole but capture is not possible, the counters in this hole are picked up and sowing continues. If the final counter ends in an empty hole, the turn ends. Captures cannot be made on each player's first turn. Play continues until one player has no holes with two or more counters, and the opponent wins. 
(game "Nsumbi" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "16,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))          
        (regions "Home" P2 (sites Track "Track2"))          
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom)))  
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top)))   
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        phases:{
        (phase "Opening" 
            (play 
                (move Select
                    (from (sites Mover))
                    (then 
                        (sow
                            "Track"
                            owner:(mover)
                        )
                    )
                )		
            )
            (nextPhase Mover "Playing")
        )
        (phase "Playing"
            (play 
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover) 
                        ) 
                        if:(< 1 (count at:(from)))
                    )
                    (then 
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if
                                (and { 
                                    (< 1 (count at:(to)))
                                    (is In (to) (sites Mover "Inner")) 
                                    (> (count at:("OppositePit" (to))) 0) 
                                    (> (count at:("OppositeOuterPit" (to))) 0) 
                                })
                                (and {
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (last From)) 
                                        count:(count at:("OppositePit" (to)))
                                    ) 
                                    (fromTo 
                                        (from ("OppositeOuterPit" (to))) 
                                        (to (last From)) 
                                        count:(count at:("OppositeOuterPit" (to)))
                                    ) 
                                    (sow
                                        (last From)
                                        count:(+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))))
                                        "Track"
                                        owner:(mover)
                                        origin:True
                                    )
                                })
                                (if (< 1 (count at:(to)))
                                    (moveAgain)
                                )
                            )
                        )
                    )
                )		
            )		
        )
        }
        
        (end ("BlockWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "Tuknanavuhpi" 
    (players 2) 
    (equipment { 
        (board (square 5 diagonals:Solid) use:Vertex)
        (piece "Counter" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    
    (rules 
        (start { 
            (place "Counter1" (union (difference (expand (sites Bottom) steps:2) (sites {"E5" "G5" "I5"})) (sites {"B2" "B4" "D2" "D4" "F2" "F4" "H2" "H4"})))
            (place "Counter2" (union (difference (expand (sites Top) steps:2) (sites {"E5" "A5" "C5"})) (sites {"B6" "B8" "D6" "D8" "F6" "F8" "H6" "H8"})))
        })
        
        (play (forEach Piece))
        
        (end ("NoMoves" Loss))
    )
)
Tuknanavuhpi is a leaping capture game played by the Hopi in Arizona during at the turn of the twentieth century. It is similar to games derived from Alquerque, like other Native American games adapted from the Spanish.Played on a grid of 4x4 squares, each square with both diagonals. Pieces are played on the intersections of the lines, moving to an empty point along one of the lines. Play begins with 20 pieces per player. Players take turns moving the pieces, and capture the opponent's pieces by hopping over them. When the back line on a player's side of the board is vacated, it is no longer in play. The player who captures the other player's pieces wins. 

Construct a Ludii game based on the following description
A dynamic connection game on shifting, unstable ground.Bide is a strategy game for 2 to 6 players on a hexhex-5 board that is initially empty. Players take turns by placing stones of their color on the hexagonal cells. At the beginning of your turn you are given a new stone. You can either play it, or bide. If you bide, set the stone aside and your turn ends immediately. The stone remains in your hand. If you play the new stone while having at least one stone in your hand, you may release, meaning you would play every stone in your hand in succession. If a player releases, all players must release on their next turn, including playing their stone for that turn. Stones when placed create shock waves, pushing all adjacent stones one space radially outward from the placement. If there are multiple connected stones adjacent to the placed stone, positioned directly in line of the shock wave, they all move one space. If this movement causes a stone to bump into another stone directly in line of the shock wave, that stone also gets pushed one space. Becoming adjacent along a different grid line than the shockwave does not count. However stones cannot be pushed past the edge of the board. Lines that are full between the edges and the placed stone cannot move. Players eventually score points when all cells are filled up with stones. Each stone is worth points equal to its distance from the edge, starting at zero. Groups consist of connected adjacent like colored stones. The player with the highest scoring group wins. If tied, remove the outermost ring of stones and rescore, repeating this process until there is a winner.  Two Players Order 3, Hex Grid
(game "Bide" 
    (players <Players:forThisTrial> )
    (equipment
        {
        (board <BoardShape:gridType> use:Vertex)
        (hand Each size:1)
        (piece "Disc" Each) 
        
        (regions "R0x" (sites Outer))
        (regions "R1x" (sites Around (sites "R0x") "Adj" includeSelf:True))
        (regions "R2x" (sites Around (sites "R1x") "Adj" includeSelf:True))
        (regions "R3x" (sites Around (sites "R2x") "Adj" includeSelf:True))
        (regions "R4x" (sites Around (sites "R3x") "Adj" includeSelf:True))
        (regions "R5x" (sites Around (sites "R4x") "Adj" includeSelf:True))
        
        
        
        
        
        }
    )
    (rules
        (meta (passEnd NoEnd))  
        (play
            (if
                (or
                    (is Prev Mover)
                    (and
                        (< 0 (size Array (values Remembered "Released")))
                        (> <Players:forThisTrial> (size Array (values Remembered "Released")))
                ))
                ("Release")
                (or
                    ("BideMove")
                    (or
                        ("ReleaseFromPool")
                        (move Add (to (intersection (sites Board) (sites Empty))))
                        (then "ResolveShockWave")
                    )
                    (then (forget Value "Released" All))
                ) 
                (then 
                    ("CascadeScoring")
        )))
        (end 
            (if
                (= 0 (count Sites in:(intersection (sites Board) (sites Empty))))
                (byScore)
))))

Construct a Ludii game based on the following description
Xonin Shatar (Sheep Chess) is a game of alignment played in Mongolia. Three concentric squares, with lines connecting the corners and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. Pieces which are in a three-in-a-row pattern cannot be removed from the board. The player who removes all of the opponent's pieces wins. 
(game "Xonin Shatar (Simple)"
    (players 2)
    
    (equipment { 
        (board (concentric Square rings:3 joinCorners:True) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3")))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3"))
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Invented by William Daniel Troyka in 2002, Blue Nile is a modern game played on a hexagonal board.Played on a hexagonal board with five spaces per side. Players take turns placing stones on an empty space. The stone must be adjacent to the last stone played but cannot be adjacent to any other. The last player to be able to make a legal move wins. 
(game "Blue Nile" 
    (players 2) 
    (equipment { 
        (board (hex 5)) 
        (piece "Marker" Neutral) 
    }) 
    
    (rules 
        
        phases:{
        (phase "start" P1 
            (play (move Add (piece (id "Marker0")) (to (sites Empty)))) 
            (nextPhase "play")
        )
        
        (phase "play"  
            (play 
                (move Add 
                    (piece "Marker0") 
                    (to 
                        (sites Around 
                            (last To) 
                            if:(and 
                                (is Empty (to)) 
                                
                                ("NoSites" (difference ("AdjacentNotEmptySites") (last To)))
                            ) 
                        )
                    )
                )
            )
        )
        }
        
        (end ("NoMoves" Loss)) 
    )
)

Construct a Ludii game based on the following description
A variant of Breakthrough played with Checkers pieces and rules (mostly).Checkers-Breakthrough is played on a 8 × 8 checkers board with checkers pieces. The initial board setup and basic piece movements are the same as in checkers. A checker piece can move either onto a diagonally forward adjacent empty square or jump over a diagonally adjacent opponent piece (possibly repeatedly). Unlike checkers, however, jumps are not mandatory and jumped-over pieces are not captured. The first player to reach the opponent’s backrank wins (thus no king promotions). 
(game "Breakthrough Checkers" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        (piece "Counter" P1 N)
        (piece "Counter" P2 S)
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Counter1" (difference (expand (sites Bottom) steps:2) (sites Phase 1) ))
            (place "Counter2" (difference (expand (sites Top) steps:2) (sites Phase 1)))
        })
        
        (play 
            (if "SameTurn"
                (or
                    ("HopMan" (last To)
                        (then 
                            ("ReplayIfCanMove" ("HopMan" (last To))) 
                        ) 
                    )
                    (move Pass)
                )
                (or 
                    (forEach Piece "Counter" 
                        ("HopMan" (from)
                            (then 
                                ("ReplayIfCanMove" ("HopMan" (last To))) 
                            )
                        ) 
                    )
                    (forEach Piece "Counter" 
                        ("StepToEmpty" (directions {FR FL})) 
                    )
                )
            )
        ) 
        
        (end (if "ReachedTarget" (result Mover Win))) 
    )
)

Construct a Ludii game based on the following description
Ceelkoqyuqkoqiji is a two-row mancala-style board game documented in Yunnan Province, China by Vernon Eagle. It was described to him by He Hao, Li Qiulan, and Wang Qiaoxin.2x5 board with one store on either end. The store to the right of the player belongs to the player. Play begins with five counters in each regular hole, with one larger stone in each store, but one is slightly smaller than the other. Game can be played with two or four players. With four players, two players control the larger stones, but cannot move the regular counters. Players throw out a finger (index, little, or thumb) to determine who plays first. Index beats thumb, thumb beats little finger, little finger beats index. This happens at the start of each round. Counters are taken from any of the holes in the player's row, sowing them in either direction, including the stores. When the last counter of a sowing is dropped in a hole, sowing continues by picking up the counters in the next hole and continuing to sow in that direction. If the hole following the last seed of a sowing is empty, the counters in the hole following this empty hole are captured. If there is an empty hole following the captured hole, and then an occupied hole immediately after it, the counters in the occupied hole are also captured, and so forth until there are two occupied or two empty holes in a row. Moves may not begin from stores. Both stores are sown into normally by both players. Stores are considered to be empty, except when its large stone remains in it, then the large stone only can be sown or captured and not any other counters that may have accumulated there. Large stones can be sown in any order a player chooses during a sowing. If a player has no counters in their holes, they may opt to place one counter in each of their holes, taking counters from their store and continue play (called huelshe). If they opt not to, the opponent takes all the remaining stones on the board. If one of the large stones remains in its original store, the player cannot opt out. If the player doesn't have enough stones for all of the holes, they may choose which holes in their row to place the counters, but they must form a continuous sequence of holes with counters. When the round ends, players must buy back their large stones if they no longer have them, at a price determined in the beginning of the game (usually seven for the larger stone and six for the smaller). Players then attempt to refill their holes with the original number of counters. The player that has fewer than the original number of counters must borrow counters from the opponent. Debt accumulates over subsequent rounds. When the debt reaches five, the player must sell one of their holes to the opponent. The selling player can choose which holes to sell. The seller then receives five counters to either repay debt or fill holes as long as debt does not exceed four.  Each row has 5 holes. The price of the largest stone is .
(game "Ceelkoqyuqkoqiji" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" largeStack:True
            <Row:tracks>
        )
        (piece "Seed" Shared) 
        (piece "Ball" P1)
        (piece "Ball" P2)
        (hand Each size:2)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 LastSite) (pair P2 FirstSite)}) 
        (regions "EndHoles" (sites {0 (+ 1 (* 2 ("Columns")))}))
    }) 
    (rules 
        
        (start {
            (place Stack "Seed" (union (sites Bottom) (sites Top)) count:<Row:size>)
            (place Stack "Ball1" (mapEntry P1))
            (place Stack "Ball2" (mapEntry P2))
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (if (!= (var "Direction") 2)
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    ("OwnedHoles") 
                                )
                                if:(!= 0 (size Stack at:(from)))
                            )
                            (then
                                (and {
                                    (forEach Value min:1 max:(size Stack at:(last From))
                                        (fromTo
                                            (from (last From) level:(- (size Stack at:(last From)) (value)))
                                            (to ("NextHole" (last From) "TrackCCW" (value)))
                                            stack:True
                                        )
                                    )
                                    (if (or (is In ("NextHole" (last From) "TrackCCW" (+ 1 (size Stack at:(last From)))) (sites "EndHoles")) (>= (size Stack at:(last From)) (* 2 <Row:size>)))
                                        (set Var "Direction" 0)
                                        (if (!= 0 (size Stack at:("NextHole" (last From) "TrackCCW" (+ 1 (size Stack at:(last From))))))
                                            (and {
                                                (set Var "Direction" 1)
                                                (moveAgain)
                                                (set Var "Replay" ("NextHole" (last From) "TrackCCW" (+ 1 (size Stack at:(last From)))))
                                            })
                                            (and
                                                (set Var "Direction" 0)
                                                (if (is Occupied ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))))
                                                    (forEach Level ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) FromTop
                                                        (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level)))
                                                            (fromTo
                                                                (from ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                                (to (handSite Mover))
                                                            )
                                                            (fromTo
                                                                (from ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                                (to (handSite Mover 1))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                })
                            )
                        )
                    )
                    (if (!= (var "Direction") 1)
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    ("OwnedHoles") 
                                ) 
                                if:(!= 0 (size Stack at:(from)))
                            )
                            (then
                                (and
                                    (forEach Value min:1 max:(size Stack at:(last From))
                                        (fromTo
                                            (from (last From) level:(- (size Stack at:(last From)) (value)))
                                            (to ("NextHole" (last From) "TrackCW" (value)))
                                            stack:True
                                        )
                                    )
                                    (if (or (is In ("NextHole" (last From) "TrackCW" (+ 1 (size Stack at:(last From)))) (sites "EndHoles")) (>= (size Stack at:(last From)) (* <Row:size> 2)))
                                        (set Var "Direction" 0)
                                        (if (!= 0 (size Stack at: ("NextHole" (last From) "TrackCW" (+ 1 (size Stack at:(last From))))))
                                            (and {
                                                (set Var "Direction" 2)
                                                (moveAgain)
                                                (set Var "Replay" ("NextHole" (last From) "TrackCW" (+ 1 (size Stack at:(last From)))))
                                            })
                                            (and
                                                (set Var "Direction" 0)
                                                (if (is Occupied ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))))
                                                    (forEach Level ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) FromTop
                                                        (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level)))
                                                            (fromTo
                                                                (from ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                                (to (handSite Mover))
                                                            )
                                                            (fromTo
                                                                (from ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                                (to (handSite Mover 1))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if (= 2 ("NumBigPiecesCaptured"))
                            (and {
                                (forEach Site
                                    (intersection (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))
                                    (if (is Occupied (site))
                                        (and
                                            (forEach Level (site) FromTop
                                                (if (>= (level) (/ (size Stack at:(site)) 2))
                                                    (fromTo
                                                        (from (site) level:(level))
                                                        (to (handSite P1))
                                                        stack:True
                                                    )
                                                )
                                            )
                                            (forEach Level (site) FromTop
                                                (if (< (level) (/ (size Stack at:(site)) 2))
                                                    (fromTo
                                                        (from (site) level:(level))
                                                        (to (handSite P2))
                                                        stack:True
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (forEach Site
                                    (union (difference (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) (sites {(mapEntry P1)}))
                                    (if (is Occupied (site))
                                        (forEach Level (site) FromTop
                                            (fromTo
                                                (from (site) level:(level))
                                                (to (handSite P1))
                                                stack:True
                                            )
                                        )
                                    )
                                )
                                (forEach Site
                                    (union (difference (sites (values Remembered "OwnedP2")) (sites (values Remembered "OwnedP1"))) (sites {(mapEntry P2)}))
                                    (if (is Occupied (site))
                                        (forEach Level (site) FromTop
                                            (fromTo
                                                (from (site) level:(level))
                                                (to (handSite P2))
                                                stack:True
                                            )
                                        )
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                            (and
                                (if (and ("NoPieceOnOwnedHoles" P1) (>= (size Stack Cell at:(handSite P1)) ("NumOwnedHoles" P1)))
                                    (forEach Value min:1 max:("NumOwnedHoles" P1)
                                        (fromTo
                                            (from Cell (handSite P1) level:(- (size Stack Cell at:(handSite P1)) (value)))
                                            (to (regionSite (sites (values Remembered "OwnedP1")) index:(- (value) 1)))
                                            stack:True
                                        )
                                    )
                                )
                                (if (and ("NoPieceOnOwnedHoles" P2) (>= (size Stack Cell at:(handSite P2)) ("NumOwnedHoles" P2)))
                                    (forEach Value min:1 max:("NumOwnedHoles" P2)
                                        (fromTo
                                            (from Cell (handSite P2) level:(- (size Stack Cell at:(handSite P2)) (value)))
                                            (to (regionSite (sites (values Remembered "OwnedP2")) index:(- (value) 1)))
                                            stack:True
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (>= 4 (size Stack Cell at:(handSite P1)))
                        (result P2 Win)
                    )
                    (if (>= 4 (size Stack Cell at:(handSite P2)))
                        (result P1 Win)
                    )
                    }
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= <Row:size> (size Stack Cell at:(handSite Mover)))
                    (move Select
                        (from Cell (handSite Mover))
                        (to ("LeftMostEmpty"))
                        (then
                            (and {
                                (forEach Value min:1 max:<Row:size>
                                    (fromTo
                                        (from Cell (last From) level:(- (size Stack Cell at:(last From)) (value)))
                                        (to (last To))
                                        stack:True
                                    )
                                )
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= (* 2 <Row:size>) (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if <Row:conditionBetweenRounds>
                                        (and {
                                            (forEach Value min:1 max:(- (count Cell at:(handSite Mover)) <Row:size>)
                                                (fromTo
                                                    (from Cell (handSite Mover) level:(- (- (size Stack Cell at:(handSite Mover)) <Row:size>) (value)))
                                                    (to ("NextLeftMostEmpty"))
                                                    stack:True
                                                )
                                            )
                                            (forEach Value min:1 max:(- <Row:size> (- (count Cell at:(handSite Mover)) <Row:size>))
                                                (fromTo
                                                    (from Cell (handSite Next) level:(- (size Stack Cell at:(handSite Next)) (value)))
                                                    (to ("NextLeftMostEmpty"))
                                                    stack:True
                                                )
                                            )
                                            ("RemmemberOwnedHoles" ("NextLeftMostEmpty"))
                                            ("RemmemberOpponentOwnedHoles" ("NextLeftMostEmpty"))
                                        })
                                    )
                                )
                            })
                        )
                    )
                    (then
                        (if (and (is Empty Cell (handSite P1)) (is Empty Cell (handSite P2))) 
                            (and
                                (if (= (size Stack Cell at:(handSite P1 1)) 2)
                                    (and
                                        (fromTo
                                            (from Cell (handSite P1 1) level:1)
                                            (to (mapEntry P1))
                                            stack:True
                                        )
                                        (fromTo
                                            (from Cell (handSite P1 1) level:0)
                                            (to (mapEntry P2))
                                            stack:True
                                        )
                                    )
                                    (if (= (size Stack Cell at:(handSite P2 1)) 2)
                                        (and
                                            (fromTo
                                                (from Cell (handSite P2 1) level:1)
                                                (to (mapEntry P1))
                                                stack:True
                                            )
                                            (fromTo
                                                (from Cell (handSite P2 1) level:0)
                                                (to (mapEntry P2))
                                                stack:True
                                            )
                                        )
                                        (and
                                            (fromTo
                                                (from Cell (handSite P1 1) level:0)
                                                (to (mapEntry P1))
                                                stack:True
                                            )
                                            (fromTo
                                                (from Cell (handSite P2 1) level:0)
                                                (to (mapEntry P2))
                                                stack:True
                                            )
                                        )
                                    )
                                )
                                (if (< 50 (value Random (range 1 100)))
                                    (set NextPlayer (player 1))
                                    (set NextPlayer (player 2))
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (and (is Empty Cell (handSite P1)) (is Empty Cell (handSite P2))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Yovodji is a game observed in Dahomey during the early twentieth century. It was a game played typically by women, often played during funerals.2x6 board. Four counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a counterclockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. When the final counter falls into an occupied hole, these are picked up and sowing continues. When the final counter of a sowing lands on in an empty hole in the player's own row, the contents of the hole in the opponent's row opposite it are captured. If the opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row. 
(game "Yovodji" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))		 
        (play 
            (if (is Proposed "End")
                (or (move Vote "End") (move Vote "No"))
                (or
                    (if (is Cycle) (move Propose "End")) 
                    (move Select 
                        (from 
                            (if 
                                ("SameTurn") 
                                "LastHoleSowed" 
                                (sites Mover)
                            ) 
                            if:(< 0 (count at:(from)))
                        )
                        (then 
                            (sow 
                                apply:(if ("CaptureAsInOware" (to))
                                    (fromTo 
                                        (from (to)) 
                                        (to (handSite Mover)) 
                                        count:(count at:(to))
                                    )
                                    (if (< 1 (count at:(to))) 
                                        (moveAgain)
                                        (if (and 
                                                (is In (to) (sites Mover)) 
                                                (< 1 (count at:("OppositePit" (to))))
                                            )
                                            (fromTo 
                                                (from ("OppositePit" (to)))
                                                (to (handSite Mover)) 
                                                count:(count at:("OppositePit" (to)))
                                            )
                                        )
                                    )
                                )
                                includeSelf:False
                                backtracking:("CaptureAsInOware" (from)) 
                            )
                        )
                    )
                )
            )
        )
        (end ("MancalaByScoreWhen" (or (no Moves Mover) (is Decided "End"))))
    )
)

Construct a Ludii game based on the following description
Futoshiki is a numerical deduction puzzle invented by Tamaki Seto in 2001.Futoshiki is played on a square grid. The starting state may have numbers placed in the squares of the grid. The goal is to place numbers in the squares so that each row and each column has only one instance of a particular number. The \ 
(game "Futoshiki"
    (players 1) 
    (equipment { 
        (board 
            (square <Challenge:size>) 
            (values Vertex (range 1 <Challenge:size>)) 
            use:Vertex
        ) 
        <Challenge:hints>
        (regions {Columns Rows})
    }) 
    (rules 
        (start <Challenge:start>)
        (play 
            (satisfy {
                (forAll Hint (< (from) (to)))
                (all Different)
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
Chaupar is a very popular race game from South Asia that is related to similar games from the region. It has been documented since at least the sixteenth century, when the first description of the rules has been documented.Four 3x8 rectangles arranged in a cross with a large empty square in the center. Two teams of two players, or by two players playing with two sets of pieces. The pieces move along the outer track of the board according to the throw of three four-sided dice with values of 1, 2, 5 and 6. The values of each die must be played individually, except in certain cases. Each player has four pieces, which begin on the sixth and seventh space of the central row and the seventh and eight space in the right hand row of the arm of the board belonging to the player. If a piece lands on a space occupied by an opponent, the opponent's piece is sent back to the starting position. If two of a player's pieces are on the same space, they cannot be sent to the beginning. In addition, when three pieces are on the same spaces, if triple sixes are thrown the pieces may move twelve spaces together. The same rule applies for threes and twos, moving six and four, respectively. After completing a circuit of the board, the pieces then move into the central row of squares in the arm where the player began. The player must then move off all of their pieces by an exact roll. If a player has removed all of their pieces from the board and their partner is still playing, the player rolls on what would be their turn and the partner moves according to these rolls in addition to their own turn. The player or team to remove all of their pieces from the board first wins.
         
(game "Chaupar" 
    (players 4) 
    (equipment { 
        ("PachisiBoard" 
            {
            (track "Track1" "61,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,54,E1,N7,End" P1 directed:True)
            (track "Track2" "21,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True)
            (track "Track3" "88,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True)
            (track "Track4" "32,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)
            }
        )
        (dice d:4 faces:{1 2 5 6} num:3)
        (map "Start" {(pair P1 61) (pair P2 21) (pair P3 88) (pair P4 32)})
        (piece "Pawn" Each ("PieceMove" "Track"))
    }) 
    (rules 
        (start {
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
            
            
            (place Stack "Pawn1" (sites {61 58 59 56}))
            (place Stack "Pawn2" (sites {21 20 0 1}))
            (place Stack "Pawn3" (sites {91 88 93 90}))
            (place Stack "Pawn4" (sites {33 32 49 50}))
        })
        
        (play ("RollEachNewTurnMove" ("Move")))
        
        (end ("EscapeTeamWin"))
    )
)

Construct a Ludii game based on the following description
Pulijudamu is a hunt game played in the area of Vijayanagara. Written sources place the game in the sixteenth century, and graffiti at the site of Vijayanagara could indicate that it was older. It was a game considered to belong to the lower classes in the sixteenth century and is still played by agricultural workers today. It is considered more impressive to win with more tigers and fewer goats.A triangle, with a line drawn from the apex to the base. A rectangle intersects with the triangle, and has a line connecting the midpoints of the short sides. One player plays as the tiger(s), one to four in number. The other player plays as five to 23 goats (or dogs, or lambs). The tiger begins on the apex of the triangle, and any other tigers on the spots adjacent to the apex. The tiger player moves by moving a piece to an empty adjacent spot along the lines of the board. The goat player begins the game by placing a goat on an empty point on the board, and then the tiger player moves. When all of the goats are placed, they move like the tiger. The tiger may capture a goat by hopping over it to an empty spot on the opposite adjacent side of the goat along the lines of the board. The goats win by blocking the tiger(s) from being able to move; the tiger(s) win by capturing enough goats to prevent them from blocking it/them. 1 Tiger. 5 Goats.
(game "Pulijudamu" 
    (players 2) 
    (equipment { 
        (board 
            (add
                (remove
                    (merge
                        (scale 1 2 (wedge 5 3)) 
                        (shift 0 2 (scale 8 2 (rectangle 3 2)))
                    )
                    edges:{{17 18} {15 16} {13 14}}
                )
                edges:{{13 7} {15 4} {17 1} {3 18} {6 16} {9 14}}
            )
            use:Vertex
        ) 
        (hand Each) 
        (piece "Goat" P2 ("StepToEmpty"))
        (piece "Tiger" P1
            (or 
                ("StepToEmpty")
                ("HopCapture")
            )
        )
    }) 
    (rules 
        (start {
            (place "Goat2" (handSite P2) count:<Goat:num>)
            (place "Tiger1" (handSite P1) count:<Tiger:num>)
        })
        
        phases:{
        (phase "Opening" P1
            (play
                (move 
                    (from (handSite Mover)) 
                    (to 
                        (if (= 0 (count Sites in:(intersection (sites Top) (sites Occupied by:Mover))))
                            (sites Top)
                            (intersection (sites Empty) (sites {1 2 3}))
                        )
                    ) 
                    (then (if ("HandOccupied" Mover) (moveAgain)))
                )
            )
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        (phase "Opening" P2
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("NoMovesP1NoPiecesP2"))
    )
)

Construct a Ludii game based on the following description
Driesticken is a simple game of alignment played in the Netherlands in the seventeenth century. 3x3 intersecting lines. Three pieces per player. Players alternate turns placing pieces on an empty spot on the board. When all pieces are placed, players alternate turns moving a piece to any empty spot on the board. The first player to place their pieces in an orthogonal row along the lines wins.
         
(game "Driesticken"
    (players 2) 
    (equipment {
        (board (square 3) use:Vertex)
        (hand Each)
        (piece "Marker" Each (move (from) (to (sites Empty))))
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win" Orthogonal))
    )
)

Construct a Ludii game based on the following description
Tibetan Jiuqi is a board game played by Chinese Tibetans, widely distributed in Sichuan, Qinghai, Gansu and Tibetan Autonomous Region of China.8x8 board, 32 pieces per player. There's a diagonal in the centre of the chessboard, but it's not an edge.
            
            The game is played by white first and is divided into three main stage: Layout, Battle and Fly.
            
            Layout stage: When placing a piece, both player must first place a piece on the diagonal of the middle square of the board, and then two players alternately put a piece on any point of the board until the board is full of chess pieces.
            
            Battle Stage: At the end of the Layout stage, the first player removes the pieces on the Jiu-ti (diagonal line in the middle square of the board), and then the player who secondly place pieces in the Layout stage starts the first move and enters the Battle Stage; During the move, the opponent's pieces are taken by using the Square capture, Jumping capture.
            
            Flying Stage: Later in the game, if a player's number of pieces is less than 8, the player enters the Flying Pieces phase, where the player moves pieces without the one-step-per-frame limit, and pieces can land on any empty square. The opponent's pieces are taken by using the Square capture, Jumping capture, but the rules of the Jumping capture have changed a little.
            
            Jumping capture: Pieces capture opponent's pieces by jumping them in a forward direction if they are adjacent. Multiple captures are allowed. But in the Flying Stage, single captures are forbidden, you can only do multiple captures.
            
            Square capture: Use four adjacent friendly chess pieces to make a square. When a player makes a new square, they may remove another of the opponent's pieces from the board.  Multiple captures are allowed.
            
        The goal: One player wins if the number of pieces of the opponent is less than 4. 
(game "Tibetan Jiuqi"
    (players 2)
    (equipment {
        (board 
            (add
                (square 8)
            )
            use:Vertex
        )
        (piece "Marker" Each
            (or 
                ("StepToEmpty" ~
                    (then 
                        ("CountSquares")
                    )
                )
                ("HopSequenceCapturePlayPhase")
            )
        )
        (hand Each)
    })
    (rules
        (start 
            (place "Marker" "Hand" count:32)          
        )
        
        phases:{
        (phase "FirstPlacement" 
            (play 
                (or
                    (move (from (handSite Mover)) ( to (sites  "D4") if:(is Empty (to))  ))
                    (move (from (handSite Mover)) ( to (sites  "E5") if:(is Empty (to))  ))
                )
            )
            (nextPhase Mover "Layout")    
        )
        (phase "Layout" 
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" Mover) "RemoveCentre")    
        )
        (phase "RemoveCentre" 
            (play
                (move Remove (sites {"D4" "E5"}) 
                    (then 
                        (if (not (and (is Empty  27) (is Empty  36)  ))
                            (moveAgain)
                        )
                    )
                )   
            )
            (nextPhase All (and (is Empty  27) (is Empty  36)  ) "Battle")    
        )
        (phase "Battle" 
            (play
                (if "SameTurn"
                    (if (> (value Player Mover) 0)
                        (or
                            ("SquareRemove") 
                            ("HopSequenceCaptureAgainJiu")  
                        )
                        (or
                            ("HopSequenceCaptureAgainJiu")
                            (move Pass)
                        )     
                    )
                    (forEach Piece)
                )
            )
            (nextPhase All (or (< (count Pieces Mover) 9) (< (count Pieces Next) 9)  )  "Fly")    
        )
        (phase "Fly"
            (play
                
                (if "SameTurn"
                    (if (> (value Player Mover) 0)
                        (or
                            ("SquareRemove") 
                            ("HopSequenceCaptureAgainJiu")  
                        )
                        (or
                            ("HopSequenceCaptureAgainJiu")
                            (move Pass)
                        )     
                    )
                    (if (< (count Pieces Mover) 9)
                        (forEach Piece 
                            (or
                                ("HopSequenceCaptureFlyPhase")
                                (move 
                                    (from (sites Occupied by:Mover))
                                    (to (sites Empty))
                                    (then 
                                        ("CountSquares")
                                    )
                                )
                            ) 
                        )
                        (forEach Piece
                            (or 
                                ("StepToEmpty" ~
                                    (then 
                                        ("CountSquares")
                                    )
                                )
                                ("HopSequenceCaptureFlyPhaseMoreThanEight")
                            )
                        )
                    )
                )
            )
        )
        }
        (end ("HavingLessPiecesLoss" Next 3))
    )
)

Construct a Ludii game based on the following description
Rimau-Rimau is a hunt game played in the late nineteenth century in Singapore. 5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. One player plays as the tiger, which is placed on the apex of either triangle. The other player plays as 24  people, nine of which begin on the nine central points of the board. To begin, the person playing as the tiger removes three of the people from their starting position and places them on any points on the board. The person playing as the people then places one of the remaining people on an empty spot on the board. The tiger then moves to an empty adjacent spot along the lines of the board. Play continues like this until all of the people are placed, at which point the people move to an adjacent empty spot on the board as well. On its turn, the tiger may hop over a line of people to an empty spot on the other side of the line, following the lines of the board and only if the number of people in the line is odd. The tiger wins if it captures all the people; the people win when they block the tiger from being able to move. 
(game "Rimau-Rimau (One Tiger)" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (hand Each) 
        (piece "Tiger" P1 
            (or {
                ("StepToEmpty")
                ("BigHop" ("IsEnemyAt" (between))) 
            })
        ) 
        (piece "human" P2 "StepToEmpty") 
    }) 
    (rules 
        (start {
            (place "human2" (expand (sites Centre)))
            (place "human2" (handSite P2) count:15)
            (place "Tiger1" (handSite P1))
        })
        
        phases:{
        (phase "PlacementTiger" P1
            (play (move (from (handSite P1)) (to (sites {"C3" "C7"})) (then (moveAgain))))
            (nextPhase Mover "MoveHuman")
        )
        
        (phase "MoveHuman" P1
            (play 
                (move 
                    (from (intersection (expand (sites Centre)) (sites Occupied by:Next))) 
                    (to (difference (sites Empty) (expand (sites Centre)))) 
                    (then 
                        (if (< 6 (count Sites in:(intersection (expand (sites Centre)) (sites Occupied by:Next))))
                            (moveAgain)
                        )
                    )
                )
            )
            (nextPhase Mover (= 6 (count Sites in:(intersection (expand (sites Centre)) (sites Occupied by:Next)))) "Movement")
        )
        
        (phase "PlacementHuman" P2
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                ) 
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement"
            (end ("NoMovesP1NoPiecesP2"))
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Canadian Draughts" 
    (players 2) 
    ("DraughtsEquipment" (square 12))
    
    (rules 
        ("BlackCellsSetup" 5)
        
        (play <Rules:rule>)
        
        (end ("BlockWin"))
    )
)
Canadian Draughts is played on a 12x12 checker board and is popular in Canada (particularly Quebec) and was also known to be played in New England. Anecdotally, it is said to have been invented by French settlers to Quebec, but 12x12 boards are known from Europe before this. Played on a 12x12 board with 30 pieces per player. Otherwise, it follows the rules of International Draughts.Played on a 12x12 board with 30 pieces per player, arranged on the dark squares. Pieces move diagonally one or can jump an opponent's adjacent player to capture it. Pieces can move forward or backwards. When a piece reaches the opposite edge of the board from its starting position, it becomes a king and can may move and jump over any number of spaces diagonally. Captures are compulsory and the maximum number of jumps must be made. Winning is achieved by capturing all the opponent's pieces or by blocking them from moving. The rules are the standard ones.

Construct a Ludii game based on the following description
O-Pat-Kono is a two-player game of alignment played since at least the late nineteenth century in Korea.Played on a 4x4 grid. Each player has seven pieces, placed on the intersections of the lines, five on the back row and one on each outer intersection of the second line. Pieces are moved diagonally across the squares. The object is to place one's pieces in the opponent's starting position. The first player to do so wins. 
(game "O-Pat-Kono" 
    (players 2) 
    (equipment { 
        (board (rectangle 5 5) use:Vertex) 
        (piece "Marker" Each "StepDiagonalToEmpty") 
        (regions "Home" P1 (union (sites Bottom) (sites {"A2" "E2"}))) 
        (regions "Home" P2 (union (sites Top) (sites {"A4" "E4"}))) 
    }) 
    (rules 
        (start {
            (place "Marker1" (sites P1))
            (place "Marker2" (sites P2))
        })
        (play (forEach Piece))
        
        (end ("FillWin" (sites Next)))
    )
)

Describe the mechanics of the following Ludii game
(game "The Pawn Game" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8))
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
        )
        <Variant:piece>
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            <Variant:startP1>
            <Variant:startP2>
        })
        
        (play (forEach Piece))
        
        (end {
            ("ReachWin" (sites Mover) Mover)
            ("BlockWin")
            <Variant:end>
        }) 
    )
)
This mini-game (also called the Pawn Game) gives a good feel for how the pawns move, capture and defend themselves. Pawns provide the backdrop for chess. Structures such as pawn chains will emerge as well as important concepts such as the sacrifice. To play the game well requires counting ahead as pawns race each other.Each side has a line of pawns. The pawns move as in chess i.e. The pawn moves forwards one square (optionally two squares on its first move) and captures diagonally forwards one square by replacing the opponent’s piece. The rule of En Passant is also allowed. White goes first. The first person to reach the other side is the winner. You also win if it is your opponent’s move and they have no moves left.
        In Ludii, options are also available to add each of the five other Chess piece types. In the variant with the king piece, if you capture the opponent king, you win as well. The game is played with only pawns.

Construct a Ludii game based on the following description
Conspirateurs is a game resembling Halma. R.C. Bell claimed that it was invented around the time of the French Revolution, but this may have been speculation.Play begins with an empty board. Black goes first. Players alternate turns. The game proceeds in two phases: Drop phase: Players place one cone per turn on any vacant cell on the special 9×5 centre area of the board. Players may not move a cone until all their cones have been placed. After the drop phase is completed, the conspirateurs scatter to hide in sanctuaries. A sanctuary may hold at most one man. The first to bring all his conspirateurs to sanctuary wins the game. Move phase: If a conspirateur starts the turn already on a sanctuary then it can’t move. Players move one man per turn to a vacant point one step in any direction orthogonally or diagonally, or players may leap over an adjacent man (friend or foe; and whether the jumpee is on a sanctuary or not) and land on the vacant point immediately beyond. Multiple leaps are allowed in a single turn: a man may continue to leap in any direction as long as there are jumps to be made, and may stop jumping at any point (leaps are not compulsory). A jumped man is not captured (there is no capturing in Conspirateurs). GAME END The game ends when a player brings all her conspirateurs to shelter holes (sanctuaries), thus winning the game 
(game "Conspirateurs" 
    (players 2) 
    (equipment { 
        (board (square 17)) 
        (piece "Pawn" Each)
        (hand Each)
        (regions "Secret Meeting Place" (sites {106..114 123..131 140..148 157..165 174..182}))
        (regions "Sanctuaries" (sites {"A1" "B1" "D1" "F1" "H1" "J1" "L1" "N1" "P1" "Q1" "A2" "Q2" "A4" "Q4" "A6" "Q6" "A8" "Q8" "A9" "Q9" "A10" "Q10" "A12" "Q12" "A14" "Q14" "A16" "Q16" "A17" "B17" "D17" "F17" "H17" "I17" "J17" "L17" "L17" "N17" "P17" "Q17"}))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (handSite P1) count:21)
            (place "Pawn2" (handSite P2) count:21)
        })
        
        phases:{
        (phase "Placement" 
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (forEach (sites "Secret Meeting Place") if:(is Empty (site))))
                )
            ) 
            (nextPhase (and ("HandEmpty" P1) ("HandEmpty" P2)) "Movement")
        )
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    (or 
                        ("HopSequence" (last To)) 
                        (move Pass)
                    )
                    (forEach Piece (if (not (is In (from) (sites "Sanctuaries"))) 
                            (or 
                                ("HopSequence" (from)) 
                                "StepToEmpty"
                            )
                        )
                    )
                )
            )
            (end (if "GoalReached" (result Mover Win)))
        ) 
        }
        
    )
)

Describe the mechanics of the following Ludii game
(game "Jeson Zam"
    (players 2)
    
    (equipment { 
        (board
            (add
                (remove
                    (add
                        (merge {
                            (rotate 30 (tri 2))
                            (shift 0.2 0 (rotate -30 (tri 2)))
                        })
                        vertices:{{0.6 0.3}} 
                    )
                    edges:{{0 2} {0 1} {1 2} {3 5} {5 4} {4 3}}
                )
                vertices:{
                {0.6 0.625} 
                {0.915 0.3} 
                {0.285 0.3} 
                {0.6 -0.01} 
                {0.285 0.1725} 
                {0.285 0.4375} 
                {0.915 0.4375} 
                {0.915 0.1725} 
                {0.75 0.075} 
                {0.45 0.075} 
                {0.75 0.535} 
                {0.45 0.535} 
                }
                edges:{
                {1 13} {13 17} {17 7} {7 2} 
                {2 12} {12 9} {9 11} {11 0}
                {5 13} {13 8} {8 14} {14 4}
                {1 14} {14 15} {15 10} {10 0}
                {5 7} {7 18} {18 12} {12 3}
                {3 11} {11 16} {16 10} {10 4}
                {0 16} {16 6} {6 17} {17 5}
                {4 15} {15 6} {6 18} {18 2}
                {3 9} {9 6} {6 8} {8 1}
                }
            )
            use:Vertex
        ) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ 
                (then ("ReplayIfLine3")) 
            )
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:9))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal) 
                    (move 
                        (from (handSite Mover)) 
                        (to (difference (sites Empty) (sites Centre))) 
                        (then ("ReplayIfLine3")) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal) 
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)
Jesön Zam (The nine ways) is an alignment game played in Mongolia. The game is described as boys with white hair dancing with boys with black hair.Two triangles, which form a six-pointed star, with lines connecting the corner of one triangle with the corner of the other triangle which is opposite it. Nine pieces per player. Players alternate turns placing a piece on an empty point on the board. Players cannot place a piece in the central point during this phase. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent point on the board. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. When three pieces are in a three-in-a-row pattern, they cannot be removed. The player who removes all of the opponent's pieces from the board wins. 

Construct a Ludii game based on the following description
Tugi-Épfe is a race game played by Tewa speaking Puebloan people of New Mexico around the turn of the twentieth century. The pieces represent horses, which race around the board, and may send one another back to start.Stones are placed on the ground to make a square with ten spaces per side, the spaces between the stones being the place where the pieces are played. One piece per player. Three sticks used as dice, one side flat, the other round. One of the sticks is notched on the round side. Throws are as follows: All flat sides up = 5; all round sides up = 10; one flat and two round, with no notches up = 1, two flat and one round, with no notches up = 3, two flat or two round, with notches up = 15. Pieces begin in one corner of the board. Players may move in opposite directions around the board, or in the same direction. When players move in the same direction, they may send the opponent's piece back to the beginning if they land on their spot. When the opponent is sent back to the beginning, they may then choose their direction of play. When players are moving in opposite directions, the opponent's piece may not be sent to start. The first player to travel around the board and land in the starting space wins. The game has 2 players.
(game "Tugi-Epfe"
    (players <Player:num>)
    (equipment {
        (board 
            (merge {
                (rectangle 1 11)
                (rectangle 11 1)
                (shift 0 10 (rectangle 1 11))
                (shift 10 0 (rectangle 11 1))
            })
            {
            (track "TrackCW" {0 10..19 20..29 39..30 9..0} directed:True)
            (track "TrackCCW" {0..9 30..39 29..20 19..10 0} directed:True)
            }
            use:Edge
        ) 
        (dice d:2 facesByDie:{{0 10} {0 1} {0 1}} num:3) 
        (map "ThrowDiceValue" {
            (pair 0 5) 
            (pair 12 5) 
            (pair 2 1) 
            (pair 1 3) 
            (pair 10 15) (pair 11 15) 
        })
        (piece "Horse" Each
            (if ("IsOffBoard" (value Player Mover))
                (or 
                    ("MoveOn" ("SiteToMoveOnTrackCW") ("RememberSelectedTrack" ("SelectCW")))
                    ("MoveOn" ("SiteToMoveOnTrackCCW") ("RememberSelectedTrack" ("SelectCCW")))
                )
                ("MoveOn" "SiteToMoveOnSelectedTrack")
            )
        )
        (regions "AllSites" (sites Board))
    })
    (rules 
        (start 
            (place Stack items:{<Player:initHorse>} 0)
        )
        (play 
            ("RollMove"
                (forEach Piece)
                (then 
                    (if 
                        (= (last To) ("Goal"))
                        (remove (last To))
                    )
                )
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Stratomic is a chess variant invented by Robert Montay-Marsais in 1972. The game is played on a 10×10 board with all the standard chess pieces present, and in addition, two nuclea pieces (representing nuclear missiles) and two extra pawns per side. The game brings the concept of modern warfare weaponry to chess.The standard conventions of chess apply, including normal castling and en passant. Pawns promote on the 9th ranks and may promote to missile. The missile moves and captures as a chess king: one step in any direction. It may be captured like any other piece.
            
            Missile launches
            A player can launch a missile at any time to any board square, occupied or not. The launched missile \ 
(game "Stratomic" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 10)) 
        
        (piece "Pawn" Each 
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
                )
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                "EnPassant"
                }
                (then
                    (and
                        ("ReplayInMovingOn" (sites Mover "Promotion")) 
                        (set Counter)
                    )
                )
            )
        )
        
        (piece "Rook" Each 
            (move Slide 
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "King" Each 
            (move Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndResetCounter"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "Bishop" Each 
            (move Slide 
                Diagonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "Knight" Each 
            (move Leap 
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "Queen" Each 
            (move Slide 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            ) 
        )
        
        (piece "NuclearBomb" Each
            (move Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        
        (map "King" {(pair 1 "F2") (pair 2 "E9")})
        (map "RookLeft" {(pair 1 "A2") (pair 2 "J9")})
        (map "RookRight" {(pair 1 "J2") (pair 2 "A9")})
        (regions "Promotion" P1 (sites Row 8))
        (regions "Promotion" P2 (sites Row 1))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 2))
            (place "Pawn2" (sites Row 7))
            (place "NuclearBomb1" (sites {"A2" "J2"})) (place "Rook1" {"B2" "I2"} state:1) (place "Knight1" {"C2" "H2"}) (place "Bishop1" {"D2" "G2"}) (place "Queen1" coord:"E2") (place "King1" coord:"F2" state:1) 
            (place "NuclearBomb2" (sites {"A9" "J9"})) (place "Rook2" {"B9" "I9"} state:1) (place "Knight2" {"C9" "H9"}) (place "Bishop2" {"D9" "G9"}) (place "Queen2" coord:"F9") (place "King2" coord:"E9" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook" "NuclearBomb"}) Mover)
                (do 
                    (or 
                        (if ("AuthorisedToLaunch")
                            (move Select
                                (from (sites Occupied by:Mover component:"NuclearBomb") if:(not (is Threatened (id "NuclearBomb" Mover) at:(from) (forEach Piece))))
                                (to (sites Board))
                                (then
                                    (and
                                        (forEach Site (sites Around (last To) includeSelf:True)
                                            (if (and {(is Occupied (site)) (!= (what at:(site)) (id "King" P1)) (!= (what at:(site)) (id "King" P2)) })
                                                (remove (site))
                                            )
                                        )
                                        (remove (last From))
                                    )
                                )
                            ) 
                        )
                        ("CastingAndMovingPieces")
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover ("CastingAndMovingPieces")))
                )
            )
        )
        
        (end {
            (if (and 
                    ("IsInCheck" "King" Next ("CastingAndMovingPieces"))
                    ("NextCanNotMove")
                ) 
                (result Mover Win)
            ) 
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
The game is played on a 7x7 board.MOVES - A move consists of either:
            - A growth, i.e., a drop of a stone on an empty adjacent (orthogonal or diagonal) to friendly cell;
            - An orthogonal or diagonal slide of a stone already on board (like a chess Queen) to an empty cell;
            - A drop of a stone on any empty cell.
            - Any opponent adjacent stones to the new piece (either through growth or slide) are flipped to the moving player's colour. Notice that the third option (simple drop) do not flip the colour of adjacent stones.
            
        GOAL - Wins the player with most stones when the board is filled. 
(game "Quad Wrangle"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Ball" Each
            (move Slide
                (then
                    (forEach Site
                        (sites Around (last To))
                        (if ("IsEnemyAt" (site))
                            (and
                                (remove (site))
                                (add (piece (id "Ball" Mover)) (to (site)))
                            )
                        )
                    )
                )
            )
        )
    })
    (rules
        (start {
            (place "Ball1" (difference (union (sites Top) (sites Right)) (union {(sites Left) (sites Bottom) (intersection (sites Top) (sites Right))})))
            (place "Ball2" (difference (union (sites Bottom) (sites Left)) (union {(sites Right) (sites Top) (intersection (sites Bottom) (sites Left))})))
        })
        
        (play
            (or {
                (move Add
                    (to (sites Around (sites Occupied by:Mover) Empty))
                    (then
                        (forEach Site
                            (sites Around (last To))
                            (if ("IsEnemyAt" (site))
                                (and
                                    (remove (site))
                                    (add (piece (id "Ball" Mover)) (to (site)))
                                )
                            )
                        )
                    )
                )
                (forEach Piece)
                (move Add
                    (to (difference (sites Empty) (sites Around (sites Occupied by:Mover) Empty)))
                )
            })
        )
        
        (end (if (is Full)
                (byScore {
                    (score P1 (count Pieces P1))
                    (score P2 (count Pieces P2))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Natt Klab ash-Shawk is a capturing game that was played in Palestine. 5x5 board, the central square marked with an X. Twelve pieces per player. Pieces begin the game on the first two rows in front of the player, and in the two squares to the player's right in the central row. Players alternate turns moving a piece orthogonally to an adjacent empty space. Players may capture an opponent's piece by hopping over it. The player who captures all of the opponent's pieces wins. 
(game "Natt Klab ash-Shawk"
    (players 2)
    (equipment {
        (board (square 5)) 
        (piece "Marker" Each
            (or
                ("StepOrthogonalToEmpty")
                ("HopOrthogonalCapture")
            )
        )
    })
    (rules 
        (start { 
            (place "Marker1" (union {(expand (sites Bottom)) (sites {"D3" "E3"}) }))
            (place "Marker2" (union {(sites {"A3" "B3"}) (expand (sites Top)) }))
        })
        (play (forEach Piece))
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Fox and Geese is a game known from medieval Europe with a complicated history. Many different versions are known, and it spread to many places that encountered Europeans and was adopted in various places with local rules. It is still played today, and it was thought that during the medieval and early modern period it was played by poorer classes of people, at least in England. In general, it is a typical hunt game.The game is played on a cruciform board adapted from an Alquerque board. One player plays as the fox, the other as the geese. The geese begin in a set starting position; the person playing as the fox may choose any available spot to place the fox as their first move. Players move as in Alquerque, but only the fox can hop to capture. The goal of the geese is to block the fox from being able to move; the fox's goal is to capture all of the geese. The game starts with 13 geese.
(game "Fox and Geese" 
    (players 2) 
    (equipment { 
        ("CrossBoard" 3 7 use:Vertex diagonals:Alternating)
        (hand P1)
        (piece "Fox" P1 (or ("HopCapture") "StepToEmpty"))
        (piece "Goose" P2 "StepToEmpty") 
    }) 
    (rules 
        (start { 
            <Place:geese>
            (place "Fox1" (handSite P1))
        })
        
        phases:{ 
        (phase "Placement" P1 
            (play 
                (move 
                    (from (handSite P1)) 
                    (to (sites Empty))
                )
            ) 
            (nextPhase ("HandEmpty" P1) "Movement")
        )
        (phase "Movement" (play (forEach Piece)))
        }
        
        (end ("NoMovesLossAndNoPiecesPlayerLoss" P2))
    )
)

Describe the mechanics of the following Ludii game
(game "Mini Wars" 
    (players <Scenario:numPlayers>) 
    (equipment { 
        (board <Scenario:boardShape>)
        
        <Scenario:boardRegins>
        
        (hand Shared size:14)
        
        (piece "Base" Each)
        (piece "Factory" Each)
        (piece "Town" Each)
        (piece "Airport" Each)
        (piece "Dock" Each)
        
        (piece "Soldier" Each (or {"HumanMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Motorbike" Each (or {"HumanMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        
        (piece "Speeder" Each (or {("VehicleMove" 1) "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Shooter" Each (or {("VehicleMove" 1) "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Tank" Each (or {("VehicleMove" 1) "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        
        (piece "Antiair" Each (or {("VehicleMove" 1) ("RangedAttack" 1 2) "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Launcher" Each (or {("VehicleMove" 1) ("RangedAttack" 2 3) "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Artillery" Each (or {("VehicleMove" 0) ("RangedAttack" 3 5) "HealMoveBuilding" "HealMoveUnit"}))
        
        (piece "Helicopter" Each (or {"AircraftMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Fighter" Each (or {"AircraftMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Bomber" Each (or {"AircraftMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        
        (piece "Cruiser" Each (or {"BoatMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Submarine" Each (or {"BoatMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Battleship" Each (or {"BoatMove" ("RangedAttack" 2 4) "HealMoveBuilding" "HealMoveUnit"}))
        
        (piece "Base" Neutral) 
        (piece "Factory" Neutral)
        (piece "Town" Neutral)
        (piece "Airport" Neutral)
        (piece "Dock" Neutral)
        
        (piece "Soldier" Neutral)
        (piece "Motorbike" Neutral)
        
        (piece "Speeder" Neutral)
        (piece "Shooter" Neutral)
        (piece "Tank" Neutral)
        
        (piece "Antiair" Neutral)
        (piece "Launcher" Neutral)
        (piece "Artillery" Neutral)
        
        (piece "Helicopter" Neutral)
        (piece "Fighter" Neutral)
        (piece "Bomber" Neutral)
        
        (piece "Cruiser" Neutral)
        (piece "Submarine" Neutral)
        (piece "Battleship" Neutral)
        
        <Scenario:playerMaps>
        
        "DoctrineSetup"
    }) 
    (rules 
        (meta (passEnd NoEnd))
        (start {  
            <Scenario:buildingSetup>
            <Scenario:pieceSetup>
            <Scenario:teams>
            (set Score Each <Scenario:startingMoney>)
            
            (place "Soldier0" (handSite Shared 0) count:30 state:1 value:30)
            (place "Motorbike0" (handSite Shared 1) count:50 state:1 value:40)
            
            (place "Speeder0" (handSite Shared 2) count:60 state:1 value:60)
            (place "Shooter0" (handSite Shared 3) count:80 state:1 value:60)
            (place "Tank0" (handSite Shared 4) count:100 state:1 value:80)
            
            (place "Antiair0" (handSite Shared 5) count:80 state:1 value:50)
            (place "Launcher0" (handSite Shared 6) count:80 state:1 value:50)
            (place "Artillery0" (handSite Shared 7) count:100 state:1 value:40)
            
            (place "Helicopter0" (handSite Shared 8) count:60 state:1 value:40)
            (place "Fighter0" (handSite Shared 9) count:100 state:1 value:100)
            (place "Bomber0" (handSite Shared 10) count:120 state:1 value:100)
            
            (place "Cruiser0" (handSite Shared 11) count:60 state:1 value:70)
            (place "Submarine0" (handSite Shared 12) count:100 state:1 value:100) 
            (place "Battleship0" (handSite Shared 13) count:120 state:1 value:120) 
            
            <FogOfWar:EachMove>
        })
        
        (play 
            (or 
                (or { 
                    (forEach Piece)
                    ("BuyHumanMove")
                    ("BuyBoatMove") 
                    ("BuyAircraftMove") 
                    ("BuyVehicleMove") 
                    }
                    (then 
                        (and {
                            (forEach Player
                                ("RemovePiecesIfPlayerHasLost" Player)
                            )
                            (moveAgain)
                            (and {<FogOfWar:EachMove>})
                        })
                    )
                )
                (move Pass
                    (then
                        (and {
                            (forEach Site (sites Occupied by:Mover container:"Board")
                                (set State at:(site) (mapEntry "Movement" (what at:(site))))
                            )
                            (set Score 
                                Mover
                                (+ {
                                    (* (count Sites in:(sites Occupied by:Mover component:"Base")) 20) 
                                    (* (count Sites in:(sites Occupied by:Mover component:"Town")) 10) 
                                    (score Mover) 
                                })
                            )
                            (forEach Site (sites Occupied by:Mover components:{"Town" "Base" "Factory" "Dock" "Airport"})
                                (set Value at:(site) (min (mapEntry "MaxHealth" (what at:(site))) (+ (value Piece at:(site)) 10)))
                            )
                            (and {<FogOfWar:EachMove>})
                        })
                    )
                )
            )
        )
        
        (end 
            (forEach NonMover 
                if:("IsOffBoard" (where "Base" Player)) (result Player Loss)
            )
        )
    )
)
Mini Wars is a simplified tabletop war game.
            <b>General Rules:</b>
            
            <u>The following rules apply to all units, unless stated otherwise in their description:</u>
            
            - All units move and measure distance orthogonally.
            - Units may move up to their maximum movement limit and can then attack an adjacent site.
            
            - Attacking a unit will deal damage to it (see damage calculation section).
            - If an attacked unit's health reaches zero, it will be removed from the battlefield.
            - Defending units that survive an attack, will then deal counter damage to their attacker.
            
            - Units can reinforce an adjacent unit of the same type, instead of attacking.
            - Both units must be owned by the same player.
            - Reinforcing will convert health from one unit to the other, transferring as much health as possible.
            - Any units that are left with zero health after reinforcing are removed.
            - A unit which has been reinforced cannot perform any further actions this turn.
            
            <u>The following rules apply to all buildings:</u>
            
            - There are five types of building: Town, Factory, Airport, Dock and Base.
            
            - Attacking a building will deal damage to it (see damage calculation section).
            - If an attacked building's health reaches zero, it will gain 50 health and change ownership to the player who attacked it. 
            - Buildings that are attacked, will not deal counter damage.
            
            - Units can heal at an adjacent building that you own, instead of attacking.
            - Healing at a building, will convert health from the building to the unit, transferring as much health as possible.
            
            - Additional units can be purchased using gold at their corresponding production building.
            - To purchase a unit, drag it from your hand to an available site next to a production building that you own.
            - The cost of purchasing a unit is represented by its count.
            - Purchased units cannot move, attack or heal, on the same turn they are purchased.
            
            - Each player receives 10 gold for every Town they own and 20 gold for every Base they own, at the start of their turn.
            - Buildings gain 10 health at the end of the owning player's turn, up to a maximum of 100.
            - Grey buildings are neutral, and are not owned by any player.
            
            - If a player loses ownership of all their Bases, they lose the game.
            
            
            <b>Units:</b>
            
            <u>Human</u> (Purchased from Towns)
            
            Soldier
            Move: 3
            Health: 30
            Cost: 30
            Damage Factor: 50%
            
            Motorbike
            Move: 5
            Health: 40
            Cost: 50
            Damage Factor: 50%
            
            <u>Vehicle</u> (Purchased from Factories)
            
            Speeder
            Move: 6
            Health: 60
            Cost: 60
            Damage Factor: 40%
            
            Shooter
            Move: 4
            Health: 60
            Cost: 80
            Damage Factor: 40%
            - Deals double damage against Humans.
            
            Tank
            Move: 4
            Health: 80
            Cost: 100
            Damage Factor: 50%
            
            Anti-Aircraft
            Move: 4
            Health: 50
            Cost: 80
            Damage Factor: 100%
            - Can only attack Aircraft.
            - Can attack units 1-2 spaces away.
            - Does not deal or receive counter damage during an attack.
            
            Missile Launcher
            Move: 3
            Health: 50
            Cost: 80
            Damage Factor: 50%
            - Cannot attack Aircraft.
            - Can only attack units 2-3 spaces away.
            - Does not deal or receive counter damage during an attack.
            
            Artillery
            Move: 3
            Health: 40
            Cost: 100
            Damage Factor: 100%
            - Cannot attack Aircraft.
            - Can only attack units 3-5 spaces away.
            - Does not deal or receive counter damage during an attack.
            - Cannot attack or heal in the same turn that it moved.
            
            <u>Aircraft</u> (Purchased from Airports)
            
            Helicopter
            Move: 4
            Health: 40
            Cost: 60
            Damage Factor: 70%
            
            Fighter Jet
            Move: 6
            Health: 100
            Cost: 100
            Damage Factor: 100%
            - Can only attack Aircraft.
            
            Bomber
            Move: 5
            Health: 100
            Cost: 120
            Damage Factor: 80%
            - Cannot attack Aircraft.
            
            <u>Boat</u> (Purchased from Docks)
            
            Cruiser
            Move: 5
            Health: 70
            Cost: 60
            Damage Factor: 50%
            
            Submarine
            Move: 5
            Health: 100
            Cost: 100
            Damage Factor: 80%
            - Can only attack Boats.
            
            Battleship
            Move: 4
            Health: 120
            Cost: 120
            Damage Factor: 50%
            - Cannot attack Aircraft.
            - Can only attack units 2-4 spaces away.
            - Does not deal or receive counter damage during an attack.
            
            
            <b>Movement Restrictions:</b>
            
            Humans may travel across plains, forests, and shallow water. They may also move 1 space into mountains instead of their regular movement.
            Vehicles may travel across plains. They may also move 1 space into forests or shallow water instead of their regular movement.
            Aircraft may travel across all spaces.
            Boats may travel across shallow and deep water.
            Buildings cannot move (obviously).
            Units cannot move over enemy or neutral occupied spaces.
            
            
            <b>Damage Calculation:</b>
            
            An attacking unit deals damage equal to its health, multiplied by its damage factor. 
            For example, A submarine has a damage factor of 80%, so a submarine with 20 health will deal 16 damage when it attacks (20 x 0.8).
            If the defending unit is in shallow or deep water, it takes 25% more damage.
            If the defending unit is in a forest, it takes 25% less damage.
            Aircraft are unaffected by terrain when calculating damage against them.
            All damage values are rounded down to the nearest whole number.
            
            
            <b>Fog of War:</b> (Optional)
            
            All friendly units and buildings can see tiles up to 2 spaces away.
            Aircraft can see tiles up to 3 spaces away.
            Boats can see shallow and deep water tiles up to 3 spaces away.
            Humans on a mountain can see tiles up to 3 spaces away.
            Forest and mountain tiles can only be seen if adjacent to them.
            Enemy units and buildings that are not visible cannot be attacked, and have their type and health hidden.
            
            
            <b>Army Doctrine:</b>
            
            At the start of the game (selected via the game options) you may pick a doctrine for your army.
            
            None - No effect.
            Special Forces - Human units do 50% more damage, all other units do 25% less damage.
            Brute Strength - Direct Vehicle units (no range on their attack distance) do 50% more damage, all other units do 25% less damage.
            Sharpshooter - Indirect Vehicle units (range on their attack distance) do 50% more damage, all other units do 25% less damage.
            Ace Pilot - Aircraft units do 50% more damage, all other units do 25% less damage.
            Sea Dog - Boat units do 50% more damage, all other units do 25% less damage.
            Guerrilla Warfare - Attacks against buildings deal 50% more damage, but attacks against units deal 25% less damage.
            Foreign Invader - Attacks against buildings deal 50% less damage, but attacks against units deal 25% more damage.
            Conscription - Units cost 50% less gold, but do 50% less damage.
            Elite Training - Units cost 50% more gold, but do 50% more damage.
            Glass Cannon - Units do 50% more damage, but take 50% more damage.
            Hardened Resolve - Units do 50% less damage, but take 50% less damage.
            Preemptive Strike - Units do 50% more damage when attacking, but never deal counter damage.
            Retaliation - Units do 50% less damage when attacking, but deal 100% more counter damage.
            Lady Luck - All attack damage is randomly selected between 50% and 150% of the normal amount.
            
        
        (id  Scenario - First Encounter No Fog of War. Player 1 - No Doctrine. Player 2 - No Doctrine. Player 3 - No Doctrine. Player 4 - No Doctrine.

Construct a Ludii game based on the following description
Oumoul Kono is a blockade game played in Korean during the nineteenth century.The board is a square, with the diagonals drawn. A circle is drawn around the midpoint of the top side of the square. Two pieces per player, the pieces for one player on the top corners and the other on the remaining corners. Players alternate turns moving along the lines on the board, the player on the top corners moving first, but can never move along the line with the circle. The player who blocks their opponent from being able to move wins. 
(game "Oumoul Kono" 
    (players 2) 
    (equipment { 
        (board 
            (square 2 diagonals:Solid)
            use:Vertex
        )
        (piece "Disc" Each
            (move Step 
                (to 
                    if:(and {
                        (or {
                            (and (!= (from) (coord "A3")) (!= (from) (coord "C3")))
                            (and (= (from) (coord "C3")) (!= (to) (coord "A3")))
                            (and (= (from) (coord "A3")) (!= (to) (coord "C3")))
                        }) 
                        (is Empty (to))
                    })
                )
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Disc1" (sites Bottom)) 
            (place "Disc2" (sites Top))
        })
        (play (forEach Piece))
        (end ("NoMoves" Loss)) 
    )
)

Construct a Ludii game based on the following description
Discovered during Markus Niebisch's internship at Ludii, when a crossover-operator for games replaced the ending rule of Chess with the ending rule of hex.It is interesting as it still plays like Chess, but leads to a much more offensive play with many more potential sacrifices.Like regular Chess, but player wins, if any of his pieces reach the last rank of the enemy. Check still applies, but Checkmate only forces to pass. 
(game "Reach Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then
                (and
                    (if (is In (last To) (sites Mover "Promotion")) 
                        (moveAgain)
                    )
                    (set Counter)
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        ("Castling")
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end (if (is Connected Mover) (result Mover Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Peg Solitaire" 
    (players 1) 
    (equipment { 
        <Variant:board>
        (piece "Marker" P1 ("HopFriendCapture" Orthogonal))
    }) 
    (rules 
        (start { 
            (place "Marker" (difference (sites Board) (sites <Variant:noPieceSite>)))
        })
        
        (play (forEach Piece))
        (end (if <Variant:end> (result P1 Win))) 
    )
)
Peg Solitaire is a single-player game attested in Europe since the seventeenth century. There are two board variations, \Play begins with all holes filled except the central hole. The player moves a peg by orthogonally jumping an adjacent peg and removing it from the board. The goal is to remove all but one peg, leaving it in the central hole. The game is played on the English board.

Construct a Ludii game based on the following description
Onek Rong is a multiplayer graph theory game, which can be played by two or more players. It is played on an undirected and vertex-weighted graph. Initially, the graph contains only uncoloured vertices. At each turn, a player chooses a vertex to colour with his own colour, or pass. If there is no other adjacent vertex with the same colour, the player receives the weight of the vertex as score. When all vertices are coloured, or all players pass, the player who with the maximum score wins.   The version of the game played with 2 players.
(game "Onek Rong" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board <Board:type> use:Vertex)
        (piece "Marker" Each) 
    })
    
    (rules 
        (start
            <Board:start>
        ) 
        (play
            (or
                (move Claim    
                    (to (sites Empty)) 
                    (then 
                        (if (= 1 (size Group at:(last To))) 
                            (addScore Mover (cost Vertex at:(last To))) 
                        )
                    ) 
                )
                (move Pass)     
            )
        )
        (end
            (if (or (= (count Sites in:(sites Empty)) 0) (all Passed))
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Sittuyin is a game derived from Indian Chaturanga. It differs from similar games in that it begins with placement phase, in which pieces are placed on the board as the players see fit. In the nineteenth and early twentieth century, it was most frequently played by the elderly.8x8 board, with diagonals drawn in the 2x2 squares in each corner, as well as the diagonals of the entire board. Each player has a complement of pieces, with special moves as follows: Min-gyi (x1, \ 
(game "Sittuyin"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (hand Each size:6)
        ("ChessKing" "King_noCross")
        ("ChessRook" "Rook")
        (piece "Elephant" Each ("StepToNotFriend" Forwards))
        ("ChessKnight" "Knight")
        ("ChessPawn" "Pawn" ~ (then ("PromoteIfReach" (difference (sites "DiagonalSites") (sites Mover "Home")) "Queen")))
        (piece "Queen" Each ("StepToNotFriend" Diagonal))
        (regions "Home" P1 (expand (sites Bottom) steps:3))
        (regions "Home" P2 (expand (sites Top) steps:3))
        (regions "NoPawnSites" 
            (union
                (difference (sites Row 3) (expand (sites Right) steps:3))
                (difference (sites Row 4) (expand (sites Left) steps:3))
            )
        )
        (regions "PawnSites" 
            (union {
                (difference (sites Row 2) (expand (sites Right) steps:3))
                (difference (sites Row 3) (expand (sites Left) steps:3))
                (difference (sites Row 4) (expand (sites Right) steps:3))
                (difference (sites Row 5) (expand (sites Left) steps:3))
            })
        )
        (regions "DiagonalSites" 
            (union 
                (union (sites Centre) (expand (sites Corners) steps:1))
                (sites {"C6" "F6" "F3" "C3"})
            )
        )
        (map "KingInitPos" {
            (pair P1 (coord "G2")) 
            (pair P2 (coord "B7")) 
        })
    })
    (rules 
        (start { 
            (place "Pawn1" (difference (sites Row 2) (expand (sites Right) steps:3)))
            (place "Pawn1" (difference (sites Row 3) (expand (sites Left) steps:3)))
            (place "Pawn2" (difference (sites Row 4) (expand (sites Right) steps:3)))
            (place "Pawn2" (difference (sites Row 5) (expand (sites Left) steps:3)))
            (place "King_noCross1" (handSite P1)) (place "King_noCross2" (handSite P2))
            (place "Queen1" (handSite P1 1)) (place "Queen2" (handSite P2 1))
            (place "Elephant1" (handSite P1 2) count:2) (place "Elephant2" (handSite P2 2) count:2)
            (place "Knight1" (handSite P1 3) count:2) (place "Knight2" (handSite P2 3) count:2)
            (place "Rook1" (handSite P1 4) count:2) (place "Rook2" (handSite P2 4) count:2)
        })
        phases:{
        (phase "PlaceKing"
            (play 
                (move 
                    (from (sites Occupied by:Mover container:"Hand" component:"King_noCross")) 
                    (to (mapEntry "KingInitPos" Mover))
                )
            )
            (nextPhase Mover "PlaceFirstElephant")
        )
        (phase "PlaceFirstElephant"
            (play 
                (move 
                    (from (sites Occupied by:Mover container:"Hand" component:"Elephant")) 
                    (to (sites Around (mapEntry "KingInitPos" Mover)))
                )
            )
            (nextPhase Mover "PlaceOtherPieces")
        )
        (phase "PlaceOtherPieces"
            (play 
                (if ("PawnToReplace")
                    ("ReplaceAPawn")
                    (or 
                        (if ("AllPiecesOnBoard")
                            (or
                                (forEach Piece "Pawn" "StepForwardToEmpty") 
                                (move 
                                    (from ("AnyOwnedSitesOnBoardExceptPawn"))
                                    (to 
                                        ("EmptySiteOnPlayerSideOrOccupiedByOwnedPawn")
                                        (apply ("IfPawnStoreIt"))
                                    )
                                    (then (if ("PawnToReplace") (moveAgain)))
                                )
                            )
                        )
                        (move 
                            (from (sites Occupied by:Mover container:"Hand")) 
                            (to 
                                ("EmptySiteOnPlayerSideOrOccupiedByOwnedPawn")
                                (apply ("IfPawnStoreIt"))
                            )
                            (then (if ("PawnToReplace") (moveAgain)))
                        )
                    )
                )
            )
            (nextPhase ("PawnWasMovedForward") "Playing")
        )
        (phase "Playing"
            (play
                (do
                    (forEach Piece)
                    ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
                )
            )
            (end ("Checkmate" "King_noCross"))
        )
        }
    )
)

Construct a Ludii game based on the following description
Quantik is a pure abstract strategy game. The goal is to be the first player to pose the fourth different forms of a line, a column or a square zone.Each turn the players will put one of their pieces on the boardgame. It's forbidden to put a shape in a line, a column or an area on which this same form has already been posed by the opponent. We can only double a shape if we have played the previous one ourself. The first player who places the fourth different form in a row, column or zone wins the game immediately, no matter who owns the other pieces of that winning move. 
(game "Quantik"
    (players 2)
    (equipment {
        (board (square 4) use:Vertex)
        (piece "Disc" Each)
        (piece "Square" Each)
        (piece "Triangle" Each)
        (piece "Hex" Each)
        (regions "BottomLeft" (expand origin:(coord "A1") All))
        (regions "BottomRight" (expand origin:(coord "D1") All))
        (regions "TopLeft" (expand origin:(coord "A4") All))
        (regions "TopRight" (expand origin:(coord "D4") All))
        (hand Each size:4)
        (map { 
            (pair (id "Disc1") (id "Disc2")) (pair (id "Disc2") (id "Disc1"))
            (pair (id "Square1") (id "Square2")) (pair (id "Square2") (id "Square1"))
            (pair (id "Triangle1") (id "Triangle2")) (pair (id "Triangle2") (id "Triangle1"))
            (pair (id "Hex1") (id "Hex2")) (pair (id "Hex2") (id "Hex1"))
        })
    })
    (rules 
        (start {
            (place "Disc1" (handSite P1) count:2)
            (place "Disc2" (handSite P2) count:2)
            (place "Square1" (handSite P1 1) count:2)
            (place "Square2" (handSite P2 1) count:2)
            (place "Triangle1" (handSite P1 2) count:2)
            (place "Triangle2" (handSite P2 2) count:2)
            (place "Hex1" (handSite P1 3) count:2)
            (place "Hex2" (handSite P2 3) count:2)
        })
        (play 
            (move 
                (from (sites Occupied by:Mover container:(mover)))
                (to (sites Empty) 
                    if:(and { 
                        "NotSameRow"
                        "NotSameColumn"
                        "NotSameSquare"
                    })
                )
            )
        )
        (end 
            (if 
                (or {
                    ("AllDifferent" (sites "BottomLeft"))
                    ("AllDifferent" (sites "BottomRight"))
                    ("AllDifferent" (sites "TopLeft"))
                    ("AllDifferent" (sites "TopRight"))
                    ("AllDifferent" (sites Row 0))
                    ("AllDifferent" (sites Row 1))
                    ("AllDifferent" (sites Row 2))
                    ("AllDifferent" (sites Row 3))
                    ("AllDifferent" (sites Column 0))
                    ("AllDifferent" (sites Column 1))
                    ("AllDifferent" (sites Column 2))
                    ("AllDifferent" (sites Column 3))
                    (no Moves Next) 
                })
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Blocking game played on a 6x8 or 7x7 board.Each player has a pawn, that can move to any neighboring cell. After moving, the player places a block to the cell he came from. First player who cannot move loses. The game is played on a 7x7 board.
(game "Snailtrail"
    (players 2)
    (equipment {
        (board (rectangle <Board:size>))
        (piece "Pawn" Each (move Step (to if:(is Empty (to))) (then (moveAgain))))
        (piece "Square" Neutral)
    })
    (rules
        (start {
            <Board:placement>
        })
        (play 
            (if (is Even (count Moves))
                (forEach Piece)
                (move Add (piece "Square0") (to (last From)))
            )
        )
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Qi Guo Xiangxi (\19x19 lines, pieces are played on the intersections of the lines. Seventeen pieces per player, each with special moves, as follows: Jiang (General) x1: moves orthogonally or diagonally any distance; Pian (Deputy General) x1: Moves orthogonally any distance; Bai (Officer) x1: moves diagonally any distance; Ren (Emissary) x1: moves orthogonally or diagonally any distance, but cannot capture or be captured; Pao (Catapult) x1: moves orthogonally any distance, but can only capture by jumping over one of the player's own pieces first; Gong (Bow) x1: moves orthogonally or diagonally four spaces; Nu (Crossbow) x1: moves orthogonally or diagonally five spaces; Dao (Knife) x2: moves one space diagonally; Jian (Sword) x4: moves one space orthogonally; Qi (Mounted riders) x4: moves one space in a straight line then three diagonally, does not jump. Seven players. Players play as seven states: Ch'in (white), Ch'u (red), Han (orange), Ch'i (dark blue), Wei (green), Chao (purple), and Yen (black). They play in that order. One piece, the Chou (King, which is yellow), is placed in the central spot and does not move and pieces cannot enter that space. Pieces capture an enemy piece by moving to the spot it occupies. A player is eliminated when their general or ten of their pieces are captured, and their remaining pieces are removed from the board. Play continues until one player remains, one player captures two generals, or one player captures thirty pieces. The player with the most captured pieces wins. 
(game "Qi Guo Xiangxi"
    (players 7)
    (equipment {
        (board (square 19) use:Vertex)
        (piece "King" Shared)
        (piece "General" Each
            (move Slide 
                All
                (between
                    if:("EmptyNotKing" (between))
                )
                (to 
                    if:("EnemyNotKing" (to))
                    "CaptureToPiece"
                ) 
            ) 
        )
        (piece "Deputy General" Each
            (move Slide 
                Orthogonal
                (between
                    if:("EmptyNotKing" (between))
                )
                (to 
                    if:("EnemyNotKing" (to))
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "Officer" Each
            (move Slide 
                Diagonal
                (between
                    if:("EmptyNotKing" (between))
                )
                (to 
                    if:("EnemyNotKing" (to))
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "Diplomat" Each (move Slide All))
        (piece "Archer" Each
            (move Hop 
                All 
                (between (exact 3) if:(is Empty (between))) 
                (to 
                    if:(or (is Empty (to)) ("EnemyNotKing" (to))) 
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "CrossBow" Each
            (move Hop 
                All 
                (between (exact 4) if:(is Empty (between))) 
                (to 
                    if:(or (is Empty (to)) ("EnemyNotKing" (to))) 
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "Knife" Each
            (move Step 
                Diagonal
                (to 
                    if:(or (is Empty (to)) ("EnemyNotKing" (to))) 
                    "CaptureToPiece"
                )
            )
        )
        (piece "Broadsword" Each
            (move Step 
                Orthogonal
                (to 
                    if:(or (is Empty (to)) ("EnemyNotKing" (to))) 
                    "CaptureToPiece"
                )
            )
        )
        (piece "Catapult" Each
            (or 
                (move Slide Orthogonal) 
                (move Hop 
                    Orthogonal 
                    (between 
                        before:(count Rows) 
                        after:(count Rows) 
                        if:("IsFriendAt" (between))
                    )
                    (to 
                        if:(is Empty (to)) 
                        (apply 
                            if:("EnemyNotKing" (to)) 
                            ("RemoveEnemyPiece")
                        )
                    ) 
                ) 
            )
        )
        (piece "Knight" Each 
            (forEach Direction 
                Orthogonal 
                (to 
                    if:(is Empty (to)) 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL} of:All) 
                            (between (exact 3) if:(is Empty (between)))
                            (if (or (is Empty (to)) ("EnemyNotKing" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            ("RemoveEnemyPiece")
                                        )
                                    )
                                )
                            )
                        ) 
                    )
                )
            )
        )
        (hand Each)
    })
    (rules 
        (start {
            (place "King" (centrePoint))
            (place "General1" coord:"A10") (place "General2" coord:"F1") (place "General3" coord:"N1")
            (place "General4" coord:"S6") (place "General5" coord:"S14") (place "General6" coord:"N19")
            (place "General7" coord:"F19")
            (place "Deputy General1" coord:"A11") (place "Deputy General2" coord:"E1") (place "Deputy General3" coord:"M1")
            (place "Deputy General4" coord:"S5") (place "Deputy General5" coord:"S13") (place "Deputy General6" coord:"O19")
            (place "Deputy General7" coord:"G19")
            (place "Officer1" coord:"A9") (place "Officer2" coord:"G1") (place "Officer3" coord:"O1")
            (place "Officer4" coord:"S7") (place "Officer5" coord:"S15") (place "Officer6" coord:"M19")
            (place "Officer7" coord:"E19")
            (place "Catapult1" coord:"B10") (place "Catapult2" coord:"F2") (place "Catapult3" coord:"N2")
            (place "Catapult4" coord:"R6") (place "Catapult5" coord:"R14") (place "Catapult6" coord:"N18")
            (place "Catapult7" coord:"F18")
            (place "Broadsword1" {"A12" "B11" "B9" "A8"}) (place "Broadsword2" {"D1" "E2" "G2" "H1"}) (place "Broadsword3" {"L1" "M2" "O2" "P1"})
            (place "Broadsword4" {"S4" "R5" "R7" "S8"}) (place "Broadsword5" {"S12" "R13" "R15" "S16"}) (place "Broadsword6" {"P19" "O18" "M18" "L19"})
            (place "Broadsword7" {"H19" "G18" "E18" "D19"})
            (place "Knight1" {"A13" "B12" "B8" "A7"}) (place "Knight2" {"C1" "D2" "H2" "I1"}) (place "Knight3" {"K1" "L2" "P2" "Q1"})
            (place "Knight4" {"S3" "R4" "R8" "S9"}) (place "Knight5" {"S11" "R12" "R16" "S17"}) (place "Knight6" {"P18" "Q19" "L18" "K19"})
            (place "Knight7" {"H18" "I19" "D18" "C19"})
            (place "CrossBow1" coord:"C10") (place "CrossBow2" coord:"F3") (place "CrossBow3" coord:"N3")
            (place "CrossBow4" coord:"Q6") (place "CrossBow5" coord:"Q14") (place "CrossBow6" coord:"N17")
            (place "CrossBow7" coord:"F17")
            (place "Knife1" {"C9" "C11"}) (place "Knife2" {"E3" "G3"}) (place "Knife3" {"M3" "O3"})
            (place "Knife4" {"Q5" "Q7"}) (place "Knife5" {"Q13" "Q15"}) (place "Knife6" {"O17" "M17"})
            (place "Knife7" {"G17" "E17"})
            (place "Archer1" coord:"D10") (place "Archer2" coord:"F4") (place "Archer3" coord:"N4")
            (place "Archer4" coord:"P6") (place "Archer5" coord:"P14") (place "Archer6" coord:"N16")
            (place "Archer7" coord:"F16")
            (place "Diplomat1" coord:"E10") (place "Diplomat2" coord:"F5") (place "Diplomat3" coord:"N5")
            (place "Diplomat4" coord:"O6") (place "Diplomat5" coord:"O14") (place "Diplomat6" coord:"N15")
            (place "Diplomat7" coord:"F15")
        })
        (play 
            (forEach Piece
                (then 
                    (and {
                        ("RemovePiecesIfPlayerHasLost" P1)
                        ("RemovePiecesIfPlayerHasLost" P2)
                        ("RemovePiecesIfPlayerHasLost" P3)
                        ("RemovePiecesIfPlayerHasLost" P4)
                        ("RemovePiecesIfPlayerHasLost" P5)
                        ("RemovePiecesIfPlayerHasLost" P6)
                        ("RemovePiecesIfPlayerHasLost" P7)
                    })
                )
            )
        )
        (end { 
            ("PlayerLoseIfNoPiece" P1)
            ("PlayerLoseIfNoPiece" P2)
            ("PlayerLoseIfNoPiece" P3)
            ("PlayerLoseIfNoPiece" P4)
            ("PlayerLoseIfNoPiece" P5)
            ("PlayerLoseIfNoPiece" P6)
            ("PlayerLoseIfNoPiece" P7)
            (if (or (= ("PiecesCaptured") 30) (= 2 ("GeneralCaptured")))
                (byScore)
            )
        })
    )
)

Construct a Ludii game based on the following description
Five Men's Morris is attested in the seventeenth century, but it is possible that it was played earlier than this. It is played on a Six Men's Morris board, but each player has five pieces. Otherwise, the rules are the same as for Six Men's Morris.Same rules as Murray, except players cannot remove an opponent's piece that is in a three in a row formation unless there are no other options. Any Enemy piece can be captured.
(game "Five Men's Morris"
    (players 2) 
    
    (equipment { 
        (board (concentric Square rings:2) use:Vertex)
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ 
                (then ("ReplayIfLine3" Orthogonal exact:True))
            )
        ) 
    })
    
    (rules 
        (start (place "Marker" "Hand" count:5))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    <Remove:rule>
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True))
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    <Remove:rule>
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("HavingLessPiecesLoss" Next 2))
    )
)

Construct a Ludii game based on the following description
Sig is a name used for several games throughout North Africa. This version was played in Western Sahara, and is related to similar games, such as Tab, which are popular in North Africa and Southwest Asia.4x20-25 board. Player on two teams of two players. Each team has a number of pieces which are equal to the number of holes in one of the rows. Pieces baring in the outer rows of the board. Eight sticks used as dice, painted red on one side. The throws are as follows: All sides of one color = 8; seven of one color = 1; six of one color = 6; five of one color = 5; four of one color= 4. Throws of 4 and 1 allow the player another throw. Pieces are moved after the throws are made. Each throw must be used to move a piece; the value of a throw cannot be subdivided between pieces. Pieces move from left to right in the team's home row, the right to left in the second row, left to right in the third row, and then right to left in the opposing team's home row. Pieces may not move past other pieces belonging to the team, but may move past the opponent's pieces. Then a piece lands in a spot occupied by a piece belonging to the opposing team, the opposing team's piece is captured. Once a player places their pieces in the opponent's home row, they cannot be taken. The team continue until all of the pieces are in the opponents' home rows, and the team with the most remaining pieces wins. Each row has 20 holes.
(game "Sig (Western Sahara)"
    (players 4)
    (equipment {
        (board (rectangle 4 <Board:size>) 
            {
            (track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True)
            (track "Track2" <Board:trackTeam2> P2 directed:True)
            (track "Track3" "0,E,N1,W,N1,E,N1,W" P3 directed:True)
            (track "Track4" <Board:trackTeam2> P4 directed:True)
            }
            use:Vertex
        )
        (piece "Stick" Each)
        (regions "AllSites" (sites Board))
        ("StickDice" 8)
        (map "Throw" {(pair 0 8) (pair 1 1) (pair 2 6) (pair 3 5) (pair 4 4) (pair 5 5) (pair 6 6) (pair 7 1) (pair 8 8)})
        (regions "Home" P1 (sites Bottom))
        (regions "Home" P2 (sites Top))
        (regions "Home" P3 (sites Bottom))
        (regions "Home" P4 (sites Top))
    })
    (rules 
        (start { 
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
            (place "Stick1" (sites Bottom))
            (place "Stick2" (sites Top))
        })
        (play 
            ("RollMove"
                (if (or (is Mover P1) (is Mover P3))
                    (forEach Site (sites Occupied by:Team1) ("Move" Team1))
                    (forEach Site (sites Occupied by:Team2) ("Move" Team2))
                )
                (then 
                    (if ("SpecialThrows")
                        (moveAgain)
                    )
                )
            )
        )
        (end (if ("AllPiecesInOpponentHome") {
                (if (= ("PiecesOwnedBy" Team1) ("PiecesOwnedBy" Team2)) (result Mover Draw))
                (if (< ("PiecesOwnedBy" Team1) ("PiecesOwnedBy" Team2)) (result Team2 Win))
                (if (> ("PiecesOwnedBy" Team1) ("PiecesOwnedBy" Team2)) (result Team1 Win))
            })
        )
    )
)

Construct a Ludii game based on the following description
Loop Chess is a Chess variant that borrows incorporates the reintroduction of captured pieces into Chess.The rules are the same as for Chess, except instead of moving a piece, a player's turn may be taken by replacing a captured piece on the board on any empty space. This piece is controlled by the player who replaced it. Captured pawns cannot be placed in the first or last row. 
(game "Loop Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8))
        (piece "Pawn" Each 
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
                )
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                "EnPassant"
                }
                (then
                    (and
                        (if (is In (last To) (sites Mover "Promotion")) 
                            (moveAgain)
                        )
                        (set Counter)
                    )
                )
            )
        )
        
        (piece "Rook" Each 
            (move Slide
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "King" Each 
            (move Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndResetCounter"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "Bishop" Each 
            (move Slide 
                Diagonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "Knight" Each 
            (move Leap 
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "Queen" Each 
            (move Slide 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            ) 
        )
        
        (map "where" {(pair 2 64) (pair 1 70) (pair 4 65) (pair 3 71) (pair 6 66) (pair 5 72) (pair 8 67) (pair 7 73) (pair 10 68) (pair 9 74) (pair 12 69) (pair 11 75)})
        (map "captured" {(pair 1 2) (pair 2 1) (pair 3 4) (pair 4 3) (pair 5 6) (pair 6 5) (pair 7 8) (pair 8 7) (pair 9 10) (pair 10 9) (pair 11 12) (pair 12 11)})
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "LastRanks" (union (sites Top) (sites Bottom)))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
        
        (hand Each size:6)
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or {
                        (move (from (sites Occupied by:Mover container:"Hand" components:{"Rook" "Bishop" "Knight" "Queen"})) (to (sites Empty)))
                        (move (from (sites Occupied by:Mover container:"Hand" component:"Pawn")) (to (difference (sites Empty) (sites "LastRanks"))))
                        (forEach Piece)
                        (if (and {
                                "KingInTheInitialPlace" 
                                ("HasNeverMoved" "King")
                                (not ("IsInCheck" "King" Mover)) 
                            })
                            (or
                                (if (and 
                                        ("HasNeverMoved" "RookLeft")
                                        (can Move ("DoCastle" "RookLeft" E 3 (is Empty (to))))
                                    )
                                    "BigCastling"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookRight")
                                        (can Move ("DoCastle" "RookRight" W 2 (is Empty (to))))
                                    )
                                    "SmallCastling"
                                )
                            )
                        )
                    })
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            (if (and 
                    ("IsInCheck" "King" Next)
                    ("NextCanNotMove")
                ) 
                (result Mover Win)
            ) 
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Social Distance Chess was inspired by the COVID-19 pandemic, during which many of the games in Ludii were implemented. It models social distancing principles in a Chess-like game.TODO  
(game "Social Distance Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (rectangle 8 15)) 
        
        (piece "Pawn" Each 
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
                )
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                "EnPassant"
                }
                (then
                    (and
                        (if (is In (last To) (sites Mover "Promotion")) 
                            (moveAgain)
                        )
                        (set Counter)
                    )
                )
            )
        )
        
        (piece "Rook" Each 
            (move
                Slide 
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "King" Each 
            (move
                Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndResetCounter"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "Bishop" Each 
            (move
                Slide 
                Diagonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "Knight" Each 
            (move
                Leap 
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "Queen" Each 
            (move
                Slide 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            ) 
        )
        
        (map "King" {(pair 1 "I1") (pair 2 "I8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "O1") (pair 2 "O8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
        }
    ) 
    (rules 
        (start
            { 
            (place "Pawn1" {"A3" "C3" "E3" "G3" "I3" "K3" "M3" "O3"})
            (place "Pawn2" {"A6" "C6" "E6" "G6" "I6" "K6" "M6" "O6"})
            (place "Rook1" {"A1" "O1"} state:1) 
            (place "Knight1" {"C1" "M1"}) 
            (place "Bishop1" {"E1" "K1"}) 
            (place "Queen1" {"G1"}) 
            (place "King1" {"I1"} state:1) 
            (place "Rook2" {"A8" "O8"} state:1) 
            (place "Knight2" {"C8" "M8"}) 
            (place "Bishop2" {"E8" "K8"}) 
            (place "Queen2" {"G8"}) 
            (place "King2" {"I8"} state:1) 
            }
        )
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        (if (and {
                                "KingInTheInitialPlace" 
                                ("HasNeverMoved" "King")
                                (not ("IsInCheck" "King" Mover)) 
                            })
                            (or
                                (if (and 
                                        ("HasNeverMoved" "RookLeft")
                                        (can Move ("DoCastle" "RookLeft" E 3 (is Empty (to))))
                                    )
                                    "BigCastling"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookRight")
                                        (can Move ("DoCastle" "RookRight" W 2 (is Empty (to))))
                                    )
                                    "SmallCastling"
                                )
                            )
                        )
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end
            {
            (if (and 
                    ("IsInCheck" "King" Next)
                    ("NextCanNotMove")
                ) 
                (result Mover Win)
            ) 
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
            }
        )
    )
)

Construct a Ludii game based on the following description
Los Doze Canes is a race game related to other European Tables games. It was played by children. It is described in the Libro de los Juegos of Alfonso X.2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Twelve pieces per player. Two dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Each player enters their pieces into their home section of the board (to the left of one player, to the right of the other player, and move pieces along a horseshoe-shaped track around the board toward the other player's home space. At the beginning of play, the first player will choose one quadrant of the board, and the goal of the game will be for one player to move two  pieces onto each of the six places in that quadrant. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board, and must be reentered. The quadrant selected is the bottom left one.
(game "Los Doze Canes"
    (players 2)
    (equipment {
        ("TableBoard" "TableTracksOppositeWithHands")
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("NoEnemyOrOnlyOne" ("SiteToMoveOnTrack"))
                    (move 
                        (from) 
                        (to 
                            "SiteToMoveOnTrack" 
                            ("HittingCapture" (handSite Next))
                        )
                    )
                )
            )
        )
        (hand Each)
    })
    (rules 
        (start {
            (place Stack "Disc1" (handSite P1) count:12)
            (place Stack "Disc2" (handSite P2) count:12)
        })
        (play
            ("RollEachNewTurnMove"
                (or 
                    (forEach Piece top:True) 
                    (forEach Piece container:(mover) top:True)
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )
        (end {
            (if (and {
                    (= 2 (size Stack at:<End:site1>))
                    (= 2 (size Stack at:<End:site2>))
                    (= 2 (size Stack at:<End:site3>))
                    (= 2 (size Stack at:<End:site4>))
                    (= 2 (size Stack at:<End:site5>))
                    (= 2 (size Stack at:<End:site6>))
                    (= 0 (count Sites in:(difference (sites Occupied by:Mover) (sites <End:sites>))))
                })
                (result Mover Win)
            )
            (if (and 
                    (< 2 (size Stack at:12))
                    (< 2 (size Stack at:0))
                )
                (result Mover Draw)
            )
        })
    )
)

Construct a Ludii game based on the following description
Fetach is a capturing game played in Morocco. It was described by Moroccan immigrants in France, who described games played during their childhood in Southern Morocco.5x5 intersecting lines with diagonals drawn in each quadrant. Twelve pieces per player, which begin on the rows closest to the player and the two spots to the right of the central point, leaving the central point open. Players alternate turns moving the pieces along the lines of the board. The first play is from one of the pieces directly above or below the central point. Pieces cannot move backwards. A player may capture an opponent's piece by hopping over it to an empty spot immediately adjacent to the opponent's piece on the opposite side, along the lines of the board. Pieces which reach the opposite edge of the board from where they started are promoted and can move and capture any distance along the two large diagonals of the board. The player who captures all of the opponent's pieces wins. 
(game "Fetach"
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Counter" Each
            (or {
                ("StepToEmpty" 
                    (if (!= 0 (count Moves))
                        (difference Adjacent Backwards)
                        Forwards
                    )
                    (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                )
                ("HopCapture" ~
                    (difference Adjacent Backwards)
                    (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                    
                )
            })
        )
        (piece "DoubleCounter" Each
            (or {
                ("StepToEmpty" Adjacent) 
                ("HopCapture" ~ Adjacent)
                ("HopLargeDiagonals")
            })
        )
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    
    (rules 
        (start { 
            (place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"}) }))
            (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top)) }))
        })
        (play (forEach Piece))
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Pentalath was invented by Cameron Browne in 2009. It is a connection game with the goal of creating a group of five in a row, but with complications.The board starts empty. White plays first. Players take turns placing a piece of their colour on an empty cell. Passing is not allowed. After each move, the opponent's pieces with no freedom are captured and removed from the board. A piece has freedom if the group it belongs to touches an empty cell. It is not allowed to place a piece in a space without freedom, unless that move captures the other player's pieces to create freedom. The game ends when one of the players wins a game by making a line of five (or more) stones of their colour. The game is played on the half of a HexHex board of size 7.
(game "Pentalath" 
    (players 2) 
    (equipment { 
        (board 
            <Board:type>
        )
        (piece "Marker" Each)
    }) 
    
    (rules 
        (play 
            (do
                (move Add 
                    (to (sites Empty))
                    (then ("EncloseCapture"))
                )
                ifAfterwards:("HasFreedom" Orthogonal)
            )
        )
        (end (if (is Line 5) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Described by H.J.R. Murray in A History of Board-Games Other Than Chess in 1898Played on a 8x8 board. Each player has two stones, who can jump over any other stone. Enemy stones jumped over are captured. First player unable to move loses. 
(game "Leap Frog"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Marker" Each
            (move Hop
                (between
                    if:(is Occupied (between))
                    (apply (if ("IsEnemyAt" (between)) (remove (between))))
                )
                (to if:(is Empty (to)))
            )
        )
    })
    (rules
        (start {
            (place "Marker1" {"B4" "C5" "C6" "D2" "D4" "D6" "E3" "E5" "E7" "F3" "F4" "G5"})
            (place "Marker2" {"B5" "C3" "C4" "D3" "D5" "D7" "E2" "E4" "E6" "F5" "F6" "G4"})
        })
        (play (forEach Piece))
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Cross was invented by Cameron Browne in 2008. It is a connection game on a Hex board.A player wins by connecting three non-adjacent board sides with a chain of their pieces. A player loses by connecting two opposite board sides with a chain of their pieces (without also connecting three non-adjacent sides). The game is played on a 5x5 board
(game "Cross" 
    (players 2) 
    (equipment { 
        (board (hex <Board>)) 
        (piece "Marker" Each)
    }) 
    (rules 
        (play (move Add (to (sites Empty))))
        (end {
            (if (is Connected {(sites Side S) (sites Side NW) (sites Side NE)}) (result Mover Win)) 
            (if (is Connected {(sites Side N) (sites Side SW) (sites Side SE)}) (result Mover Win))
            (if (is Connected {(sites Side N) (sites Side S) }) (result Mover Loss))
            (if (is Connected {(sites Side NW) (sites Side SE) }) (result Mover Loss))
            (if (is Connected {(sites Side NE) (sites Side SW) }) (result Mover Loss))
        })
    )
)

Construct a Ludii game based on the following description
This game was observed played by Yoruba people, who called it Akidada, and in Ghana, during the early twentieth century. The board was traced into the sand, and the players used pieces which took the form of sticks made from palm leaves, one player using green sticks and the other using brown.Each player has six pieces. They take turns placing the pieces on the intersections of a , attempting to make three in a row. If they are unsuccessful after all of the pieces are placed, they then take turns moving their piece one spot along one of the lines until someone makes three in a row (Murray 1951: 43). The game is played according to the rules of Murray.
(game "Achi"
    (players 2) 
    <Variant>
)

Construct a Ludii game based on the following description
Verquere is a European Tables game known since at least the eighteenth century. It was said to have been invented in Holland, but was also played in England.2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A throw of doubles forces the player to play the throw twice. Each player's pieces begin in three stacks of five, on the leftmost point (with respect to the opponent) on the opponent's side of the board. Play proceeds (with respect to the player) from right to left on the opponent's side of the board, and then from left to right on the player's side of the board. A player cannot place two pieces on a single point on any of the first twelve points of the board, except for those pieces in the starting position. A player cannot move a piece onto a point containing two or more pieces belonging to the opponent. When a piece lands on a point occupied by a single piece belonging to the opponent, it is removed from the board and must be entered again, and can only do so using the value of one die, not both, with the starting point considered to be point 1, the next point 2, etc. Opponent's pieces can be removed from the board in this way when reentering the board. If a player cannot reenter pieces on the board they lose their turn. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. 
(game "Verquere"
    (players 2)
    (equipment {
        ("BackgammonBoard" ("BackgammonTracksSameDirectionOppositeCornersWithBars2" End)) 
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die
                replayDouble:True 
                if:("DieNotUsed")
                (if ("IsEndTrack" ("NextSiteFrom" (from) (pips)))
                    (if ("AllPiecesInFinalQuadrant")
                        (move Remove (from))
                    )
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:(and 
                                ("NoEnemyOrOnlyOne" (to))
                                (if (not (is In (to) (sites Mover "StartingSide")))
                                    True
                                    (is Empty (to))
                                )
                            )
                            ("HittingCapture" (mapEntry "Bar" Next))
                        )
                    )
                )
                (then ("ReplayNotAllDiceUsed"))
            )		
        )
        (regions "FinalQuadrant" P1 (sites {7..12}))
        (regions "FinalQuadrant" P2 (sites {13..18}))
        (regions "StartingSide" P1 (sites {25..20 18..13}))
        (regions "StartingSide" P2 (sites {0..5 7..12}))
        (map "Bar" {(pair P1 6) (pair P2 19)})
    })
    (rules 
        (start { 
            (place Stack "Disc1" 25 count:15)
            (place Stack "Disc2" 0 count:15) 
        })
        (play 
            ("RollEachNewTurnMove"
                (forEach Piece top:True)
            )		
        )
        
        (end ("EscapeWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "Fallas"
    (players 2)
    (equipment {
        ("TableBoard" "TableTracksOpposite")
        (dice d:6 num:3)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" ("NextSiteFrom" (from) (pips)))
                    (move Remove (from))
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NoEnemyOrOnlyOne" (to))
                            (apply 
                                (if ("IsEnemyAt" (to))
                                    (if ("NoGoBack" Next)
                                        (and
                                            (remove (to))
                                            (trigger "StartQuadrantFull" Next)
                                        )
                                        (fromTo 
                                            (from (to))
                                            (to ("GoBack" Next))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (then "ReplayNotAllDiceUsed")
            )		
        )
        (regions "StartQuadrant" P1 (sites {6..11}))
        (regions "StartQuadrant" P2 (sites {18..23}))
    })
    (rules 
        (start {
            (place Stack "Disc1" 7 count:13)
            (place Stack "Disc1" 11 count:2)
            (place Stack "Disc2" 19 count:13)
            (place Stack "Disc2" 23 count:2)
        })
        (play ("RollEachNewTurnMove" (forEach Piece)))
        (end {
            ("EscapeWin")
            (if (is Triggered "StartQuadrantFull" P1) (result P2 Win))
            (if (is Triggered "StartQuadrantFull" P2) (result P1 Win))
            (if (and ("NewTurn") (no Moves Mover)) (result Mover Loss))
        })
    )
)
Fallas is a race game from Spain that is related to other European Tables games. It is documented in Alfonso X's Libro de los Juegos.2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Play begins with thirteen pieces on the seventh point of the track, and two pieces on the twelfth point. Three six-sided dice. Players move pieces according to the value of each individual die. Play moves around the board through starting from the quadrant where the pieces begin, through the one where the opponent's pieces begin, and then through the remaining quadrant on the opponent's side of the board, where the pieces are borne off the board. When a piece lands on a spot occupied by a single piece of the opponent, the opponent's piece is sent back to its starting quadrant. If a player's piece is sent back to start, but all of the spaces in their starting quadrant are occupied by the opponent's pieces, the player loses automatically. Also, any roll that allows the player to only move to spaces occupied by the opponent results in an automatic loss for the player. Otherwise, the first player to bear off all their pieces wins. 

Construct a Ludii game based on the following description
Blocking game played on a 6x8 or 7x7 board.Each player has a pawn, that can move to any neighboring cell. After moving, the player places a block on the board to try to block the opponent's pawn. First player who cannot move loses. The game is played on a 6x8 board.
(game "Isolation"
    (players 2)
    (equipment {
        (board (rectangle <Board:size>))
        (piece "Pawn" Each (move Step (to if:(is Empty (to))) (then (moveAgain))))
        (piece "Square" Neutral)
    })
    (rules
        (start {
            <Board:placement>
        })
        (play 
            (if (is Even (count Moves))
                (forEach Piece)
                (move Add (piece "Square0") (to (sites Empty)))
            )
        )
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
N puzzles are played with tiles within a grid, with one empty space. For instance, in a 4x4 grid there are 15 tiles.The tiles are each given a number from 1 to n-1. By sliding the tiles into the open space, the object is to placed the tiles in order based on their numbering. 
(game "N Puzzles" 
    (players 1) 
    (equipment { 
        (board (square <Version:boardSize>)) 
        <Version:pieces>
    }) 
    
    (rules
        (start (place Random {<Version:random>}))
        
        (play (forEach Piece))
        
        (end 
            (if 
                (is Target {<Version:order>}) (result P1 Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Andot is a two-row mancala-style board game played by the Bega people of Sudan. The game is typically played using pieces of dried camel dung as counters in hole scooped out of the sand.2x6 board. Four counters per hole. Players sow in a clockwise direction from their left three holes or anti-clockwise from their right three holes. When the final counter of a sowing falls into a hole in the opponent's row or in the leftmost or rightmost hole of the player's own row, which contains three counters, making it now contain four, this hole is marked and counters cannot be sown from this hole. Sowing cannot occur from a hole with a single counter into a hole containing three in the opponent's row, but is allowed when the hole containing three is in the player's own row. A player cannot sow  a lone counter that was sown into their row by the opponent on the previous turn back into the hole from which it was just moved. If a player is unable to sow from their row, the opponent may continue to play until the player is able to move. Play continues until all of the counters are in marked holes. The player with the most counters in their marked holes wins. 
(game "Andot" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (regions "Home" P1 (sites Bottom)) 
        (regions "Home" P2 (sites Top)) 
        (regions "LeftThree" P1 (expand (intersection (sites Bottom) (sites Left)) steps:2 E)) 
        (regions "LeftThree" P2 (expand (intersection (sites Top) (sites Right)) steps:2 W)) 
        (regions "RightThree" P1 (expand (intersection (sites Bottom) (sites Right)) steps:2 W))
        (regions "RightThree" P2 (expand (intersection (sites Top) (sites Left)) steps:2 E))
        (regions "ExtremeHoles" P1 
            (intersection (union (sites Left) (sites Right)) (sites Bottom))
        )
        (regions "ExtremeHoles" P2 
            (intersection (union (sites Left) (sites Right)) (sites Top))
        )
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Board)))
        
        (play 
            (or
                (move Select 
                    (from 
                        (sites Mover "LeftThree") 
                        if:(and
                            (or 
                                (and 
                                    (= (count at:(from)) 1) 
                                    (and
                                        (!= (from) ("NextHoleFrom" (last From) "TrackCCW"))
                                        (if (is In ("NextHoleFrom" (from) "TrackCW") (sites Next "Home"))
                                            (!= (count at:("NextHoleFrom" (from) "TrackCW")) 3)
                                            True
                                        ) 
                                    )
                                ) 
                                (> (count at:(from)) 1)
                            )
                            (= 0 (state at:(from)))
                        )
                    )
                    (then 
                        (sow
                            "TrackCW"
                            apply:(if (and 
                                    (= (count at:(to)) 4) 
                                    (is In (to) (union (sites Mover "ExtremeHoles") (sites Next "Home")))
                                )
                                (set State at:(to) (mover))
                            )
                        )
                    )
                )
                (move Select 
                    (from 
                        (sites Mover "RightThree") 
                        if:(and
                            (or 
                                (and 
                                    (= (count at:(from)) 1) 
                                    (and
                                        (!= (from) ("NextHoleFrom" (last From) "TrackCW"))
                                        (if (is In ("NextHoleFrom" (from) "TrackCCW") (sites Next "Home"))
                                            (!= (count at:("NextHoleFrom" (from) "TrackCCW")) 3)
                                            True
                                        ) 
                                    )
                                ) 
                                (> (count at:(from)) 1)
                            )
                            (= 0 (state at:(from)))
                        )
                    )
                    (then 
                        (sow
                            "TrackCCW"
                            apply:(if (and 
                                    (= (count at:(to)) 4) 
                                    (is In (to) (union (sites Mover "ExtremeHoles") (sites Next "Home")))
                                )
                                (set State at:(to) (mover))
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" ("AllCountersInMarkedHoles")))
    )
)

Construct a Ludii game based on the following description
This variant of Chess was invented in 1951 by Joseph Boyer, one of the most productive inventors of chess variants.The game is played on a board of 9 by 9 squares, checkered, with black squares in the corners.Each player has a king, a queen, two rooks, two knights, and two bishops, i.e., the usual set of pieces without pawns. There is an additional piece, not owned by any player: the ball.The ball starts the game on e5. The squares e1 and e9 are the goals.A move of a player consists of two parts: he first makes a normal move with one of his pieces (this is not obligatory), but no piece may move to a goal, i.e., to e1 or e9. (Pieces like rooks and queens however may move across it, e.g. from d1 to f1.) However, no captures are made, and check is disregarded. Then, after this move, the player may, if he can, have a piece kick the ball.
            
            A piece can kick the ball if the ball is adjacent to it (i.e., a kings move away.) The ball moves in the same way as the piece that kicks the ball, and the ball must be moved directly away from the piece. Also, the ball cannot be moved to or over occupied squares (except when a knight kicks the ball). For instance, a rook on a3 can kick a ball on a4 to squares a5, a6, a7, a8, a9, as long as the ball isn't moved to an occupied square; but a rook on a3 cannot kick a ball on b4.
            
            A knight can kick the ball to any square, a knight-move away from the square where the ball was before the kick, but not to a square, adjacent to the knight.
            
            When the ball is kicked to a square adjacent to another piece of the same player, the player may make another kick. This is called a `pass'. If after a second kick, a third kick is possible, the player may also make this third kick, and similar for successive kicks. Making an infinite number of passes, in order to draw the game, however is not allowed. Note that when kicking, only the ball moves but all normal pieces remain on the same places.
            
        The object of the game is to kick to ball to the goal at the opponents side of the board. However, it is not allowed to kick the ball into or across the goal from a square on the 1st or 9th row. 
(game "Football Chess" 
    (players 2) 
    (equipment { 
        (board (square 9)) 
        
        (piece "Rook" Each (move Slide Orthogonal (to (apply if:(not (is In (to) (sites "Goals")))))))
        (piece "King" Each (move Step (to if:(and (is Empty (to)) (not (is In (to) (sites "Goals")))))))
        (piece "Bishop" Each (move Slide Diagonal (to (apply if:(not (is In (to) (sites "Goals")))))))
        (piece "Knight" Each (move Leap "KnightWalk" (to if:(and (is Empty (to)) (not (is In (to) (sites "Goals")))))))
        (piece "Queen" Each (move Slide (to (apply if:(not (is In (to) (sites "Goals")))))))
        (piece "Ball" Shared)
        (regions "Goals" (sites {"E1" "E9"}))
        (map "Goal" {(pair P1 "E9") (pair P2 "E1")})
    }) 
    (rules 
        (meta (no Repeat PositionalInTurn))
        (start { 
            (place "Rook1" {"A1" "I1"}) (place "Knight1" {"B1" "H1"}) (place "Bishop1" {"C1" "G1"}) (place "Queen1" coord:"D1") (place "King1" coord:"F1") 
            (place "Rook2" {"A9" "I9"}) (place "Knight2" {"B9" "H9"}) (place "Bishop2" {"C9" "G9"}) (place "Queen2" coord:"D9") (place "King2" coord:"F9") 
            (place "Ball" {"E5"})
        })
        
        (play 
            (if ("SameTurn")
                (or
                    (if ("KickBallAgainWithoutMoving")
                        (forEach Site (sites Around (where "Ball" Shared)) ("KickTheBall" (site))
                            (then (if (can Move (forEach Site (sites Around (where "Ball" Shared)) ("KickTheBall" (site)))) ("CanKickAgainWithoutMoving")))		
                        )
                        ("KickTheBall" (last To) 
                            (then (if (can Move (forEach Site (sites Around (where "Ball" Shared)) ("KickTheBall" (site)))) ("CanKickAgainWithoutMoving")))
                        )
                    )
                    (move Pass)
                )
                (or 
                    (forEach Piece (then (if (can Move ("KickTheBall" (last To))) (moveAgain))))
                    (forEach Site 
                        (sites Around (where "Ball" Shared)) 
                        ("KickTheBall" (site))
                        (then (if (can Move (forEach Site (sites Around (where "Ball" Shared)) ("KickTheBall" (site)))) ("CanKickAgainWithoutMoving")))		
                    )
                )
            )
        )
        
        (end {
            (if (= (where "Ball" Shared) (mapEntry P1)) (result P1 Win))
            (if (= (where "Ball" Shared) (mapEntry P2)) (result P2 Win))
        })
    )
)

Construct a Ludii game based on the following description
Kay is a two-row mancala-style board game played in Haiti. It is very similar to games from the Caribbean and West Africa.2x6 board, one store on either end. Four counters in each hole. Sowing occurs in an anti-clockwise direction and begins in the player's row. When the final counter lands in an occupied hole which is not followed by an empty hole, the contents are picked up and sowing continues. If the final counter falls in an occupied hole followed by an empty hole, or if it falls into an empty hole, the turn ends. Sowing always skips the hole from which the sowing began if it goes all the way around the board. When the final counter falls into an occupied hole in the opponent's row containing three counters, these are captured and the turn ends. Any holes in the opponent's row containing four counters in an unbroken consecutive sequence behind this hole are also captured. Single counters can only be sowed when the next hole is empty. Play continues until one player can no longer play. The player who has captured the most counters wins. 
(game "Kay" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Bottom)) 
        (regions "Home" P2 (sites Top)) 
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (move Select
                (from 
                    (if ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover) 
                    ) 
                    if:(or 
                        (< 1 (count at:(from)))
                        (and 
                            (= 1 (count at:(from)))
                            (is Empty ("NextHoleFrom" (from) "Track" 1))
                        )
                    )
                )
                (then
                    (sow
                        if:True
                        apply:(if (= 4 (count at:(to)))
                            (fromTo
                                (from (to))
                                (to (mapEntry Mover))
                                count:(count at:(to))
                            )
                            (if (< 1 (count at:(to)))
                                (if (is Occupied ("NextHoleFrom" (to) "Track" 1))
                                    (moveAgain)
                                )
                            )
                        )
                        includeSelf:False
                        backtracking:(= 4 (count at:(to)))
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Next)))
    )
)

Construct a Ludii game based on the following description
King and Courtesan is a drawless two player army game where each player seeks to get their king into the enemy home square, or kill the enemy king. King and Courtesan was invented by Mark Steere in May 2022.GOAL
            Get your king into the enemy home square, or kill the enemy king.
            
            MOVES
            Players make one move per turn, starting with Red. There are three possible
            types of moves, explained below. Players will always have a move available,
            and must make one. Passing is not allowed.
            
            NON-CAPTURING MOVES
            Kings and courtesans can move to an adjacent, unoccupied square in any of
            the three forward directions.
            
            CAPTURING MOVES
            Kings and courtesans can move to an adjacent, enemy occupied square in any
            of eight directions, capturing the enemy king or courtesan by replacement.
            
            EXCHANGE MOVE
            You can transfer the top checker of your king onto an adjacent, friendly
            courtesan in any of the three forward directions, thus exchanging king and
            courtesan.
            
            In the Ludii implementation, the king is controlled like this: 
            To make an exchange move you must drag or click the top piece.
        To make a step/capture move, you must drag or click the bottom piece. A size 6 board is currently selected
(game "King And Courtesan"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board (rotate 45 (square <Size>)))
        (piece "Disc" Each
            (or {
                ("StepToEmpty" Forwards stack:True)
                (move Step
                    (to 
                        if:("IsEnemyAt" (to)) 
                        (apply 
                            (and
                                (if
                                    (= 2 (size Stack at:(to)))
                                    (set Var "NextLoss" 1)
                                )
                                (remove (to) count:(size Stack at:(to)))
                            )
                        )
                    )
                    stack:True
                )
                (move Step
                    (from if:(= 2 (size Stack at:(from))))
                    Forwards
                    (to 
                        if:(is Mover (who at:(to)))
                    )
                )
            })
        )
    })
    (rules
        (start {
            (place "Disc1" (expand (sites Bottom) steps:(- <Size> 2) Orthogonal))
            (place "Disc2" (expand (sites Top) steps:(- <Size> 2) Orthogonal))
            (place Stack "Disc1" (sites Bottom))
            (place Stack "Disc2" (sites Top))
        })
        
        (play (forEach Piece top:True))
        
        (end {
            (if 
                (= 1 (var "NextLoss")) 
                (result Next Loss)
            )
            (if 
                (or
                    (and
                        (= (id P1) (who at:(- (* <Size> <Size>) 1)))
                        (= 2 (size Stack at:(- (* <Size> <Size>) 1)))
                    )
                    (and
                        (= (id P2) (who at:0))
                        (= 2 (size Stack at:0))
                    )
                )
                (result Mover Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
A chess variant played on boards made of hexagons invented by Dave McCooey and Richard Honeycutt in 1978-1979.McCooey Chess is played on a hexagonal board with each side having length 6, and each space oriented horizontally. The board has has 91 spaces.
            
            Piece Movement:
            * All pieces other than Pawns move as in Glinski Chess.
            - Kings step one space in any of the 12 directions. They do not castle.
            - Queens slide in any of the 12 directions.
            - Rooks slide in any of the 6 adjacent direction.
            - Bishops slide in any of the 6 'diagonal' directions.
            - Knights move two spaces in any adjacent direction, then one space in another direction.
            * Pawns can advance one space forward without capturing. A Pawn on a Pawn start space but not in the innermost column can advance two spaces forward without capturing. Pawns capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). En Passant capture and Pawn promotion take place as in Glinski Chess.
            
        The game ends on a checkmate or stalemate. 
(game "McCooey Chess"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board (rotate 90 (hex 6)))
        
        (piece "King" Each ("KingCaptureStep" All ~))
        (piece "Queen" Each ("SlideCaptureMove" All ~))
        (piece "Rook" Each ("SlideCaptureMove" Orthogonal ~))
        (piece "Bishop" Each ("SlideCaptureMove" Diagonal ~))
        (piece "Knight" Each (move Leap
                "KnightWalk"
                (to if:"IsToEmptyOrEnemy"
                    "CaptureToPieceAndResetCounter"
                )
            )
        )
        
        (piece "Pawn" Each
            (or {
                "StepForwardToEmpty"
                (if (and
                        "IsFromInStartCell"
                        (not (is In (from) (sites Mover "CentrePawnStartCell")))
                    )
                    "PawnStep_Double"
                )
                "PawnCapture_Diag"
                "EnPassant_Diag"
                }
                (then
                    (and
                        (if (is In (last To) (sites Mover "PromotionZone"))
                            (moveAgain)
                        )
                        (set Counter)
                    )
                )
            )
        )
        
        (regions "CentrePawnStartCell" P1 (sites {"D4"}))
        (regions "CentrePawnStartCell" P2 (sites {"H8"}))
        
        (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE)))
        (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE)))
        
        (regions "Region-Dark" (sites Phase 0))
        (regions "Region-Light" (sites Phase 2))
        (regions "Region-Medium" (sites Phase 1))
    })
    
    (rules
        (start {
            (place "King1" coord:"B1")
            (place "Queen1" coord:"A2")
            (place "Rook1" {"A3" "C1"})
            (place "Bishop1" {"A1" "B2" "C3"})
            (place "Knight1" {"B3" "C2"})
            
            (place "King2" coord:"K10")
            (place "Queen2" coord:"J11")
            (place "Rook2" {"I11" "K9"})
            (place "Bishop2" {"K11" "J10" "I9"})
            (place "Knight2" {"I10" "J9"})
            
            (place "Pawn1" {"A4" "B4" "C4" "D4" "D3" "D2" "D1"})
            (place "Pawn2" {"H11" "H10" "H9" "H8" "I8" "J8" "K8"})
        })
        phases:{
        (phase "Movement"
            (play
                (if ("SameTurn")
                    ("PromoteTo" (piece {"Queen" "Rook" "Bishop" "Knight"}))
                    (do (forEach Piece)
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
            )
            (end {
                ("Checkmate" "King")
                (if (or
                        (no Moves Mover)
                        (= (counter) 100)
                    )
                    (result Mover Draw)
                )
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Shing Quon Tu is a Chinese promotion game played during the seventeenth century. In it, players navigate the Chinese bureaucracy by throwing dice and following the instructions on the spaces. The dice throws are determined by the number of dice with the same number, rather than the numerical values shown.98 spaces on the board. Six six-sided dice. One piece per player. Pieces are initially placed on the board based on the values of the throws of the dice. The throws are as follows:
            
            Space one: two 1s;
            Space 2: two 2s;
            Space 3: two 3s;
            Space 4: two  4s
            Space 5: two 5s;
            Space 6: two 6s;
            Space 7: five of any number;
            Space 8: six of any number;
            Space 9: three 1s;
            Space 10; three 2s;
            Space 11; three 3s;
            Space 12; three 4s;
            Space 13; three 5s;
            Space 14; three 6s;
            Space 16; four 1s;
            Space 17; four 2s;
            Space 18; four 3s;
            Space 19; four 4s;
            Space 20: four 5s;
            Space 21: four 6s.
            
            From here, the players move to prescribed spaces based on the throw they make, based on the instructions for the space they are currently on. There are three throws which result in a move: Te (\ The game is played with 2 players.
(game "Shing Quon Tu"
    (players <Players:num>)
    (equipment {
        (board 
            (union {
                (scale 2 2.2 (square 1))
                (shift 0 -0.5 (scale 1 0.5 (square 1)))
                (shift 1 -0.5 (scale 1 0.5 (square 1)))
                (shift 0 -1 (scale 0.5 0.5 (rectangle 1 2)))
                (shift 1 -1 (scale 0.5 0.5 (rectangle 1 2)))
                (shift 0 -2 (scale 1 0.5 (rectangle 2 1)))
                (shift 1 -2 (scale 1 0.5 (rectangle 2 1)))
                (shift 2 -2 (scale 1 0.5 (rectangle 6 1)))
                (shift 2 1 (scale 1 1.2 (square 1)))
                (shift 0 2.2 (scale 0.5 1 (rectangle 1 6)))
                (shift -2 -2 (scale 1 1.04 (rectangle 5 2)))
                (shift -2 -3 (rectangle 1 5))
                (shift 3 -3 (scale 1 1.55 (rectangle 4 1)))
                (shift -2 3.2 (scale 2 1 (rectangle 1 3)))
                (shift -2 4.2 (scale 3 1 (rectangle 1 2)))
                (shift -3.2 -2 (scale 1.2 (rectangle 6 1)))
                (shift 4 -2.6 (scale 1.3 (rectangle 6 1)))
                (shift 4 -3 (scale 1.3 0.4 (square 1)))
                (shift -2 -4.3 (scale 1 1.3 (square 1)))
                (shift -3.2 -4.3 (scale 1.2 0.383 (rectangle 6 1)))
                (shift -3.2 -5.5 (scale 1.2 (square 1)))
                (shift -1 -4.3 (scale 0.335 1.29 (rectangle 1 6)))
                (shift 1.01 -4.3 (scale 0.4 1.29 (rectangle 1 9)))
                (shift 4.61 -4.3 (scale 0.7 1.29 (square 1)))
                (shift -2 -5.5 (scale 0.501 1.2 (rectangle 1 6)))
                (shift 2 -5.5 (scale 0.4 1.2 (rectangle 1 6)))
                (shift 1.005 -5.5 (scale 1 1.2 (square 1)))
                (shift 4.4 -5.5 (scale 0.91 1.2 (square 1)))
            })
            (track "Track" 
                {98 96 95 94 93 92 91 97 90 89 88 87 86 85 68 62 63 64 65 66 67 48 49 50 51 52 53 46 47 59 58 57 56 55 54 60 84 83 82
                81 80 79 78 77 76 75 74 73 72 71 70 69 61 34 24 26 28 30 32 43 44 45 42 41 40 39 38 37 36 35 25 27 29 31 33 18 19 20
                21 22 23 17 16 15 14 13 12 11 9 7 10 8 6 5 4 3 2 1
                } 
            directed:True)
        )
        (dice d:6 num:6)
        (hand Each)
        (piece "Pawn" Each)
        (map "Site" {
            (pair 1 98) (pair 2 96) (pair 3 95) (pair 4 94) (pair 5 93) (pair 6 92)
            (pair 7 91) (pair 8 97) (pair 9 90) (pair 10 89) (pair 11 88) (pair 12 87)
            (pair 13 86) (pair 14 85) (pair 15 68) (pair 16 62) (pair 17 63) (pair 18 64)
            (pair 19 65) (pair 20 66) (pair 21 67) (pair 22 48) (pair 23 49) (pair 24 50)
            (pair 25 51) (pair 26 52) (pair 27 53) (pair 28 46) (pair 29 47) (pair 30 59)
            (pair 31 58) (pair 32 57) (pair 33 56) (pair 34 55) (pair 35 54) (pair 36 60)
            (pair 37 84) (pair 38 83) (pair 39 82) (pair 40 81) (pair 41 80) (pair 42 79)
            (pair 43 78) (pair 44 77) (pair 45 76) (pair 46 75) (pair 47 74) (pair 48 73)
            (pair 49 72) (pair 50 71) (pair 51 70) (pair 52 69) (pair 53 61) (pair 54 34)
            (pair 55 24) (pair 56 26) (pair 57 28) (pair 58 30) (pair 59 32) (pair 60 43)
            (pair 61 44) (pair 62 45) (pair 63 42) (pair 64 41) (pair 65 40) (pair 66 39)
            (pair 67 38) (pair 68 37) (pair 69 36) (pair 70 35) (pair 71 25) (pair 72 27)
            (pair 73 29) (pair 74 31) (pair 75 33) (pair 76 18) (pair 77 19) (pair 78 20)
            (pair 79 21) (pair 80 22) (pair 81 23) (pair 82 17) (pair 83 16) (pair 84 15)
            (pair 85 14) (pair 86 13) (pair 87 12) (pair 88 11) (pair 89 9) (pair 90 7)
            (pair 91 10) (pair 92 8) (pair 93 6) (pair 94 5) (pair 95 4) (pair 96 3)
            (pair 97 2) (pair 98 1) (pair 0 0)
        })
        
        (map "OppositeSite" {
            (pair 98 1) (pair 96 2) (pair 95 3) (pair 94 4) (pair 93 5) (pair 92 6)
            (pair 91 7) (pair 97 8) (pair 90 9) (pair 89 10) (pair 88 11) (pair 87 12)
            (pair 86 13) (pair 85 14) (pair 68 15) (pair 62 16) (pair 63 17) (pair 64 18)
            (pair 65 19) (pair 66 20) (pair 67 21) (pair 48 22) (pair 49 23) (pair 50 24)
            (pair 51 25) (pair 52 26) (pair 53 27) (pair 46 28) (pair 47 29) (pair 59 30)
            (pair 58 31) (pair 57 32) (pair 56 33) (pair 55 34) (pair 54 35) (pair 60 36)
            (pair 84 37) (pair 83 38) (pair 82 39) (pair 81 40) (pair 80 41) (pair 79 42)
            (pair 78 43) (pair 77 44) (pair 76 45) (pair 75 46) (pair 74 47) (pair 73 48)
            (pair 72 49) (pair 71 50) (pair 70 51) (pair 69 52) (pair 61 53) (pair 34 54)
            (pair 24 55) (pair 26 56) (pair 28 57) (pair 30 58) (pair 32 59) (pair 43 60)
            (pair 44 61) (pair 45 62) (pair 42 63) (pair 41 64) (pair 40 65) (pair 39 66)
            (pair 38 67) (pair 37 68) (pair 36 69) (pair 35 70) (pair 25 71) (pair 27 72)
            (pair 29 73) (pair 31 74) (pair 33 75) (pair 18 76) (pair 19 77) (pair 20 78)
            (pair 21 79) (pair 22 80) (pair 23 81) (pair 17 82) (pair 16 83) (pair 15 84)
            (pair 14 85) (pair 13 86) (pair 12 87) (pair 11 88) (pair 9 89) (pair 7 90)
            (pair 10 91) (pair 8 92) (pair 6 93) (pair 5 94) (pair 4 95) (pair 3 96)
            (pair 2 97) (pair 1 98) (pair 0 0)
        })
        
        (map "TeMove" {
            (pair 1 37) (pair 2 37) (pair 3 37) (pair 4 38) (pair 5 38) (pair 6 38)
            (pair 7 73) (pair 8 72) (pair 9 52) (pair 10 51) (pair 11 50) (pair 12 49)
            (pair 13 48) (pair 14 47) (pair 15 55) (pair 16 23) (pair 17 23) (pair 18 23)
            (pair 19 23) (pair 20 23) (pair 21 23) (pair 27 56) (pair 30 32) (pair 35 67) 
            (pair 36 66) (pair 46 89) (pair 47 59) (pair 48 74) (pair 49 71) (pair 50 47) 
            (pair 51 50) (pair 52 51) (pair 59 71) (pair 60 62) (pair 61 47) (pair 62 61) 
            (pair 63 65) (pair 64 69) (pair 65 64) (pair 66 60) (pair 67 70) (pair 68 86) 
            (pair 69 84) (pair 70 68) (pair 71 74) (pair 72 90) (pair 73 92) (pair 75 93) 
            (pair 81 31) (pair 82 91) (pair 83 82) (pair 84 83) (pair 85 84) (pair 86 85) 
            (pair 87 86) (pair 88 87) (pair 89 91) (pair 90 92) (pair 91 93) (pair 92 94)
            (pair 94 97) (pair 95 98) (pair 96 95) (pair 97 0) (pair 98 0)
        })
        
        (map "CungMove" {
            (pair 1 76) (pair 2 76) (pair 3 76) (pair 8 60) (pair 9 23) (pair 15 53) (pair 16 22)
            (pair 17 22) (pair 18 22) (pair 19 22) (pair 20 22) (pair 21 22) (pair 27 25) (pair 37 36)
            (pair 41 30) (pair 42 31) (pair 47 54) (pair 48 65) (pair 49 54) (pair 69 88)
        })
        
        (map "ChangMove" {
            (pair 30 29) (pair 31 29) (pair 32 29) (pair 33 29) (pair 34 29) (pair 35 29) 
            (pair 54 28) (pair 55 28) (pair 56 28) (pair 57 28) (pair 58 28) (pair 59 28) 
            (pair 68 29) 
        })
    })
    (rules 
        <Players:start>
        
        phases:{
        (phase "Opening"
            (play
                ("RollMove"
                    (or {
                        (if (= 2 "NumDiceOne") 
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 1))
                            )
                        )
                        (if (= 2 "NumDiceTwo") 
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 2))
                            )
                        )
                        (if (= 2 "NumDiceFour") 
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 3))
                            )
                        )
                        (if (= 2 "NumDiceThree") 
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 4))
                            )
                        )
                        (if (= 2 "NumDiceFive") 
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 5))
                            )
                        )
                        (if (= 2 "NumDiceSix") 
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 6))
                            )
                        )
                        (if (or {(= 5 "NumDiceOne") (= 5 "NumDiceTwo") (= 5 "NumDiceThree") (= 5 "NumDiceFour") (= 5 "NumDiceFive") (= 5 "NumDiceSix") })
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 7))
                            )
                        )
                        (if (or {(= 6 "NumDiceOne") (= 6 "NumDiceTwo") (= 6 "NumDiceThree") (= 6 "NumDiceFour") (= 6 "NumDiceFive") (= 6 "NumDiceSix") })
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 8))
                            )
                        )
                        (if (= 3 "NumDiceOne")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 9))
                            )
                        )
                        (if (= 3 "NumDiceTwo")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 10))
                            )
                        )
                        (if (= 3 "NumDiceThree")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 11))
                            )
                        )
                        (if (= 3 "NumDiceFour")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 12))
                            )
                        )
                        (if (= 3 "NumDiceFive")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 13))
                            )
                        )
                        (if (= 3 "NumDiceSix")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 14))
                            )
                        )
                        
                        (if (= 4 "NumDiceOne")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 16))
                            )
                        )
                        (if (= 4 "NumDiceTwo")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 17))
                            )
                        )
                        (if (= 4 "NumDiceThree")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 18))
                            )
                        )
                        (if (= 4 "NumDiceFour")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 19))
                            )
                        )
                        (if (= 4 "NumDiceFive")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 20))
                            )
                        )
                        (if (= 4 "NumDiceSix")
                            (move 
                                (from (handSite Mover))
                                (to (mapEntry "Site" 21))
                            )
                        )
                    })
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Playing")
        )
        
        (phase "Playing"
            (play
                (if ("SameTurn")
                    (if (can Move ("MovePiece"))
                        ("MovePiece")
                        (move Pass
                            (then
                                (and {
                                    (forget Value "Te" All)
                                    (forget Value "Cung" All)
                                    (forget Value "Chang" All)
                                })
                            )
                        )
                    )
                    ("RollMove"
                        (move Pass)
                        (then
                            (and {
                                (moveAgain)
                                (if (= 2 ("NumDiceFour"))
                                    (remember Value "Te" 1)	
                                    (if (= 4 ("NumDiceFour"))
                                        (and
                                            (remember Value "Te" 1)	
                                            (remember Value "Te" 1)	
                                        )
                                        (if (= 6 ("NumDiceFour"))
                                            (and {
                                                (remember Value "Te" 1)	
                                                (remember Value "Te" 1)	
                                                (remember Value "Te" 1)	
                                            })
                                        )
                                    )
                                )
                                (if (= 2 ("NumDiceOne"))
                                    (remember Value "Chang" 1)	
                                    (if (= 4 ("NumDiceOne"))
                                        (and
                                            (remember Value "Chang" 1)	
                                            (remember Value "Chang" 1)	
                                        )
                                        (if (= 6 ("NumDiceOne"))
                                            (and {
                                                (remember Value "Chang" 1)	
                                                (remember Value "Chang" 1)	
                                                (remember Value "Chang" 1)	
                                            })
                                        )
                                    )
                                )
                                (if (= 2 ("NumDiceTwo"))
                                    (remember Value "Cung" 1)	
                                    (if (= 4 ("NumDiceTwo"))
                                        (and
                                            (remember Value "Cung" 1)
                                            (remember Value "Cung" 1)
                                        )
                                        (if (= 6 ("NumDiceTwo"))
                                            (and {
                                                (remember Value "Cung" 1)	
                                                (remember Value "Cung" 1)	
                                                (remember Value "Cung" 1)	
                                            })
                                        )
                                    )
                                )
                                (if (= 2 ("NumDiceThree"))
                                    (remember Value "Cung" 1)	
                                    (if (= 4 ("NumDiceThree"))
                                        (and
                                            (remember Value "Cung" 1)
                                            (remember Value "Cung" 1)
                                        )
                                        (if (= 6 ("NumDiceThree"))
                                            (and {
                                                (remember Value "Cung" 1)	
                                                (remember Value "Cung" 1)	
                                                (remember Value "Cung" 1)	
                                            })
                                        )
                                    )
                                )
                                (if (= 2 ("NumDiceFive"))
                                    (remember Value "Cung" 1)	
                                    (if (= 4 ("NumDiceFive"))
                                        (and
                                            (remember Value "Cung" 1)
                                            (remember Value "Cung" 1)
                                        )
                                        (if (= 6 ("NumDiceFive"))
                                            (and {
                                                (remember Value "Cung" 1)	
                                                (remember Value "Cung" 1)	
                                                (remember Value "Cung" 1)	
                                            })
                                        )
                                    )
                                )
                                (if (= 2 ("NumDiceSix"))
                                    (remember Value "Cung" 1)	
                                    (if (= 4 ("NumDiceSix"))
                                        (and
                                            (remember Value "Cung" 1)
                                            (remember Value "Cung" 1)
                                        )
                                        (if (= 6 ("NumDiceSix"))
                                            (and {
                                                (remember Value "Cung" 1)	
                                                (remember Value "Cung" 1)	
                                                (remember Value "Cung" 1)	
                                            })
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
        )
        }
        
        (end (if (= ("Palace") (where "Pawn" Mover)) (result Mover Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Radran" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board <Board:type> use:Edge) 
        (piece "Marker" Neutral)  
    }) 
    
    (rules
        (start
            <Board:start>
        )
        (play
            (move Add (piece "Marker0")
                (to Edge (sites Empty Edge))
                (then
                    (addScore Mover (cost Edge at:(last To)))
                )	    
            ) 
        )
        (end
            (if (is RegularGraph Neutral)	
                (byScore)
            )
        )
    )
)
Radran is a graph theory game that uses a regular graph mechanism. A regular graph is a graph where each vertex has the same number of neighbours; i.e. every vertex has the same degree. Radran can be played on any undirected and edge-weighted graph. It can be played with two or more player.The graph is initially empty. Players alternate turns colouring an uncoloured edge between two of the vertices. Both players share a common colour for this gameplay. Radran is a score-based game. At each turn, a player gets a score, which is equal to the cost of his last coloured edge. The game ends when the coloured graph is regular. The player with the highest score wins.  The version of the game played with 2 players.

Construct a Ludii game based on the following description
Invented by Colin Vout in 1972 as described in the book Winning Ways for Your Mathematical Plays.Played on a nxn board. Each player has n-1 cars, that can move either forward or up and down. Cars can leave the board once they have reached the opposite edge. First player to run out of legal moves wins. The game is played on a 3x3 board.
(game "Dodgem"
    (players 2)
    (equipment {
        (board (square <Board>))
        (piece "Car" P1 E 
            (if (is In (from) (sites Right))
                (move Remove (from))
                ("StepMove")
            )
        )
        (piece "Car" P2 N 
            (if (is In (from) (sites Top))
                (move Remove (from))
                ("StepMove")
            )
        )
    })
    (rules
        (start {
            (place "Car1" (difference (sites Left) (sites {"A1"})))
            (place "Car2" (difference (sites Bottom) (sites {"A1"})))
        })
        (play (forEach Piece))
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
N Queens is a Chess puzzle. N queens are placed on an nxn board so that they cannot take one another.The goal is to place eight queens on a standard Chess board so that none of them can take another. The puzzle is played on a 4x4 board
(game "N Queens"
    (players 1) 
    (equipment { 
        (board (square <Size>) (values Cell (range 0 1)))
        (regions {AllDirections})
    })
    
    (rules
        (play
            (satisfy {
                (is Count (sites Board) of:1 <Size>)
                (all Different except:0)
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
This game is played in a 5x10 square board.MOVE - On each turn, a player may do one of the following actions:
            - Drop a friendly stone at an empty cell, which is in a diagonal line of sight with another friendly stone, i.e., both stones must be separated by a diagonal line of empty cells. 
            - Transform an enemy stone, at a diagonal line of sight of a friendly stone, into a wall (which is a neutral stone).
            
        GOAL - When there are no valid moves, wins the player with more friendly stones. 
(game "Diagonals (2002)"
    (players 2)
    (equipment {
        (board (rectangle 5 10) use:Vertex)
        (piece "Ball" Each)
        (piece "Ball" Neutral)
    })
    (rules
        (start {
            (place "Ball1" (intersection (expand (sites Bottom)) (sites Right)))
            (place "Ball2" (intersection (expand (sites Top)) (sites Left)))
        })
        (play 
            (or
                (move Add (to (intersection (sites Direction from:(sites Occupied by:Mover) Diagonal stop:(is Occupied (to))) (sites Empty))))
                (move Select
                    (from
                        (forEach (sites Occupied by:Next)
                            if:(!= 0 (count Sites in:(intersection (sites LineOfSight at:(site) Diagonal) (sites Occupied by:Mover))))
                        )
                    )
                    (then
                        (and
                            (remove (last To))
                            (add (piece (id "Ball" Neutral)) (to (last To)))
                        )
                    )
                )
            )
        )
        (end (if (and (no Moves P1) (no Moves P2))
                (byScore {
                    (score P1 (count Pieces P1))
                    (score P2 (count Pieces P2))
                })
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Chaturanga (al-Adli)"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (piece "King_noCross" ("StepToNotFriend"))
        ("ChessRook" "Rook")
        (piece "Elephant"
            (move Hop Orthogonal 
                (between (exact 1) if:True) 
                (to if:(not ("IsFriendAt" (to)))
                    (apply 
                        (if ("IsEnemyAt" (to))
                            (remove (to))
                        )
                    ) 
                )
            )
        )
        ("ChessKnight" "Knight")
        ("ChessPawn" "Pawn")
        (piece "Queen" ("StepToNotFriend" Diagonal))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Elephant1" {"A1" "H1"}) (place "Rook1" {"B1" "G1"}) (place "Knight1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Elephant2" {"A8" "H8"}) (place "Rook2" {"B8" "G8"}) (place "Knight2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8") 
        })
        
        (play 
            (do (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (= (count Pieces Next) 1) (result Mover Loss)) 
        })
    )
)
Chaturanga is a capturing game from India which is the ancestor of many similar replacement capture games worldwide. This version is reported from the Shatranj scholar al-Adli.8x8 board. 8 Bhata (or Padati; move like Chess pawns but without being able to move two on the first turn); 2 Ashva (horses; move like Chess knights); 2 Gaja (elephants; two spaces in any orthogonal direction, jumping over the first square); 2 Ratha (chariots; moves like a rook in chess); 1 Mantri (counselor; moves one square diagonally in any direction); 1 Raja (king; moves one square in any direction). These are set up along one edge of the board: Gaja-Ratha-Ashva-Mantri-Raja-Ashva-Ratha-Gaja, with the eight Bhata lined up in the row in front of these. Players take turns moving. When one piece lands on the space occupied by another piece, it is captured. When a Raja can be captured by an opponent's piece on the next turn, it is in check. The Raja must not be in check at the end of the player's turn. When this is unavoidable, it is checkmate and the opponent wins. A Raja that is stalemated wins. A player who reduces their opponent to only the Raja wins.
         

Construct a Ludii game based on the following description
Kawasukutz (\Forty stones, arranged in a circle, with larger gaps (doors) between the stones after every ten. The gaps between the stones are the playing spaces. Any number of players. One stick per player. Three sticks used as dice, one marked with two notches, one marked with three notches, the other marked with ten notches. The value of the throw is the number of notches which land face up. Players move their sticks around the board, beginning at one of the doors. Players may choose in which direction to proceed around the board. When a player lands on the same space as an opponent, the opponent's piece is sent back to the starting door. The first player to complete the circuit of the board wins. The game has 2 players.
(game "Kawasukuts"
    (players <Player:num>)
    (equipment {
        ("FortyStonesWithFourGapsBoard"
            {
            (track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True)
            (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)
            }
        )
        (regions "Gates" (sites {36..39}))
        (piece "Marker" Each
            (if ("IsOffBoard" (value Player Mover))
                (or 
                    ("MoveOn" ("SiteToMoveOnTrackCW") ("RememberSelectedTrack" ("SelectCW")))
                    ("MoveOn" ("SiteToMoveOnTrackCCW") ("RememberSelectedTrack" ("SelectCCW")))
                )
                ("MoveOn" "SiteToMoveOnSelectedTrack")
            )
        )
        (dice d:2 facesByDie:{{0 2} {0 3} {0 10}} num:3)
        (hand Each)
    })
    (rules 
        (start (place "Marker" "Hand"))
        phases:{
        (phase "Placement" 
            (play 
                (move
                    (from (handSite Mover))
                    (to (sites "Gates"))
                    (then (set Value at:(last To) (last To)))
                )
            )
            (nextPhase Mover "Playing")
        )
        (phase "Playing"
            (play ("RollMove" (forEach Piece)))	
            (end 
                (if 
                    (and (!= 0 ("ThrowValue")) ("MadeACompleteCircuit"))
                    (result Mover Win)
                )
            )
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Netted"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Ball" P1 maxState:3)
        (piece "Ball" P2 maxState:3)
        (piece "I" P1 maxState:6)
        (piece "I" P2 maxState:6)
    })
    (rules
        (play
            (if 
                (= 1 (mover))
                ("AddExcept" "SuicideP1")
                ("AddExcept" "SuicideP2")
                (then
                    (and { 
                        (if 
                            (= 1 (mover))
                            ("RemoveExcessOrthogonals" "SuicideP2")
                            ("RemoveExcessOrthogonals" "SuicideP1")
                        )
                        ("UpdateStateNext" 1)
                        ("UpdateStateNext" 2)
                        ("AddDiagonalMarkers")
                        ("RemoveExcessDiagonals")
                    })
                )
            )
        )
        (end 
            (if 
                (or {
                    (is Triggered "Enmeshed" Mover)
                    (is Triggered "Enmeshed" Next)
                    (no Moves Mover)
                })
                (if  
                    (is Triggered "Enmeshed" Next)
                    (result Mover Win)
                )
                (result Mover Loss)
            )
        )
    )
)
Netted is a race to surround the opponent  Nets include Hex diagonals and single empty spaces, and so can cross each other. It is placement only and so can be played as a paper and pencil game. However the computer version adds markers for the empty space connections which must be removed when the spaces are filled.                The distinctive features are  1) a novel type of liberty for live groups that involves the count of available edge sites, and 2) the novel definitions for surrounding that include diagonals that cut groups, and connections across single empty spaces that can be broken by the opponent's placement.        Moves are forced, suicide is prohibited, stalemate is a loss for the player who is stalemated.        Strategy notes: sites next to the board corners are strong ways to gain the corner territory - Board should be at least 5-6 to avoid winnable edge play. Hex N+1 / N-1 Grid Order 2 board

Construct a Ludii game based on the following description
Shatranj is a game derived from Chaturanga which probably began in Iran and spread throughout the Islamic world and into Europe. It is the game from which Chess directly evolved into its modern form, though Shatranj was known as \8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): One square diagonally. 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Pil. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the eighth rank. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins. 
(game "Shatranj" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        ("ChessPawn" "Pawn" ~ (then ("ReplayInMovingOn" (sites Mover "Promotion"))))
        ("ChessRook" "Rook")
        ("ChessKing" "King_noCross")
        (piece "Bishop_noCross" Each 
            (move Hop 
                Diagonal 
                (between if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        ("IsEnemyAt" (to))
                    ) 
                    (apply (remove (to)))
                )
            )
        )
        ("ChessKnight" "Knight")
        (piece "Ferz_noCross" Each ("StepToNotFriend" Diagonal)) 
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece "Ferz_noCross") Mover)
                (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (= (count Pieces Next) 1) (result Mover Win)) 
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
This two-row mancala-style board is played by the Darod people in Somalia, and is related to other games in the Horn of Africa. The board takes the form of two rows with five holes.Play begins with four counters in each hole. Players move by picking up all of the counters in any of the holes in their row and sowing them anti-clockwise. If the next hole after the one in which the final counter is dropped contains counters, these are picked up and sowing continues. If the next hole after the one in which the last counter was sown is empty, the counters in the hole after this one are taken and the turn is over. If that hole is empty, none are taken. When all of the holes in one row are empty, the player whose row still contains counters captures these counters. A new game begins. Each player fills as many of the holes in their row with four counters. The player which cannot fill all of their holes with four counters removes from play all of the holes that cannot be filled, and sets aside the extra counters. They play another round with the same rules as before, but without the eliminated hole(s). The game ends when one player must close all of the holes in their row, thus being unable to play. 
(game "Bosh" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 5 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top))  
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start {
            (set Count 4 to:(sites Track)) 
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Sowing" 
            (play
                (or {
                    (move Select 
                        (from 
                            (if 
                                ("SameTurn") 
                                "PlayFromNextHole" 
                                ("OwnedHoles") 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then 
                            (sow
                                apply:(if 
                                    (and 
                                        (= (count at:("NextHoleFrom" (to) 1)) 0) 
                                        (> (count at:("NextHoleFrom" (to) 2)) 0)
                                    )
                                    (fromTo 
                                        (from ("NextHoleFrom" (to) 2)) 
                                        (to (handSite Mover)) 
                                        count:(count at:("NextHoleFrom" (to) 2))
                                    )
                                    (if
                                        (> (count at:("NextHoleFrom" (to) 1)) 0) 
                                        (moveAgain)
                                    )
                                )
                                skipIf:("OnlyOnFilledHoles")
                            )
                        )
                    )
                    }
                    (then 
                        (if ("OneRowIsEmpty")
                            (and
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to (intersection (sites Empty) (sites Mover)))
                        count:4
                    )
                    (move Pass
                        (then
                            (forEach Site ("OwnedHoles")
                                (if (is Empty (site))
                                    ("ForgetValue" (site))
                                )
                            )
                        )
                    )
                )
            )
            (end (if (all Passed)
                    {
                    (if ("NoOwnedHoles" 1) (result P2 Win))
                    (if ("NoOwnedHoles" 2) (result P1 Win))
                    }
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
The game is played on a 5x5 board with the center square representing the King's Valley. Players start with 5 pieces on opposites sites of the board, with the center pieces being the kings.King's Valley is a very simple and easy game to play. This is because all the pieces move the same. Any piece can move straight horizontal, vertical or diagonal, but always as far as possible. Pieces always stop their movement either at the sides of the board or before another piece in the same row, column, or diagonal.
        The winner is the first player that manages to move his king piece to the central square of the board, which represents the King's Valley. 
(game "King's Valley"
    (players 2)
    (equipment {
        (board (square 5))
        (piece "Disc" Each "Move")
        (piece "King" Each "Move")
    })
    (rules 
        (start {
            (place "King1" (intersection (sites Bottom) (sites Column 2)))
            (place "King2" (intersection (sites Top) (sites Column 2)))
            (place "Disc1" (difference (sites Bottom) (sites Column 2)))
            (place "Disc2" (difference (sites Top) (sites Column 2)))
        })
        (play (forEach Piece))
        (end (if (is In (where "King" Mover) (sites Centre)) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Place stones in line of sight of the most recent stone until it is trapped. Whoever dominates the trapped area wins.Play on an equilateral triangular hexagon-tessellated grid. Use a neutral pawn and black/white checkers. Players take turns moving a neutral pawn around on the board (passing is not allowed). The neutral pawn can move any number of empty points, in any direction in a straight line, but cannot move onto, or jump over occupied points. When a player moves the pawn, first they place a checker of their own color, onto the destination point. Then they move the pawn on top of it. When the pawn is trapped, the game is over. At the end of the game, each player gets a point for each checker of their own color adjacent to, or underneath, the pawn. The person with the highest score wins. Played on a size 3 board.
(game "Trike"
    (players 2)
    (equipment {
        (board (hex Triangle <Board>))
        (piece "Marker" Each)
    })
    
    (rules
        (meta (swap))
        
        phases:{
        (phase "Opening" P1
            (play
                (move Add 
                    (to (sites Empty)) 
                    (then (set Var (last To)))
                )
            )
            (nextPhase)
        )
        
        (phase "Play"
            (play
                (move Add 
                    (to (sites LineOfSight Empty at:(var)))
                    (then (set Var (last To)))
                )
            )
        )
        }
        
        (end
            (if
                (no Moves Next)
                (byScore {
                    (score P1 (+ (if (is Mover P1) 1 0) ("Nbors" (last To) P1)))
                    (score P2 (+ (if (is Mover P2) 1 0) ("Nbors" (last To) P2)))
                })
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Quantum Leap" 
    (players 2) 
    (equipment { 
        (board (hex 5))
        (piece "Marker" Each 
            (move Hop 
                Orthogonal 
                (between 
                    (exact (- "DistanceToMove" 1))
                    if:True
                )
                (to 
                    if:("IsEnemyAt" (to)) 
                    (apply (remove (to)))
                )
            )
        )
    }) 
    (rules 
        (start {
            (place "Marker2" (centrePoint))
            (place Random {"Marker2"} count:29) 
            (place Random {"Marker1"} count:30) 
        })
        phases:{
        (phase "Swap" 
            (play
                (or
                    (move Pass)
                    (move Select
                        (from (sites Occupied by:Mover))
                        (to (sites Occupied by:Next))
                        (then
                            (swap Pieces (last From) (last To))
                        )
                    )
                )
            )
            (nextPhase "Play")		
        )
        (phase "Play" (play (forEach Piece)))
        }
        (end ("NoMoves" Loss)) 
    )
)
Quantum Leap was invented in 2013 by Néstor Romeral Andrés. It can be played on a hexagonal grid of any size.Play begins with the supply of pieces (30 of each colour) randomly distributed on the board, so each cell contains only one stone and there is one free space left. This free space can be anywhere except the centre space. Each player has an allocated colour. Before the game starts, Black can swap the positions of any two stones on the board. White then starts the game. Players alternate turns during the game until one of them cannot make a valid move, thereby losing the game. On a turn, a player must make one capture. A player makes a capture by leaping in a straight line in any of the 6 directions exactly as many spaces as friendly pieces surround its original position, and landing on an enemy piece, which is removed from the game. The player who cannot make a capture loses. 

Describe the mechanics of the following Ludii game
(game "MiniXiangqi" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (rectangle 7 7) use:Vertex) 
        
        
        (piece "Jiang" Each ("StepMoveOnThePalace" Orthogonal)) 
        
        
        (piece "Ma" Each 
            (forEach Direction 
                Orthogonal 
                (to 
                    if:(is Empty (to)) 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL} of:All) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (remove (to))
                                        )
                                    )
                                )
                            )
                        ) 
                    )
                )
            ) 
        )
        
        
        (piece "Ju" Each ("SlideCapture" Orthogonal))
        
        
        (piece "Pao" Each 
            (or 
                (move Slide Orthogonal) 
                (move Hop
                    Orthogonal 
                    (between 
                        before:(count Rows) 
                        after:(count Rows) 
                        if:(is Occupied (between))
                    )
                    (to 
                        if:(is Empty (to)) 
                        (apply 
                            if:("IsEnemyAt" (to)) 
                            (remove (to))
                        )
                    ) 
                ) 
            )
        )
        
        
        (piece "Zu" Each ("StepToNotFriend" (directions {Forward Rightward Leftward})))
        
        (regions "PalaceP1" P1 { 2..4 9..11 16..18 })
        (regions "PalaceP2" P2 { 30..32 37..39 44..46 })
    }) 
    
    (rules 
        (start { 
            (place "Jiang1" coord:"D1") (place "Ma1" {"C1" "E1"}) (place "Ju1" {"A1" "G1"}) (place "Pao1" {"B1" "F1"}) (place "Zu1" {"A2" "C2" "D2" "E2" "G2"})
            (place "Jiang2" coord:"D7") (place "Ma2" {"C7" "E7"}) (place "Ju2" {"A7" "G7"}) (place "Pao2" {"B7" "F7"}) (place "Zu2" {"A6" "C6" "D6" "E6" "G6"})
        })
        
        (play (do 
                (forEach Piece) 
                ifAfterwards:(and 
                    ("JiangSameColumnWithNoPieceBetween")
                    (not ("IsInCheck" "Jiang" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "Jiang")
            ("BlockWin")
        })
    )
)
A smaller version of Xiangqi.The rules for pieces are the same as regular Xiangqi, except pawns start with the ability to move sideways. 

Construct a Ludii game based on the following description
Throngs a highly abstracted wargame (territorial invasion game) for two players. It is typically played on the intersections of a triangular grid, using Go stones. It is a double-move game: each player takes 2 full turns in succession before the next player takes control.                         Movement: The game is distinguished by the way the power of a moving piece is determined according to the pieces around it: A piece can move as far as the difference in count of the friends and enemies in its immediate vicinity.                         Removing an enemy and adding one's own piece take one power unit each. Remaining power goes into a series of steps or hops that may change direction at empty locations.                         Strategy: Power to travel up to seven units per move can be developed during the game. As the offensive capacity develops, defensive measures are needed, first starting with limiting the mobility of enemy stones by approaching them, then by building walls, and thickening them along the axes of the opponent's catapulting sites (empty locations surrounded by many of that player's own stones.) These sites allow adding a stone and catapulting it up to a distance of 5, and are re-useable. In addition to these methods, defense is by scattering stones behind one's own lines to immobilise enemy stones that invade.                        The majority of turns naturally involve placement as well as movement, due to the benefit of gaining material; even though newly placed stones travel a reduced distance due to the cost of their placement. Occasional moves without placement are used mainly to initiate difficult invasions, as they risk simultaneously opening up positional weaknesses.                          Individual stones may be captured by replacement when they are sufficiently out-numbered at a location, which means that towards the end of the game, chains of stones not anchored to a triangle, loop, or board edge will be consumed one-by-one by captures. Thus the shape and nature of territorial walls is worth contesting.                        Boards: The standard board is centerless, designed to allow maximal distance moves from the center, while minimizing the size of the board. The hexagonal corner regions help to stabilize invasions in outlying areas. The reverse angles along the edge are slightly less defensible than the other parts, breaking the edges into stategic zones.                        The game is easily adapted not only to to different size and shape boards, but also to different grid topologies, while remaining interesting and playable. A 'perforated' grid is included to demonstrate this, but there are many other possibilities as well.                         The center of the board is very advantageous, and a pie rule or balanced starting positions are needed. The standard starting position places the initial pieces near the edges to allow players a wider variety of strategies. Placing multiple starting stones, and or playing on torus boards, leads to finer grained, denser, highly tactical games, while using few starting pieces and larger boards or boards with less connectivity (e.g. boards with holes, and boards on semi-regular grids) lead to a more territorial game.                    Play on a torus also eliminates the advantage of a board center, but requires a larger board because invasion is no longer from a single direction.Objective
            Each player tries to achieve a majority of territory.
            Objectively, territory means a player's pieces on a filled board when no captures are left to be made. 
            
            However, as implemented, territory is a score which is based on a reading of each occupied cell and its neighbors to see who would own that cell if the opponent were allowed a neighboring placement and a chance to capture there. 
            Empty cells are scored as a player's territory that player's piece would be safe there, but the opponent's stone would not, even with another stone added to help it.
            
            In general this underestimates objective territory except in the case of chain captures. 
            To prevent ending the game while chain captures are pending, a player must exceed the majority count by 3 to win, unless no moves are left.
            
            Definitions:
            - The vicinity of a site is that site, together with all the sites immediately adjacent to it.
            - The action-potential of a site is the number of the moving player's stones in the site's vicinity minus the number of the opponent's stones there. For example, the action-potential of a site on Black's move is 3 if its vicinity contains either: 5 Black and 2 White, 4 Black and 1 White, or 3 Black and no White.
            
            The structure of the game:
            Before play begins, one player places a Black stone and two White stones on three different sites. 
            Then the other player decides to play either as Black or as White. 
            
            A standard setup is provided by default. To choose other positions, select the Pie option from the menu.
            
            After the player's colors are determined, player alternate turns with each taking two moves in succession on their turn, beginning with Black.  
            
            Moves:
            A move begins on a site that has sufficient action-potential to be completed (calculated as described above). 
            Before movement, the following amounts are deducted from the action-potential, based on the site's contents:
            
            -- No deduction is taken if the site is already occupied by your own stone.
            -- If the site is occupied by the enemy, you deduct 2 actions to remove and replace it with your stone.
            -- If the site is empty, you deduct one action to add one of your own stones, with the following exception:
            ---- The empty-site deduction is waived if there is no other empty site next to the chosen site and the action-potential at that site is zero.
            
            When you select a site, the application will calculate these deductions for you, and if there is any remaining action potential, it will be shown on the transparent stone.
            
            You may use this leftover actions potential, to move the stone at that site, in a sequence of steps and jumps; spending one action for each space moved during the sequence.
            -- A step is a move to an adjacent empty site.
            -- A jump is a movement in a straight line over occupied sites.
            The distance along the path traveled may not exceed the number of actions that remain.
            
            The application accepts a click on the final destination of the stone. It calculates whether the destination can be reached according to the rules. If you click on the current site or a site at an intermediate distance, the move will end there.
            
            Voluntary passing and partial passing are allowed.
            
            The following rule to keep the game progressing must be obeyed when ever possible:
            -- A player must add or capture whenever that player has not added a piece within the last 3 moves (i.e. at least once in 2 turns.)
            
            Ending the game:
            The game ends when the two scores add up to the size of the board, or when the score of one player exceeds half the board plus a safety factor of 3. 
            The score is based on:
            1 point for each friendly piece unless: 
            A. It could be captured by the opponent if an opponent's piece were added next to it, or 
            B. It could not be defended against capture by adding a friendly piece after 2 opponent's pieces were added next to it.
            
            1 point for each opponent's piece that can be captured, even if all the rest of the empty sites around it are filled with opponent's pieces
            (this purposely underestimates the territory)
            
            1 point for each empty space where both A: and B: below are true,
            A: if a friendly piece were placed there, it would be secure no matter how many additional opponent's pieces were placed next to it. 
            B: if an opponent's piece were placed there and on an adjacent empty site, one of them could be captured if the remaining sites around them were filled with friendly pieces.
            
        This method ends the game when one player has a clear advantage. Ragged edged centerless board for shorter plays. Black places 2 Black and one White as Pie offer, White can chose to move or to change their colors and pass.
(game "Throngs" 
    (players 2)
    (equipment {
        <Board:type>
        (piece "Ball" P1)
        (piece "Ball" P2)
    })
    (rules 
        (meta (passEnd NoEnd))
        <Variants:starting>
        <Variants:pieOrNot>
        (end
            (if
                (or
                    
                    (all Passed)
                    
                    
                    
                    
                    (<
                        (count Sites in:(sites Board))
                        (* 2 (- (score Next) ("SafetyFigure")))
                    )
                )
                (byScore) 
            )
        )
    )
)

Construct a Ludii game based on the following description
Makonn is a four-row mancala-style board game played in the Seychelles. It was described to Alex de Voogt in the 2007, but the game is attested from at least the time of World War I by the presence of game boards in the National Historic Museum from that time.4x10 board. Forty counters in total. Play begins with one counter in each hole. One player then rearranges these counters however they like, as long as they remain on their side of the board and they remain on the board. They can arrange it so that they capture counters from the opponent's side according to the capture rules. The other player then does the same. Play begins with a player picking up counters from one of the holes with more than one on their side. Counters are sown in an anti-clockwise direction. When the last counter lands in an occupied hole, these counters are picked up and sowing continues until the last counter falls in an empty hole. When the last counter falls into an empty hole, either the turn ends or the player captures. Captures are only made from the inner row; if the corresponding hole in the opponent's inner row holds counters, these are captured; if there are also counters in the corresponding hole in the opponent's outer row, these are also captured. Play continues until one player has nothing left or one player has only single counters in their holes. If the player has no counters left, they have lost. If only single counters remain in a player's holes, they may now move single counters, but only into empty holes. Captures are made in the same way as before. 
(game "Makonn" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "20,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))          
        (regions "Home" P2 (sites Track "Track2"))          
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 1 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        phases:{
        
        (phase "Rearrangement"
            (play 
                (or
                    (move
                        (from (sites Mover "Home") if:(is Occupied (from)))
                        (to (sites Mover "Home") if:(!= (from) (to)))
                        (then
                            (and
                                (if 
                                    (and {
                                        (!= 1 (value Player Mover))
                                        (is In (last To) (sites Mover "Inner"))
                                        (= 1 (count at:(last To)))
                                    })
                                    (if (is Occupied ("OppositePit" (last To)))
                                        (and {
                                            (set Value Mover 1)
                                            (remove ("OppositePit" (last To)))
                                            (if (is Occupied ("OppositeOuterPit" (last To))) 
                                                (remove ("OppositeOuterPit" (last To)))
                                            )
                                        })
                                    )
                                )
                                (moveAgain)
                            )
                        )
                    )
                    (move Pass)
                )
            )
            (nextPhase Mover (was Pass) "Sowing")
        )
        
        (phase "Sowing" 
            (play
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover "Home") 
                        )
                        if:(if ("SameTurn")
                            True
                            (if ("OnlyHoleWithSingleCounters")
                                (is Occupied (from))
                                (< 1 (count at:(from)))
                            )
                        )
                    )
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (and
                                    (set Var "Replay" (to))
                                    (moveAgain)
                                )
                                (if (is Occupied ("OppositePit" (to)))
                                    (and 
                                        (remove ("OppositePit" (to)))
                                        (if (is Occupied ("OppositeOuterPit" (to))) 
                                            (remove ("OppositeOuterPit" (to)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        
        }
        
        (end (if (all Sites (sites Next "Home") if:(= 0 (count at:(site)))) (result Next Loss)))
    )
)

Construct a Ludii game based on the following description
Nuktagaq is an Inuit hunt game played in the Canadian Arctic. Cross-shaped board made of five squares. The four squares of the arms have diagonals and lines connecting the midpoints of opposite sides. The central square has diagonals and a line connecting the central point with the midpoint of the lower side. One player plays with nineteen pieces, which begin on the uppermost nineteen points. The other player plays with two pieces, which begin on the central space and the one immediately below it. The player with two pieces goes first. Pieces move along the lines of the board to an empty adjacent spot. The player with two pieces may capture an adjacent opponent's piece by hopping over it to an empty spot immediately on the opposite side of it. The player with two pieces wins by capturing all of the opponent's pieces; the player with nineteen pieces wins by blocking the opponent from being able to move. 
(game "Nuktagaq" 
    (players 2) 
    (equipment { 
        (board 
            (remove
                ("CrossGraph" 3 7 diagonals:Alternating)
                edges:{{17 10} {9 10} {10 11}}
            )
            use:Vertex
        )
        (hand P1)
        (piece "Marker" P1 (or ("HopCapture") "StepToEmpty"))
        (piece "Marker" P2 "StepToEmpty") 
    }) 
    (rules 
        (start { 
            (place "Marker2" (difference (expand (sites Top) steps:4) (union (sites Row 2) (sites Centre))))
            (place "Marker1" (sites Direction from:(sites Centre) S included:True distance:1)) 
        })
        
        (play (forEach Piece))
        
        (end ("NoMovesLossAndNoPiecesPlayerLoss" P2))
    )
)

Construct a Ludii game based on the following description
Rolit is an easy to learn strategy game that’s fun for the whole family. The aim of the game is to capture your opponent’s Rolit balls and turn balls to make them your color. The player with the most Rolit balls of their color wins!This is basically 4-player Othello, albeit more \ The game is playing with two players.
(game "Rolit"
    (players <Players:num>)
    (equipment {
        (board (square 8))
        (piece "Ball" Neutral)
    })
    (rules 
        
        (start {
            (place "Ball0" coord:"D5" state:1)
            (place "Ball0" coord:"E5" state:2)
            (place "Ball0" coord:"E4" state:3)
            (place "Ball0" coord:"D4" state:4)
        })
        
        (play
            (priority 
                (forEach Site 
                    (sites Empty)
                    (append 
                        "ReverseBoundedPieces" 
                    )
                )
                (move Add (piece "Ball0" state:(mover))
                    (to (sites Around (sites Occupied by:Neutral) Empty))
                )
                (then
                    (forEach Player 
                        (set Score Player 
                            (count Sites in:(sites State (player)))
                        )	
                    )
                )
            )
        )
        
        (end
            (if (all Passed)
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Equi-based games are games played on a hex grid that share the following properties:Each player has two kinds of pieces, one kind (Discs) move using steps and/or hops with flip-captures, the other kind (Hexes) are stationary. The stationary pieces have more score value, and they are limited to certain sites of placement. Identifying the placement sites for the stationary Hex pieces is based on their having an equal number of influencing neighbor pieces belonging to the player and to his (selected) enemy.Turns consist of either: placing any a piece, or moving a Disc. The Disc move may be followed by optionally placing a Hex piece. The game ends when in succession, none of the players adds a piece to the board. The winner is the player who has the highest score, with the first player not to place a piece winning in the case of a tiebreaker. In the original game of Equi, The influencing neighbor pieces were found along lines of sight, and included only those pieces that were at the same distance as the nearest of them. The original game also had special placement limitations not discussed here, to reduce cycling. These evolved into produce the version cited here.Areas of variation. The main families are: 1. Equi - Line of sight based rules, forced flip-hopping of enemy pieces, and optional friendly hops, piece values same magnitude, but opposite sign. Details are that moving Disc pieces can only be entered onto non-Equi sites and not to suicide sites. The game is intended as a 2 player strategy game.Equiversi - intended to be easier to play and more territorial and have less cycling issues.The first change was to replace line of sight influence with adjacent piece influence, that is easier to see. With the increase in hex placement opportunities thus available, friendly hops were disallowed.Then a second evolution, Equiversi-2, occurred with the concept of allowing players to decide a range of piece values for the Discs prior to play, -- represented here only by the selection of a zero value. Reduced value allowed for a relaxation of all placement restrictions on the Discs. An implementation side effect is that selecting a site gives a piece-choice pop-up for those sites where Hexes may be played. Pre-selecting the piece to play would be a better implementation.Evolution to Hops-a-Daisy            Nothing in the game prohibits a multi-player implementation, except that king-making could be an issue. Thus the idea of a small, light multi-player game based on Equi was born. To increase the chaotic experience, the hop changes both piece type and ownership leading to entirely different strategies. Hops-a-Daisy default rules allow hopping any piece, 'morphing' it (changing its type). Opponent's pieces are flipped to the mover's ownership as well. For ease of play, Disc placement is either to Non-Hex sites or unlimited. Hex placement considers all opponents as enemies. These settings can be changed to restrict hopping and/or Hex placement rules to either the preceding or following player's pieces. The game is strictly for fun and thus should be played on a small board.These games also inspired Refugia, with different placement restrictions, single piece types, and ownership changes taking place in stages, which has been implemented separately on Ludii.Equi is a game system played on a hex grid, for 2 or more players, using 2 types of reversable pieces.
            
            Each player has: 
            -- Hexes that are stationary. The Hexes score 10 points at the end of the game, but are limited to certain sites of placement. 
            -- Discs that move using steps and/or hops with flip-captures,  Discs score according to the value selected in the (Options) normally -10.
            Note: look in the drop-down (Options) tab to see what Option are selected. 
            
            Equi gets its name from the Hex placement rules: The neighborhood of the chosen location for a Hex must contain equal numbers of your own and your opponent's pieces.  This neighborhood could be defined either as adjacent locations, or as locations in each direction of travel that are at the same distance as the closest relevant piece. (See the (Options) for your game.) The (Options) also determine who you can hop and who is your enemy in a multi-player seting.
            
            Turns: Each turn offers a choice, either place any a piece, or move a Disc. 
            In addition, the Disc move may be followed by optionally placing a Hex.
            Any placement ends the turn.
            
            The standard options make Disc 'flip-captures' mandatory: This means that if a Disc is next to an opponent's piece which it can hop, then it must do so. The ownership of the hopped piece flips immediately. 
            
            The same Disc may hop any number of available pieces, but may not, in any case, hop over the same location twice in the same turn. 
            
            Depending on the (Options) chosen the Disc may, or may not, hop friendly pieces. Hopping friendly pieces is never required.
            
            In some (Options) the hopped pieces also 'morph' between Disc and Hex. The (Options) also determine whose pieces morph and whose don't.
            
            Except for Enemy flip-captures, all parts of a turn are optional and passing is allowed. But be careful about not making a placement during a turn, as this is an offer to end the game.
            
            Placements:
            Sites for placing Hexes have already been explained.
            Sites for placing a Disc at the beginning of a turn, are given in the (Options). 
            -- 'Non-Hex' means sites where Hexes are not allowed to be placed.
            -- 'Safe' means not on sites where the next player's first action could be to hop-flip the Disc.
            -- 'Any' means any empty site
            
            The game ends when all the players have consecutively taken their turn without making a placement.
            
        Please have fun with this playground, and let me, the author, know which are your favorite game options... 2 players Board & size: Hexhex with edges alternating 2 and 4 Hopping any piece changes type, Hopping enemies also changes ownership An adjacent Enemy must be hopped, a friend can be. Can hop all others, Equi is based on all NonMovers Equi count is based on Lines-of-Sight distance to any piece Place Discs at any Empty location Discs value is -10
(game "Hops-a-Daisy Generalized"
    (players <NumberPlayers:inGame>)
    (equipment {
        (board (hex <Board:size>) use:Cell)
        (piece "Disc" Each)
        (piece "Hex" Each)
    })
    (rules 
        (start (set Score Each 0)) 
        (play
            <ChosenHop:prioritySetting>
        )
        (end 
            (if 
                (is Proposed "End")
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
A version of 4-player Shogi.Pieces move the same as in normal Shogi. Once a player is checkmated their Osho is removed, but all their other pieces remain on the board as neutral obstacles. Neutral pieces cannot help checkmate other players. Setup by Ota Mitsuyasu in 1993
(game "Yonin Shogi" 
    (players {(player N) (player W) (player S) (player E)}) 
    
    (equipment { 
        (board (square 9))
        
        
        (piece "Osho" Each ("StepMove"))
        
        
        (piece "Fuhyo" Each 
            ("StepMove" 
                Forward 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InLastRank" (last To)) 
                            ("Promote") 
                            (moveAgain) 
                        ) 
                    ) 
                )
            )
        )
        
        
        (piece "Ginsho" Each ("StepMove" (directions {Forward BL BR FL FR}) "CanPromote"))
        
        
        (piece "Hisha" Each ("SlideMove" Orthogonal "CanPromote"))
        
        
        (piece "Kakugyo" Each ("SlideMove" Diagonal "CanPromote"))
        
        
        (piece "Keima" Each 
            (forEach Direction 
                Forward 
                (to 
                    if:True 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL}) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (add 
                                                (piece ("Captured" (what at:(to)))) 
                                                (to (mapEntry "Where" ("Captured" (what at:(to)))))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                ) 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InTwoFurthestRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                ) 
            ) 
        )
        
        
        (piece "Kyosha" Each
            ("SlideMove" 
                Forward 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InLastRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                )
            ) 
        )
        
        
        ("ShogiGold" "Kinsho" "CapturePiece")
        
        
        ("ShogiGold" "Tokin" "CapturePiece")
        
        
        ("ShogiGold" "Narigin" "CapturePiece")
        
        
        (piece "Ryuo" Each (or ("SlideMove" Orthogonal) ("StepMove" Diagonal)))
        
        
        (piece "Ryuma" Each (or ("SlideMove" Diagonal) ("StepMove" Orthogonal)))
        
        
        ("ShogiGold" "Narikei" "CapturePiece")
        
        
        ("ShogiGold" "Narikyo" "CapturePiece")
        
        (regions "LastRankP1" P1 (sites Top))
        (regions "LastRankP2" P2 (sites Left))
        (regions "LastRankP3" P3 (sites Bottom))
        (regions "LastRankP4" P4 (sites Right))
        (regions "TwoFurthestRankP1" P1 (expand (sites Top)))
        (regions "TwoFurthestRankP2" P2 (expand (sites Left)))
        (regions "TwoFurthestRankP3" P3 (expand (sites Bottom)))
        (regions "TwoFurthestRankP4" P4 (expand (sites Right)))
        (regions "Promotion" P1 (expand (sites Top) steps:2))
        (regions "Promotion" P2 (expand (sites Left) steps:2))
        (regions "Promotion" P3 (expand (sites Bottom) steps:2))
        (regions "Promotion" P4 (expand (sites Right) steps:2))
        (map "Where" {
            (pair (id "Fuhyo" P1) (handSite P1)) (pair (id "Fuhyo" P2) (handSite P2)) (pair (id "Fuhyo" P3) (handSite P3)) (pair (id "Fuhyo" P4) (handSite P4)) 
            (pair (id "Ginsho" P1) (handSite P1 1)) (pair (id "Ginsho" P2) (handSite P2 1)) (pair (id "Ginsho" P3) (handSite P3 1)) (pair (id "Ginsho" P4) (handSite P4 1)) 
            (pair (id "Hisha" P1) (handSite P1 2)) (pair (id "Hisha" P2) (handSite P2 2)) (pair (id "Hisha" P3) (handSite P3 2)) (pair (id "Hisha" P4) (handSite P4 2)) 
            (pair (id "Kakugyo" P1) (handSite P1 3)) (pair (id "Kakugyo" P2) (handSite P2 3)) (pair (id "Kakugyo" P3) (handSite P3 3)) (pair (id "Kakugyo" P4) (handSite P4 3)) 
            (pair (id "Keima" P1) (handSite P1 4)) (pair (id "Keima" P2) (handSite P2 4)) (pair (id "Keima" P3) (handSite P3 4)) (pair (id "Keima" P4) (handSite P4 4)) 
            (pair (id "Kyosha" P1) (handSite P1 5)) (pair (id "Kyosha" P2) (handSite P2 5)) (pair (id "Kyosha" P3) (handSite P3 5)) (pair (id "Kyosha" P4) (handSite P4 5)) 
            (pair (id "Kinsho" P1) (handSite P1 6)) (pair (id "Kinsho" P2) (handSite P2 6)) (pair (id "Kinsho" P3) (handSite P3 6)) (pair (id "Kinsho" P4) (handSite P4 6)) 
            (pair (id "Tokin" P1) (handSite P1)) (pair (id "Tokin" P2) (handSite P2)) (pair (id "Tokin" P3) (handSite P3)) (pair (id "Tokin" P4) (handSite P4)) 
            (pair (id "Narigin" P1) (handSite P1 1)) (pair (id "Narigin" P2) (handSite P2 1)) (pair (id "Narigin" P3) (handSite P3 1)) (pair (id "Narigin" P4) (handSite P4 1)) 
            (pair (id "Ryuo" P1) (handSite P1 2)) (pair (id "Ryuo" P2) (handSite P2 2)) (pair (id "Ryuo" P3) (handSite P3 2)) (pair (id "Ryuo" P4) (handSite P4 2)) 
            (pair (id "Ryuma" P1) (handSite P1 3)) (pair (id "Ryuma" P2) (handSite P2 3)) (pair (id "Ryuma" P3) (handSite P3 3)) (pair (id "Ryuma" P4) (handSite P4 3)) 
            (pair (id "Narikei" P1) (handSite P1 4)) (pair (id "Narikei" P2) (handSite P2 4)) (pair (id "Narikei" P3) (handSite P3 4)) (pair (id "Narikei" P4) (handSite P4 4)) 
            (pair (id "Narikyo" P1) (handSite P1 5)) (pair (id "Narikyo" P2) (handSite P2 5)) (pair (id "Narikyo" P3) (handSite P3 5)) (pair (id "Narikyo" P4) (handSite P4 5)) 
        })
        (map "Promoted" { 
            (pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) (pair (id "Fuhyo" P3) (id "Tokin" P3)) (pair (id "Fuhyo" P4) (id "Tokin" P4)) 
            (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) (pair (id "Ginsho" P3) (id "Narigin" P3)) (pair (id "Ginsho" P4) (id "Narigin" P4)) 
            (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) (pair (id "Hisha" P3) (id "Ryuo" P3)) (pair (id "Hisha" P4) (id "Ryuo" P4)) 
            (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2)) (pair (id "Kakugyo" P3) (id "Ryuma" P3)) (pair (id "Kakugyo" P4) (id "Ryuma" P4)) 
            (pair (id "Keima" P1) (id "Narikei" P1)) (pair (id "Keima" P2) (id "Narikei" P2)) (pair (id "Keima" P3) (id "Narikei" P3)) (pair (id "Keima" P4) (id "Narikei" P4)) 
            (pair (id "Kyosha" P1) (id "Narikyo" P1)) (pair (id "Kyosha" P2) (id "Narikyo" P2)) (pair (id "Kyosha" P3) (id "Narikyo" P3)) (pair (id "Kyosha" P4) (id "Narikyo" P4)) 
        })
        
        (hand Each size:7)
    })
    
    (rules 
        (start { 
            <PiecePlacement:PiecePlacement>
        })
        
        (play
            (if ("SameTurn")
                (or
                    ("Promote")
                    (move Pass)
                )
                (do 
                    (or {
                        (move 
                            (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) 
                            (to (sites Empty))
                        ) 
                        ("PlacePawn" Mover Next)
                        ("PlaceLance" Mover)
                        ("PlaceKnight" Mover) 
                        (forEach Piece) 
                    })
                    ifAfterwards:(not ("IsInCheck" "Osho" Mover))
                )
                (then
                    (and {
                        ("RemoveKingIfCheckmate" P1 1)
                        ("RemoveKingIfCheckmate" P2 2)
                        ("RemoveKingIfCheckmate" P3 3)
                        ("RemoveKingIfCheckmate" P4 4)
                    })
                )
            )
        )
        
        (end {
            (forEach NonMover
                if:("IsOffBoard" (where "Osho" Player)) 
                (result Player Loss)
            ) 
            ("NoMoves" Loss)
        })
    )
)

Construct a Ludii game based on the following description
ConHex is an abstract strategy game for two players. Both aim to complete a contiguous chain of connected cells between the 2 sides of their colour. Cells are claimed by conquering them. In order to conquer a cell, players must surround it with pegs.Each player has an allocated colour. The game is played in turns. On his first move, the second player may elect to swap colours (swap option). This is to prevent overly strong opening moves.
            
            Each turn the current player places one of their pegs on an empty hole, which may conquer one or more cells. A cell is conquered by the first player to occupy at least half of its surrounding holes. A blue rectangle is placed on cells conquered by Blue, and a red rectangle is placed on cells conquered by Red.
            The central cell, which has five holes, is conquered by the player who has occupied any three of these holes. 
        The first player that completes a contiguous chain of connected cells of his colour between the 2 sides of his colour wins the game.   
(game "ConHex" 
    (players 2)
    (equipment {
        (board
            (add
                (keep
                    (splitCrossings 
                        (merge 
                            (rotate 45 (dual (square 12 diagonals:Concentric)))
                            (shift 3 3 (scale 6 (square 1)))
                        )
                    )
                    (poly { {3 3} {3 9} {9 9} {9 3} })
                )
                vertices:{{6 6}}
            )
        )
        (piece "Marker" Each)
        (piece "Rectangle" Each)
        (regions "Holes" (union (difference (sites Board Vertex) (sites Outer Vertex)) (sites Corners Vertex)))
        (regions P1 {(sites Side N) (sites Side S) })
        (regions P2 {(sites Side W) (sites Side E) })
    })
    (rules
        (meta (swap))
        (play 
            (move Add (to Vertex (sites Empty Vertex) if:(is In (to) (sites "Holes")))
                (then 
                    (forEach Site
                        "CellOfLastVertex" 
                        (if "MajorityOfEmptyCell"
                            "CaptureTheCell"
                        )
                        (then
                            (forEach Site (forEach ("CellOfLastVertex") if:(is Mover (who Cell at:(site))))
                                (if (is Connected at:(site) Mover)
                                    (trigger "Connected" Mover)
                                )
                            )		
                        )
                    )
                )		
            )
        )
        
        (end {
            (if (is Triggered "Connected" Mover) (result Mover Win))
            (if (<= 52 (count Moves)) (result Mover Draw))
        }) 
    )
)

Construct a Ludii game based on the following description
Two-Colour is a 2-player graph theory game. It can be played on any graph. Every turn, the current player places a piece of their colour on any empty vertex of the graph. If the last coloured vertex has no adjacent vertex with the same colour, the player gets one point. The game is over, when both players passed their turn or there is no empty vertex. Finally, the player with the highest score wins. 
         
(game "Two-Colour" 
    (players 2) 
    (equipment { 
        (board <Board:type> use:Vertex)
        (piece "Marker" Each) 
    }) 
    (rules 
        (play    
            (or
                (move Add
                    (to (sites Empty)) 
                    (then 
                        (if (= 1 (size Group at:(last To))) 
                            (addScore Mover 1)  
                        )
                    )     
                )
                (move Pass)	   
            )
        )
        (end
            (if (all Passed)	
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Dig Dig is an alignment game played by Teochew Chinese people in Malaysia during the twentieth century. One player generally plays with twigs, and the other as pieces of grass.Three concentric squares, with lines connecting the corners and midpoints of the squares. Two players. Players alternate turns placing one of their pieces on one of the spots on the board. A player may place a piece on top of a piece belonging to their opponent during this phase of the game, and they are both canceled out. When three uncanceled pieces form a row along the lines on the board, the player may capture one of the opponent's pieces. Once all of the spots have been occupied, the canceled pieces are removed. Players alternate turns moving one of their pieces to an empty adjacent spot on the board.The player who captures all of the opponent's pieces wins. 
(game "Dig Dig"
    (players 2)
    
    (equipment { 
        (board (concentric Square rings:3 joinCorners:True) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ 
                (then ("ReplayIfLine3" if:("IsSingletonStack" (to))))
            )
        ) 
    }) 
    
    (rules 
        (start {
            (place Stack "Marker1" (handSite P1))
            (place Stack "Marker2" (handSite P2))
        })
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to 
                            (union 
                                (forEach
                                    (sites Occupied by:Next container:"Board") 
                                    if:(= 1 (size Stack at:(site)))
                                )
                                (sites Empty)
                            )
                        )
                        copy:True
                        (then ("ReplayIfLine3" if:("IsSingletonStack" (to)))) 
                    )
                    (then 
                        (if 
                            (and (not (is Next Mover)) (is Full))	
                            (and {
                                ("RemoveDeadPieces" P1) 
                                ("RemoveDeadPieces" P2)
                                (set Pending)
                            })
                        )		
                    )
                )
            ) 
            (nextPhase (is Pending) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveEnemyPiece"
                    (forEach Piece)
                )
            )
            (end (if (all Sites (sites Occupied by:Next) if:(not (is In (site) (sites Board)))) (result Mover Win)))
        )
        }
    )
)

Construct a Ludii game based on the following description
Tic-Tac-Toe is a game of alignment popular among children. It is known from the nineteenth century in England and the United States, but may be older.Play occurs on a 3x3 grid. One player places an X, the other places an O and players take turns placing their marks in the grid, attempting to get three in a row of their colour. 
(game "Tic-Tac-Toe" 
    (players 2) 
    (equipment { 
        (board (square 3)) 
        (piece "Disc" P1) 
        (piece "Cross" P2) 
    }) 
    (rules 
        (play (move Add (to (sites Empty))))
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
In this version of the blocking game known as Jänes Soppi  both players have three pieces. It was played by children in Kärla, Estonia.3x3 intersecting lines, with triangles extending on opposite ends of the large square and the central line extending to the apices. One player plays as three notched sticks, called hares, and the other as three sharp sticks, known as the hounds. Players alternate turns placing a piece on the board. When the players have placed all of their pieces on the board, they move one of their pieces to an empty adjacent spot along the lines. The first player to block their opponent from being able to move wins. 
(game "Janes Soppi (Symmetrical)" 
    (players 2) 
    (equipment { 
        (board
            (remove
                ("ThreeMensMorrisGraphWithLeftAndRightTriangles")
                edges:{{6 4} {4 2} {0 4} {4 8}}
            )
            use:Vertex
        )
        (hand Each)
        (piece "Hound" P1 "StepToEmpty")
        (piece "Hare" P2 "StepToEmpty")
    }) 
    
    (rules 
        (start {
            (place "Hound1" (handSite P1) count:3)
            (place "Hare2" (handSite P2) count:3)
        })
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Played in Turkey, Greece, Egypt, the Levant, and other places in Southwest Asia. The game is first documented during the late seventeenth century. Similar games are played among coastal communities in East Africa and Indian Ocean Islands (such as Comoros), probably through trade with the Ottoman Empire.Played on an 8x8 board. 16 pieces per player, lined up in the second and third rows (first row on each side is empty). Pieces move forward or horizontally one space, and capture opponents' pieces by jumping in these directions. When they reach the opposite side, they become a king and can jump opponents' pieces from any distance orthogonally. Captures must be taken if possible, and the maximum number of jumps must be made. Multiple captures cannot be made by moving 180 degrees from the previous jump. Pieces can be promoted to king mid-jump. Winning is achieved by capturing all of the other player's pieces or by blocking them so they cannot move. 
(game "Dama" 
    (players 2) 
    ("DraughtsEquipment" (square 8))
    (rules 
        (start { 
            (place "Counter1" (union (sites Row 1) (sites Row 2)))
            (place "Counter2" (union (sites Row 5) (sites Row 6)))
        })
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves
                        ("HopMan" (last To)
                            (then 
                                ("ReplayIfCanMove" ("HopMan" (last To))
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            )
                        )
                    )
                    (max Moves ("PromotedHopOrthogonalSequenceCapture" (from (last To)) (difference Orthogonal OppositeDirection)))
                )
                (priority {
                    (max Moves
                        (or 
                            (forEach Piece "Counter" 
                                ("HopMan" (from)
                                    (then 
                                        ("ReplayIfCanMove" ("HopMan" (last To))
                                            ("PromoteIfReach" (sites Next) "DoubleCounter")
                                        ) 
                                    )
                                ) 
                            )
                            (forEach Piece "DoubleCounter" ("PromotedHopOrthogonalSequenceCapture" (from) Orthogonal))
                        )
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {Forward Rightward Leftward}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Orthogonal))
                    )
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Ultimate Tic-Tac-Toe is a board game composed of nine Tic-Tac-Toe boards arranged in a 3x3 grid.Each small 3x3 Tic-Tac-Toe board is referred to as a local board, and the larger 3x3 board is referred to as the global board. The game starts with X playing wherever they want in any of the 81 empty spots. This move 'sends' their opponent to its relative location. For example, if X played in the top right square of their local board, then O needs to play next in the local board at the top right of the global board. O can then play in any one of the nine available spots in that local board, each move sending X to a different local board. If a move is played so that it is to win a local board by the rules of normal Tic-Tac-Toe, then the entire local board is marked as a victory for the player in the global board. Once a local board is won by a player or it is filled completely, no more moves may be played in that board. If a player is sent to such a board, then that player may play in any other board. Game play ends when either a player wins the global board or there are no legal moves remaining, in which case the game is a draw. 
(game "Ultimate Tic-Tac-Toe" 
    (players 2) 
    (equipment { 
        (board 
            (union 
                (square 9) 
                (scale 3 (square 3))
            )
            use:Cell
        ) 
        
        (piece "Disc"  P1) 
        (piece "DiscLarge" P1) 
        (piece "Cross"  P2) 
        (piece "CrossLarge" P2) 
        
        (regions "SubGames" (sites { 0..80}))
        (regions "SubGame0" (sites { 0..2 9..11 18..20}))
        (regions "SubGame1" (sites { 3..5 12..14 21..23}))
        (regions "SubGame2" (sites { 6..8 15..17 24..26}))
        (regions "SubGame3" (sites {27..29 36..38 45..47}))
        (regions "SubGame4" (sites {30..32 39..41 48..50}))
        (regions "SubGame5" (sites {33..35 42..44 51..53}))
        (regions "SubGame6" (sites {54..56 63..65 72..74}))
        (regions "SubGame7" (sites {57..59 66..68 75..77}))
        (regions "SubGame8" (sites {60..62 69..71 78..80}))
        (regions "SuperGame" (sites {81..89}))
        (map
            "SubToSuper"
            {0..80}
            {
            81 81 81 82 82 82 83 83 83 
            81 81 81 82 82 82 83 83 83 
            81 81 81 82 82 82 83 83 83 
            84 84 84 85 85 85 86 86 86 
            84 84 84 85 85 85 86 86 86 
            84 84 84 85 85 85 86 86 86 
            87 87 87 88 88 88 89 89 89 
            87 87 87 88 88 88 89 89 89 
            87 87 87 88 88 88 89 89 89 
            } 
        )
        (map
            "SubToSub"
            {0..80}
            {
            0 1 2 0 1 2 0 1 2 
            3 4 5 3 4 5 3 4 5
            6 7 8 6 7 8 6 7 8 
            0 1 2 0 1 2 0 1 2 
            3 4 5 3 4 5 3 4 5
            6 7 8 6 7 8 6 7 8 
            0 1 2 0 1 2 0 1 2 
            3 4 5 3 4 5 3 4 5
            6 7 8 6 7 8 6 7 8 
            } 
        )
    }) 
    (rules 
        (play 
            (priority {
                
                
                (move Add
                    (piece (if (= (mover) P1) (id "Disc" P1) (id "Cross" P2)))
                    (to 
                        (if (= 0 (mapEntry "SubToSub" (last To))) 
                            (sites "SubGame0")
                            (if (= 1 (mapEntry "SubToSub" (last To))) 
                                (sites "SubGame1")
                                (if (= 2 (mapEntry "SubToSub" (last To))) 
                                    (sites "SubGame2")
                                    (if (= 3 (mapEntry "SubToSub" (last To))) 
                                        (sites "SubGame3")
                                        (if (= 4 (mapEntry "SubToSub" (last To))) 
                                            (sites "SubGame4")
                                            (if (= 5 (mapEntry "SubToSub" (last To))) 
                                                (sites "SubGame5")
                                                (if (= 6 (mapEntry "SubToSub" (last To))) 
                                                    (sites "SubGame6")
                                                    (if (= 7 (mapEntry "SubToSub" (last To))) 
                                                        (sites "SubGame7")
                                                        (if (= 8 (mapEntry "SubToSub" (last To))) 
                                                            (sites "SubGame8")
                                                        ) 
                                                    ) 
                                                ) 
                                            ) 
                                        ) 
                                    ) 
                                ) 
                            ) 
                        )
                        if:(and 
                            (is Empty (to)) 
                            (is Empty (mapEntry "SubToSuper" (to)))
                        )
                    )
                )
                
                
                (move Add 
                    (piece (if (= (mover) P1) (id "Disc1") (id "Cross2")))
                    (to 
                        (intersection (sites "SubGames") (sites Empty))
                        if:(and (is Empty (to)) (is Empty (mapEntry "SubToSuper" (to))))
                    )
                )
                }
                (then 
                    (if (is Line 3 if:("CheckLineRightSubGame")) 
                        (add 
                            (piece (if (= (mover) P1) (id "DiscLarge1") (id "CrossLarge2")))
                            (to (mapEntry "SubToSuper" (last To)))
                        )
                    )
                )
            )
        )
        (end 
            (if 
                (is Line 3 throughAny:(sites "SuperGame") Mover) 
                (result Mover Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "MaxMatch" 
    (players 2)
    (equipment { 
        (board <Board:type> use:Vertex)
    }) 
    
    (rules  	 
        (play 
            (or 
                (move Add
                    (to
                        Edge 
                        (sites Empty Edge)
                    )
                    (then
                        (if 
                            (is Path Edge Mover length:(exact 1)) 
                            (addScore Mover 1)
                        )    		 
                    )	
                )
                (move Pass)
            )
        )
        
        (end 	 	
            (if (all Passed)	
                (byScore)
            )
        )
    )
)
MaxMatch is a 2-player game. This game is based on the principle of \Every turn, the current player can choose to pass, or select a previously-unselected edge. If the selected edge is disjoint from any other friendly edge, then the player gets 1 point. If the graph is full (i.e., all edges have been selected) or both players are passed their turn, the game is over and the winner is selected by their score.
         

Construct a Ludii game based on the following description
Invented by Randy Cox and Bill Taylor, Chameleon is a Hex variantPlayed on a Hex board. Players may play a piece of any color piece. The goal is to form a line connecting the player's two sides with either color. The game is played on a 3x3 board The first player to connect his two sides wins.
(game "Chameleon" 
    (players 2) 
    (equipment { 
        (board (hex Diamond <Board>)) 
        (piece "Marker" Each)
        (hand Shared size:2)
        (regions P1 {(sites Side NE) (sites Side SW) })
        (regions P2 {(sites Side NW) (sites Side SE) })
    }) 
    (rules 
        (meta (swap))
        (start {
            (place "Marker1" (handSite Shared)) 
            (place "Marker2" (handSite Shared 1)) 
        })
        (play 
            (move 
                (from (sites Hand Shared)) 
                (to (sites Empty))
                copy:True
            )
        ) 
        (end {
            (if (is Connected Mover) (result Mover <Result:mover>))
            (if (is Connected Next) (result Next <Result:next>))
        })
    )
)

Construct a Ludii game based on the following description
Saturankam is a race game played in South Asia. It is played by Sinhalese and Tamil people, and is similar to other games throughout the region. Though it is sometimes known as Siga or Chaturanga, it is distinct from the most widely-played games known by these names.9x9 board, with the central square of each side marked, as well as the central space of the board. Two to four players, each player with two pieces. Played with two four-sided dice, marked 1, 3, 4, 6. Throws may be divided as the players see fit between their pieces. Doubles allow another throw. Players start with their pieces on the marked square on their side of the board. Pieces move along a spiraling track, starting in an anti-clockwise direction around the outer edges of the board, then changing to a clockwise direction when reaching the 32nd space in the track, and continuing in this direction in a spiral pattern until reaching the central square. If a player lands on a space occupied by an opponent's piece, the opponent's piece is removed from the board, and the player must throw a double 1 to enter it again on their starting square. Pieces resting on a marked space are safe from being sent to the start. The goal is to reach the central square with both pieces, which must be reached by an exact throw. If a piece is 1, 3, or 4 spaces from the center, the player must throw doubles of that number to reach the goal.
         The game is played with 2 players.
(game "Saturankam"
    (players <Players:num>)
    (equipment {
        (board (square 9)
            {
            <Players:tracks>
            }
        )
        (dice d:4 faces:{1 3 4 6} num:2)
        (piece "Marker" Each
            (if
                (and
                    (or { 
                        (= ("SiteToMoveOnTrack" from:(from) 1) (centrePoint))
                        (= ("SiteToMoveOnTrack" from:(from) 3) (centrePoint))
                        (= ("SiteToMoveOnTrack" from:(from) 4) (centrePoint))
                    })
                    (= (value Player Mover) ("ThrowValue"))
                )
                (if 
                    (and 
                        (all DiceEqual)
                        (= ("SiteToMoveOnTrack" from:(from) (/ ("ThrowValue") 2)) (centrePoint))
                    )
                    (move
                        (from (from))
                        (to (centrePoint))
                        (then
                            (and
                                (moveAgain)
                                (set Var "Double" 1)
                            )	
                        )
                    )
                )
                (forEach Value min:1 max:(value Player Mover)
                    (move 
                        (from (from) level:(level))
                        (to
                            ("SiteToMoveOnTrack" from:(from) (value))
                            if:True
                            (apply 
                                (and
                                    (if (and (not (is In (to) (sites "SafeSites"))) ("IsEnemyAt" (to)))
                                        (forEach Level (to) FromTop
                                            (fromTo
                                                (from (to) level:(level))
                                                (to (handSite (who at:(to) level:(level))))
                                            )
                                        )
                                    )
                                    (if (< 0 (- (value Player Mover) (value)))
                                        (and
                                            (moveAgain)
                                            (set Value Mover (- (value Player Mover) (value)))
                                        )
                                        (and
                                            (set Value Mover 0)
                                            (if (all DiceEqual)
                                                (and
                                                    (moveAgain)
                                                    (set Var "Double" 1)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        (hand Each)
        (regions "SafeSites" (sites {4 44 76 36 40}))
        <Players:entries>
    })
    (rules 
        <Players:start>
        (play 
            (if (or (= 1 (var "Double")) ("NewTurn"))
                ("RollMove" 
                    (move Pass 
                        (then 
                            (and {
                                (set Value Mover ("ThrowValue"))
                                (if (= 1 (var "Double")) (set Var "Double" 0))
                                (moveAgain)
                            })
                        )
                    )
                )
                (if (can Move ("Move")) 
                    ("Move")
                    (move Pass (then (and (set Var "Double" 0) (set Value Mover 0))))
                )
            )
        )
        (end (if ("AllReachedCenter") (result Mover Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Shatranj al-Kabir"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board 
            (merge {
                (square 11)
                (shift 11 1 (square 1))
                (shift -1 9 (square 1))
            })
        )
        (piece "Pawn" Each
            (if (= "ValueOfPawnKingPower" (value Piece at:(from)))
                ("StepToNotFriend")
                (or
                    "StepForwardToEmpty" 
                    ("StepToEnemy" (directions {FR FL}))	
                    (then 
                        (if ("NotSpecialPawn")
                            ("PromoteToAssignedPiece")
                            (if ("HasToDoThirdPromotion")
                                ("ThirdPromotionOfSpecialPawn")
                            )
                        )
                    )
                )
            )
        )
        
        (piece "Wazir" Each
            (move Hop Orthogonal 
                (between (exact 2) if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        ("EnemyNotImmumned")
                    ) 
                    (apply (remove (to)))
                ) 
            )		
        )
        
        (piece "Knight_rotated" Each
            (move Leap 
                { {F F F R F } {F F F L F } } 
                (to 
                    if:(or (is Empty (to)) ("EnemyNotImmumned")) 
                    "CaptureToPiece"
                ) 
            )		
        )
        
        (piece "Elephant" Each
            (move Hop Diagonal 
                (between (exact 2) if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        ("EnemyNotImmumned")
                    ) 
                    (apply (remove (to)))
                ) 
            )		
        )
        
        (piece "Queen" Each
            (move Step 
                Diagonal
                (to 
                    if:(or (is Empty (to)) ("EnemyNotImmumned")) 
                    "CaptureToPiece"
                ) 
            )		
        )
        
        (piece "King_noCross" Each
            (move Step 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        (and
                            ("EnemyNotImmumned")
                            (or 
                                (!= (to) (mapEntry "ExtraSquare" Next))
                                (and 
                                    (= (to) (mapEntry "ExtraSquare" Next))
                                    (< (value Piece at:(to)) 23)
                                )
                            )
                        )
                    ) 
                    "CaptureToPiece"
                ) 
            )		
        )
        
        (piece "Amazon" Each
            (move Step 
                Orthogonal
                (to 
                    if:(or (is Empty (to)) ("EnemyNotImmumned")) 
                    "CaptureToPiece"
                ) 
            )		
        )
        
        (piece "Giraffe" Each
            (forEach Direction 
                Diagonal 
                (to 
                    if:(is Empty (to)) 
                    (apply 
                        (and {
                            (move (from)
                                (to 
                                    (sites To
                                        (slide 
                                            (from (to))
                                            Orthogonal
                                            (between (min 3))
                                            (to 
                                                if:("EnemyNotImmumned")
                                                "CaptureToPiece"
                                            ) 
                                        )
                                    )
                                )
                            )
                        })
                    )
                )
            )
        )
        (piece "Bishop_noCross" Each
            (move Slide 
                Diagonal
                (between (min 2))
                (to 
                    if:("EnemyNotImmumned")
                    "CaptureToPiece"
                ) 
            )
        )
        
        (piece "Knight" Each
            (move Leap 
                "KnightWalk" 
                (to 
                    if:(or (is Empty (to)) ("EnemyNotImmumned")) 
                    "CaptureToPiece"
                ) 
            )		
        )
        
        (piece "Rook" Each
            (move Slide 
                Orthogonal
                (to 
                    if:("EnemyNotImmumned") 
                    "CaptureToPiece"
                ) 
            )		
        )
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
        (map "InitShahPawn" {(pair P1 "G3") (pair P2 "G9")})
        (map "ExtraSquare" {(pair P1 "M2") (pair P2 "A10")})
    })
    (rules 
        (start {
            (place "Pawn1" coord:"B3" value:1) 
            (place "Pawn2" coord:"L9" value:2) 
            (place "Pawn1" coord:"C3" value:3) 
            (place "Pawn2" coord:"K9" value:4) 
            (place "Pawn1" coord:"D3" value:5) 
            (place "Pawn2" coord:"J9" value:6) 
            (place "Pawn1" coord:"E3" value:7) 
            (place "Pawn2" coord:"I9" value:8) 
            (place "Pawn1" coord:"F3" value:9) 
            (place "Pawn2" coord:"H9" value:10) 
            (place "Pawn1" coord:"G3" value:11) 
            (place "Pawn2" coord:"G9" value:12) 
            (place "Pawn1" coord:"H3" value:13) 
            (place "Pawn2" coord:"F9" value:14) 
            (place "Pawn1" coord:"I3" value:15) 
            (place "Pawn2" coord:"E9" value:16) 
            (place "Pawn1" coord:"J3" value:17) 
            (place "Pawn2" coord:"D9" value:18) 
            (place "Pawn1" coord:"K3" value:19) 
            (place "Pawn2" coord:"C9" value:20) 
            (place "Pawn1" coord:"L3" value:21) 
            (place "Pawn2" coord:"B9" value:22) 
            (place "King_noCross1" coord:"G2") (place "King_noCross2" coord:"G10")
            (place "Queen1" coord:"F2") (place "Queen2" coord:"H10")
            (place "Amazon1" coord:"H2") (place "Amazon2" coord:"F10")
            (place "Giraffe1" (sites {"E2" "I2"})) (place "Giraffe2" (sites {"E10" "I10"}))
            (place "Bishop_noCross1" (sites {"D2" "J2"})) (place "Bishop_noCross2" (sites {"D10" "J10"}))
            (place "Wazir1" (sites {"F1" "H1"})) (place "Wazir2" (sites {"F11" "H11"}))
            (place "Knight1" (sites {"C2" "K2"})) (place "Knight2" (sites {"C10" "K10"}))
            (place "Rook1" (sites {"B2" "L2"})) (place "Rook2" (sites {"B10" "L10"}))
            (place "Elephant1" (sites {"B1" "L1"})) (place "Elephant2" (sites {"B11" "L11"}))
            (place "Knight_rotated1" (sites {"D1" "J1"})) (place "Knight_rotated2" (sites {"D11" "J11"}))
        })
        (play
            (do
                (or {
                    (move 
                        (from ("SiteWithSpecialPawnAndFirstPromotion"))
                        (to ("SitePawnCanCaptureTwice"))
                        (then ("MakePawnReadyForSecondPromotion"))
                    )
                    (move 
                        (from ("SiteWithSpecialPawnAndSecondPromotion"))
                        ("ToEmptyInitSiteShahPawn")
                        (then ("MakePawnReadyForThirdPromotion"))
                    )
                    (if (and (!= (value Player Mover) 1)
                            ("IsInCheck" "King_noCross" Mover)	
                        )
                        (forEach Site ("AnyOwnedSitesOnBoardExceptKing")
                            (move Swap Pieces (where "King_noCross" Mover) (site) (then (set Value Mover 1)))
                        )
                    )
                    (forEach Piece)
                })
                ifAfterwards:(and (not ("NextCanNotMove")) (not ("IsInCheck" "King_noCross" Mover)))
            )
        )
        (end { 
            ("BlockWin")
            ("Checkmate" "King_noCross")
            (if 
                (or 
                    ("IsPieceAt" "King_noCross" P2 (mapEntry "ExtraSquare" P1))
                    ("IsPieceAt" "King_noCross" P1 (mapEntry "ExtraSquare" P2))
                )
                (result Mover Draw)
            )
        })
    )
)
Shatranj al-Kabir is a type of Shatranj that is described in several manuscripts from medieval Southwest Asia. They agree that this was a favorite game of Timur, also known as Tamerlane. It is a larger version of Shatranj with more pieces, a larger board, and the use of citadels to force a draw.11x10 board, with a twelfth space on the right of the second row of eleven on each side. Each player starts with the following pieces, with their specialized moves: Shah (x1): moves orthogonally or diagonally one space; Wazir (x1): moves one space orthogonally; Firzan (x1) moves one space diagonally; Dabbaba (x2): jumps orthogonally to the third space; Tali'as (x2): moves diagonally two or more spaces; Jamal (x2): jumps diagonally one space then two orthogonally in the same direction; Zurafa (x2): moves diagonally one space then orthogonally three or more spaces; Pil (x2) jumps two spaces diagonally; Asb (x2): jumps one space diagonally and one space orthogonally in the same direction; Rukh(x2): moves any number of spaces orthogonally; Baidaq (x10); move orthogonally forward one space or diagonally forward one space to capture. Each Baidaq is assigned to one of the piece types and promotes to that piece. They are placed in the third rank, with the Baidaq al-Bayadiq on the leftmost square,  with the following promotion assignments for each regular Baidaq proceeding from left to right beginning on the second square from the left: Dabbaba, Jamal, Pil, Firzan, Shah, Wazir, Zurafa, Tali'as, Asb, Rukh.  Baidaq al-Bayadiq (x1), moves like a Baidaq, but does not promote immediately when it reaches the opposite edge. Instead, it waits there, immune to capture, until a situation arises where two of the opponent's pieces could theoretically be taken by a pawn. The Baidaq al-Bayadiq is then moved to that spot, any piece (including the player's own) being moved from that spot, and then the capture being made on the next turn. It then proceeds as before, and if it is to be promoted again, it becomes a Shah's Baidaq, and is replaced on the appropriate starting position. If it is promoted a third time, it becomes Shah Masnu'a, and the original Shah's Baidaq becomes Shahzada, and both move like the Shah.  If the Shah can be taken on the next turn, it is in Check and must not be in Check at the beginning of the next turn. If a Shah is not in Check but no legal moves are available, it is a Stalemate and the opponent wins. If the Shah is in Check and it is impossible to escape, Checkmate occurs and the opponent wins. Once per game, a player  may swap a Shah which is in Check or Stalemate with another of the player's pieces. If the player can place the Shah in the extra space on the opponent's side of the board, the game is a draw. The Shah cannot enter the extra space if the opponent's Shah Masnu's occupies it.  

Construct a Ludii game based on the following description
The word Siryu is used for several board games in the Tabelbala Oasis of Algeria. This one is a capturing game that is similar to the game of Tab that is played throughout North Africa and Southwest Asia.4x12 board. Twelve pieces per player, one playing as sticks and the other as stones. Pieces begin on the board, one each in every space of the outer rows. Six sticks, with one black side and one white side, used as dice. Players choose who will play as black and who will play as white, and the throws are as follows: six black or white up = 6, five black or white up (called sir)= 5 plus another throw; four black or white up = 0, three black and three white up = 3. A player must throw sir in their colour to unlock a piece before moving it. Pieces move from left to right in their home row, right to left in the next row, left to right in the row following that, and then return to the second row. When a player's piece lands on a spot occupied by an opponent's piece, the opponent's piece is captured. The player who captures all of the opponent's pieces wins. 
(game "Siryu (War)"
    (players 2)
    (equipment {
        (board 
            (rectangle 4 12) 
            {
            (track "Track1" "0,E,N1,W,N1,E,23,E,W,N1,E,23,W,N1,E,23,W,N1,E,23,W,N1,E,23,W,N1,E,23,W,N1,E,23" loop:True P1)
            (track "Track2" "47,W,S1,E,S1,W,24,E,N1,W,24,E,N1,W,24,E,N1,W,24,E,N1,W,24,E,N1,W,24,E,N1,W,24" loop:True P2)
            }
            use:Vertex
        )
        (piece "Stick" P1 ("PieceMove"))
        (piece "Marker" P2 ("PieceMove"))
        (regions "AllSites" (sites Board))
        ("StickDice" 6)
        (map "ThrowDiceValue" {(pair 0 6) (pair 1 5) (pair 2 0) (pair 3 3) (pair 4 0) (pair 5 5) (pair 6 6)})
        (map "Sir" {(pair 1 1) (pair 2 5)})
    })
    (rules 
        (start { 
            (place "Stick1" (sites Bottom) state:1)
            (place "Marker2" (sites Top) state:1)
        })
        (play 
            ("RollMove" 
                (if (can Move (forEach Piece))
                    (forEach Piece (then (if (= ("ThrowValue") 5) (moveAgain))))
                    (move Pass (then (if (= ("ThrowValue") 5) (moveAgain))))
                )
            )
        )
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Mawkar Katiya is a two-row mancala-style board game that was played by the Khasi people of India in the early part of the twentieth century.2x7 board. Five counters in each hole. Players sow in a clockwise direction. When the final counter lands in a hole, the contents of the next hole are picked up and sowing continues. When the final counter is sown and the next hole is empty, the contents of the hole in the opposite row of the empty hole are captured. Play continues until all of the counters are captured. 
            
        A new game begins. The players fill their holes with five counters in each, starting from their left. The player who has remaining counters after all of their holes are full puts the extra counters aside. The player who has fewer counters places the remainder in the next empty hole. Any empty holes are out of play for the round. Play begins with the same rules, with the following modifications: Each player, during their opponent's turn, also captures counters in any hole that are made to equal the number of extra counters they had at the beginning of this round (i.e., the number of counters set aside by the winning player or the number of counters less than five that placed in the final hole by the loser). The player who could fill their holes will capture one counter each time that player sows into the hole in which the opponent placed fewer than five counters at the beginning of the round. The opponent cannot sow in this hole. In addition, at the end of the round, the player who filled their holes at the beginning of the round will always capture pieces that accumulate in this hole. Subsequent rounds are played like this until one player captures all of the counters, and thus wins. 
(game "Mawkar Katiya" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            {
            (track "TrackCW" "6,W,N,E" loop:True)
            (track "TrackCCW" "0,E,N,W" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "LeftMost" {(pair P1 0) (pair P2 13)})
    }) 
    
    (rules 
        (start {
            (set Count 5 to:(sites Track "TrackCW")) 
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                (sites {(var "Replay")}) 
                                (sites Mover) 
                            ) 
                            if:(and {
                                (is Occupied (from)) 
                                (is In (from) ("PlayableSites"))
                                (!= (next) (state at:(from)))
                            })
                        )
                        (then
                            (do
                                (and
                                    (set Var "NumSowed" (count at:(last To)))
                                    (set Var "StateSowFrom" (state at:(last To)))
                                )
                                next:(sow
                                    "TrackCW"
                                    apply:(if (is Occupied ("NextHole" (to) 1))
                                        (and 
                                            (moveAgain)
                                            (set Var "Replay" ("NextHole" (to) 1))
                                        )
                                        (if (is Occupied ("OppositePitTwoRows" ("NextHole" (to) 1)))
                                            (and
                                                (fromTo
                                                    (from ("OppositePitTwoRows" ("NextHole" (to) 1)))
                                                    (to (handSite Mover))
                                                    count:(count at: ("OppositePitTwoRows" ("NextHole" (to) 1)))
                                                )
                                                (set State at:("OppositePitTwoRows" ("NextHole" (to) 1)) (state at:("OppositePitTwoRows" ("NextHole" (to) 1))))
                                            )
                                        )
                                    )
                                    skipIf:(or (and (!= (state at:(to)) (mover)) (!= (state at:(to)) 0)) (not (is In (to) ("PlayableSites"))))
                                )
                                (then
                                    (and {
                                        (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed")))
                                            (if (and (= (value Player Mover) (count at:(site))) (or (= (state at:(site)) (mover)) (= (state at:(site)) 0)))
                                                (and
                                                    (fromTo
                                                        (from (site))
                                                        (to (handSite Mover))
                                                        count:(value Player Mover)
                                                    )
                                                    (set State at:(site) (state at:(site)))
                                                )
                                                (if (and (is Occupied (site)) (= (mover) (state at:(site))))
                                                    (and
                                                        (fromTo
                                                            (from (site))
                                                            (to (handSite Mover))
                                                            count:1
                                                        ) 
                                                        (set State at:(site) (state at:(site)))
                                                    )
                                                )
                                            )
                                        )
                                        (set Var "NumSowed" 0)
                                        (if (< 0 (var "StateSowFrom")) (set State at:(last From) (var "StateSowFrom")))
                                    })
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("NoPieceOnBoard")
                            (and {
                                (forEach Site (sites Board)
                                    (and
                                        (if (= (state at:(site)) 1)
                                            (fromTo
                                                (from (site))
                                                (to (handSite P1))
                                                count:(count at:(site))
                                            )
                                        )
                                        (if (= (state at:(site)) 2)
                                            (fromTo
                                                (from (site))
                                                (to (handSite P2))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                )
                                (forget Value "Playable" All)
                                (if (>= (count Cell at:(handSite P1)) (count Cell at:(handSite P2)))
                                    (set Var "CurrentWinner" 1)
                                    (set Var "CurrentWinner" 2)
                                )
                                (set Value P2 0)
                                (set Value P1 0)
                                (forEach Site (sites Board) 
                                    (if (!= 0 (state at:(site))) (set State at:(site) 0))
                                )
                            })
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                    (if (<= 5 (count Cell at:(handSite Mover)))
                        (move
                            (from (handSite Mover))
                            (to "LeftMostEmpty")
                            count:5
                            (then (remember Value "Playable" (last To)))
                        )
                        (if (and (!= 0 (count Cell at:(handSite Mover))) (!= (mover) (var "CurrentWinner")))
                            (move
                                (from (handSite Mover))
                                (to "LeftMostEmpty")
                                count:(count Cell at:(handSite Mover))
                                (then
                                    (and {
                                        (remember Value "Playable" (last To))
                                        (set Value Mover (count at:(last To)))
                                        (set State at:(last To) (next))
                                    })
                                )
                            )
                        )
                    )
                    (if (= (mover) (var "CurrentWinner"))
                        (move Pass
                            (then
                                (set Value Mover (count Cell at:(handSite Mover)))
                            )
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Sute is a four-row mancala-stlye board game played by the Chikunda people of Malawi.4x8=20 holes, with an even number per row. One counter in each hole, except the right-hand end row of the inner row. Sowing occurs in an anti-clockwise direction, only into an empty hole. When a counter lands in a hole in the inner row and the opponent's opposite inner row hole is empty, the contents of the opponent's opposite outer row hole are captured. The player who captures all of the opponent's pieces wins. 
(game "Sute" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "16,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start 
            (set Count 1 
                to:(difference
                    (union (sites P1 "Home") (sites P2 "Home"))
                    (union 
                        (intersection (sites Right) (sites Row 1))
                        (intersection (sites Left) (sites Row 2))
                    )
                ) 
            ) 
        )
        
        (play 
            (move Select
                (from 
                    (sites Mover "Home") 
                    if:(and 
                        (> (count at:(from)) 0)
                        (= 0 (count at:("NextHoleFrom" (from))))
                    )
                )
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (and (= (count at:("OppositePit" (to))) 0) (is In (to) (sites Mover "Inner")))
                            (remove ("OppositeOuterPit" (to)))
                        )
                    )
                )
            )
        )
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Rimoe"
    (players 2)
    (equipment {
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (piece "King" P1
            (priority {
                ("Hop")
                ("StepToEmpty")
            })
        )
        (piece "Marker" P2 ("StepToEmpty"))
        (hand Each)
    })
    (rules
        (start {
            (place "King1" (centrePoint) count:<Play:numKings>)
            (place "Marker2" (handSite P2) count:16)
            (place "Marker2" (difference (expand (sites Centre)) (centrePoint)))
        })
        phases:{
        (phase "Placement" P2
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        (end ("NoMovesP1NoPiecesP2"))
    )
)
Rimoe is a hunt game played on the island of Simeulue, and similar to others in neighboring lands. It is typically played in the Soeraoe, a religious building.5x5 intersecting lines, with diagonals drawn in the four quadrants of the board. Two triangles, their apices intersecting the main board at opposite midpoints. The base of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. One player plays as the Rimoe (king), which starts on the central point. The other player has 24 pieces, eight of which start on the board, on the points immediately adjacent to the Rimoe. The Rimoe plays first, and takes one of the opponent's pieces by hopping over it to an empty spot immediately behind it in a straight line. The Rimoe captures in this way any uninterrupted line of pieces with an odd number. The Rimoe cannot capture a line of pieces with an even number. When the Rimoe cannot capture, it moves one to an empty adjacent space along the lines of the board. The other player places on of their remaining pieces on the board on their turn. When there are no more pieces left to place, the player moves one of the pieces to an empty adjacent spot along the lines. The Rimoe wins by capturing all of the opponent's pieces; the opponent wins by blocking the Rimoe from being able to move. The game is played with one Rimoe able to hop an odd number of enemy pieces.

Construct a Ludii game based on the following description
Gurvan Xudag is a blockade game played in Mongolia. Three guardians attempt to herd three calves into their pens.Three vertical lines, and two horizontal lines intersecting them along their top end points and their midpoints. The ends of the lines which are not connected to one another are the calves' pens. Three pieces per player, one playing as calves (black), and the other as guardians (white), arranged on the intersections of opposite vertical lines. Players alternate turns moving one of their pieces to an adjacent spot. The guardians attempt to trap the calves into the three pens, the calves attempt to block the guardians from being able to move. 
(game "Gurvan Xudag"
    (players 2)
    (equipment {
        (board 
            (remove (square 3) edges:{{0 1}{1 2}})
            use:Vertex
        )
        (piece "Human" P1 "StepToEmpty")
        (piece "Cow" P2 "StepToEmpty")
    })
    (rules 
        (start {
            (place "Human1" (sites Left))
            (place "Cow2" (sites Right))
        })
        (play (forEach Piece))
        (end {
            (if (no Moves P1) (result P2 Win))
            (if (and ("AllCowsInBottom") (no Moves P2)) (result P1 Win))
        })
    )
)

Construct a Ludii game based on the following description
Gabata is a name for several mancala-style board games in the Horn of Africa. This is one of the more popular versions, played in central Ethiopia and the Adegrat region of Eritrea.2x6 board. Four counters in each hole. The game begins with a stylised move. One player takes one counter from their rightmost hole, and holds in in their hand. They then take one counter from the next hole, moving in an anti-clockwise direction, and place it in the next hole. They then take a counter from the next hole after that, and placing it in the next hole, continuing until there is an alternating pattern of a hole with five counters followed by a hole with three counters. The original hole from which the first counter was taken will have four counters. The player will then place the first counter taken into the next hole in the opponent's row, causing it to hold four counters. This creates a weg, a hole captured by that player, which is involved in capturing (see below). Players alternate making this first move in subsequent rounds. The next phase begins once this stylised move is completed. Sowing occurs in an anti-clockwise direction. If the final counter of a sowing falls into a hole containing counters, these are picked up and sowing continues. A player's turn ends when the final counter falls into an empty hole. When the final counter of a sowing falls into a hole containing three counters, it creates a weg, and the turn ends. Players cannot sow from a weg they've captured. A player may capture counters from an opponent's weg when the final counter of a sowing falls into the opponent's weg on the player's turn. The final counter and one counter in the weg are captured. The player may then take the counters from any of their holes and sow from there. If a player cannot play, they must pass their turn, but may play again if this becomes possible in a subsequent turn. Play ends when there are no possible moves left on the board. Players then capture the counters in their wegs. A new round begins. The players fill as many of their holes with four counters as they are able. The player with more counters will capture as many holes from the opponent in which they can place four or more counters. If the player has three remaining counters after holes are filled with four, the opponent would cede their one remaining counter to the opponent to make four and the player captures one further hole. If there are two remaining, the players draw lots to determine which player owns the remaining hole. The player who played second in the previous round begins the new round with the same stylized move, and play continues as before after that. Play continues until one player owns no holes; the opponent wins. 
(game "Gabata (Shoa and Adegrat)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightMost" {(pair P1 5) (pair P2 6)})
    }) 
    (rules 
        
        (start {
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
            (set Count 4 to:(sites Track)) 
        })
        
        phases:{
        (phase "Opening"
            (play
                (if (is Mover P1)
                    (move Select
                        (from 
                            (if (and (not (is Pending)) ("SameTurn"))
                                (sites {("NextHole" (last From) "TrackCCW" 2)})
                                (sites {10})
                            )
                        )
                        (then
                            (sow
                                count:1
                                "TrackCCW"
                                apply:(if (not (is In ("NextHole" (from) "TrackCCW" 2) (intersection (sites Bottom) (sites Right))))
                                    (moveAgain)
                                    (set State at:11 (mover))
                                )
                            )
                        )
                    )
                    (move Select
                        (from 
                            (if (and (not (is Pending)) ("SameTurn"))
                                (sites {("NextHole" (last From) "TrackCCW" 2)})
                                (sites {1})
                            )
                        )
                        (then
                            (sow
                                count:1
                                "TrackCCW"
                                apply:(if (not (is In ("NextHole" (from) "TrackCCW" 2) (intersection (sites Top) (sites Left))))
                                    (moveAgain)
                                    (set State at:0 (mover))
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase 
                (if (is Mover P1) 
                    (is In ("NextHole" (last From) "TrackCCW" 2) (intersection (sites Bottom) (sites Right))) 
                    (is In ("NextHole" (last From) "TrackCCW" 2) (intersection (sites Top) (sites Left))) 
                )
                "Sowing"
            )
        )
        
        (phase "Sowing" 
            (play
                (or {
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))
                        )
                        (then
                            (sow
                                "TrackCCW"
                                apply:(if (and 
                                        (= 0 (state at:(to))) 
                                        (= 4 (count at:(to)))
                                    )
                                    (set State at:(to) (mover))
                                    (if (< 1 (count at:(to)))
                                        (if (= 0 (state at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                            (if (!= (mover) (state at:(to)))
                                                (and
                                                    (fromTo
                                                        (from (to))
                                                        (to (handSite Mover))
                                                        count:(min 2 (count at:(to)))
                                                    )
                                                    (set State at:(to) (state at:(to)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OnlyPiecesInMarked")
                            (and { 
                                (forEach Site ("SitesMarkedBy" 1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site ("SitesMarkedBy" 2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                                (set Var "Round" (+ 1 (var "Round")))
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (>= 1 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (>= 1 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("RightMostEmpty"))
                        count:4
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 4 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 3 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("RightMostEmpty"))
                                                count:3
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("RightMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("RightMostEmpty"))
                                        })
                                        (if (= 2 (count Cell at:(handSite Mover)))
                                            (and {
                                                (fromTo 
                                                    (from (handSite Mover))
                                                    (to ("RightMostEmpty"))
                                                    count:2
                                                )
                                                (fromTo 
                                                    (from (handSite Next))
                                                    (to ("RightMostEmpty"))
                                                    count:2
                                                )
                                                ("RememberOwnedHolesRandom" ("RightMostEmpty"))
                                            })
                                        )
                                    )
                                )
                            })
                        )
                    )
                    (then
                        (if (and (is Empty (handSite P1)) (is Empty (handSite P2))) 
                            (and
                                (if 
                                    (is Even (var "Round"))
                                    (set NextPlayer (player 2))
                                    (set NextPlayer (player 1))
                                )
                                (set Pending)
                            )
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Opening")
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Ti"
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions "Home" P1 (sites Bottom))      
        (regions "Home" P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))
        phases:{
        (phase "TwoFirstTurn" 
            (play 
                (if ("SameTurn")
                    (forEach Value min:1 max:(var "NumCounters")
                        (move Add 
                            (piece (id "Seed" Shared)) 
                            (to ("NextHole")
                                (apply
                                    (set Var "NumCounters" (- (var "NumCounters") (value)))
                                )
                            ) 
                            count:(value)
                            (then
                                (if (< 0 (var "NumCounters"))
                                    (moveAgain)
                                    (set Value Mover (+ 1 (value Player Mover)))
                                )
                            )
                        )
                    )
                    (move Select
                        (from (sites Mover "Home") if:(> (count at:(from)) 0))
                        (then 
                            (and {
                                (moveAgain)
                                (remove (last To) count:(count at:(last To)))
                                (set Var "NumCounters" (count at:(last To)))
                            })
                        )
                    )
                )
            )
            (nextPhase Mover (= (value Player Mover) 1) "Sowing")
        )
        
        (phase "Sowing"
            (play 
                (do
                    (or
                        (move Select
                            (from (sites Mover "Home") if:(> (count at:(from)) 1))
                            (then 
                                (sow
                                    if:(or 
                                        (= (count at:(to)) 2) 
                                        (= (count at:(to)) 3)
                                    ) 
                                    apply:(fromTo 
                                        (from (to)) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:(to))
                                    )
                                    includeSelf:False
                                    backtracking:True
                                )
                            )
                        )
                        (move Select
                            (from (sites Mover "Home") if:(= (count at:(from)) 1))
                            (then (sow))
                        )
                    )
                    ifAfterwards:(< 0 (count in:(sites Next "Home")))
                )
            )
        )
        }
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )	
)
Ti is a two-row mancala-style baord game played by the Mende people of Sierra Leone. It can be played on pedestaled boards, or as holes in the ground. The holes of the board are called \2x6 board with two stores. Four counters per hole. Sowing occurs in an anti-clockwise direction. In the first and second moves, players may choose to drop as many counters as they wish into the holes they are sowing into. From the third turn on, the players must sow one counter at a time. The hole from which a sowing began is skipped if the sowing goes all the way around the board. When the final counter lands in a hole containing one or two people, thus causing it to contain two or three, these are captured. Any previous holes, in an unbroken sequence, also containing two or three counters, are captured. A move of a single counter cannot capture. When a player's row is empty, the opponent must sow into their row if it is possible to do so. Play ends when one player's row is empty, and the opponent claims all of the remaining counters. The player with the most counters wins. 

Construct a Ludii game based on the following description
Wold und Schaaf (wolf and sheep) is a game played in Germany. One player plays as four sheep, which attempt to block one wolf, who attempts to move behind the line of sheep.8x8 checkered board. One player plays as four sheep (white pieces), which begin on the four dark squares on one side of the board. The other player plays as one wolf (black piece), which can be placed on any dark space on the board. Players alternate turns moving a piece to an empty adjacent dark square on the board. The sheep move forward only but the wolf may also move backward. The goal of the sheep is to block the wolf from being able to move, the goal of the wolf is to move beyond the line of sheep. 
(game "Wolf und Schaaf" 
    (players 2) 
    (equipment { 
        (board (square 8)) 
        (piece "Sheep" P2 N ("StepToEmpty" (directions {FR FL}))) 
        (piece "Wolf" P1 "StepDiagonalToEmpty")
        (hand P1)
    }) 
    (rules 
        (start {
            (place "Wolf1" (handSite P1))
            (place "Sheep2" {"A1" "C1" "E1" "G1"})
        })
        
        phases:{
        (phase "Placement" P1 
            (play 
                (move 
                    (from (handSite P1)) 
                    (to (intersection (sites Phase 0) (sites Empty)))
                )
            )
            (nextPhase "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end {
            (if (and (no Moves P1) (is Mover P1)) (result P2 Win))
            (if ("WolfBeyondSheepRow") (result P1 Win))
        }) 
    )
)

Construct a Ludii game based on the following description
In his column in the July 1980 issue of Scientific American, Martin Gardner (well known for this writings on mathematical recreations), gives the following one dimensional chess variants.Here, the King and Rook move as usual, and the knight moves exactly two squares, and may jump over a piece doing that. Gardner asks his readers whether white can win. (White can make a draw by taking the opponents rook and thus giving stalemate.). Board of length 8.
(game "1D Chess" 
    (players 2) 
    (equipment { 
        (board (rectangle 1 <BoardSize:BoardSize>)) 
        ("ChessRook" "Rook")
        ("ChessKing" "King")
        (piece "Knight" Each ("LeapCapture" { {F F} }))
    }) 
    (rules 
        (start { 
            (place "Rook1" coord:"C1") (place "Knight1" coord:"B1") (place "King1" coord:"A1") 
            <BoardSize:PiecePlacement>
        })
        
        (play (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King" Mover))))
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Hund efter Hare is a blockade game played in Denmark. This version is from Vendsyssel, and has been played at least since the nineteenth century.Three diamonds in a row, the central one connecting to the others one opposite corners. A horizontal line connects the top corners of the diamonds, another horizontal line connects the bottom corners of the diamonds, and a longer horizontal line connects all the middle corners. The outer two diamonds have vertical lines connecting their top and bottom corners. One player plays as three hounds, which begin on the outer corner and top and bottom corner of one of the end diamonds. The other player plays as one hare, which begins on the central point of the same diamond. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. The Hare moves first. The hounds win by blocking the hare from being able to move. The game has an ending condition only for P2.
(game "Hund efter Hare (Vendsyssel)"
    (players 2)
    (equipment {
        (board 
            (add
                (merge {
                    (add (remove (rectangle 1 7) vertices:{3}) edges:{{2 3}})
                    (scale 2 (shift 0.5 -0.5 (rectangle 1 3)))
                    (scale 2 (shift 0.5 0.5 (rectangle 1 3)))
                })
                edges:{
                {0 9} {0 6} {11 5} {5 8} {1 6} 
                {1 9} {4 11} {4 8} {9 2} {2 7}
                {6 2} {2 10} {10 3} {3 8} {7 3}
                {3 11}
                }
            )
            use:Vertex
        )
        (piece "Hare" P1 "StepToEmpty")
        (piece "Dog" P2 "StepToEmpty")
    })
    (rules 
        (start {
            (place "Hare1" coord:"B2")
            (place "Dog2" (sites {"A2" "B1" "B3"}))
        })
        (play (forEach Piece))
        <End:rule>
    )
)

Construct a Ludii game based on the following description
Sher Bakr is a hunt game that was played in Shahpur, Punjab, India, in the early twentieth century.An isosceles triangle, with the height of the triangle and two lines, which bisect the sides of the triangle, but intersect the height at the same point, roughly central, such that they are at an angle but do not bisect it. One player plays as the tiger, which begins at the apex of the triangle, the other as four goats, which begin on the central point. The goats play first, removing one of the pieces from the stack to an adjacent empty spot. The tiger moves along the lines to an empty adjacent spot. The goats also move in this way. Goats may only be stacked on the central point. The tiger may capture a goat by jumping over it, and a jump from one side of the triangle to the opposite side, over the central point, is allowed. The goats win by blocking the tiger from being able to move, the tiger wins by capturing one goat. 
(game "Sher Bakr" 
    (players 2) 
    (equipment { 
        (board
            (rotate 180 
                (add
                    (remove 
                        (scale 1 2 (wedge 3)) 
                        vertices:{2}
                    )
                    vertices:{{2 1.333}}
                    edges:{{4 6} {6 0} {1 6} {6 2}}
                )
            )
            use:Vertex
        )
        (hand Each) 
        (piece "Goat" P1
            (move Step 
                (to 
                    if:(or 
                        (is Empty (to))
                        (and (= (to) (centrePoint)) ("IsFriendAt" (to)))
                    )
                )
            )
        )
        (piece "Tiger" P2
            (or {
                ("StepToEmpty")
                ("HopCapture")
                
                (if (and {(= (from) 2) ("IsEnemyAt" (centrePoint)) (is Empty 1)})
                    (move (from 2) (to 1) (then (remove (centrePoint))))
                )
                (if (and {(= (from) 1) ("IsEnemyAt" (centrePoint)) (is Empty 2)})
                    (move (from 1) (to 2) (then (remove (centrePoint))))
                )
            })
        )
    }) 
    (rules 
        (start {
            (place Stack "Goat1" (centrePoint) count:4)
            (place Stack "Tiger2" 0)
        })
        
        (play (forEach Piece top:True))
        
        (end {
            (if (no Moves P2) (result P1 Win))
            (if (= 3 (count Pieces P1)) (result P2 Win))
        })
    )
)

Construct a Ludii game based on the following description
Laomuzhu is a two-row mancala-style board game from the Yunnan region of China. It is similar to other mancala games from Asia, but it has extra capturing rules determined by the movement of specialized stones.2x5 board. Five counters per hole. Each player has a larger stone, which they place in any hole on their side of the board. Sowing proceeds in either direction, the first player chooses which and all sowing for the rest of the game proceeds in that direction. Players may sow from any hole on the board.  If the last counter falls into a hole with counters, the counters in the next hole are picked up and sowing continues, and if this hole is empty, the counters in the hole following the empty hole are captured. If there is an unbroken sequence of alternating empty and occupied holes, the counters in the occupied holes are captured until there are two empty or two occupied holes. If the final counter falls into an empty hole the turn ends. Also, if a large stone is dropped into an occupied hole during sowing, the contents of that hole are captured by the owner of the large stone, even if it is not the current player. If a player captures the other player's large stone, it is kept by the capturing player in subsequent rounds until it is captured. The game ends when one player's holes are empty, the opponent claiming the remainder of the counters. The players then attempt to fill all of the holes on their side of the board with either five counters or the large stone. Both large stones must be used to fill holes. Any holes that cannot be filled with five counters or a large stone are left empty, but may be sown into and played from as normal. Play continues in this fashion until one player cannot fill any holes.  
(game "Laomuzhu" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 5 store:None largeStack:True
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "4,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (piece "Ball" P1)
        (piece "Ball" P2)
        (hand Each size:2)
        (regions P1 (sites Bottom))  
        (regions P2 (sites Top))   
        (map {(pair P1 0) (pair P2 9)}) 
    }) 
    (rules 
        
        (start {
            (place Stack "Seed" (union (sites Bottom) (sites Top)) count:5)
            (place Stack "Ball1" (handSite P1 1))
            (place Stack "Ball2" (handSite P2 1))
        })
        
        phases:{
        (phase "Placement"
            (play
                (if (is Occupied Cell (handSite Mover 1))
                    (move
                        (from Cell (handSite Mover 1) level:(topLevel Cell at:((handSite Mover 1))))
                        (to (sites Mover))
                        stack:True
                    )
                )
            )
            
            (nextPhase Mover (is Empty Cell (handSite Mover 1)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (or {
                    (if (!= (var "Direction") 2)
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    (sites Mover) 
                                )
                                if:(!= 0 (size Stack at:(from)))
                            )
                            (then
                                (and {
                                    (forEach Value min:1 max:(size Stack at:(last From))
                                        (if (= (id "Seed" Shared) (what at:(last From) level:(- (size Stack at:(last From)) (value))))
                                            (fromTo
                                                (from (last From) level:(- (size Stack at:(last From)) (value)))
                                                (to ("NextHole" (last From) "TrackCCW" (value)))
                                                stack:True
                                            )
                                            (and
                                                (if (and (is Occupied ("NextHole" (last From) "TrackCCW" (value))) (!= ("NextHole" (last From) "TrackCCW" (value)) (last From)))
                                                    (if (= (who at:(last From) level:(- (size Stack at:(last From)) (value))) P1)
                                                        (forEach Level ("NextHole" (last From) "TrackCCW" (value)) FromTop
                                                            (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCCW" (value)) level:(level)))
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCCW" (value)) level:(level))
                                                                    (to (handSite P1))
                                                                )
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCCW" (value)) level:(level))
                                                                    (to (handSite P1 1))
                                                                )
                                                            )
                                                        )
                                                        (forEach Level ("NextHole" (last From) "TrackCCW" (value)) FromTop
                                                            (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCCW" (value)) level:(level)))
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCCW" (value)) level:(level))
                                                                    (to (handSite P2))
                                                                )
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCCW" (value)) level:(level))
                                                                    (to (handSite P2 1))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (fromTo
                                                    (from (last From) level:(- (size Stack at:(last From)) (value)))
                                                    (to ("NextHole" (last From) "TrackCCW" (value)))
                                                    stack:True
                                                )
                                            )
                                        )
                                    )
                                    (if (< (var "Direction") 1) (set Var "Direction" 1))
                                    (if (< (size Stack at:(last From)) 8)
                                        (if (!= 0 (size Stack at:("NextHole" (last From) "TrackCCW" (+ 1 (size Stack at:(last From))))))
                                            (and 
                                                (moveAgain)
                                                (set Var "Replay" ("NextHole" (last From) "TrackCCW" (+ 1 (size Stack at:(last From)))))
                                            )
                                            (if (is Occupied ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))))
                                                (forEach Level ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) FromTop
                                                    (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level)))
                                                        (fromTo
                                                            (from ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                            (to (handSite Mover))
                                                        )
                                                        (fromTo
                                                            (from ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                            (to (handSite Mover 1))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                })
                            )
                        )
                    )
                    (if (!= (var "Direction") 1)
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    (sites Mover) 
                                ) 
                                if:(!= 0 (size Stack at:(from)))
                            )
                            (then
                                (and {
                                    (forEach Value min:1 max:(size Stack at:(last From))
                                        (if (= (id "Seed" Shared) (what at:(last From) level:(- (size Stack at:(last From)) (value))))
                                            (fromTo
                                                (from (last From) level:(- (size Stack at:(last From)) (value)))
                                                (to ("NextHole" (last From) "TrackCW" (value)))
                                                stack:True
                                            )
                                            (and
                                                (if (and (is Occupied ("NextHole" (last From) "TrackCW" (value))) (!= ("NextHole" (last From) "TrackCW" (value)) (last From)))
                                                    (if (= (who at:(last From) level:(- (size Stack at:(last From)) (value))) P1)
                                                        (forEach Level ("NextHole" (last From) "TrackCW" (value)) FromTop
                                                            (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCW" (value)) level:(level)))
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCW" (value)) level:(level))
                                                                    (to (handSite P1))
                                                                )
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCW" (value)) level:(level))
                                                                    (to (handSite P1 1))
                                                                )
                                                            )
                                                        )
                                                        (forEach Level ("NextHole" (last From) "TrackCW" (value)) FromTop
                                                            (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCW" (value)) level:(level)))
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCW" (value)) level:(level))
                                                                    (to (handSite P2))
                                                                )
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCW" (value)) level:(level))
                                                                    (to (handSite P2 1))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (fromTo
                                                    (from (last From) level:(- (size Stack at:(last From)) (value)))
                                                    (to ("NextHole" (last From) "TrackCW" (value)))
                                                    stack:True
                                                )
                                            )
                                        )
                                    )
                                    (if (< (var "Direction") 1) (set Var "Direction" 2))
                                    (if (< (size Stack at:(last From)) 8)
                                        (if (!= 0 (size Stack at: ("NextHole" (last From) "TrackCW" (+ 1 (size Stack at:(last From))))))
                                            (and 
                                                (moveAgain)
                                                (set Var "Replay" ("NextHole" (last From) "TrackCW" (+ 1 (size Stack at:(last From)))))
                                            )
                                            (if (is Occupied ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))))
                                                (forEach Level ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) FromTop
                                                    (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level)))
                                                        (fromTo
                                                            (from ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                            (to (handSite Mover))
                                                        )
                                                        (fromTo
                                                            (from ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                            (to (handSite Mover 1))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                })
                            )
                        )
                    )
                    }
                    (then
                        (if ("NoPieceOnOwnedHoles" P1)
                            (forEach Site
                                (sites Board)
                                (if (is Occupied (site))
                                    (forEach Level (site) FromTop
                                        (if (= (id "Seed" Shared) (what at:(site) level:(level)))
                                            (fromTo
                                                (from (site) level:(level))
                                                (to (handSite P1))
                                                stack:True
                                            )
                                            (fromTo
                                                (from (site) level:(level))
                                                (to (handSite P1 1))
                                                stack:True
                                            )
                                        )
                                    )
                                )
                            )
                            (if ("NoPieceOnOwnedHoles" P2)
                                (forEach Site
                                    (sites Board)
                                    (if (is Occupied (site))
                                        (forEach Level (site) FromTop
                                            (if (= (id "Seed" Shared) (what at:(site) level:(level)))
                                                (fromTo
                                                    (from (site) level:(level))
                                                    (to (handSite P2))
                                                    stack:True
                                                )
                                                (fromTo
                                                    (from (site) level:(level))
                                                    (to (handSite P2 1))
                                                    stack:True
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (and (> 5 (size Stack Cell at:(handSite P1))) (= 0 (size Stack Cell at:(handSite P1 1))))
                        (result P2 Win)
                    )
                    (if (and (> 5 (size Stack Cell at:(handSite P2))) (= 0 (size Stack Cell at:(handSite P2 1))))
                        (result P1 Win)
                    )
                    }
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play 
                (or
                    (if (<= 5 (size Stack Cell at:(handSite Mover)))
                        (move Select
                            (from Cell (handSite Mover))
                            (to ("LeftMostEmpty"))
                            (then
                                (forEach Value min:1 max:5
                                    (fromTo
                                        (from Cell (last From) level:(- (size Stack Cell at:(last From)) (value)))
                                        (to (last To))
                                        stack:True
                                    )
                                )
                            )
                        )
                    )
                    (if (!= 0 (size Stack Cell at:(handSite Mover 1)))
                        (move Select
                            (from Cell (handSite Mover 1))
                            (to (sites Mover))
                            (then
                                (fromTo
                                    (from Cell (last From) level:(topLevel Cell at:(last From)))
                                    (to (last To))
                                    stack:True
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Symmetric Chess is played following each and every rules of Chess but making two slight adjustments appropriate to the 9x8 board.1) When castling king moves 3 squares towards either rook. 2) Both bishops of each player cannot run along squares of a same color. One of them must change in such a manner that it transits through squares of the other color. Being in its original square without having been moved before, it will take an orthogonal step towards any of the 3 surrounding squares that are of the other color, provided that these are empty. This special move is called conversion and it must be done as an ordinary move during the game. 
(game "Symmetric Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (rectangle 8 9)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        
        (piece "Bishop" Each 
            (or {
                ("SlideCapture"
                    (from if:(!= (state at:(from)) 2))
                    Diagonal 
                    (then (set Counter))
                    (then
                        (and
                            (forEach Site (sites Occupied by:Mover component:"Bishop")
                                (set State at:(site) 2)
                            )
                            (set State at:(last To) 0) 
                        )
                    )
                )
                (move Step 
                    Orthogonal
                    (to 
                        if:(and (not ("IsFriendAt" (to))) (!= (state at:(from)) 0)) 
                        (apply 
                            (if ("IsEnemyAt" (to))
                                (remove 
                                    (to) 
                                    (then (set Counter))
                                )
                            )
                        ) 
                    ) 
                    (then
                        (forEach Site (sites Occupied by:Mover component:"Bishop")
                            (set State at:(site) 0)
                        )
                    )
                )
            })
        )
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "I1") (pair 2 "I8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "I1"} state:1) (place "Knight1" {"B1" "H1"}) (place "Bishop1" {"C1" "G1"} state:1) (place "Queen1" {"D1" "F1"}) (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "I8"} state:1) (place "Knight2" {"B8" "H8"}) (place "Bishop2" {"C8" "G8"} state:1) (place "Queen2" {"D8" "F8"}) (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        (if (and 
                                ("HasNeverMoved" "King")
                                (not ("IsInCheck" "King" Mover)) 
                            )
                            (or
                                (if (and 
                                        ("HasNeverMoved" "RookLeft")
                                        (can Move ("CastleRook" "RookLeft" E 2 (is Empty (to))))
                                    )
                                    "BigCastling"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookRight")
                                        (can Move ("CastleRook" "RookRight" W 2 (is Empty (to))))
                                    )
                                    "SmallCastling"
                                )
                            )
                        )
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Rab'e is a three-row mancala-style board game played in Eritrea. It is different from other three-row games because captures may happen at any time during the player's move.3x6 board. Four counters per hole. Each player controls one row of holes and the half of the central row to their right. Sowing occurs from left ro right in the player's full row, right to left in their holes in the central row, then right to left in the opponent's full row, then left to right in the opponent's holes in the central row, at that point continuing into the player's full row again. When the final counter is sown into an occupied hole, the counters are picked up and sowing continues. When the final counter falls into an empty hole, the turn ends. At any point while the player sows, if a hole is made to contain four counters, these are captured, regardless of who the hole belongs to. When the final counter causes a capture, the turn ends. Play continues until a player has no counters in their holes. The opponent then captures the remaining counters. Players then redistribute their counters, four in each hole, starting from the leftmost hole in their row in the direction of play. The player with fewer counters distributes all of their counters on the board, even if they cannot place four in the final hole of the counting. The player with more counters then places four counters in the same number of holes as the other player, taking any remaining as their winnings. Play continues in this fashion until one player captures all of the counters. 
(game "Rab'e" 
    (players 2) 
    (equipment { 
        (mancalaBoard 3 "Columns" store:None
            (track "Track" "0,E,N1,W2,17,W,S1,E2" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (union (sites Bottom) (difference (expand (sites Right) steps:2) (sites Top)))) 
        (regions P2 (union (sites Top) (difference (expand (sites Left) steps:2) (sites Bottom)))) 
        (hand Each)
        (map "LeftMost" {(pair P1 0) (pair P2 17)}) 
        (map "CorrespondingHoles" {
            (pair 0 17) (pair 1 16) (pair 2 15) (pair 3 14) (pair 4 13) (pair 5 12) (pair 11 6) (pair 10 7) (pair 9 8) 
            (pair 8 9) (pair 7 10) (pair 6 11) (pair 12 5) (pair 13 4) (pair 14 3) (pair 15 2) (pair 16 1) (pair 17 0)
        })
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from 
                            (if ("SameTurn")
                                ("LastHoleSowed") 
                                (sites Mover) 
                            )
                            if:(< 0 (count at:(from)))
                        )
                        (then
                            (do
                                (set Var "NumSowed" (count at:(last To)))
                                next:(sow
                                    apply:(if (and (!= 4 (count at:(to))) (< 1 (count at:(to)))) (moveAgain))
                                )
                                (then
                                    (and
                                        (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed")))
                                            (if (= 4 (count at:(site)))
                                                (fromTo
                                                    (from (site))
                                                    (to (handSite Mover))
                                                    count:4
                                                )
                                            )
                                        )
                                        (set Var "NumSowed" 0)
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OneHomeEmpty")
                            (and { 
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (if (<= ("NumCapturedPieces" P1) ("NumCapturedPieces" P2))
                                    (set NextPlayer (player 1))
                                    (set NextPlayer (player 2))
                                )
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:4
                        (then
                            (if (<= 4 (count Cell at:(handSite Mover)))
                                (moveAgain)
                                (and
                                    (if (!= 0 (count Cell at:(handSite Mover)))
                                        (and
                                            (fromTo
                                                (from (handSite Mover))
                                                (to ("LeftMostEmpty"))
                                                count:(count Cell at:(handSite Mover))
                                            )
                                            (fromTo
                                                (from (handSite Next))
                                                (to (mapEntry "CorrespondingHoles" ("LeftMostEmpty")))
                                                count:(count Cell at:(handSite Next))
                                            )
                                        )
                                    )
                                    (forEach Site (sites Mover)
                                        (if (is Occupied (site))
                                            (fromTo
                                                (from (handSite Next))
                                                (to (mapEntry "CorrespondingHoles" (site)))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (= 0 (count Cell at:(handSite Mover))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Pieces move the same as they do in standard chess, but a piece transfers at the completion of its move to the opposite board.A move in Alice chess has two basic stipulations: the move must be legal on the board on which it is played, and the square transferred to on the opposite board must be vacant. (Consequently, capture is possible only on the board upon which a piece currently stands). The en passant rule is removed. 
(game "Alice Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        (piece "Pawn" Each 
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    "DoubleStep"
                )
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                }
                (then
                    (and {
                        (if (is In (last To) (sites Mover "Promotion")) 
                            (moveAgain)
                        )
                        (set Counter)
                        (set Value at:(last To) (% (+ (value Piece at:(last To)) 1) 2))
                    })
                )
            )
        )
        
        (piece "Rook" Each 
            (move Slide 
                Orthogonal 
                (between 
                    if:(or
                        (is Empty (between))
                        (!= (value Piece at:(from)) (value Piece at:(between)))
                    )
                ) 
                (to 
                    if:(and ("IsEnemyAt" (to)) (= (value Piece at:(from)) (value Piece at:(to))))
                    "CaptureToPieceAndResetCounter"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "King" Each 
            (move Step 
                (to 
                    if:(and (not ("IsFriendAt" (to))) (or (is Empty (to)) (= (value Piece at:(from)) (value Piece at:(to)))))
                    "CaptureToPieceAndResetCounter"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "Bishop" Each 
            (move Slide 
                Diagonal 
                (between 
                    if:(or
                        (is Empty (between))
                        (!= (value Piece at:(from)) (value Piece at:(between)))
                    )
                ) 
                (to 
                    if:(and ("IsEnemyAt" (to)) (= (value Piece at:(from)) (value Piece at:(to))))
                    "CaptureToPieceAndResetCounter"
                ) 
                (then
                    (set Value at:(last To) (% (+ (value Piece at:(last To)) 1) 2))
                )
            )
        )
        (piece "Knight" Each 
            (move Leap 
                "KnightWalk" 
                (to 
                    if:(and (not ("IsFriendAt" (to))) (or (is Empty (to)) (= (value Piece at:(from)) (value Piece at:(to)))))
                    "CaptureToPieceAndResetCounter"
                ) 
                (then
                    (set Value at:(last To) (% (+ (value Piece at:(last To)) 1) 2))
                )
            )
        )
        (piece "Queen" Each 
            (move Slide 
                (between 
                    if:(or
                        (is Empty (between))
                        (!= (value Piece at:(from)) (value Piece at:(between)))
                    )
                ) 
                (to 
                    if:(and ("IsEnemyAt" (to)) (= (value Piece at:(from)) (value Piece at:(to))))
                    "CaptureToPieceAndResetCounter"
                ) 
                (then
                    (set Value at:(last To) (% (+ (value Piece at:(last To)) 1) 2))
                )
            ) 
        )
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (do (set Var "promotedValue" (value Piece at:(last To)))
                    next:(move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover 
                        (then (set Value at:(last To) (var "promotedValue"))) 
                    )
                )
                (do 
                    (or 
                        (forEach Piece)
                        ("Castling")
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Dash Guti is a game with leaping captures played in India, and similar to many other games with similar movement and capturing rules.Each player lays out the pieces on the board on the intersections of the lines, each filling all the intersections of the triangle closest to the player, plus the extra intersection to their right. Play moves to the next adjacent intersection connected by a line. Opponent's pieces can be captured by hopping over them. The player who captures all of the opponent's pieces wins. 
(game "Dash Guti" 
    (players 2) 
    (equipment { 
        (board 
            (add
                (merge {
                    (wedge 4)
                    (shift 0 3 (rotate 180 (wedge 4)))
                })
                vertices:{{0 3} {6 3}}
                edges:{{7 19} {19 18} {0 19} {0 20} {20 16} {20 9}}
            )
            use:Vertex
        )
        (piece "Counter" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Counter1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (intersection (sites Row 3) (sites Left))}))
            (place "Counter2" (union {(sites Row 6) (sites Row 5) (sites Row 4) (intersection (sites Row 3) (sites Right))}))
        })
        
        (play (forEach Piece))
        
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
In 1967, an US game company called Diversified Creations marketed a chess variant called Official Football Chess. Same rules as Chess, just a different setup. 
(game "Official Football Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "D1") (pair 2 "D8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites {"B2" "C2" "E2" "F2"}))
            (place "Pawn2" (sites {"B7" "C7" "E7" "F7"}))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"D2"}) (place "Bishop1" {"A2" "H2"}) (place "Queen1" coord:"E1") (place "King1" coord:"D1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"D7"}) (place "Bishop2" {"A7" "H7"}) (place "Queen2" coord:"E8") (place "King2" coord:"D8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        (if (and 
                                ("HasNeverMoved" "King")
                                (not ("IsInCheck" "King" Mover)) 
                            )
                            (or
                                (if (and 
                                        ("HasNeverMoved" "RookLeft")
                                        (can Move ("CastleRook" "RookLeft" E 3 (is Empty (to))))
                                    )
                                    "BigCastling"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookRight")
                                        (can Move ("CastleRook" "RookRight" W 2 (is Empty (to))))
                                    )
                                    "SmallCastling"
                                )
                            )
                        )
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Theseus and the Minotaur is a type of logic maze designed by Robert Abbott. In this maze, the player acts as Theseus, who is attempting to escape the Labyrinth.The goal of Theseus is to escape of the labyrinth. Theseus can step orthogonally but after steping the Minotaur comes closer to him twice faster. If the minotaur catches him, Theseus dies. The board in Wikipedia. The minotaur comes closer to Theseus in looking only the number of orthogonal steps without to take in account the walls. Theseus wins immediately if he reaches the exit.
(game "Theseus and the Minotaur" 
    (players 1) 
    (equipment { 
        (board <Board:type>) 
        (piece "Theseus" P1 
            (move Step 
                Orthogonal 
                (to 
                    if:(and (is Empty (to)) ("NoEdgeBetweenCells" (from) (to)))
                )
            )
        )
        (piece "Minotaur" Neutral)
        (piece "Marker" Shared)
        (regions "Exit" {<Board:exit>})
    }) 
    (rules 
        (start {
            (place "Theseus" coord:<Board:startTheseus>)
            (place "Minotaur0" coord:<Board:startMinotaur>)
            (set 
                Shared 
                Edge 
                (union 
                    (sites Outer Edge) 
                    (sites {<Board:walls>})
                )
            )
        })
        (play
            (or
                (forEach Piece)
                (move Pass)
                (then
                    <Minotaur:threat>
                )
            )
        )
        (end {
            (if (no Pieces Mover) (result Mover Loss))
            (if (is In (where (id "Theseus")) (sites "Exit")) (result Mover Win))
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Sumi Naga Game (Hunt)" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Goat" P1 "StepToEmpty")
        (piece "Tiger" P2
            (or
                ("StepToEmpty")
                ("HopSequenceCapture")
            )
        )
        (hand P1)
    }) 
    
    (rules 
        (start { 
            (place "Goat1" (handSite P1) count:20)
            (place "Tiger2" (sites Corners))
        })
        
        phases:{
        (phase "Placement" P1 
            (play (move (from (handSite P1)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" Mover) "Moving")
        )
        (phase "Moving" (play (forEach Piece)))
        }
        
        (end ("NoMovesP2NoPiecesP1"))
    )
)
This game, played by the Sümi Naga people of India, is a hunt game played with four tigers against twenty goats.5x5 intersecting lines, with diagonals drawn in each quadrant. One player plays as four tigers, which begin on the four corners of the board. The other player plays as twenty goats, which begin off the board. Play begins by placing one of the goats on an empty spot. The other player then moves the tiger to an empty adjacent spot along the lines on the board. The tiger may hop over an adjacent goat, to an empty space on the opposite adjacent side of the goat along the lines. Play continues like this until all of the goats are placed, after which the goats also move to one adjacent spot along the lines. The tigers win by capturing all of the goats; the goats win by blocking the tigers from being able to move. 

Describe the mechanics of the following Ludii game
(game "The SmallHolder"
    (players 2)
    (equipment
        {
        (board <Board:type> use:Cell)
        
        (piece "Disc" Each)
        }
    )
    (rules
        (play
            <Group:creationRule>
        )
        (end 
            "EndNoMoves"
)))
'The Smallholder' is an evolution of the game Offshore to find a similar game that is easier to play on a physical set.
            The game gives up most of the counting: 
            No territory counting - last to place wins; 
            No tracking of the larger group sizes.
            
            The concept started with the ancestor of Offshore (no counting) and then added in a different placement limitation:
            
            -- Must play to form a new group, or, if there are already multiple groups, may also play to merge or extend the smallest group.
            
            This rule is much easier to visualize without counting.
            The rule has further evolved to require forming a new group if there are less than 2 groups that have adjacent playable sites.
            
            Next, piecewise capture was introduced, and finally, the 'hull' notion of territory was replaced with territory defined as spaces between two members of a group, to make the play tighter and more tactical, as well as being easier to visualize.
            
            Some further options improved play: Excluding blocked groups from counting as smallest group, or from counting towards the 2 viable group requirement, allows freer play, and make the Hull version more viable. 
            
            The options are left available so that players can assess on their own the value of these changes.
            The main division is between Gap based territory and Hull based territory.
            
            ---------------     
            Hull territory games such as 'Setback', feature more aggressive territorial fights.
            If the Group option is set to any type of priority, the end game features a fill in phase, and territorial area is the primary concern.
            
            Otherwise, as in the 'Setback' game, itself, the strategy is to keep 2 groups as long as possible, and at the critical moment link them to wipe out all but one of the opponent groups, and to hold enough territory that the opponent has nowhere to form a new group. Link too early, and you will need to form your own new group. 
            
            In the case of placement being to the absolute smallest groups, an additional strategy gains dominance: Trapping a small group without capturing it - the smaller the better. Then the opponent must constantly create new groups instead of expanding to capture you.
            
            The Hull game played with Piecewise capture tends to lead to turnovers, and to lead to endings of one sparse group each - possibly the fastest version.  
            
            When applied together with the Group 'priority' option, however, these groups tend to fill in as opposing chevrons, first to fill-in losing.
            
            --------------
            The Gap based games are tighter conflicts, suited to piecewise capture because holdings expand too slowly for groupwise capture to occur frequently.
            
            The original Gap game required group creation and adding to absolute smallest group, leading to the tactics of boxing in singletons at the corners or any other small groups so that expansion would be impossible. This is the game's tension as capture and control is driven by reducing many groups to fewer larger ones.
            
            This rule drives new group formation automatically. 
            Easing the extension rule to placement 'next to the smallest PLAYABLE group,' makes the game more interesting: - then the Group formation rule keeps the same dynamic but less strictly. 
            
            With the group rule then set to 'must create if less than 2 playable' we get 'Nibbler' which is the closest to the original (strictest.) 
            
            If the rule less than 2 ABSOLUTE is used a trapped group becomes an advantage, and least strict rules, using Priority to drive group creation are no longer about trapping at all, and more similar to the source game 'Offshore' - building groups to capture each other maximise territory, except it is based on Gap territory rather than Hull territory.
            
        Finally, 'Stymie' is a Gap game that uses Group capture with re-entry to minimise the influence of capture, and minimal requirement for new group creation, to make a game focussing on filling, where the purpose of the filling is to trap a small group, and not run out of merging plays yourself.  One loses this game due to not being able to play next to one's smallest group.Goal: Last to place a stone, wins.
                
                Definitions:
                -- Stones are connected if they are the same color and next to each other orthogonally.
                -- Groups consist of connected stones. 
                Every stone is part of exactly one group. Every group contains all the stones connected to it. 
                (Groups without any adjacent playable sites are shown with grey dots, for convenience.)
                
                Play starts with black. Turns alternate. Passing is not allowed.
                
                A player with less than 2 groups with adjacent playable sites must place a stone to create a new group, or LOSE.     
                Otherwise, placement is allowed next to a group of the same size as the smallest mover's group with an adjacent playable site.
                
                Group holdings are all the sites that lie between pairs of each group's members.
                After placement, capture every enemy STONE within friendly holdings. 
                
                Placement inside the opponent's holdings is forbidden.
                
        -- Nibbler is close to the original Gap game, but gives a bit more freedom in play, and may work better than the original on larger boards. 232323 Hexagon Board A player with a single group must create a new group, or LOSE. Otherwise, placement is allowed next to a group of the same size as the smallest mover's group with an adjacent playable site. Group holdings are all the sites that lie between pairs of each group's members. After placement, capture every enemy STONE within friendly holdings. Placement inside the opponent's holdings is forbidden.

Construct a Ludii game based on the following description
Alquerque or Alquerque de Doze was the Spanish version of a game which originated in the Arabic-speaking world. The first description of rules are found in Alfonso X's Libro de los Juegos in 13th century Spain. Many historians consider Alquerque to be an ancestor of Draughts and many other games in cultures that interacted with Islamic peoples or the Spanish.The board consists of 5x5 intersecting lines with diagonals. Pieces are placed on the intersections and can move along the lines. Each player has 12 pieces. Pieces can move to one adjacent point. Captures can be made by hopping over an opponent's piece. The goal is to capture all of the opponent's pieces. No force capture, no sequence.
(game "Alquerque" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Counter" Each)
    }) 
    
    (rules 
        (start { 
            (place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"}) }))
            (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top)) }))
        })
        
        <Play>
        
        (end ("NoMoves" Loss)) 
    )
)

Construct a Ludii game based on the following description
Gabata is a term used to refer to several mancala-style games in the Horn of Africa. This version is a two-row game played by an Oromo woman in Addis Ababa.2x6 board. Four counters in each hole. Play begins with a stylised move. One player takes the four counters in their leftmost hole and places them into the next hole, moving in an anti-clockwise direction. They then take the four counters in the next hole, and place them in the following holes. This continues until the entire board has an alternation pattern of a hole with eight counters followed by one with zero counters. The player then sows beginning from the final hole with eight counters they created. When the final counter of a sowing lands in a hole with counters, the player picks up these counters and sowing continues. When the final counter falls into an empty hole, the turn ends. At any time during the sowing a hole is made to contain four counters, they are captured by the player who is sowing, except when it is the final hole of a sowing, in which case they are picked up and sowing continues. If a player cannot play, they must pass their turn and may resume play when they are next able. When all of the counters have been captured, the player who captured the most counters wins. 
(game "Gabata (Oromo)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        phases:{
        (phase "Opening1"
            (play
                (move Select 
                    (from
                        (if ("SameTurn")
                            (var "Replay")
                            0
                        )
                    )
                    (then
                        (sow
                            numPerHole:4
                            apply:(and
                                (moveAgain)
                                (if (is Occupied ("NextHole" (to) 1))
                                    (set Var "Replay" ("NextHole" (to) 1))
                                    (set Var "Replay" Undefined)
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (= Undefined (var "Replay")) "Opening2")
        )
        
        (phase "Opening2"
            (play
                (move Select 
                    (from
                        (if (and ("SameTurn") (!= Undefined (var "Replay")))
                            (var "Replay")
                            6
                        )
                    )
                    (then
                        (do
                            (set Var "NumSowed" (count at:(last To)))
                            next:(sow
                                apply:(if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                )
                            )
                            (then
                                (and
                                    (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1)))
                                        (if (= 4 (count at:(site)))
                                            (fromTo
                                                (from (site))
                                                (to (handSite Mover))
                                                count:4
                                            )
                                        )
                                    )
                                    (set Var "NumSowed" 0)
                                )
                            )
                        )
                    )
                )
            )
            
            (nextPhase (not (is Next Prev)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (move Select 
                    (from
                        (if (and ("SameTurn") (!= Undefined (var "Replay")))
                            (sites {(var "Replay")})
                            (sites Mover)
                        )
                        if:(is Occupied (from))
                    )
                    (then
                        (do
                            (set Var "NumSowed" (count at:(last To)))
                            next:(sow
                                apply:(if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                )
                            )
                            (then
                                (and
                                    (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1)))
                                        (if (= 4 (count at:(site)))
                                            (fromTo
                                                (from (site))
                                                (to (handSite Mover))
                                                count:4
                                            )
                                        )
                                    )
                                    (set Var "NumSowed" 0)
                                )
                            )
                        )
                    )
                )
            )
        )
        
        }
        
        (end ("MancalaByScoreWhen" ("NoPieceOnBoard")))
        
    )
)

Construct a Ludii game based on the following description
The Icosian Game was invented in 1857 by William Rowan Hamilton. It is also called the Hamiltonian game (Ball and Coxeter 1987, p. 262), is the problem of finding a Hamiltonian cycle along the edges of a dodecahedron. Hamilton sold this game to a London game dealer in 1859 for 25 pounds, and the game was subsequently marketed in Europe in a number of forms (Gardner 1957). The game marketed two versions of it, under the name Around the World. One version, for the parlor, was played on a flat board; another, for the traveler, consisted of an actual dodecahedron. In both cases, nails at each vertex stood for a major city of the world and the player wrapped a piece of string around these nails as they went. In the event, the game was a complete sales flop, mainly because it was too easy, even for children – but not for Hamilton himself who always used the icosian calculus to figure out his moves, instead of just trying different paths like everyone else!The player aims to make a Hamiltonian cycle, which is a path in which each vertex is visited once, no edge is visited twice, and the ending point is the same as the starting point. 
(game "Icosian" 
    (players 1)
    (equipment { 
        (board 
            (graph
                vertices:{ 
                {4 0} {12 0} {5 3} {8 4} {11 3} {4 6} {6 7} {8 6} {10 7} {12 6} 
                {0 10} {3 9} {7 9} {9 9} {13 9} {16 10} {5 11} {11 11} {8 13} {8 16}}
                edges:{
                {0 1} {0 2} {0 10} {1 4} {1 15} {2 3} {2 5} {3 4} {3 7} {4 9} {5 6} 
                {5 11} {10 11} {11 16} {6 12} {6 7} {7 8} {8 9} {9 14} {14 15} {8 13} 
                {13 12} {12 16} {13 17} {14 17} {16 18} {18 17} {18 19} {10 19} {15 19}}
            )
            use:Vertex
        )   
    }) 
    
    (rules 
        phases:{
        (phase "Init" P1 
            (play 
                (move Add
                    (to
                        Edge 
                        (sites Empty Edge)	 
                    )
                )
            )
            (nextPhase "PathMaking") 
        )
        
        (phase "PathMaking" P1 
            (play 
                (or
                    (do 
                        (move Add
                            (to
                                Edge 
                                (sites Empty Edge)   
                            )
                        )
                        ifAfterwards:"IncressPath"
                    )
                    (do 
                        (move Add
                            (to
                                Edge 
                                (sites Empty Edge)
                            )
                        )
                        ifAfterwards:"HamiltonianCycle"
                    )
                )
            )	   
        )
        }  
        (end 	 	
            (if 
                (>= (count Moves) (count Sites "Board")) 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Mogul Putt'han is played throughout South Asia, documented since the early nineteenth century and likely is older. It is played on an alquerque board with triangular extensions on two opposite sides.Game is played on an Alquerque board with 5x5 intersecting lines and with a triangular appendage on either side. Each player has sixteen pieces, which are placed on the intersections and move along the lines to the next open intersection. Players can hop opponents pieces to capture them. Multiple captures in one turn are allowed. A player wins when they capture all of the opponent's pieces or block them from being able to move. The game is played with sixteen pieces.
(game "Mogul Putt'han" 
    (players 2) 
    (equipment { 
        <Start:board>
        (piece "Marker" Each 
            (or 
                ("HopSequenceCapture")
                ("StepToEmpty")
            )
        )
    }) 
    (rules 
        <Start:rules>
        
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
 Select groups in order for both players Order 3 limping board (27 cell)
(game "Sprout-R-Out" 
    (players 2)
    (equipment
        {
        (board (trim <Board:type> )  use:Cell)
        (piece "Ball" Each )
        }
    )
    (rules
        (meta (no Repeat Positional))
        (play
            (if "SameTurn"
                "Placements"
                (do 
                    (forEach Site (sites Occupied by:Next)
                        (set State at:(site) 1)
                    )
                    next:(priority
                        {
                        "PlaceOutsideImmortalTerritory"
                        "RemoveGroupOfNext"
                        (move Pass)
                        }
                ))
                (then
                    (and 
                        {
                        (set Score P1 ("ScoreOf" "P1"))
                        (set Score P2 ("ScoreOf" "P2"))
                        (if
                            (is Mover P1)
                            (set Value Mover ("ValueOf" "P1"))
                            (set Value Mover ("ValueOf" "P2"))
                        )
                        (if
                            (not (is Next Mover))
                            (forEach Site (sites Occupied by:Next)
                                (set State at:(site) 0)
                        ))
                        }
                ))
        ))
        (end 
            (if 
                "EndCondition"
                {
                (if
                    (= 
                        (score P1) 
                        (score P2)
                    )
                    (result Mover Win)
                )
                (if
                    "EndCondition"
                    (byScore)
                )
                }
))))

Construct a Ludii game based on the following description
Fractal is a two player game. The unique board, starts out empty. The two players, Red and Blue, take turns coloring cells with their own color, one cell per turn, starting with Red.The two players, Red and Blue, take turns coloring cells with their own color, one cell per turn, starting with Red.
            
        To win you must form a path of cells of your own color connecting the two border regions of your color. 
(game "Fractal"
    (players 2)
    (equipment {
        (board 
            (add
                (add
                    (union
                        
                        (shift 3.45 6
                            (scale 3
                                (remove
                                    (remove
                                        (clip
                                            (hex 3)
                                            (poly { { 0 1} { 2 1 } { 4 5 } { 1 4 } })
                                        )
                                        cells:{9}
                                    )
                                    vertices:{26 30 34 39 35 40 36 31 27 22 18 14 9 13 8 12 17 21 25}
                                )
                            )
                        )
                        
                        (union 
                            
                            (remove
                                (shift 5.77 10
                                    (scale 0.333
                                        (remove
                                            (remove 
                                                (hex Star 5)
                                                cells:{0 1 2 3 4 5 6 7 8 9
                                                30 29 45 28 44 59 27 43 58 72
                                                165 164 149 163 148 134 162 147 133 120
                                                180 178 179 175 176 177 171 172 173 174
                                                150 135 151 152 136 121 108 122 137 153
                                                15 16 31 17 32 46 18 33 47 60
                                                }
                                            )
                                            cells:{
                                            0 1 2 3 4 12 21 31 42 54 77 88 98 107 115
                                            120 119 118 117 116 108 99 89 78 66
                                            43 32 22 13 5 
                                            6 8 9 11 30 41 65
                                            87 97 114 112 111 109 90 79 55 33 23
                                            }
                                        )
                                    )
                                )
                                vertices:{0..40 42 43 45..50 62..67 80..84 97..100 113..116
                                128..131 143..146 158..160 173 174 187 200 212 224 366
                                237 250 263 264 276..278 290..293 305..308 321..324
                                337..340 353..357 369..374 375..380 382 383 385..425
                                358..363 341..345 325..328 309..312 294..297 279..282
                                265..267 251 252 238 225 213 201 188 175 161..162
                                147..149 132..135 117..120 101..104 85..88 68..72 51..56 59
                                }
                            )
                            
                            
                            (remove
                                (remove
                                    (remove
                                        (remove
                                            (remove 
                                                (hex Star 5)
                                                cells:{0 1 2 3 4 5 6 7 8 9
                                                30 29 45 28 44 59 27 43 58 72
                                                165 164 149 163 148 134 162 147 133 120
                                                180 178 179 175 176 177 171 172 173 174
                                                150 135 151 152 136 121 108 122 137 153
                                                15 16 31 17 32 46 18 33 47 60
                                                }
                                            )
                                            cells:{
                                            0 1 2 3 4 12 21 31 42 54 77 88 98 107 115
                                            120 119 118 117 116 108 99 89 78 66
                                            43 32 22 13 5 
                                            6 8 9 11 30 41 65
                                            87 97 114 112 111 109 90 79 55 33 23
                                            }
                                        )
                                        cells:{
                                        26 27 35 36 37 45 46
                                        }
                                    )
                                    vertices:{
                                    193 180 167 181 168 182 195 208 220 232 245 258 244 257 243 230 217 205
                                    }
                                )
                                vertices:{188 198 199 208 209 219
                                0..40 42 43 59 45..50 62..67 80..84 97..100 113..116 128..131 
                                143..146 158..160 171..172 182 193 203 213 224 234 245 246
                                258..260 272..275 287..290 303..306 319..322 335..339 351..362
                                364 365 367..407 340..345 323..327 307..310 291..294 276..279
                                261..264 247..249 235 236 225 214 204 194 183 173 161 162
                                147..149 132..135 117..120 101..104 85..88 68..72 51..56
                                }
                            )
                        )
                    )
                    edges:{
                    {216 4} {7 229} {217 5} {236 8} {12 282} {18 318} {22 364}
                    {25 378} {24 377} {21 357} {17 311} {11 275} {91 286}
                    {43 270} {30 262} {31 263} {50 271} {287 101} {307 154} 
                    {323 202} {331 215} {330 214} {322 195} {306 144}
                    }
                )
                cells:{ 
                {0 4 216 218 223 230 222 229 7 3}
                {4 1 5 217 220 226 233 225 232 224 219 216}
                {5 2 6 8 236 228 235 227 221 217}
                {8 10 12 282 274 281 273 266 258 251 244 236}
                {12 14 16 18 318 310 302 296 290 282}
                {18 20 22 364 356 348 341 334 325 317 326 318}
                {22 26 29 25 378 376 370 363 371 364}
                {25 28 24 377 373 367 360 368 361 369 375 378}
                {24 27 23 21 357 365 358 366 372 377}
                {21 19 17 311 319 312 320 327 335 342 349 357}
                {17 15 13 11 275 283 291 297 303 311}
                {275 11 9 7 229 237 245 252 259 268 276 267}
                {43 36 44 37 32 30 262 254 261 270}
                {30 33 38 46 39 47 40 34 31 263 255 262}
                {31 35 41 49 42 50 271 264 256 263}
                {50 58 65 72 80 89 100 90 101 287 279 271}
                {101 112 122 132 143 154 307 300 294 287}
                {202 323 315 307 154 164 153 163 172 179 186 194}
                {323 332 339 331 215 213 208 201 209 202}
                {338 331 215 212 207 199 206 198 205 211 214 330}
                {330 337 329 322 195 203 196 204 210 214}
                {322 314 306 144 155 145 156 165 173 180 187 195}
                {306 299 293 286 91 102 113 123 133 144}
                {286 278 270 43 51 59 66 73 82 92 81 91}
                }
            )
        )
        (piece "Marker" Each)
        (regions P1 {(sites Side NW) (sites Side SE) })
        (regions P2 {(sites Side NE) (sites Side SW) })
    })
    (rules
        (play (move Claim (to (sites Empty))))
        (end (if (is Connected Mover) (result Mover Win))) 
    )
)

Construct a Ludii game based on the following description
Flower Shop is a colorful dynamic connection game invented by Mihaw Zapawa.Flower Shop is played on a hexhex board and uses the 12* placement protocol, that is: barring the first player's first placement, which must be a single piece, players make two placements in a turn. There are two types of pieces: impartial *stalks* (green) and partial *flowers* (pink and yellow). A maximal set of connected stalks is called a *plant*.
            
            Rules
            There are two placement restrictions:
            1. Each flower may be adjacent to no more than one stalk and no other flowers.
            2. Each plant can only be adjacent to at most one colour of flowers.
            
            The game ends when no legal placements can be made. The *worth* of each plant is the number of stalks in it times the number of flowers adjacent to it. The *score* of each player is the total worth of all the plants adjacent to his flowers. Highest score wins. In case of equal scores, no player wins.
            
        (Description taken - but slighlty adapted - from mindsports.nl.) 
(game "Flower Shop"
    (players 2)
    (equipment {
        (board (hex 7))
        (tile "Hex" Each)
        (piece "Disc" Neutral)
    })
    (rules
        (play
            (do
                (or
                    (move Add
                        (piece (mover))
                        (to 
                            (sites Empty)
                            if:(= 0
                                (count Sites
                                    in:(intersection
                                        (sites Occupied by:All component:"Hex")
                                        (sites Around (to) Orthogonal)
                                    )
                                )
                            )
                        )
                    )
                    (move Add
                        (piece "Disc0")
                        (to (sites Empty))
                    )
                )
                ifAfterwards:(and
                    (all Sites
                        (sites Occupied by:All component:"Hex")
                        if:(> 2
                            (count Sites
                                in:(intersection
                                    (sites Around
                                        (site)
                                        Orthogonal
                                    )
                                    (sites Occupied by:Neutral)
                                    
                                )
                            )
                        )
                    )
                    (all Sites
                        (sites Occupied by:Neutral)
                        if:(not
                            (and
                                (< 0
                                    (count Sites
                                        in:(sites Around
                                            (sites Group at:(site))
                                            Own
                                            Orthogonal
                                        )
                                    )
                                )
                                (< 0
                                    (count Sites
                                        in:(sites Around
                                            (sites Group at:(site))
                                            Enemy
                                            Orthogonal
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (then
                    (if
                        (= 1 (% (+ 1 (count Moves)) 2))
                        (moveAgain)
                    )
                )
            )
        )
        (end 
            (if (all Passed) 
                (byScore {
                    (score P1 ("Score" P1))
                    (score P2 ("Score" P2))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Gabata is a term for many games played throughout the Horn of Africa. This version is played in Ghinda, and is similar to others played throughout Eritrea.2x6 board. Four counters per hole. Each player takes their first turn from their leftmost hole. Sowing occurs in an anti-clockwise direction. If the final counter falls into an occupied hole, these are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends. At any time during the sowing, if a hole is made to contain four counters, the owner of the hole in which the four counters are located captures them, unless it is the final hole of the sowing, in which case the player who is sowing captures them. The captures happen immediately. If a player does not capture when they should have, and a subsequent sowing causes this hole to contain five counters, it becomes a Jen. Players can no longer capture from a Jen in the same manner as before. Captures are made from it when the final counter of a sowing lands in it, in which case the final counter and one counter from the Jen are captured by the player who is sowing. Play continues until a player can no longer move because there are no counters in their row, and the opponent captures the remaining counters. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra the weaker player is given the two extra counters. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes. 
(game "Gabata (Ghinda)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "LeftMost" {(pair P1 0) (pair P2 11)})
    }) 
    (rules 
        
        (start {
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
            (set Count 4 to:(sites Track "Track")) 
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select 
                        (from
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (if (= 1 (value Player Mover))
                                    ("OwnedHoles")
                                    (sites {(mapEntry "LeftMost" Mover)})
                                )
                            )
                            if:(is Occupied (from))
                        )
                        (then
                            (and
                                (do
                                    (set Var "NumSowed" (count at:(last To)))
                                    next:(sow
                                        apply:(if (< 1 (count at:(to)))
                                            (if (= 4 (count at:(to)))
                                                (fromTo
                                                    (from (to))
                                                    (to (handSite Mover))
                                                    count:4
                                                )
                                                (and
                                                    (moveAgain)
                                                    (set Var "Replay" (to))
                                                )
                                            )
                                        )
                                    )
                                    (then 
                                        (and
                                            (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1)))
                                                (if (= 4 (count at:(site)))
                                                    (fromTo
                                                        (from (site))
                                                        (to (if (is In (site) (sites (values Remembered "OwnedP1"))) (handSite P1) (handSite P2)))
                                                        count:4
                                                    )
                                                )
                                            )
                                            (set Var "NumSowed" 0)
                                        )
                                    )
                                )
                                (if (!= 1 (value Player Mover)) (set Value Mover 1))
                            )
                        )
                    )
                    }
                    (then
                        (if (or ("NoPieceOnOwnedHolesP1") ("NoPieceOnOwnedHolesP2"))
                            (and {
                                (if ("NoPieceOnOwnedHolesP2")
                                    (forEach Site (sites Board)
                                        (fromTo
                                            (from (site))
                                            (to (handSite P1))
                                            count:(count at:(site))
                                        )
                                    )
                                    (forEach Site (sites Board)
                                        (fromTo
                                            (from (site))
                                            (to (handSite P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:4
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 4 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 3 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("LeftMostEmpty"))
                                                count:3
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("LeftMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("LeftMostEmpty"))
                                        })
                                        (if (= 2 (count Cell at:(handSite Mover)))
                                            (and {
                                                (fromTo 
                                                    (from (handSite Mover))
                                                    (to ("LeftMostEmpty"))
                                                    count:2
                                                )
                                                (fromTo 
                                                    (from (handSite Next))
                                                    (to ("LeftMostEmpty"))
                                                    count:2
                                                )
                                                ("RememberOwnedHolesRandom" ("LeftMostEmpty"))
                                            })
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Siga, as played in Sri Lanka, is a race game similar to Saturankam, which is also played there. Typically, it is played on a cloth with pawns, or drawn on the ground with sticks as the pawns.5x5 board, with an X in the central square of each side of the board, as well as the central square of the board. Two players. Two pieces per player. Four cowrie shells used as dice. Throws have the value of the number of mouths that land face up, with no mouths up = 8. Players start on opposite sides of the board, the first point on their track being the marked square on that side. Players move in an anti-clockwise direction around the board, until reaching the space before the starting space, at which point they move into the space above it, and proceed around the inner part of the board in a clockwise direction, until below the central square. Players enter a piece with a throw of 1. Throws of 1 or 8 give the player another turn. When a player's piece lands on the same space as a space with an opponent's piece, the opponent's piece is removed from the board and must enter again, and the player causing this receives another throw. Pieces resting on a marked square cannot be sent back to start. To reach the central space, the player must throw the exact number required. The first player to move both pieces to the central space first wins. 
(game "Siga (Sri Lanka)"
    (players 2)
    (equipment {
        (board (square 5)
            {
            (track "Track1" "2,E,N,W,S,E1,N3,E2,S2,W1,N1" P1 directed:True)
            (track "Track2" "22,W,S,E,N,W1,S3,W2,N2,E1,S1" P2 directed:True)
            }
        )
        (piece "Marker" Each
            (move 
                (from (from) level:(level))
                (to
                    ("SiteToMoveOnTrack" from:(from) ("ThrowValue"))
                    if:True
                    (apply
                        (if (and (not (is In (to) (sites "SafeSites"))) ("IsEnemyAt" (to)))
                            (and
                                (forEach Level (to) FromTop
                                    (fromTo
                                        (from (to) level:(level))
                                        (to (handSite (who at:(to) level:(level))))
                                    )
                                )
                                (moveAgain)
                            )
                        )
                    )
                )
            )		
        )
        (hand Each)
        ("StickDice" 4)
        (map "Throw" {(pair 0 8) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)})
        (map "Entry" {(pair P1 2) (pair P2 22)})
        (regions "SafeSites" (sites {2 10 12 14 22}))
    })
    (rules 
        (start {
            (place Stack "Marker1" (handSite P1) count:2)
            (place Stack "Marker2" (handSite P2) count:2)
        })
        (play 
            ("RollMove"
                (or
                    (if (and (is Occupied (handSite Mover)) ("Throw1"))
                        (move 
                            (from (handSite Mover))
                            (to (mapEntry "Entry" (mover)))
                        )
                    )
                    (forEach Piece)
                )
                (then (if ("IsSpecialThrow") (moveAgain)))
            )
        )
        (end (if ("AllPiecesOnCentre" Mover) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Choro is a four-row mancala-style board game played by the Didinga people in what is now South Sudan. It was documented by Driberg in the early twentieth century.4x8 board. Two counters in each hole. Opening play: Two players play simultaneously, lifting and sowing counters from their outer rows. Rules for sowing and capturing are the same as in the main phase of the game except that all holes in each player's outer rows are considered to be in opposition and back captures can be made from them. Once a counter has been sown into the inner row, this ceases and captures can only be made from the inner row. The opening ends when both players reach an empty hole, and the first player to do so begins play in the main phase. 
            
            Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over
            
            For capturing: Holes are in 'opposition' when one player has the front row hole occupied and the opponent has both of the holes opposite it occupied. If the last hole in a sowing is in opposition, the player takes the counters in both of the opponent's holes and places them in the empty hole from which the player lifted the counters. The player then sows the captured counters from this hole. Further captures in the sowing can occur in the same way. However, each player has two holes from which clockwise plays can be made: the leftmost hole in the outer row and the second from the left in the inner row. Clockwise moves can only be made from these holes if they immediately lead to a capture. When the captured counters are sown, starting from the same hole, they can also be sown clockwise if they lead to a capture. If they cannot lead to a capture, they are sown anti-clockwise. 
            
            Another alternative the player has is that, if the player plays clockwise from one of these holes and therefore makes a capture, the captured counters may be placed in the hole and left there, and the player may play instead from the other hole from which clockwise captures are allowed in a clockwise direction, if it leads to a capture. 
            
            The player may continue playing from this hole as above until the possibilities to move are exhausted, and then may move from any hole in an anti-clockwise direction. Multiple captures can only be made in a clockwise direction from these holes if it is made on the first sowing of the turn. Otherwise, only one clockwise capture can be made and sowing must proceed in an anti-clockwise direction. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. 
            
        Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses. 
(game "Choro (Acholi)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "24,E,S1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))          
        (regions "Outer" P2 (sites Top))           
        (piece "Seed" Shared)
        (map "LeftMostOuter" {(pair P1 0) (pair P2 31)})
        (map "SecondLeftInner" {(pair P1 9) (pair P2 22)})
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        phases:{
        (phase "OuterPhase"
            (play
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover "Outer") 
                        )
                        if:(if ("SameTurn")
                            (< 0 (count at:(from)))
                            (< 1 (count at:(from)))
                        )
                    )
                    (then 
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(and 
                                (if (and (!= 1 (value Player Mover)) (is In (to) (sites Mover "Inner"))) 
                                    (set Value Mover 1)
                                )
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (= 1 (value Player Mover))
                                            (if (and {
                                                    (is Occupied ("OppositePit" (to)))
                                                    (is Occupied ("OppositeOuterPit" (to)))
                                                    (is In (to) (sites Mover "Inner"))
                                                })
                                                (and {
                                                    (fromTo
                                                        (from ("OppositePit" (to)))
                                                        (to (last From))
                                                        count:(count at:("OppositePit" (to)))
                                                    )
                                                    (fromTo
                                                        (from ("OppositeOuterPit" (to)))
                                                        (to (last From))
                                                        count:(count at:("OppositeOuterPit" (to)))
                                                    )
                                                    (set Var "Replay" (from))
                                                })
                                                (set Var "Replay" (to))
                                            )
                                            (if (is Occupied ("OuterPhaseOppositePit"))
                                                (and
                                                    (fromTo
                                                        (from ("OuterPhaseOppositePit"))
                                                        (to (last From))
                                                        count:(count at:("OuterPhaseOppositePit"))
                                                    )
                                                    (set Var "Replay" (from))
                                                )
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (= 1 (count at:(last To afterConsequence:True))) "MainPhase")
        )
        
        (phase "MainPhase"
            (play
                (or
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)}) 
                            )
                            if:(and {
                                if:(if ("SameTurn")
                                    (< 0 (count at:(from)))
                                    (< 1 (count at:(from)))
                                )
                                (is In (from) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)}))
                                (is In ("NextHole" (from) "TrackCW" (count at:(from))) (sites Mover "Inner"))
                                (is Occupied ("OppositePit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                                (is Occupied ("OppositeOuterPit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                            })
                        )
                        (then 
                            (sow
                                "TrackCW"
                                owner:(mover)
                                apply:
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and {
                                                (is Occupied ("OppositePit" (to)))
                                                (is Occupied ("OppositeOuterPit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            })
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                                (set Var "Replay" (from))
                                            })
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover) 
                            )
                            if:(if ("SameTurn")
                                (< 0 (count at:(from)))
                                (< 1 (count at:(from)))
                            )
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                owner:(mover)
                                apply:
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and {
                                                (is Occupied ("OppositePit" (to)))
                                                (is Occupied ("OppositeOuterPit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            })
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                                (set Var "Replay" (from))
                                            })
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end ("BlockWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "Unfair" 
    (players 2) 
    (equipment { 
        (board (square <Board:size>) use:Vertex) 
        (piece "Ball" Each) 
    }) 
    (rules 
        
        (play
            (or 
                (move Add (to (sites Empty) if:(= (id P1) (mover)))
                    (then 
                        (if (= 0 (count MovesThisTurn)) 
                            (moveAgain)
                        )
                    )
                ) 
                (move Add (to (sites Empty) if:(= (id P2) (mover)))
                    (then 
                        (if 
                            (< (count MovesThisTurn) 3) 
                            (moveAgain)
                        )
                    )
                ) 
            )
        )
        
        (end {
            (if (and ((= (id P1) (mover)) (is Line 4 Orthogonal))) (result Mover Win))
            (if (and ((= (id P2) (mover)) (is Line 7 Orthogonal))) (result Mover Win))
        })
    )
)
Unfair is an asymmetric N-in-a-row game invented by Stephen Tavener in 2015. The two players have different goals and place different numbers of pieces per turn.Played on a square grid 11x11 or larger.  White goes first and places two pieces every turn, Black places four pieces per turn.  White wins if they make an orthogonal line of four pieces; Black wins if they make an orthogonal line of 7 pieces. Played on a size 11 board.

Construct a Ludii game based on the following description
Ashtapada is a term referring to a board game that predates Chess in India. It is widely believed that the 8x8 Ashtapada board, which is marked in certain places, was appropriated and used for Chaturanga, since many Chaturanga boards in India maintain the Ashtapada markings, though they are meaningless for Chess. In the Ashtapabada of Balabharata (thirteenth century), a dice game is described as being played on the Ashtapada, with dice determining the movement of pieces on the board.To be reconstructed. The rules implemented here are suggested by Jenny Kile as follows: Besides being an 8x8 squared board, the board consists of certain marked spaces which denote safety, entry, or exit for players. The four corners, the four central squares, and two center squares on each side are crosscut, like shown. Two, three, or four people can play the game. If two players are playing, each would sit on one side of the board and enter their two pieces onto the center crosscut squares along the outer side The object of the game is to be the first player to enter and exit both his pieces. A player exits his piece once reaching the center squares.  The version of the game played with 2 players.
(game "Ashtapada"
    (players <Version:numPlayers>) 
    (equipment { 
        (board (square 8)
            {
            (track "Track1" "3,E,N,W,S,E1,N6,E5,S5,W4,N4,E3,S3,W1" 1 directed:True)
            (track "Track2" "60,W,S,E,N,W1,S6,W5,N5,E4,S4,W3,N3,E1" 2 directed:True)
            (track "Track3" "31,N,W,S,E,N1,W6,N5,E5,S4,W4,N3,E3,S1" 3 directed:True)
            (track "Track4" "32,S,E,N,W,S1,E6,S5,W5,N4,E4,S3,W3,N1" 4 directed:True)
            }
        )
        ("StickDice" 4)
        (hand Each)
        (map "DieValue" {(pair 4 8)})
        <Version:map>
        (regions "Protect" (sites {"A1" "A4" "A5" "A8" "D1" "D4" "D5" "D8" "E1" "E4" "E5" "E8" "H1" "H4" "H5" "H8"}))
        
        (piece "Disc" Each 
            (if ("IsNotOffBoard" "SiteToMoveOnTrack") 			
                (if 
                    (if (is In "SiteToMoveOnTrack" (sites "Protect"))
                        (not ("IsEnemyAt" "SiteToMoveOnTrack"))
                        True
                    )
                    (move 
                        (from)
                        (to 
                            "SiteToMoveOnTrack" 
                            (apply 
                                if:("IsEnemyAt" (to)) 
                                (fromTo (from (to)) (to (handSite (who at:(to)))))
                            )
                        ) 
                    )
                )
            )
        ) 
        
    }) 
    
    (rules 
        <Version:start>	
        
        (play 
            ("RollEachNewTurnMove"
                (if "SameTurn"
                    (or
                        (forEach Piece 
                            (if (= (from) (mapEntry "Exit" Mover))
                                (move Remove (from))
                                (if ("IsNotOffBoard" "MoveToNextSiteOnTrack") 			
                                    (if 
                                        (if (is In "MoveToNextSiteOnTrack" (sites "Protect"))
                                            (not ("IsEnemyAt" "MoveToNextSiteOnTrack"))
                                            True
                                        )
                                        (move 
                                            (from) 
                                            (to 
                                                "MoveToNextSiteOnTrack"
                                                ("HittingCapture" (handSite (who at:(to))))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (if 
                            ("HandOccupied" Mover)
                            (move 
                                (from (handSite Mover)) 
                                (to 
                                    (mapEntry "Entry" Mover) 
                                    if:(not ("IsEnemyAt" (to)))
                                )
                            )
                        )
                    )
                    (if (can Move (forEach Piece))
                        (forEach Piece (then (if (= (count Pips) 3) (moveAgain))))
                        (move Pass (then (if (= (count Pips) 3) (moveAgain))))
                    )
                )
            )
        )
        
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
The so-called Royal Game of Ur—we do not know its ancient name—is one of the oldest known board games, dating to the third millennium BCE. While no rules have been passed down for this game specifically, a rule set based on a successor game, 20 Squares, has been applied to this slightly different board. The board consists of a grid of 3x4 squares, connected to a grid of 3x2 squares by a short bridge of 1x2 squares connecting the central rows of the other two grids. The game was played with four tetrahedral dice and 7 small disks per player as playing pieces. 4x3 grid with a 3x 2 grid connected by a \ The pieces follow the track described by Finkel. The rosettes are protecting the pieces and allow them to replay.
(game "Royal Game of Ur"
    (players 2) 
    (equipment  { 
        (board 
            (hole 
                (hole
                    (rectangle 3 8) 
                    (poly { {4 0} {4 1} {6 1} {6 0}})
                )
                (poly { {4 2} {4 3} {6 3} {6 2}})
            )
            {<Track>}
        )
        ("StickDice" 4)
        (hand Each)
        (regions "Replay" (sites {"A1" "A3" "D2" "G1" "G3"}))
        
        (piece "UrPiece" Each
            (if ("IsEndTrack" "SiteToMoveOnTrack")
                "RemoveAPiece"
                (if ("IsNotOffBoard" "SiteToMoveOnTrack") 	 			
                    <Rosette:move>
                )
            )
        )
        
    }) 
    
    (rules 
        (start { 	
            (place "UrPiece1" (handSite P1) count:7)
            (place "UrPiece2" (handSite P2) count:7)
        })	
        
        (play ("RollMove" (if (!= (count Pips) 0) (or (forEach Piece) (forEach Piece container:(mover))))))
        
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Yavalax is inspired by both Yavalath and Connect6.Goal: Simultaneously create two or more rows of exactly four stones of your color.
            
            Play: White starts by placing a white stone at an empty cell. Players then take turns placing two stones of their color at empty cells, one stone after another.
            
            In each placement, players are not allowed to create a single
            4-in-a-row of their color, unless that placement simultaneously
            creates at least one other 4-in-a-row of their color to win the game.
            
            This means that players may NOT make a single 4-in-a-row of their color on the first placement of their turn even if they can make a second 4-in-a-row on their second placement.
            
            In no event are players allowed to create 5 (or more) -in-a-row of their color.
            
        The first player to make simultaneous 4-in-a-rows of their color wins immediately, whether it was their first or second placement. The game is played on a 13x13 board.
(game "Yavalax" 
    (players 2) 
    (equipment { 
        (board (square <Board:size>)) 
        (piece "Marker" Each) 
    }) 
    (rules 
        phases:{
        (phase "Opening"
            (play (move Add (to (sites Empty))))
            (nextPhase "General")
        )
        (phase "General"
            (play 
                (do
                    (move Add 
                        (to (sites Empty))
                        (then
                            (if ("NewTurn") (moveAgain))
                        )
                    )
                    ifAfterwards:(and
                        (not ("MoreThan4InARow"))
                        (!= 1 ("NumSimultaneousFourInARow"))
                    )
                )
            )
        )
        }
        (end (if (<= 2 ("NumSimultaneousFourInARow")) (result Mover Win))) 
    )
)

Construct a Ludii game based on the following description
Alquerque de Tres is a simple alignment game described in the Libro de los Juegos of Alfonso X. The board on which it is played is found at Roman sites, and so it is possible that the game is much older. It is depicted as played by children.3x3 intersecting lines, with diagonal lines of the board. Three pieces per player. players alternate turns placing a piece on one of the empty spots. The player who places their pieces in a line wins. 
(game "Alquerque de Tres"
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 3 3)
        (hand Each)
        (piece "Marker" Each)
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        (play (move (from (handSite Mover)) (to (sites Empty))))
        (end ("Line3Win"))
    )
)

Describe the mechanics of the following Ludii game
(game "Okwe (Achalla)"
    (players 2)
    (equipment {
        (board 
            (add
                (concentric {10}) 
                vertices:{{0.45 0.45} {-0.45 -0.45} {0.45 -0.45} {-0.45 0.45}}
            )
            (track "Track" {0 2 4 6 8 9 7 5 3 1} loop:True)
            use:Vertex
        )
        
        (regions P1 (sites {0..4}))  
        (regions P2 (sites {5..9}))  
        (map {(pair P1 11) (pair P2 10)}) 
        (piece "Seed" Shared)
    })
    (rules
        (start (set Count 10 to:(sites Track)))
        (play 
            (forEach Site 
                (forEach (sites Mover) if:(< 1 (count at:(site))))
                (forEach Value min:2 max:(count at:(site))
                    (do (set Var (value))
                        next:(move Select 
                            (from (site))
                            (then 
                                (sow 
                                    count:(var)
                                    if:True
                                    apply:(if (and (<= (count at:(to)) 9) (is Odd (count at:(to))))
                                        (fromTo 
                                            (from (to)) 
                                            (to (mapEntry (mover))) 
                                            count:(count at:(to))
                                        )
                                        (if (and (<= (count at:("NextHoleFrom" (to))) 9) (is Odd (count at:("NextHoleFrom" (to)))))
                                            (fromTo 
                                                (from ("NextHoleFrom" (to))) 
                                                (to (mapEntry (mover))) 
                                                count:(count at:("NextHoleFrom" (to)))
                                            )
                                        )
                                    )
                                    origin:True
                                    backtracking:(and (<= (count at:(to)) 9) (is Odd (count at:(to))))
                                )
                            )
                        )	
                    )
                )
            )
        )
        (end ("MancalaByScoreWhen" (and (no Moves P1) (no Moves P2))))
    )
)
Okwe is the name of several mancala-style board games from West Africa. This particular game was played by the Ibo people in Achalla, Nigeria in the early twentieth century.Two rows of five holes arranged in a circle around four stores in the center. Each player has five holes on one half of the circle. Ten counters in each hole. Players sow from their holes, and can choose to sow any number of counters, but must leave at least one in the starting hole. Sowing occurs in an anti-clockwise direction. If sowing ends in a hole making its contents an odd number of counters, they are captured, but not more than nine. If the sowing ends and the last counter makes the contents of a hole an even number and the next hole has an odd number of counters, the contents of the odd hole are taken, but not more than nine. In both situations, if there is an unbroken sequence of holes with an odd number of counters, these are all taken, but not more than nine from each. 

Construct a Ludii game based on the following description
Xanan Zirge is an alignment game played in Mongolia. Players attempt to place their pieces three in a row, or in a square.9x9 intersecting lines. Forty pieces per player. Players alternate turns placing a piece on an empty space on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot on the board. When a player places three of their pieces in an orthogonal or diagonal line, they remove one of the opponent's pieces. Players also remove one of the opponent's pieces when they place four pieces so that they are one the four corners of one of the squares on the board. Pieces which are in these patterns cannot be removed from the board. The player who removes all of the opponent's pieces wins. 
(game "Xanan Zirge"
    (players 2) 
    
    (equipment { 
        (board (square 9) use:Vertex)
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ "IfLine3OrSquareMoveAgain")
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:40))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveEnemyPieceNotInLine3AndNotInSquare"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        "IfLine3OrSquareMoveAgain"
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveEnemyPieceNotInLine3AndNotInSquare"
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Intotoi is a two-row mancala-style board game played by the Samburu people of Kenya. It was documented in the early twentieth century.2x12 board. Starting position, from the left hand hole, for each player: 0-3-3-0-3-3-0-3-3-0-3-3 In the opening play, one player must sow two counters from the second hole from their right. The opponent then makes the same play from their row, or from the fourth hole from their right. When the final counter lands in an occupied hole, these are picked up and sowing continues. A player's turn ends when the final counter falls into an empty hole. Players may now begin their move from any hole in their row, but only if it ends in an empty hole in their row or if it enters the opponent's row. If the final counter lands in an occupied hole in the opponent's row, these are picked up and sowing continues. If the final counter lands in an occupied hole in the player's row, the contents of the hole in the opponent's hole opposite it are captured. Sowing ends when a capture is made or when a counter falls into an empty hole. 
(game "Intotoi" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))     
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start (set Count 3 to:(sites {1 2 4 5 7 8 10 11 22 21 19 18 16 15 13 12})))
        
        phases:{
        
        (phase "Opening1" 
            (play 
                (move Select
                    (from 10)
                    (then (sow count:2))
                )
            )
            (nextPhase "Opening2")
        )
        
        (phase "Opening2"
            (play
                (if ("SameTurn") 
                    (move Select
                        (from 
                            (sites {"PlayFromLastHole"})
                            if:(> (count at:(from)) 0)
                        )
                        (then 
                            (sow
                                apply:(if (!= 1 (count at:(to)))
                                    (moveAgain)
                                )		
                            )
                        )
                    )
                    (move Select
                        (from 
                            (sites {13 15})
                            if:(> (count at:(from)) 0)
                        )
                        (then 
                            (sow
                                count:2
                                apply:(if (!= 1 (count at:(to)))
                                    (moveAgain)
                                )		
                            )
                        )
                    )
                )
            )
            (nextPhase (not (is Next Mover)) "Play")
        )
        
        (phase "Play"
            (play 
                (move Select
                    (from 
                        (sites From
                            (do 
                                (move Select
                                    (from 
                                        (sites Mover)
                                        if:(> (count at:(from)) 0)
                                    )
                                    (then (sow))
                                )
                                ifAfterwards:(or
                                    (and (= 1 (count at:("PlayFromLastHole"))) (is In ("PlayFromLastHole") (sites Mover)))
                                    (is In ("PlayFromLastHole") (sites Next))
                                )
                            )
                        )
                        if:(> (count at:(from)) 0)
                    )
                    (then 
                        (sow
                            apply:(if (= 1 (count at:(to)))
                                (if (and (is Occupied ("OppositePit" (to))) (is In (to) (sites Mover)))
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (handSite Mover)) 
                                        count:(count at:("OppositePit" (to)))
                                    )
                                )
                                (moveAgain)
                            )		
                        )
                    )
                )
            )
            (nextPhase Mover (is Next Mover) "Replay")
        )
        
        (phase "Replay"
            (play 
                (move Select
                    (from 
                        (sites {"PlayFromLastHole"})
                        if:(> (count at:(from)) 0)
                    )
                    (then 
                        (sow
                            apply:(if (= 1 (count at:(to)))
                                (if (and (is Occupied ("OppositePit" (to))) (is In (to) (sites Mover)))
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (handSite Mover)) 
                                        count:(count at:("OppositePit" (to)))
                                    )
                                )
                                (moveAgain)
                            )		
                        )
                    )
                )
            )
            (nextPhase Mover (not (is Next Mover)) "Play")
        )
        }
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Describe the mechanics of the following Ludii game
(game "Killer Sudoku"
    (players 1) 
    (equipment { 
        (board (square 9) (values Cell (range 1 9))) 
        <Challenge>
        (regions {Columns Rows SubGrids})
        (regions "RegionHint" HintRegions)
    }) 
    (rules 
        (play
            (satisfy {
                (is Sum "RegionHint" (hint))
                (all Different)
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)
Killer Sudoku is a puzzle that combines elements of Sudoku and Kakuro. Despite the name, the simpler Killer Sudokus can be easier to solve than regular Sudokus, depending on the solver's skill at mental arithmetic; the hardest ones, however, can take hours to crack.Numbers from 1 to 9 have to be placed in the squares such that each row, column, cage has each number appearing only once, and the numbers in each cage add up to the assigned number. 

Construct a Ludii game based on the following description
Rimau-Rimau is a kind of hunt game played in Singapore during the nineteenth century. In this version, two tigers play against 23 people.5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. One player plays as two tigers, the other as 23 people. One of the tigers begins on any spot on the board. Eight of the people begin on the spots surrounding the central point of the board. The tiger player, on their first turn, removes one of the people and then places the second tiger anywhere on the board. The people then play, placing one of the remaining people on an empty spot on the board. On the tiger's turn, the player may move one of the tigers to an empty adjacent spot along the lines of the board. The tiger may also capture a person by hopping over it to an empty adjacent spot immediately on the opposite side of it along the lines of the board. When all of the people are placed, they move to an empty adjacent spot along the lines of the board on their turn. The tigers win by capturing all the people; the people win by blocking both tigers from being able to move. The two tigers start in the hand.
(game "Rimau-Rimau (Two Tigers)" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (hand Each) 
        (piece "Tiger" P1 
            (or {
                ("StepToEmpty")
                ("HopCapture") 
            })
        ) 
        (piece "human" P2 "StepToEmpty") 
    }) 
    (rules 
        <Start:start>
        <Start:play>
    )
)

Construct a Ludii game based on the following description
Kapana Bona is a two-row mancala-style board game played by the Gourounsi people in West Africa. Instead of being played on a board, the counters are placed in heaps on the ground.2x3 board. Eight counters in each pile. A player takes the counters from any of the piles and sows them anti-clockwise, beginning with the pile from which the counters were taken. Any piles that now contain 2, 4, or 6 counters are captured. The player who captures the most counters wins.
         
(game "Kapana Bona" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 3 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 8 to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (sites Board) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow origin:True
                        (then
                            (forEach Site (sites Board) 
                                (if (or {
                                        (= (count at:(site)) 2)
                                        (= (count at:(site)) 4)
                                        (= (count at:(site)) 6)
                                    })
                                    (fromTo 
                                        (from (site)) 
                                        (to (handSite Mover)) 
                                        count:(count at:(site))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (= 0 (count Sites in:(forEach (sites Board) if:(< 1 (count at:(site))))))))
    )
)

Construct a Ludii game based on the following description
A simple 4-in-a-row game played on an unusual board, which is the dual of the semi-regular 3.3.3.3.6 tiling.Players take turns placing a piece of their colour, and win by making an orthogonally connected line of 4 of their colour (diagonal steps don't count). 
(game "Flowers" 
    (players 2) 
    (equipment { 
        (board (dual (tiling T33336 3))) 
        (piece "Marker" P1) 
        (piece "Marker" P2) 
    }) 
    (rules 
        (play (move Add (to (sites Empty))))
        (end (if (is Line 4 Orthogonal) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Fanorona is perhaps the most popular game in Madagascar. It has been documented there since the nineteenth century, but it plays a part in many Malagasy stories about their past so it likely has a much longer history there. It is often played outside, and most households in Madagascar have a Fanorona board in them.Fanorona-Tsivy is played on a board of 9x5 intersecting lines with diagonals. Each player has 22 pieces, starting on the intersections of the lines except in the centre position, placed on opposite rows of the board, but alternating in the central row.. Pieces move to an adjacent intersection along the lines. Players must capture pieces when possible. Capturing is accomplished by moving to an adjacent intersection to an opposing piece in the continuing direction of the capturing stones movement, or by moving away from an adjacent opposing pieces in such a direction. When an opponent's piece is captured, all other of the opponent's pieces in that line are also captured. Multiple captures can be made, but cannot be done by moving twice in the same direction. Multiple captures are optional. A player wins by capturing all of the other player's pieces. The game is played on a 3x3 board
(game "Fanorona" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" <Board:size>)
        (piece "Marker" Each)
    }) 
    
    (rules 
        (start { 
            (place "Marker1" (union { <Board:startP1>}))
            (place "Marker2" (union { <Board:startP2>}))
        })
        
        (play
            (if "SameTurn"
                (or 
                    (if (is Occupied (last To)) 
                        ("CaptureFromLast" (last To)) 
                        ("CaptureFromLast" (last From))
                    )
                    (move Pass)
                )
                (priority {
                    (or 
                        ("MoveIn" (to) SameDirection (last To) ("LastDirection" Vertex))
                        ("MoveIn" (from) OppositeDirection (last From) (directions Vertex from:(last To) to:(last From)))
                    )
                    (forEach Piece "StepToEmpty")
                })
            )
        )
        
        (end (if (no Pieces Mover) (result Next Win)))
    )
)

Construct a Ludii game based on the following description
||Hus is a four-row mancala-style game played among several groups in Southwest Africa, including the Damara. Hus is a word applied to several different games throughout the region, which were documented in the early twentieth century. 4x12-24 (only even numbers allowed) board. Play begins with two counters in the outer row of each players' holes and two counter in each of the four holes on the right hand side of both players' inner row of holes. Player picks up contents of any hole containing two or more counters and sows them anti-clockwise. If the final counter of the sowing falls into an empty hole, the turn is over. If the last counter falls into an occupied hole, sowing continues by picking up the counters in that hole and continuing in the same direction. If the last counter falls into an occupied hole in the player's inner row, and the opponent's two holes opposite it are occupied, these are captured and sowing continues using these counters beginning at the next hole after the one which caused the capture. Play ends when one player cannot move; i.e. when they have only single counters in holes or all their counters have been captured. Each player has 12 holes. The player can sow from any hole with one or more seeds.
(game "Hus (Damara)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Board:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))          
        (regions "Outer" P2 (sites Top))          
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(union { 
                    (expand (intersection (sites Row 1) (sites Right)) steps:3 W) 
                    (expand (intersection (sites Row 2) (sites Left)) steps:3 E) 
                    (sites P1 "Outer")
                    (sites P2 "Outer") 
                }) 
            ) 
        )
        
        (play 
            (move Select
                (from 
                    (if ("SameTurn") 
                        (if "MoveAgainAfterCapture" "PlayFromNextHole" "LastHoleSowed") 
                        (sites Mover "Home") 
                    ) 
                    if:(> (count at:(from)) <Sow:numSeed>)
                )
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (> (count at:(to)) 1)
                            (if (and { 
                                    (is In (to) (sites Mover "Inner")) 
                                    (> (count at:("OppositePit" (to))) 0) 
                                    (> (count at:("OppositeOuterPit" (to))) 0)
                                })
                                (and
                                    {
                                    (fromTo 
                                        (from (to)) 
                                        (to (handSite Mover)) 
                                        count:(count at:(to))
                                    ) 
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (handSite Mover)) 
                                        count:(count at:("OppositePit" (to)))
                                    ) 
                                    (fromTo 
                                        (from ("OppositeOuterPit" (to))) 
                                        (to (handSite Mover)) 
                                        count:(count at:("OppositeOuterPit" (to)))
                                    )
                                    (if (> (count at:"NextHole") 1)
                                        (and
                                            (set Pending "NextHole") 
                                            (moveAgain)
                                        )
                                    )
                                    }
                                )
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Laquet is a race game from medieval Spain that is similar to other European Tables games. It is documented in the Libro de los Juegos of Alfonso X.2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. One player places fourteen of their pieces on the first point of the table to their right closest to them, with the other piece on the point opposite it on the other side of the board. The other player places three pieces on each of the four  spots following the spot with the other player's fourteen, two on the spot following this, and one on the opposite end of the row of spots where the opponent's single piece is located. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Players move along the spaces of the board toward the spot where the first player's single piece is located, and from there they bear off. Pieces cannot be hit as in similar games. If a player cannot play the value on a die (or on both dice), the opponent may play it. The first player to bear off all of their pieces wins. 
(game "Laquet"
    (players 2)
    (equipment {
        ("TableBoard" (track "Track1" {11..6 5..0 12..17 18..23} directed:True))
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" "SiteToMoveOnTrack")
                    "RemoveAPiece"
                    (if (not ("IsEnemyAt" "SiteToMoveOnTrack"))
                        (move 
                            (from) 
                            (to "SiteToMoveOnTrack")
                        )
                    )
                )
            )
        )
    })
    (rules 
        (start {
            (place Stack "Disc1" 11 count:14)
            (place Stack "Disc1" 23)
            (place Stack "Disc2" (sites {7..10}) count:3)
            (place Stack "Disc2" 6 count:2)
            (place Stack "Disc2" 12)
        })
        (play 
            (do 
                (if (and (not (is Pending)) ("NewTurn")) (roll)) 
                next:(if (can Move (forEach Piece))
                    (forEach Piece 
                        top:True
                        (then ("ReplayNotAllDiceUsed"))
                    )
                    (move Pass (then (set Pending)))
                )
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Len Cúa Kín Ngoa is a capturing game played in Thailand in the early nineteenth century. It is somewhat of a combination of a hunt and a capturing game, where one player plays as tigers and the other as cattle, but both are able to capture via different methods.4x4 board. One player plays as four tigers, which begin the board placed in the four corner spaces. The other player plays as twelve oxen. The first move is made by placing one of the oxen on an empty space, followed by a move by the tiger closest to the ox. Players continue alternating moves, the oxen player placing an ox and the tiger player moving a tiger. When moving, pieces move to an empty adjacent spot orthogonally. Once all of the oxen are placed, the players alternate turns moving their pieces on the board. Pieces may capture another piece by hopping over an adjacent opponent's piece to an empty space immediately on the opposite side of it. Tigers capture orthogonally, oxen capture diagonally. Oxen may also capture a tiger by blocking it from being able to move. The oxen win by reducing the tigers to two. 
(game "Len Cua Kin Ngoa" 
    (players 2) 
    (equipment { 
        (board (square 4))
        (hand P1)
        (piece "Ox" P1 (or ("HopDiagonalCapture") "StepOrthogonalToEmpty"))
        (piece "Tiger" P2 (or ("HopOrthogonalCapture") "StepOrthogonalToEmpty")) 
    }) 
    (rules 
        (start { 
            (place "Ox1" (handSite P1) count:12)
            (place "Tiger2" (sites Corners))
        })
        
        phases:{ 
        (phase "Placement" P1 
            (play 
                (move 
                    (from (handSite P1)) 
                    (to (sites Empty))
                    ("RemoveAllTigersWithNoMove")
                )
            ) 
            (nextPhase ("HandEmpty" P1) "MovementP1")
        )
        (phase "MovementP1" P1
            (play 
                (forEach Piece ("RemoveAllTigersWithNoMove"))
            )
        )
        (phase "FirstTigerMovement" P2 
            (play 
                (forEach Piece
                    (if (= 
                            (count Steps (from) (last To))
                            ("MinDistanceWithCorners")
                        )
                        (or ("HopOrthogonalCapture") "StepToEmpty")
                    )
                )
            )
            (nextPhase Mover "MovementP2")
        )
        (phase "MovementP2" P2
            (play 
                (forEach Piece)
            )
        )
        }
        
        (end {
            (if (no Pieces P1) (result P2 Win))
            (if (>= 2 (count Pieces P2)) (result P1 Win))
        }) 
    )
)

Construct a Ludii game based on the following description
Triad is an abstract board game for three players which features an interesting move mechanic; the players dictate move order as the game progresses. It arose out of discussions with Joao Neto and Bill Taylor in November 2002.The game is played on a tricoloured hexagonal grid with five cells per side. The three players are called Red, Green and Blue, and each player owns the cells and the pieces that bear their colour.Each turn the current player must move, capture and drop.
            
            The current player must move one of their pieces in a straight line in any of the six hexagonal directions to land on a vacant foreign cell; any intervening cells must also be empty. The opponent who owns the landing cell becomes the candidate and the other opponent becomes the bunny.
            All opponents' pieces immediately adjacent to the landing cell are captured and removed from the board. The current player must make the move that captures the most pieces each turn, but may choose amongst equals. This is called the max capture rule.
            The moving player must then drop a bunny piece on any empty cell, unless a player has just been eliminated.
            The candidate becomes the next player to move.
            
        Goal: Play stops the moment any player is eliminated. The game is won by the player with the most pieces left, else is a tie between the two remaining players if they are both left with the same number of pieces. 
(game "Triad" 
    (players 3) 
    (equipment { 
        (board (hex 5)) 
        (piece "Marker" Each 
            (move Slide
                Orthogonal
                (to 
                    (apply 
                        if:(!= 
                            (mover) 
                            (mapEntry "PlayerPhase" (phase of:(to)))
                        )
                    )
                ) 
                (then
                    (and {
                        (forEach Site 
                            (sites Around (last To) Orthogonal)
                            (if (is Enemy (what at:(site)))
                                (remove (site))
                            )
                        )
                        "GetCandidate"
                        (moveAgain)
                    })
                )
            )
        )
        (map "PlayerPhase" {(pair 1 1) (pair 0 2) (pair 2 3)})
    }) 
    (rules
        (start {
            (place "Marker1" (expand origin:(coord "A5") steps:2))
            (place "Marker2" (expand origin:(coord "I9") steps:2))
            (place "Marker3" (expand origin:(coord "E1") steps:2))
        })
        (play
            (if "SameTurn"
                (move Add 
                    (piece ("Bunny"))
                    (to (sites Empty))
                    (then (set NextPlayer (player "Candidate")))
                )
                (max Captures (forEach Piece))
            )
        )
        (end
            (if (or {
                    (no Pieces P1) 
                    (no Pieces P2) 
                    (no Pieces P3)
                }) 
                (byScore {
                    (score P1 (count Pieces P1)) 
                    (score P2 (count Pieces P2))
                    (score P3 (count Pieces P3))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
The 32 pieces in Chex represent the 16 chess pieces on each side of a normal chess game. Each player shuffles his own 16 tiles and places them face down, then white draws his top tile and places it, with the piece oriented so it looks upright to him. Black then draws the top tile in his pile and places it so that it touches white's piece, either orthogonally or diagonally, and oriented so that it looks upright to him.
            
            At that point, white can either add another piece or move his piece on the board. A move must be a legal chess move and may not separate any element of the board; all pieces much remain touching, even if just diagonally, when a move has ended. Thus you can \ 
(game "Chex" 
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        (boardless Square) 
        (hand Each)
        
        (tile "Pawn" Each numSides:4
            (or {
                "StepForwardToEmpty" 
                ("StepToEnemy" (directions {FR FL}))
            })
        )
        
        (tile "Rook" Each numSides:4 ("SlideCapture" Orthogonal))
        (tile "King" Each numSides:4 ("StepToNotFriend"))
        (tile "Bishop" Each numSides:4 ("SlideCapture" Diagonal))
        (tile "Knight" Each numSides:4 ("LeapCapture" "KnightWalk"))
        (tile "Queen" Each numSides:4 ("SlideCapture"))
    }) 
    
    (rules 
        (start {
            (place Random 
                { 
                (count "Pawn1" 8) (count "Rook1" 2) (count "Knight1" 2) 
                (count "Bishop1" 2) (count "Queen1" 1) (count "King1" 1) 
                } 
                (handSite 1) 
            )
            (place Random 
                { 
                (count "Pawn2" 8) (count "Rook2" 2) (count "Knight2" 2)
                (count "Bishop2" 2) (count "Queen2" 1) (count "King2" 1) 
                } 
                (handSite 2) 
            )
            (forEach Value min:0 max:(topLevel at:(handSite 1)) 
                (set Hidden What at:(handSite 1) level:(value) to:P1)		
            )
            
            (forEach Value min:0 max:(topLevel at:(handSite 1)) 
                (set Hidden What at:(handSite 1) level:(value) to:P2)		
            )
            
            (forEach Value min:0 max:(topLevel at:(handSite 2)) 
                (set Hidden What at:(handSite 2) level:(value) to:P1)		
            )
            
            (forEach Value min:0 max:(topLevel at:(handSite 2)) 
                (set Hidden What at:(handSite 2) level:(value) to:P2)		
            )
        }) 
        (play 
            (if "SameTurn"
                (if (= (count Moves) 1)
                    (move 
                        (from (handSite (mover))) 
                        (to (centrePoint))
                    )
                    (do (move 
                            (from (handSite (mover))) 
                            (to 
                                (sites Around (union (sites Occupied by:P1 container:"Board") (sites Occupied by:P2 container:"Board")) Empty)
                            )
                        ) 
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
                (or 
                    (if (is Occupied (handSite (mover)))
                        (move Select
                            (from (handSite (mover))) 
                            (then 
                                (and {
                                    (moveAgain) 
                                    (set Hidden What at:(last To) level:(topLevel at:(last To)) False to:P1)
                                    (set Hidden What at:(last To) level:(topLevel at:(last To)) False to:P2)
                                })
                            )
                        )
                    )
                    (do 
                        (forEach Piece) 
                        ifAfterwards:(and (= 1 (count Groups)) (not ("IsInCheck" "King" Mover)))
                    )
                )
            )	
        )
        
        (end {
            (if (and {
                    (not 
                        (can Move 
                            (if (!= (what at:(handSite (mover))) 0) (move Select (from (handSite (mover)))))
                        )
                    )
                    ("IsNotOffBoard" (where "King" Next))
                    ("IsInCheck" "King" Next)
                    (not 
                        (can Move 
                            (do 
                                (forEach Piece Next) 
                                ifAfterwards:(and 
                                    (= 1 (count Groups)) 
                                    (not ("IsInCheck" "King" Next))
                                )
                            ) 
                        )
                    )
                }) 
                (result Mover Win)
            )
            (if (and { 
                    "SameTurn"
                    ("IsInCheck" "King" Mover) 
                    (not 
                        (can Move 
                            (do 
                                (move 
                                    (from (handSite (mover))) 
                                    (to 
                                        (sites 
                                            Around 
                                            (union 
                                                (sites Occupied by:P1 container:"Board") 
                                                (sites Occupied by:P2 container:"Board")
                                            ) 
                                            Empty
                                        )
                                    )
                                ) 
                                ifAfterwards:(not ("IsInCheck" "King" Mover))
                            )
                        )
                    )
                })
                (result Next Win)
            )
            ("DrawIfNoMoves" Mover)
        })
    )
)

Construct a Ludii game based on the following description
Kints is a race game played by the Akimel O'odham people of Arizona. It is similar to other games known as Quince, which may be related to Mesoamerican Patolli.Played on a board with 36 holes arranged in a square, with a gap in the center of each side. There are two semi circles of five holes on the outside of two opposite corners of the board. The central space of these semicircles is marked. One or two pieces per player. Four stick dice are used, with one marked side. Each die is marked differently for a different value: 4, 6, 14, 15. The throws are as follows: All marked sides up = 5; three marked sides up = 3; two marked sides up = 2, one marked side up = the value of the marked side; zero marked sides up = 10. Players’ pieces enter on the branching arcs. The second piece cannot enter before the first one leaves the arc. Players move in opposite directions around the board. If a player lands on the same spot as the opponent, the opponent’s piece is removed from the board and must re-enter. Player must make an exact throw to get a piece off the board. The player to get both of their pieces around the board, and then to reach the marked space with an exact throw. When a piece is in the hole before the marked space, they may throw anything but 14 or 15 to exit the board. The first player to remove their piece(s) from the board wins. Each player has 1 piece.
(game "Kints"
    (players 2)
    (equipment {
        ("KintsBoard"
            {
            (track "Track1" "46,5,SSE,N,E,S,W,NNW2,End" P1 directed:True)
            (track "Track2" "47,41,NNW,W,S,E,N,SSE2,End" P2 directed:True)
            }
        )
        (regions "AllSites" (sites Board))
        (regions "Arc" P1 (sites {1..5}))
        (regions "Arc" P2 (sites {41..45}))
        (dice d:2 facesByDie:{{0 4} {0 6} {0 14} {0 15}} num:4)
        (piece "Marker" Each
            (if (or ("PieceAlreadyEntered")
                    ("PieceCanEnterOnlyIfNoPieceOnArc")
                )
                ("Movement")
            )
        )
        (hand Each)
        (map "Throw" {
            (pair 0 10) (pair 39 5) (pair 24 3) (pair 25 3) (pair 35 3) (pair 33 3)
            (pair 10 2) (pair 18 2) (pair 19 2) (pair 20 2) (pair 21 2) (pair 29 2)
        })
    })
    (rules 
        (start (place "Marker" "Hand" count:<Num:piece>))
        (play ("RollMove" (or (forEach Piece) (forEach Piece container:(mover)))))
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Burrow is a whole series of draw-free annihilation games based on the general concept of capture-templates. To begin a turn, a player takes one of his pieces and captures-via-replacement some enemy piece. Some aspect of the capture provides a template whereby the piece may perform further captures. The template can be the minimal bounding box containing the move, the directions used to achieve the capture or even the number of friendly pieces in the line-of-sight. This Ludii version is implementing the Sweep Burrow version.By far the easiest of the variants so far, Sweep Burrow's template is simply the two orthogonal directions involved in making the initial capture. The only further convention here is that if the capture was made with just movement in one direction, you cannot employ a second direction.
            
        The player may not end his turn until the capturing piece have no further captures available. 
(game "Sweep Burrow"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Disc" Each
            (if
                (= 0 (count MovesThisTurn))
                (or {
                    ("Cardinal" N
                        (then (set Var 1))
                    )
                    ("Cardinal" E
                        (then (set Var 2))
                    )
                    ("Cardinal" S
                        (then (set Var 3))
                    )
                    ("Cardinal" W
                        (then (set Var 4))
                    )
                    ("NorthEast"
                        if:(and 
                            ("NorthOf" (to) (from))
                            ("EastOf" (to) (from))
                        )
                        (then (set Var 5))
                    )
                    ("SouthEast"
                        if:(and 
                            ("SouthOf" (to) (from))
                            ("EastOf" (to) (from))
                        )
                        (then (set Var 6))
                    )
                    ("NorthWest"
                        if:(and 
                            ("NorthOf" (to) (from))
                            ("WestOf" (to) (from))
                        )
                        (then (set Var 7))
                    )
                    ("SouthWest"
                        if:(and 
                            ("SouthOf" (to) (from))
                            ("WestOf" (to) (from))
                        )
                        (then (set Var 8))
                    )
                })
                ("Continue")
                (then 
                    (if
                        (< 0 (count Sites in:("NextEnemies")))
                        (moveAgain)
                    )
                )
            )
        )
    })
    (rules
        (start {
            (place "Disc1" 
                (forEach 
                    (sites Board) 
                    if:(or
                        (and
                            (is Even (row of:(site)))
                            (> 2 (% (site) 4))
                        )
                        (and
                            (is Odd (row of:(site)))
                            (< 1 (% (site) 4))
                        )
                        
                    )
                )
            )
            (place "Disc2" 
                (forEach 
                    (sites Board) 
                    if:(or
                        (and
                            (is Odd (row of:(site)))
                            (> 2 (% (site) 4))
                        )
                        (and
                            (is Even (row of:(site)))
                            (< 1 (% (site) 4))
                        )
                        
                    )
                )
            )
            
        })
        (play (forEach Piece))
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
Satoel is a capturing game played on the island of Simeulue. It is similar to other capturing games from South and Southeast Asia, but it is played on a larger board than the others. It is said to be of Malaysian origin.9x9 intersecting lines, with diagonals in each 3x3 square. Two triangles on opposite sides, the apices of which intersect the central point on that side of the square. A line from the apex bisects the base, and this line is bisected with another line which intersects with the other two sides of the triangle. Forty pieces per player, which start on the four rows closest to the player, and on half of the central row. The central space remains empty. Players alternate turns moving a piece to an empty adjacent spot along the lines. Pieces may capture the adjacent piece of an opponent by hopping over it to an empty space directly behind it in a straight line. Multiple hops can be made in one turn if possible, with direction changes allowed. The player who captures all of their opponent's pieces wins. 
(game "Satoel"
    (players 2)
    (equipment {
        (board 
            (merge {
                (square "BoardSize" diagonals:Alternating)
                (shift 2 8 (rotate 180 (wedge 3)))
                (shift 2 -2 (wedge 3))
            })
            use:Vertex
        )
        (piece "Marker" Each
            (or 
                ("HopSequenceCapture")
                ("StepToEmpty")
            )
        )
    })
    (rules 
        (start { 
            (place "Marker1" (forEach (sites Board) if:(< (site) (centrePoint))))
            (place "Marker2" (forEach (sites Board) if:(and (> (site) (centrePoint)) (< (site) (* "BoardSize" "BoardSize")))))
        })
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Tule Paid is an alignment game played in the Assam region of India.Three concentric squares, with lines connecting the diagonals and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on an empty spot on the board. When a player places three pieces in a row along one of the lines on the board, they remove one of the pieces belonging to the opponent. When all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent spot along the lines. The first player to capture all of the opponent's pieces wins. 
(game "Tule Paid"
    (players 2)
    
    (equipment { 
        (board (concentric Square rings:3 joinCorners:True) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3")))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3"))
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Tridoku is a variant of Sudoku played on a triangle basis. 
(game "Tridoku" 
    (players 1) 
    (equipment { 
        (board (tri 9) (values Cell (range 1 9)))
        (regions {0 1 2 9 10 17 18 25 32})
        (regions {11 19 26 27 39 33 40 34 41})
        (regions {3 4 5 12 13 20 21 28 35})
        (regions {14 22 29 30 36 37 42 43 44})
        (regions {6 7 8 15 16 23 24 31 38})
        (regions {45 46 47 51 52 56 57 61 65})
        (regions {69 70 71 66 67 62 63 58 53})
        (regions {48 49 50 54 55 59 60 64 68})
        (regions {72..80})
        (regions {0..8})
        (regions {0 17 32 45 56 65 72 77 80})
        (regions {80 78 74 68 60 50 38 24 8})
        (regions {4 12 20 27 34 40 46 51 56})
        (regions {4 13 21 29 36 43 49 55 60})
        (regions {60 64 59 63 58 62 57 61 56})
    }) 
    (rules
        (start <Challenge>)
        (play 
            (satisfy {
                ("NoTwoEqualsCellSharingAVertex")
                (all Different)
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
Engijn Zirge is a simple game of alignment played in Mongolia.3x3 intersecting lines, with diagonals. Three pieces per player. Players alternate turns placing pieces on the board. Once all of the pieces have been placed, the players alternate turns moving a piece to an empty adjacent spot on the board. The first player to place their pieces in a row along one of the lines wins. 
(game "Engijn Zirge"
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 3 3)
        (hand Each)
        (piece "Marker" Each "StepToEmpty")
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win"))
    )
)

Describe the mechanics of the following Ludii game
(game "CrossGeo" 
    (players 2)
    (equipment { 
        (board <Board:type> use:Edge)
        (piece "Disc" Each) 
        (piece "Marker" Shared) 
    }) 
    
    (rules  	 
        (start
            <Version:start>
        )
        
        (play	   
            <Version:play>	   
        )
        (end      
            (if (no Moves Mover) (result Next Win))   
        )
    )
)
The game CrossGeo is a 2-player mathematical game. The game has three different versions: CrossGeo, CrossGeoR-B, and CrossGeoR-G-B. CrossGeo is the basic version, which can be played on graphs with onlu green (shared) edges.The game CrossGeo can be played on graphs with any number of edges in a geometric plane, where there are some edges crossing with other edges. The edge colours are related to the playing rules of each version. For the basic version, CrossGeo, all edges have the same colour; green. In each turn, a player selects an edge to remove it, and all its intersecting edges. The player who removes the last edge is the winner of the game. The second version is the Red-Blue version; CrossGeoR-B. There are two players, one red and one blue. Players can only select the edges of their own colours. In each turn, a player selects an edge to remove it, and all its intersecting lines (of any colour). The last version is CrossGeoR-G-B; there are sets of red, green, and blue edges, with some edges crossing. Players can select the edges of their own colours or of the green colour. Importantly, the green edges are used as shared edges between both players. At each turn, a player selects an edge to remove it and all its intersecting lines (of any colour). For all the versions of CrossGeo, if the current player has no move, then the opposing player wins.   The players play on CrossGeo version.

Construct a Ludii game based on the following description
De Vasa Chess, a chess variant played on a board made of hexagons, was invented by Helge E. de Vasa in 1953-1954. The rules originally called for eight rows, but a variant with nine rows later became more popular.De Vasa Chess is most commonly played on a 9x9 rhombus-shaped board with 81 spaces. It is sometimes played on the original layout, involving a 9x8 rhombus-shaped board with only 72 spaces.
            
            Piece Movement:
            * All pieces other than Kings and Pawns move as in Glinski Chess.
            - Queens slide in any of the 12 directions.
            - Rooks slide in any of the 6 adjacent directions.
            - Bishops slide in any of the 6 'diagonal' directions.
            - Knights move two spaces in any adjacent direction, then one space in another direction.
            * Kings step one space in any of the 12 directions, and can castle either kingside (moving two spaces) or queenside (moving three spaces). Castling can only take place when neither the King nor the Rook being moved have moved before.
            * Pawns advance without capturing to an adjacent space slightly left or right of forward. On their first move, they can move two spaces in either of these directions without capturing. They capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). En passant capture and Pawn promotion take place as in Glinski Chess.
            
        The game ends on a checkmate or stalemate. 9x9 rhombus-shaped board, with pieces on rows 1, 3, 7, and 9
(game "De Vasa Chess"
    (players {(player NNE) (player SSW)})
    (equipment {
        (board <BoardConfig:BoardLayout>)
        
        (piece "King" Each
            (or {
                ("KingStepCapture" All "History_SaveMovementChange")
                (if "Castle_PreCheck"
                    (or {
                        "Castle_KingSide"
                        "Castle_QueenSide"
                    })
                )
            })
        )
        (piece "Queen" Each ("SlideCaptureMove" All ~))
        (piece "Rook" Each ("SlideCaptureMove" Orthogonal "History_SaveMovementChange"))
        (piece "Bishop" Each ("SlideCaptureMove" Diagonal ~))
        ("ChessKnight" "Knight" (then (set Counter)))
        
        (piece "Pawn" Each
            (or {
                "PawnStep_ToEmpty"
                (if "IsFromInStartCell" "PawnStep_Double")
                "PawnCapture_Diag"
                "EnPassant_Ortho"
                }
                (then
                    (and 
                        ("ReplayInMovingOn" (sites Mover "PromotionZone"))
                        (set Counter)
                    )
                )
            )
        )
        
        (map "King"  {(pair 1 "A4") (pair 2 <BoardConfig:King2Start>)})
        (map "RookLeft" {(pair 1 "A9") (pair 2 <BoardConfig:RookLeft2Start>)})
        (map "RookRight" {(pair 1 "A1") (pair 2 <BoardConfig:RookRight2Start>)})
        
        (regions "Region-Dark" (sites Phase <BoardConfig:RegionDarkPhase>))
        (regions "Region-Light" (sites Phase <BoardConfig:RegionLightPhase>))
        (regions "Region-Medium" (sites Phase <BoardConfig:RegionMediumPhase>))
        
        (regions "PromotionZone" P1 (sites Side NE))
        (regions "PromotionZone" P2 (sites Side SW))
    })
    
    (rules
        (start {
            (place "King1" coord:"A4" state:1)
            (place "Queen1" coord:"A6")
            (place "Rook1" {"A9" "A1"} state:1)
            (place "Bishop1" {"A3" "A5" "A7"})
            (place "Knight1" {"A8" "A2"})
            
            (place "King2" coord:<BoardConfig:King2Start> state:1)
            (place "Queen2" coord:<BoardConfig:Queen2Start>)
            (place "Rook2" {<BoardConfig:RookLeft2Start> <BoardConfig:RookRight2Start>} state:1)
            (place "Bishop2" <BoardConfig:Bishop2Start>)
            (place "Knight2" <BoardConfig:Knight2Start>)
            
            (place "Pawn1" <BoardConfig:Pawn1Start>)
            (place "Pawn2" <BoardConfig:Pawn2Start>)
        })
        phases:{
        (phase "Movement"
            (play
                (if ("SameTurn")
                    ("PromoteTo" (piece {"Queen" "Rook" "Bishop" "Knight"}))
                    (do (forEach Piece)
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
            )
            (end {
                ("Checkmate" "King")
                (if (or
                        (no Moves Mover)
                        (= (counter) 100)
                    )
                    (result Mover Draw)
                )
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Chalis Gutia as played near Titagarh outside Kolkata, India was played by people from all over India working in a mill there. It has a degree of flexibility in the number of pieces used on the same board.9x9 board played on the intersections, with diagonals for each 3x3 square. Typically played with 24 pieces, but any number up to 40 is possible. Pieces are arranged on the spots in the rows closest to the player, with those unable to fill a row placed on the right points of the next available row. Players alternate turns by moving a piece to an adjacent empty spot along the lines on the board. A player may capture an opponent's piece by hopping over one adjacent piece if there is an empty spot behind it along a line on the board. The player who captures all of the opponent's pieces wins. The game starts with 24 pieces by player.
(game "Challis Ghutia (Titagarh)" 
    ("TwoPlayersNorthSouth")
    (equipment { 
        ("AlquerqueBoard" 9 9)
        (piece "Marker" Each 
            (or
                ("StepToEmpty") 
                ("HopCapture") 
            )
        )
    }) 
    
    (rules 
        (start { 
            <Start:rule>
        })
        
        (play (forEach Piece)) 
        
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
Huli-Mane Ata is a simple hunt game played in the area of Vijayanagara, India by children. Boards for this game appear at the medieval ruins of Vijayanagara, but it is unclear if the game dates to that period.A triangle, with a line drawn from the apex to the base, and two lines drawn through the height connecting the opposite two sides. One player plays as one tiger, the other as five lambs. The tiger begins on the apex of the triangle. The tiger moves to an empty adjacent spot along the lines of the board. The player who plays as the lambs plays first, placing a lamb on an empty spot on the board, and then the tiger player moves. When all of the lambs are placed, the lambs move in the same manner as the tiger. The tiger may capture a lamb by hopping over it to an empty space on the opposite adjacent side of the lamb along the lines on the board. The lambs win when they block the tiger from being able to move, the tiger wins by capturing enough lambs so that it cannot be blocked. 
(game "Huli-Mane Ata" 
    (players 2) 
    (equipment { 
        (board
            (scale 1 2 (wedge 4 3))
            use:Vertex
        )
        (hand P1) 
        (piece "Lamb" P1
            ("StepToEmpty")
        )
        (piece "Tiger" P2
            (or 
                ("StepToEmpty")
                ("HopCapture")
            )
        )
    }) 
    (rules 
        (start {
            (place "Lamb1" (handSite P1) count:5)
            (place "Tiger2" (sites Top))
        })
        
        phases:{
        (phase "Opening" P1 
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end {
            (if (no Moves P2) (result P1 Win))
            (if (< (count Pieces P1) 4) (result P2 Win))
        })
    )
)

Construct a Ludii game based on the following description
Bao Kiswahili is a four-row mancala-style game popular throughout East Africa. It is widely known as one of the more complex and difficult-to-master games in the world.4x8 board. The fourth hole from the right in the inner rows of each player is larger and square. Total of 64 counters. Starting position: in the inner row, the first four holes, number of counters from the right: 0; 2; 2; 6. Play begins with each player alternately introducing the remaining counters in their holes. Each is introduced in such a way as to capture an opponent's counters, by placing it into an occupied hole which is opposite one of the opponent's occupied inner-row holes. The opponent's counters are then captured and sown along the inner row from either the leftmost or rightmost hole. If the capture occurs in the rightmost or leftmost holes in the inner row, or the hole immediately adjacent to them in the inner row, the counters must be sown from the leftmost or rightmost hole (whichever is closest), and sown along the inner row. Captures on these subsequent sowings happen according to the same rules as in the second phase, with certain exceptions explained below. If no capture is available, a counter may be placed in any occupied hole in the inner hole except the square hole, and sows them in either direction. If the square hole is the only occupied hole in the inner row, the counter is placed there and the player sows only two seeds from it in either direction. If a loaded square hole is reduced to six counters, the player places a counter there and sows the entire contents, forfeiting the special status for this hole for the rest of the game. Moves that start without a capture on the first sowing which end in the square hole stops there without further sowing. Sowing cannot start from a square hole except to capture, except as described above. If a sowing from an initial capturing move ends in an occupied square hole and no capture is possible, the player may choose to stop there or continue to sow. Once the contents of this hole have been relayed or captured the square hole loses its special status and the player may not introduce a counter into hole with one counter if there are other holes in the inner row containing multiple counters. Once all of the counters are introduced, second phase starts. Players move by sowing seeds from a player's holes. Sowing can happen in any direction, but must continue in that direction throughout the turn except in the special cases below. When the final counter of a sowing lands in a hole in the inner row and there are counters in the opponent's hole in the inner row opposite, these are captured. The captured counters are placed in the leftmost or rightmost hole of the inner row and sown along the inner row. The leftmost or rightmost hole is chosen based on which continues the sowing direction of the move that made the capture. If the capture occurs in the rightmost or leftmost holes in the inner row, or the hole immediately adjacent to them in the inner row, the counters must be sown from the leftmost or rightmost hole (whichever is closest), and sown along the inner row, even if this incurs a change of direction. If the final counter lands in an occupied hole and a capture is not possible, the counters are picked up and sowing continues. If the final counter lands in an empty hole, the turn ends. A player must make a capturing move on their initial sowing if it is available. If a capturing move is not possible on the first sowing, no captures can be made on subsequent sowings in that turn. The game is won when the opponent's inner row is cleared of counters. 
(game "Bao Kiswahili (East Africa)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 8 store:None
            {
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "23,W,N1,E" loop:True P2)
            }		
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions "Home" P1 (expand (sites Bottom))) 
        (regions "Home" P2 (expand (sites Top)))  
        (regions "Inner" P1 (sites Row 1))   
        (regions "Inner" P2 (sites Row 2))   
        (regions "SquaresHoles" (sites {12 19}))  
        (map "LeftMostInner" {(pair P1 8) (pair P2 23)})
        (map "RightMostInner" {(pair P1 15) (pair P2 16)})
        (map "AdjacentLeftMostInner" {(pair P1 9) (pair P2 22)})
        (map "AdjacentRightMostInner" {(pair P1 14) (pair P2 17)})
    }) 
    (rules 
        (start {
            (set Count 22 at:(handSite P1))
            (set Count 22 at:(handSite P2))
            (set Count 2 to:(sites {"G2" "F2" "B3" "C3"})) 
            (set Count 6 to:(sites {"E2" "D3"})) 
        })
        
        (play 
            (if ("SameTurn")
                (if (is Pending) 
                    (or
                        (if (or (= 1 (var "Side")) (= 0 (var "Side"))) 
                            (do 
                                (fromTo
                                    (from ("OppositePit" (last To afterConsequence:True)))
                                    (to (mapEntry "LeftMostInner" Mover))
                                    count:(count at:("OppositePit" (last To afterConsequence:True)))
                                )
                                next:(move Select
                                    (from (mapEntry "LeftMostInner" Mover))
                                    (then ("Sowing" "TrackCW" 1))
                                )
                            )
                        )
                        (if (or (= 2 (var "Side")) (= 0 (var "Side"))) 
                            (do 
                                (fromTo
                                    (from ("OppositePit" (last To afterConsequence:True)))
                                    (to (mapEntry "RightMostInner" Mover))
                                    count:(count at:("OppositePit" (last To afterConsequence:True)))
                                )
                                next:(move Select
                                    (from (mapEntry "RightMostInner" Mover))
                                    (then ("Sowing" "TrackCCW" 2))
                                )
                            )
                        )
                    )
                    
                    
                    (or
                        (if (or (= (var "Direction") 1) (= (var "Direction") 3))
                            (move Select
                                (from (var "Replay"))
                                (then ("Sowing" "TrackCW" 1))
                            )
                        )
                        (if (or (= (var "Direction") 2) (= (var "Direction") 3))
                            (move Select
                                (from (var "Replay"))
                                (then ("Sowing" "TrackCCW" 2))
                            )
                        )
                    )
                )
                (if (is Occupied (handSite Mover)) 
                    (priority {
                        (move 
                            (from (handSite Mover))
                            (to (sites Mover "Inner") if:(is Occupied ("OppositePit" (to))))
                            count:1
                            (then
                                (and {
                                    (moveAgain)
                                    (set Pending)
                                    (if (is In (last To) (expand (sites Right)))
                                        (set Var "Side" 2) 
                                        (if (is In (last To) (expand (sites Left)))
                                            (set Var "Side" 1) 
                                            (set Var "Side" 0) 
                                        )
                                    )
                                })
                            )
                        )
                        (if (!= (value Player Mover) 1) 
                            (move 
                                (from (handSite Mover))
                                (to (difference (sites Mover "Inner") (sites "SquaresHoles")) if:(is Occupied (to)))
                                count:1
                                (then
                                    (and {
                                        (moveAgain)
                                        (set Var "Replay" (last To))
                                        (set Var "Direction" 3) 
                                    })
                                )
                            )
                            (move 
                                (from (handSite Mover))
                                (to (sites Mover "Inner") if:(is Occupied (to)))
                                count:1
                                (then
                                    (and {
                                        (moveAgain)
                                        (set Var "Replay" (last To))
                                        (set Var "Direction" 3) 
                                    })
                                )
                            )
                        )
                        
                        (if (!= (value Player Mover) 1)
                            (move 
                                (from (handSite Mover))
                                (to (sites "SquaresHoles") if:(is Occupied (to)))
                                count:1
                                (then
                                    (and {
                                        (moveAgain)
                                        (set Var "Replay" (last To))
                                        (set Var "Direction" 3) 
                                    })
                                )
                            )
                        )
                    })
                    
                    (priority {
                        (or 
                            (move Select
                                (from 
                                    (sites Mover)
                                    if:(and (is Occupied (from))
                                        (is Occupied ("OppositePit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                                    )
                                )
                                (then
                                    (sow
                                        "TrackCW"
                                        owner:(mover)
                                        apply:(if (is In (to) (sites Mover "Inner"))
                                            (if (is Occupied ("OppositePit" (to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Pending)
                                                    (if (is In (to) (expand (sites Right)))
                                                        (set Var "Side" 2) 
                                                        (if (is In (to) (expand (sites Left)))
                                                            (set Var "Side" 1) 
                                                            (set Var "Side" 0) 
                                                        )
                                                    )
                                                })
                                                (if (< 1 (count at:(to)))
                                                    (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                        (and {
                                                            (moveAgain)
                                                            (set Var "Replay" (to))
                                                            (set Var "Direction" 1) 
                                                        })
                                                        (set Var "Direction" 0) 
                                                    )
                                                )
                                            )
                                            (if (< 1 (count at:(to)))
                                                (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "Direction" 1) 
                                                    })
                                                    (set Var "Direction" 0) 
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (move Select
                                (from 
                                    (sites Mover)
                                    if:(and (is Occupied (from))
                                        (is Occupied ("OppositePit" ("NextHole" (from) "TrackCCW" (count at:(from)))))
                                    )
                                )
                                (then
                                    (sow
                                        "TrackCCW"
                                        owner:(mover)
                                        apply:(if (is In (to) (sites Mover "Inner"))
                                            (if (is Occupied ("OppositePit" (to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Pending)
                                                    (if (is In (to) (expand (sites Right)))
                                                        (set Var "Side" 2) 
                                                        (if (is In (to) (expand (sites Left)))
                                                            (set Var "Side" 1) 
                                                            (set Var "Side" 0) 
                                                        )
                                                    )
                                                })
                                                (if (< 1 (count at:(to)))
                                                    (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                        (and {
                                                            (moveAgain)
                                                            (set Var "Replay" (to))
                                                            (set Var "Direction" 2) 
                                                        })
                                                        (set Var "Direction" 0) 
                                                    )
                                                )
                                            )
                                            (if (< 1 (count at:(to)))
                                                (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "Direction" 2) 
                                                    })
                                                    (set Var "Direction" 0) 
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (or 
                            (move Select
                                (from 
                                    (if (!= (value Player Mover) 1)
                                        (sites Mover)
                                        (difference (sites Mover) (sites "SquaresHoles"))
                                    )
                                    if:(is Occupied (from))
                                )
                                (then
                                    (sow
                                        "TrackCW"
                                        owner:(mover)
                                        apply:(if (is In (to) (sites Mover "Inner"))
                                            (if (is Occupied ("OppositePit" (to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Pending)
                                                    (if (is In (to) (expand (sites Right)))
                                                        (set Var "Side" 2) 
                                                        (if (is In (to) (expand (sites Left)))
                                                            (set Var "Side" 1) 
                                                            (set Var "Side" 0) 
                                                        )
                                                    )
                                                })
                                                (if (< 1 (count at:(to)))
                                                    (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                        (and {
                                                            (moveAgain)
                                                            (set Var "Replay" (to))
                                                            (set Var "Direction" 1) 
                                                        })
                                                        (set Var "Direction" 0) 
                                                    )
                                                )
                                            )
                                            (if (< 1 (count at:(to)))
                                                (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "Direction" 1) 
                                                    })
                                                    (set Var "Direction" 0) 
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (move Select
                                (from 
                                    (if (!= (value Player Mover) 1)
                                        (sites Mover)
                                        (difference (sites Mover) (sites "SquaresHoles"))
                                    )
                                    if:(is Occupied (from))
                                )
                                (then
                                    (sow
                                        "TrackCCW"
                                        owner:(mover)
                                        apply:(if (is In (to) (sites Mover "Inner"))
                                            (if (is Occupied ("OppositePit" (to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Pending)
                                                    (if (is In (to) (expand (sites Right)))
                                                        (set Var "Side" 2) 
                                                        (if (is In (to) (expand (sites Left)))
                                                            (set Var "Side" 1) 
                                                            (set Var "Side" 0) 
                                                        )
                                                    )
                                                })
                                                (if (< 1 (count at:(to)))
                                                    (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                        (and {
                                                            (moveAgain)
                                                            (set Var "Replay" (to))
                                                            (set Var "Direction" 2) 
                                                        })
                                                        (set Var "Direction" 0) 
                                                    )
                                                )
                                            )
                                            (if (< 1 (count at:(to)))
                                                (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "Direction" 2) 
                                                    })
                                                    (set Var "Direction" 0) 
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    })
                )
            )
        )
        
        (end 
            (forEach Player
                if:("NoPiecesInInner" Player)
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Li'b al-'Aqil (\2x6 board. 72 counters are distributed unevenly into the holes with the only rule that corresponding holes on either side of the board must contain counters. The opponent moves first, but may flip the board around if they prefer that arrangement, sacrificing the first move. Counters are sowed in an anti-clockwise direction from a hole in the player's row. If the last counter falls into a hole making it odd, these are picked up and sowing continues. If it lands in a hole making it even, these counters are captured as are the ones in the opposite hole. If the previous hole also has an even number, these and the ones in the opposite hole are captured. If the last counter falls into an empty hole, the turn ends. If a player has no counters in their holes, the opponent must give them one counter, to be placed in the leftmost hole and played from there. Play ends when the board is cleared of counters. Each player counts the number of counters they captured. The player with more counters is given a score equal to the difference in the number of counters. Another round begins again exactly as before. The game is won when a player accumulates sixty points. 
(game "Li'b al-'Aqil" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "LeftMost" {(pair P1 0) (pair P2 11)})
    }) 
    (rules 
        (start (place "Seed" (handSite P1) count:72))
        
        phases:{
        (phase "Opening1"
            (play 
                (or {
                    (if (is Occupied Cell (handSite P1))
                        (forEach Value min:1 max:(count Cell at:(handSite P1))
                            (move 
                                (from (handSite P1))
                                (to (sites Board))
                                count:(value)
                            )
                        )
                        (forEach Site (sites Board)
                            (if (is Occupied (site))
                                (move
                                    (from (site))
                                    (to (sites Board) if:(!= (to) (from)))
                                )
                            )
                        )
                        (then (moveAgain))
                    )
                    (if (and (is Empty (handSite P1)) ("CorrespondingHolesHaveSeeds"))
                        (move Pass)
                    )
                })
            )
            (nextPhase (was Pass) "Opening2")
        )
        
        (phase "Opening2"
            (play
                (or 
                    (move Pass (then (moveAgain)))
                    (move Swap Players P1 P2)
                    (then (set Pending))
                )
            )
            (nextPhase "Sowing")
        )
        
        (phase "Sowing"
            (play
                (if (and ("NewTurn") ("NoCounters" Next))
                    (move
                        (from (sites Mover) if:(is Occupied (from)))
                        (to (mapEntry "LeftMost" Next))
                    )
                    (move Select
                        (from 
                            (if 
                                (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay") })
                                (sites Mover) 
                            ) 
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                if:True
                                apply:(if (is Odd (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                    (and
                                        (fromTo
                                            (from (to))
                                            (to (handSite Mover))
                                            count:(count at:(to))
                                        )
                                        (if (is Occupied ("OppositePitTwoRows" (to)))
                                            (fromTo
                                                (from ("OppositePitTwoRows" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePitTwoRows" (to)))
                                            )
                                        )
                                    )
                                )
                                backtracking:(and (is Occupied (to)) (is Even (count at:(to))))
                            )
                        )
                    )
                    (then
                        (if ("EmptyBoard")
                            (and
                                (if (< (count Cell at:(handSite P1)) (count Cell at:(handSite P2)))
                                    (addScore P2 (- (count Cell at:(handSite P2)) (count Cell at:(handSite P1))))
                                    (addScore P1 (- (count Cell at:(handSite P1)) (count Cell at:(handSite P2))))
                                )
                                (if (is Occupied Cell (handSite P2))
                                    (fromTo
                                        (from (handSite P2))
                                        (to (handSite P1))
                                        count:(count Cell at:(handSite P2))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase ("EmptyBoard") "Opening1")
        )
        }
        
        (end
            (forEach Player
                if:(<= 60 (score Player))
                (result Player Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Halusa is two-row mancala-style game documented in early modern Mesopotamia. It was said to be played by Arabs and Turks living there, and it is one of the earliest descriptions of the rules of a mancala game that has survived. It is similar to other mancala games which are still played in Southwest Asia today. The board is drawn as a hinged wooden box, with two rows of six holes.Play begins with six counters in each hole. Sowing is anti-clockwise. If the last counter of a sowing lands in the player's own hole making it even, the counters are captured. If the contents of the hole before it is also even, these are also taken, continuing until an odd or empty hole is reached. If the last counter makes a hole odd, the turn ends. If a player has no counters in their holes at the end of the turn, the opponent must play so that the player can play on the next turn. Play ends when neither player is able to move; the last player who was able to move takes the remaining counters and the player with the most counters captured wins. 
(game "Halusa" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        (start (set Count 6 to:(sites Track)))
        
        (play (do (move Select 
                    (from 
                        (sites Mover) 
                        if:(> (count at:(from)) 0)
                    )
                    (then 
                        (sow
                            if:(and 
                                (is In (to) (sites Mover)) 
                                (is Even (count at:(to)))
                            ) 
                            apply:(fromTo 
                                (from (to)) 
                                (to (handSite Mover)) 
                                count:(count at:(to))
                            )
                            backtracking:True
                        )
                    )
                )
                ifAfterwards:(> (count in:(sites Next)) 0)
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Quixo bears a superficial resemblance to Tic-Tac-Toe – with one player being crosses and the other circles, and with both trying to create a line of their symbol – but that's where the resemblance ends. The pieces in the game are cubes that have a circle on one side, a cross on another, and blank faces on the other four; to set up the game, players place the 25 cubes with blanks face-up on the 5x5 grid in the game board.On a turn, the active player takes a cube that is blank or bearing his symbol from the outer ring of the grid, then adds it to the grid by pushing it into one of the rows from which it was removed. Thus, a few pieces of the grid change places each turn, and the cubes slowly go from blank to crosses and circles. Play continues until someone forms an orthogonal or diagonal line of five cubes bearing his symbol, with this person winning the game. 
(game "Quixo" 
    (players 2) 
    (equipment { 
        (board (square 5)) 
        (piece "Disc" P1) 
        (piece "Cross" P2) 
        (piece "Square" Neutral)
        (hand Each)
    }) 
    
    (rules 
        (start (place "Square0" (sites Board)))
        (play
            (if "SameTurn"
                (or {
                    ("Push" ("From" Left "LastRow") E)
                    ("Push" ("From" Right "LastRow") W)
                    ("Push" ("From" Bottom "LastColumn") N)
                    ("Push" ("From" Top "LastColumn") S)
                })
                "TakeAPieceInOuterSites"
            )
        )
        (end {
            (if (is Line 5 throughAny:(sites LastTo) what:(next)) (result Next Win))
            (if (is Line 5 throughAny:(sites LastTo) what:(mover)) (result Mover Win))
        })
    )
)

Construct a Ludii game based on the following description
Mweso is a four-row mancala-style game board popular in Uganda. It has been played there since at least the early twentieth century, but it is likely older.4x8 board. 32 counters per player. Players may arrange the counters however they like in their holes. Players sow by taking the counters from one of their holes and dropping them one by one in an anti-clockwise direction only in the two rows closest to them. When the last counter lands in an empty hole, the turn is over. When the last counter falls into an occupied hole, the contents of this hole are picked up and sowing continues. If the final counter falls into an occupied hole in the inner row, and the two holes opposite it in the opponent's rows are occupied, the counters in these two rows of the opponent are taken. They are then sown on the player's side of the board beginning from the hole that received the first counter of the sowing that led to the capture. Both of the opponent's holes must be occupied to capture. Clockwise sowing is allowed in certain circumstances. If a clockwise move from the four holes on the left hand side of the players board (i.e., the left two holes in the outer row or the left two hole in the inner row) can lead to a capture, a clockwise move is allowed. Sowing cannot occur with single counters. The player who can no longer move loses. 
(game "Mweso" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "24,E,S1,W" loop:True P2)
            }
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Track "TrackCCW1"))          
        (regions "Home" P2 (sites Track "TrackCCW2"))          
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom)))   
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top)))   
        (regions "Left" P1 (intersection (sites Track "TrackCCW1") (expand (sites Left)))) 
        (regions "Left" P2 (intersection (sites Track "TrackCCW2") (expand (sites Right)))) 
        (hand Each)
    }) 
    (rules 
        
        (start {
            (set Count 32 at:(handSite P1)) 
            (set Count 32 at:(handSite P2)) 
        })
        
        phases:{
        (phase "Placing"
            (play
                (move
                    (from (handSite Mover))
                    (to (sites Mover "Home"))
                    count:1
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (or {
                    (if (!= 2 (var "Direction"))
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    (sites Mover "Home") 
                                )
                                if:(< 1 (count at:(from)))
                            )
                            (then
                                (sow
                                    "TrackCCW"
                                    owner:(mover)
                                    apply:(if (< 1 (count at:(to)))
                                        (and {
                                            (set Var "Direction" 1)
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                            (if (is In (to) (sites Mover "Inner"))
                                                (if 
                                                    (and
                                                        (is Occupied ("OppositePit" (to)))
                                                        (is Occupied ("OppositeOuterPit" (to)))
                                                    )	
                                                    (and {
                                                        (fromTo
                                                            (from ("OppositePit" (to)))
                                                            (to (last From))
                                                            count:(count at:("OppositePit" (to)))
                                                        )
                                                        (fromTo
                                                            (from ("OppositeOuterPit" (to)))
                                                            (to (last From))
                                                            count:(count at:("OppositeOuterPit" (to)))
                                                        )
                                                        (sow 
                                                            (last From)
                                                            count:(+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))))
                                                            "TrackCCW"
                                                            owner:(mover)
                                                        )
                                                    })
                                                )
                                            )
                                        })
                                        (set Var "Direction" 0)
                                    )
                                )
                            )
                        )
                    )
                    (if (!= 1 (var "Direction"))
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    (sites Mover "Left") 
                                )
                                if:(and
                                    (< 1 (count at:(from)))
                                    (if ("SameTurn")
                                        True
                                        (if (is In ("NextHole" (from) "TrackCW" (count at:(from))) (sites Mover "Inner"))
                                            (and
                                                (is Occupied ("OppositePit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                                                (is Occupied ("OppositeOuterPit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                                            )
                                            False
                                        )
                                    )
                                )
                            )
                            (then
                                (sow
                                    "TrackCW"
                                    owner:(mover)
                                    apply:(if (< 1 (count at:(to)))
                                        (and {
                                            (set Var "Direction" 2)
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                            (if (is In (to) (sites Mover "Inner"))
                                                (if 
                                                    (and
                                                        (is Occupied ("OppositePit" (to)))
                                                        (is Occupied ("OppositeOuterPit" (to)))
                                                    )	
                                                    (and {
                                                        (fromTo
                                                            (from ("OppositePit" (to)))
                                                            (to (last From))
                                                            count:(count at:("OppositePit" (to)))
                                                        )
                                                        (fromTo
                                                            (from ("OppositeOuterPit" (to)))
                                                            (to (last From))
                                                            count:(count at:("OppositeOuterPit" (to)))
                                                        )
                                                        (sow 
                                                            (last From)
                                                            count:(+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))))
                                                            "TrackCCW"
                                                            owner:(mover)
                                                        )
                                                    })
                                                )
                                            )
                                        })
                                        (set Var "Direction" 0)
                                    )
                                )
                            )
                        )
                    )
                })
            )
            
            (end (if (and (not (is Next Mover)) (no Moves Next)) (result Mover Win)))
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Chaturaji" 
    (players {(player N) (player W) (player S) (player E)}) 
    (equipment { 
        (board (square 8))
        (dice d:4 from:2 num:1)
        
        (piece "Pawn" Each
            (or 
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                (then
                    (if (is In (last To) (sites Mover "Promotion"))
                        (and (moveAgain) (set Pending))
                    )
                )
            )
        )
        (piece "Boat" Each
            (move Hop 
                Diagonal 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndAddScore"
                )
            )
        )
        (piece "Knight" Each
            (move Leap 
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndAddScore"
                ) 
            )
        )
        (piece "Elephant" Each
            (move Slide 
                Orthogonal 
                (between if:(is Empty (between))) 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndAddScore" 
                )
            )
        ) 
        (piece "King_noCross" Each
            (move Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndAddScore" 
                )
            )
        )
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Left))
        (regions "Promotion" P3 (sites Bottom))
        (regions "Promotion" P4 (sites Right))
    }) 
    (rules 
        (start { 
            (place "Pawn1" {"A2" "B2" "C2" "D2"} value:1)
            (place "Pawn2" {"G1" "G2" "G3" "G4"} value:1)
            (place "Pawn3" {"H7" "G7" "E7" "F7"} value:1)
            (place "Pawn4" {"B5" "B6" "B7" "B8"} value:1)
            (place "Boat1" coord:"A1" value:2) (place "Boat2" coord:"H1" value:2) (place "Boat3" coord:"H8" value:2) (place "Boat4" coord:"A8" value:2) 
            (place "Knight1" coord:"B1" value:3) (place "Knight2" coord:"H2" value:3) (place "Knight3" coord:"G8" value:3) (place "Knight4" coord:"A7" value:3) 
            (place "Elephant1" coord:"C1" value:4) (place "Elephant2" coord:"H3" value:4) (place "Elephant3" coord:"F8" value:4) (place "Elephant4" coord:"A6" value:4) 
            (place "King_noCross1" coord:"D1" value:5) (place "King_noCross2" coord:"H4" value:5) (place "King_noCross3" coord:"E8" value:5) (place "King_noCross4" coord:"A5" value:5) 
        })
        
        (play 
            ("RollEachNewTurnMove"
                (if (and ("SameTurn") (is Pending))
                    (or {
                        ("PromoteTo" "Boat" (set Value at:(last To) 2))
                        ("PromoteTo" "Knight" (set Value at:(last To) 3))
                        ("PromoteTo" "Elephant" (set Value at:(last To) 4))
                        ("PromoteTo" "King_noCross" (set Value at:(last To) 5))
                    })
                    "PlayAPiece"
                    (then 
                        (if 
                            (can Move "PlayAPiece")
                            (moveAgain)
                        )
                    )
                )
            )
        )
        
        (end
            (if (= 
                    (count Pieces Mover) 
                    (- (count Pieces All) 1) 
                )
                (byScore)
            )
        )
    )
)
Chaturaji is a four-player game similar in some ways to Chaturanga, the Indian game from which Chess, Shogi, and other similar games are derived. Dice are used to determine which piece is moved. Several texts give many details of the game, but are not sufficient to provide all of the rules of play.8x8 board. Four players. Two dice. Four pawns, one ship, one horse, one elephant, and one king per player. The king moves one square in any direction. Pawns move one square forward, and capture one square forward diagonally. Horses move three squares diagonally. Ships move two squares diagonally. The Elephant moves any number of squares orthogonally. Moves are determined by dice roll: 5= pawn or king, 4= elephant, 3= horse, 2= ship. Captures are made by moving onto the space occupied by an opponent's piece. If a ship moves into a space to make a 2x2 square with only ships, it captures the other three ships. Pawns may promote but only to the other piece that begins in that rank or file, including a king, and that piece must have already been captured. Points are awarded based on captures: pawns=1, ships=2, horses=3, elephants=4, kings=5. If a player captures their opponents' three kings while theirs remains, they receive 54 points. The player who accumulates the most points wins.  The rules are describing with the Wikipedia ruleset.

Construct a Ludii game based on the following description
Los Alamos Chess is a Chess variant played on a 6x6 board without bishops. It was the first Chess game played by a computer program at the Los Alamos Scientific Laboratory in 1956.The rules are the same as for Chess, except pawns cannot move two spaces on the first move, there is no castling, and no en-passant capture. 
(game "Los Alamos Chess" 
    ("TwoPlayersNorthSouth")
    (equipment { 
        (board (square 6)) 
        
        ("ChessPawn" "Pawn" ~
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        
        ("ChessRook" "Rook" (then (set Counter)))
        ("ChessKing" "King" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 4))
            (place "Rook1" {"A1" "F1"}) (place "Knight1" {"B1" "E1"}) (place "Queen1" coord:"C1") (place "King1" coord:"D1") 
            (place "Rook2" {"A6" "F6"}) (place "Knight2" {"B6" "E6"}) (place "Queen2" coord:"C6") (place "King2" coord:"D6") 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Rook"}) Mover)
                (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King" Mover)))
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Players take turns placing a piece of theirs at an empty cell. When all pieces have been placed, players take turns moving one of their pieces. The pieces move like the equivalent Chess pieces but do not capture. Any piece can hop over an adjacent enemy piece to an empty cell beyond (without capturing it). First to make a line of 3 of their pieces, at any time, wins the game. 
(game "Tic-Tac-Chess" 
    (players 2) 
    (equipment { 
        (board (square 3)) 
        (hand Each size:3)
        (piece "Queen" Each (or ("HopOpponent") (move Slide All)))
        (piece "King" Each (or ("HopOpponent") ("StepToEmpty")))
        (piece "Rook" Each (or ("HopOpponent") (move Slide Orthogonal)))
    }) 
    (rules 
        (start { 
            (place "Queen" "Hand")
            (place "King" "Hand")
            (place "Rook" "Hand")
        })
        
        phases:{
        (phase "Placement"
            (play (move ("FromHand") (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("Line3Win" Mover))
    )
)

Describe the mechanics of the following Ludii game
(game "Morpharaoh" 
    (players 2)
    (equipment {
        (board (trim <Board:type>) use:Cell)
        (piece "Disc" Each)
        (piece "Disc" Neutral)
    })
    (rules 
        (play
            (or {
                (move Add
                    (to 
                        (sites Empty)
                    )
                )
                (move Add
                    (to
                        (intersection (sites Occupied by:Next) ("SitesEdge"))
                        if:(<Edge:controlType>)
                        (apply (remove (to)))
                    )
                )
                (move Add
                    (to
                        (difference (sites Occupied by:Next) ("SitesEdge"))
                        if:(<Center:controlType>)
                        (apply (remove (to)))
                    )
                )
                }
                (then "Check4Win")
            )
        )
        (end 
            (if
                (is Triggered "Win" Mover)
                (result Mover Win)
            )
        )
    )
)
The title of the game Morpharaoh is a nod to capture (morph), connection (a row), a previous square grid connection game by Luis Bolaños Mures' Morphos which inspired it, and to the Cairo tiling used for the board.    The game solves the cross-cut problem of boards with cells that meet 4-to-a-vertex in some locations, by use of a capture based on a majority n of adjacencies, thus preventing immediate recapture. To minimise the amount of captures, and thus provide the a more strategic game than one based on simple majority captures, the captures are limited to those that resolve crosscuts along an existing diagonal connection, using a lobsided 'V' pattern of surrounding stones. -- and restricting edge capture to captures adjacent to an adjacent pair of stones.     Option is provided for independently relaxing these restrictions.  A pie offer option has not yet been implemented.      The boards provided are a 48 cell and 160 cell board, designed specifically to provide an odd number of neighbors to each cell: 5 in the interior, and 3 at every edge cell. The Cairo board is one of the few regualr grids that permit such a condition. It also dilutes the possible cross-cuts to two per location, compared with 4 per location on a square grid.Goal: Connect your opposite sides with a continuous chain of stones on edge-to-edge ('orthogonally adjacent') cells.
            
            Achieving the goal ends the game.
            
            Players take turns. There is no passing.
            -- On a turn the mover either places a stone from their supply on an empty space, or uses it to replace an opponent's stone on a space that the mover controls. 
            
            Edge spaces are controlled by two orthogonally adjacent mover stones that are also orthogonally adjacent to each other.
            
        All other spaces are controlled by having at least 3 orthogonally adjacent mover stones, one of which that is both orthogonally adjacent to the second, and diagonally adjacent to the third. Using an order 1 board with 48 cells Any 2 of your pieces adjacent to an edge location give control of the location. but not next to pieces that already have more than 2 neighbors.

Describe the mechanics of the following Ludii game
(game "Breakthrough Chess" 
    ("TwoPlayersNorthSouth")
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn")
        ("ChessRook" "Rook")
        ("ChessKing" "King")
        ("ChessBishop" "Bishop")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Queen")
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play (forEach Piece))
        (end (if (and "ReachedTarget" (or "LastMoveWasKnight" "LastMoveWasPawn")) (result Mover Win))) 
    )
)
A variant of Breakthrough played with Chess pieces and rules (mostly).Chess-Breakthrough is played using a regular chess board and pieces and from the standard chess start position. The first player to place a pawn or a knight on the opponent’s backrank wins (thus no promotions). The normal chess rules for piece movements have also been slightly modified to fit our simplified boardgame framework: castling, en-passant, and two-step pawn moves are not allowed; a king can be moved into and left in check (and thus captured); and the draw-by-threefold-repetition and 50-move rules do not apply. 

Construct a Ludii game based on the following description
Gopher is a simple game made by Mark Steere to be easy to program.The first player begins the game by placing a stone anywhere on the board. Then, starting with the second player, players take turns placing a stone orthogonally adjacent to exactly one enemy stone and no friendly stones. 
(game "Gopher"
    (players 2)
    (equipment {
        (board (hex 6))
        (piece "Disc" Each)
    })
    (rules
        (play
            (if 
                (= 0 (count Moves))
                (move Add (to (sites Empty)))
                (move Add
                    (to
                        (sites Empty)
                        if:(and 
                            (= 0
                                (count Sites
                                    in:(sites Around
                                        (to)
                                        Own
                                    )
                                )
                            )
                            (= 1
                                (count Sites
                                    in:(sites Around
                                        (to)
                                        Enemy
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
Dam is a game with leaping captures that was played at least since the early twentieth century in Sri Lanka. It is closely related to Draughts games known throughout the world.12x12 checkered board. Thirty pieces per player, placed on the white spaces in the first five ranks on each player's side. Pieces move diagonally forward or backward. The opponent's pieces are captured by hopping over them. Multiple hops by one piece are allowed in one turn if they are possible. When they reach the opposite edge of the board from where they started, they become Kings. Kings may move diagonally any number of spaces.  They may capture pieces proceeding along its diagonal in one direction, as long as the next space beyond the piece to be captured is empty. It may not hop over any pieces which belong to the same player, or those belonging to the opponent except to capture them. Multiple captures for the King can only be made along the same diagonal, except when it makes a capture that brings it to the edge of the board, it can make another capture along the next available diagonal, if possible. The player who captures all of the opponent's pieces wins.  
(game "Dam" 
    (players 2)
    ("DraughtsEquipment" (square 12)) 
    (rules 
        ("WhiteCellsSetup" 5)
        
        (play 
            (if "SameTurn"
                (or
                    (if "IsUnpromoted"
                        ("HopDiagonalSequenceCaptureAgain")
                        ("DoubleCounterHopAgain") 
                    )
                    (move Pass)
                )
                (or 
                    (forEach Piece "Counter" 
                        (or
                            ("HopDiagonalSequenceCapture") 
                            ("StepToEmpty" Diagonal)
                        )
                    )
                    (forEach Piece "DoubleCounter"
                        (or
                            ("DoubleCounterHop")
                            (move Slide (directions Diagonal)) 
                        )
                    )
                )
                (then 
                    (if (and "IsUnpromoted" "JumpToPromotionZone")
                        (promote (last To) (piece "DoubleCounter") Mover)
                    )
                )	
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Spots was created by Cameron Browne for Ludii. It is played on a hexagonal board.Players take turns marking any unmarked cell with no marked neighbour. Player who can’t move loses. 
(game "Spots" 
    (players 2) 
    (equipment { 
        (board (hex 5))
        (piece "Marker" Neutral) 
    }) 
    
    (rules 
        (play 
            (move Add 
                (piece "Marker0") 
                (to 
                    (sites Empty) 
                    if:"NoNeighbour"
                )
            )
        )
        (end ("NoMoves" Loss))
    )
)

Describe the mechanics of the following Ludii game
(game "Ad elta stelpur" 
    (players 2) 
    (equipment { 
        (board (rectangle 2 13) 
            {
            (track "NormalTrack" {0..5 7..12 25..20 18..13} loop:True)
            (track "CornerTrack" {0 5 7 12 25 20 18 13} loop:True)
            }
            use:Vertex
        ) 
        (regions "LeftMost" P1 {0 1})
        (regions "LeftMost" P2 {24 25})
        (dice num:2)
        (piece "Disc" Each) 
    })
    
    (rules
        (start { 
            (place "Disc1" {0..5})
            (place "Disc2" {20..25})
        })
        
        (play 
            (do 
                (if ("NewTurn") 
                    (roll)
                    (if 
                        (and 
                            (not ("UsedADie6")) 
                            (not ("AnyDieIs6Or1"))
                        ) 
                        (roll)
                    )
                )
                next:(if ("UsedADie6")
                    (forEach Piece 
                        ("MoveAPiece" ("WithDie6Again"))
                    )
                    (forEach Die 
                        if:("DieIs6Or1")
                        (if ("DieIs1")
                            (forEach Piece 
                                ("MoveAPiece" ("WithDie1"))
                            )
                            (forEach Piece 
                                ("MoveAPiece" ("WithDie6")) 
                                (then 
                                    (and 
                                        ("UseADie6") 
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                    ) 
                    (then 
                        (if (or 
                                ("AnyDieIs6Or1") 
                                (all DiceEqual)
                            )
                            (moveAgain)
                        )
                    )
                )
            )
        )
        
        (end ("CaptureAll" Next)) 
    )
)
Að Elta Stelpur (\Played on a standard Backgammon board. Six pieces per player. Pieces begin the game, one on each point on the left half of the player's side of the board. Pieces move in an anti-clockwise direction for both players. Two six-sided dice are rolled. When a 6 is rolled, the player moves two pieces six places. If this is on the player's first turn it must be the two pieces furthest to the left. If a 1 is rolled, the player moves one piece one spot. If doubles are rolled, the player moves twice the normal roll, and plays again. When one player is reduced to a single piece, it moves only to a consecutive corner space with the roll of each 1, or two corner spaces with the roll of each 6, doubling still applies. The first player to capture all of the opponent's pieces wins. 

Construct a Ludii game based on the following description
Diviyan Keliya is a hunt game played in India and Sri Lanka. It has been documented since at least the early twentieth century, but is likely to be much older. It is similar to other hunt games played throughout South Asia.One player has two leopards, the other has 24 cows. Play begins by each player taking turns to place their pieces, and then can move to one adjacent intersection. Leopards capture cows by hopping over them. Leopards win by capturing all the cows, cows win by blocking the leopards from moving. The leopard can jump to capture.
(game "Diviyan Keliya" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithFourTriangles") 
        (hand Each)
        (piece "Leopard" P1)
        (piece "Cow" P2 "StepToEmpty") 
    }) 
    (rules 
        (start { 
            (place "Leopard1" "Hand1" count:2)
            (place "Cow2" "Hand2" count:24)
        })
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                ) 
            )
            {
            (nextPhase P1 ("HandEmpty" P1) "MovementP1")
            (nextPhase P2 ("HandEmpty" P2) "MovementP2")
            }
        )
        
        (phase "MovementP1" P1
            (play <Move:leopard>) 
        )
        
        (phase "MovementP2" P2
            (play (forEach Piece))
        )
        
        }
        
        (end ("NoMoves" Loss)) 
    )
)

Construct a Ludii game based on the following description
Ikibuguzo is a four-row mancala-style board game from the Great Lakes Region of Africa. It is closely related to other games in the region, but with different opening positions and the possibility of winning by making a specific capture.4x8 board. Two counters in each hole. Opening play:  Players rearrange their counters so that there are four counters in each hole of their outer row. If they play with the second array, they take turns sowing from each of the holes with four  counters, beginning with the rightmost hole, placing two in the first hole and one in each of the following. Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over. For capturing: Holes are in 'opposition' when one player has the front row hole occupied and the opponent has both of the holes opposite it occupied. If the last hole in a sowing is in opposition, the player takes the counters in both of the opponent's holes and places them in the empty hole from which the player lifted the counters. The player then sows the captured counters from this hole. Further captures in the sowing can occur in the same way. However, each player has two hole from which clockwise plays can be made: the leftmost hole in the outer row and the second from the left in the inner row. Clockwise moves can only be made from these holes if they immediately lead to a capture. When the captured counters are sown, starting from the same hole, they can also be sown clockwise if they lead to a capture. If they cannot lead to a capture, they are sown anti-clockwise. Another alternative the player has is that, if the player plays clockwise from one of these holes and therefore makes a capture, the captured counters may be placed in the hole and left there, and the player may play instead from the other hole from which clockwise captures are allowed in a clockwise direction, if it leads to a capture. The player may continue playing from this hole as above until the possibilities to move are exhausted, and then may move from any hole in an anti-clockwise direction. Multiple captures can only be made in a clockwise direction from these holes if it is made on the first sowing of the turn. Otherwise, only one clockwise capture can be made and sowing must proceed in an anti-clockwise direction. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses. A player may also win by capturing the counters from both of the opponent's end holes in the inner row in a single turn.
         
(game "Ikibuguzo (Opening 2)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "24,E,S1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (map "RightMost" {(pair P1 7) (pair P2 24)})
        (map "LeftMostOuter" {(pair P1 0) (pair P2 31)})
        (map "SecondLeftInner" {(pair P1 9) (pair P2 22)})
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(union (sites Bottom) (sites Top))))
        
        phases:{
        (phase "FirstMove"
            (play
                (move 
                    (from ("RightMostWithFour"))
                    (to ("NextHole" (from) "TrackCCW" 1))
                    count:2
                    (then
                        (and {
                            (fromTo
                                (from (last From))
                                (to ("NextHole" (last From) "TrackCCW" 2))
                                count:1
                            )
                            (fromTo
                                (from (last From))
                                (to ("NextHole" (last From) "TrackCCW" 3))
                                count:1
                            )
                            (set Value Mover (last From))
                        })
                    )
                )
            )
            (nextPhase Mover (= (last From) (mapEntry "LeftMostOuter" Mover)) "MainPhase")
        )
        
        (phase "MainPhase"
            (play
                (or
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)}) 
                            )
                            if:(and {
                                if:(if ("SameTurn")
                                    (< 0 (count at:(from)))
                                    (< 1 (count at:(from)))
                                )
                                (is In (from) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)}))
                                (is In ("NextHole" (from) "TrackCW" (count at:(from))) (sites Mover "Inner"))
                                (is Occupied ("OppositePit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                                (is Occupied ("OppositeOuterPit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                            })
                        )
                        (then 
                            (sow
                                "TrackCW"
                                owner:(mover)
                                apply:
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and {
                                                (is Occupied ("OppositePit" (to)))
                                                (is Occupied ("OppositeOuterPit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            })
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                                (set Var "Replay" (from))
                                            })
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover) 
                            )
                            if:(if ("SameTurn")
                                (< 0 (count at:(from)))
                                (< 1 (count at:(from)))
                            )
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                owner:(mover)
                                apply:
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and {
                                                (is Occupied ("OppositePit" (to)))
                                                (is Occupied ("OppositeOuterPit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            })
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                                (set Var "Replay" (from))
                                            })
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end ("BlockWin"))
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Sonka"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "Track1" "11,10,W,S,E" loop:True P1)
            (track "Track2" "0,1,E,N,W" loop:True P2)
            }
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Bottom))
        (regions "Home" P2 (sites Top))
        (map {(pair P1 LastSite) (pair P2 FirstSite)}) 
    }) 
    (rules 
        (start (set Count 6 to:(union (sites Bottom) (sites Top))))
        
        phases:{
        (phase "Sowing"
            (play 
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover "Home") 
                        ) 
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (!= 0 (count at:("NextSite" from:(to))))
                                (moveAgain)
                                (if (is In (to) (sites Mover "Home"))
                                    (if (!= 0 (count at:("OppositePit" (to))))
                                        (fromTo
                                            (from ("OppositePit" (to)))
                                            (to (mapEntry Mover))
                                            count:(count at:("OppositePit" (to)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end (if (all Passed)
                    {
                    (if (> 6 (count at:(mapEntry P1))) (result P2 Win))
                    (if (> 6 (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase (all Passed) "BetweenRounds")
        )
        (phase "BetweenRounds"
            (play
                (if (<= 6 (count at:(mapEntry Mover)))
                    (move
                        (from (mapEntry Mover))
                        (to (intersection (sites Empty) (sites Mover "Home")))
                        count:6
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)
Sonka is a two-row mancala-style board game played by the Iloko people of the Philippines.2x5 board with one store on either side. Six counters in each hole. Players play each turn simultaneously. Players sow from the holes in their row in an anti-clockwise direction, including their own store but not the opponent's store. When the final counter is sown, the contents of the next hole are picked up and sowing continues. If this hole is empty, the move ends and the player must wait for the other player to finish the move before they begin again. If the move ends in the player's own row, the player captures the counters in the opponent's row opposite to the one in which the last counter was dropped. Play continues until all of the counters are in the stores. The counters are then redistributed into the holes as at the beginning of the game. The player with extra counters places them in the store. 

Describe the mechanics of the following Ludii game
(game "Wrigglers"
    (players 2)
    (equipment {
        (board <BoardShape:gridType> use:Vertex)
        (piece "Disc" Each)
    })
    (rules
        (play
            (if
                (= 1 (var "Added"))
                (or {
                    "AddOrPass"
                    (forEach Piece
                        (if
                            (< 2 (count Pieces Mover in:(sites Around (from) "GridDirection"))) 
                            (move Remove (from)
                                (then (set Var "Added" 0))
                        ))
                        Mover
                    )
                })
                "AddOrPass"
                (then ("Score4" Mover))
            ) 
        )
        (end 
            (if
                (all Passed)
                {
                (if
                    (>= (score Mover) (score Next))
                    (result Mover Win)
                )
                }
                (result Next Win)
            )
        )
    )
)
Wrigglers is a Hex grid based placement game that allows a minimal amount of self-removal, and has a goal of maximizing the product of one's largest 2 groups.        The rules are very simple and the actions of the players highly independent, except for blocking by site occupation. However the goal and the difficulty of modifying one's groups make the game challenging and removals allow for end-game turnarounds.            Removal is only allowed where a player has committed to the removal on a previous turn by placing a stone that overcrouds an existing piece. This destroys the group's scoring potential, but allows the overcrouded piece to be removed, potetially dividing the group in a way the increases its potential to score.         With multiplicative scoring, two equal sized groups score far more than a single group with the same number of pieces. But if there is a 3rd group available, the benefit might be much less.Goal:Score the product of the sizes of your two largest chains. Highest score wins. 
            In case of a tie, the last to play wins.
            
            Chains are a series of adjacent like-colored stones with no branching.
            
            Play:
            Boards starts empty. The darker color starts.
            
            On a turn the moving player does one of these actions:
            - Place one of their stones onto an empty site adjacent to no more than 2 of their stones, or
            - Remove one of their stones that is adjacent to more than two of their stones.
            
            Otherwise he passes.
            
        The game ends when both players pass.  Order 3-4, Hex Grid

Construct a Ludii game based on the following description
Maleys is a Draughts game played in the Netherlands during the nineteenth century. It was speculated at the time that the rules were derived from another game from Dutch-colonised Indonesia, but there is no evidence of this.10x10  board. Twenty pieces per player, which begin in the four rows closest to the players. Pieces move diagonally forward one space. Pieces capture orthogonally or diagonally, in any direction, when there is one empty space between the piece and the opponent's piece, and an empty space immediately on the opposite side of the opponent's piece. Pieces are promoted to Queen when they reach the edge of the board opposite from where they start. Queens may capture orthogonally or diagonally in any direction over any distance, as long as there are no other pieces intervening and there is an empty spot immediately after the piece to be captured, which is where the Queen lands to make the capture. Multiple captures are allowed  for Queens and regular pieces. Queens move orthogonally or diagonally any distance. The player who captures all of the opponent's pieces wins. 
(game "Maleys" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 10))
    (rules 
        ("BlackCellsSetup" 4)
        
        (play 
            (if ("SameTurn")
                (or
                    (if ("IsUnpromoted")
                        (or 
                            ("DiagonalHopCaptureCounter" (from (last To)) ("CounterMoveAgainIfCanCaptureAgain")) 
                            ("OrthogonalHopCaptureCounter" (from (last To)) ("CounterMoveAgainIfCanCaptureAgain"))
                        )
                        (or 
                            ("DiagonalHopCaptureDoubleCounter" (from (last To)) ("DoubleCounterMoveAgainIfCanCaptureAgain")) 
                            ("OrthogonalHopCaptureDoubleCounter" (from (last To)) ("DoubleCounterMoveAgainIfCanCaptureAgain"))
                        )
                    )
                    (move Pass)
                )
                (or 
                    (forEach Piece "Counter" "CounterMove")
                    (forEach Piece "DoubleCounter" "DoubleCounterMove")
                )
            )
        ) 
        
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
Pasang is a capturing game played in Brunei. The board is set up in a number of different common arrangements of pieces. It was generally played by women, and particularly when attending marriage, initiation, or circumcision ceremonies. The pieces were generally stored in a cup in the center of the board.11x11 intersecting lines, with the central nine points out of play. Diagonal lines connect the corners of the central square of the board to the outer corners. Played with  two to four players. Black and white stones fill the board, alternating color, with black in the corners of the board. The first player captures one of the stones on one of the corners of the board. Subsequent moves involve capturing a stone by hopping over it with an adjacent stone to an empty space. Multiple captures are possible, but only one, three, five, or seven are allowed in a turn. If an even number of captures is possible, the final capture cannot be taken. Players are not required to capture as many as may be possible. The game ends when no more captures are possible. The player with the highest score wins: black stones count as one, white as two. 2 Players.
(game "Pasang"
    (players <Players:num>) 
    (equipment { 
        (board 
            (add
                (remove
                    (square 11)
                    vertices:{48 49 50 59 60 61 70 71 72}
                )
                edges:{ {0 12} {12 24} {24 36} {10 20} {20 30} {30 40} {75 87} {87 99} {99 111} {71 81} {81 91} {91 101} }
            )
            use:Vertex
        ) 	
        (piece "Marker" Shared ("Move" (from) ("CaptureAgain")))
        (piece "Disc" Shared ("Move" (from) ("CaptureAgain")))
    })
    (rules 
        (start {
            (place "Marker" (forEach (sites {0..47 56..63}) if:(is Even (site))))
            (place "Disc" (forEach (sites {0..47 56..63}) if:(is Odd (site))))
            (place "Marker" (forEach (sites {48..55 64..111}) if:(is Odd (site))))
            (place "Disc" (forEach (sites {48..55 64..111}) if:(is Even (site))))
        })
        phases:{
        (phase "InitPhase"
            (play
                (move Remove
                    (sites Corners)
                    (then (set Score Mover 1))
                )
            )
            (nextPhase "MainPhase")
        )
        
        (phase "MainPhase"
            (play 
                (if ("SameTurn")
                    (and
                        (move Pass
                            (then
                                (forEach Site (sites Board) 
                                    (if (= 1 (state at:(site))) 
                                        (set State at:(site) 0)
                                    )
                                )		
                            )
                        )
                        ("Move" (from (last To)) ("CaptureAgain"))
                    )
                    (forEach Piece Shared)
                )
            )
        )
        }
        (end (if (no Moves Next) (byScore)))
    )
)

Construct a Ludii game based on the following description
This version of \2x6 board with two store holes on either end. Play begins with four counters in each row. For the opening move, a player may take all of the counters in one hole and add them to the next hole. Play continues with players sowing from any one of the holes in their row in an anti-clockwise direction. If a sowing reaches the hole from which the sowing began, this hole is skipped. If the final counter falls in a hole containing three counters, thus making it contain four counters, these are captured. An unbroken sequence of holes containing four counters moving backwards from the final hole are also captured. Single counters cannot be sown. If a player cannot move, the opponent must sow in a way that allows them to play on the next turn. Play continues until one player has no counters on their side of the board. The player with the most captured counters wins. 
(game "English Wari (St. Lucia)" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    (rules 
        (start (set Count 4 to:(sites Track)))
        
        phases:{
        (phase "Init" 
            (play 
                (move Select 
                    (from (sites Mover)) 
                    (then 
                        (fromTo 
                            (from (last To)) 
                            (to ("NextSiteOnTrack" 1 from:(last To))) 
                            count:(count at:(last To))
                        ) 
                    )
                )
            ) 
            (nextPhase (= (next) 1) "Sowing")
        )
        (phase "Sowing" 
            (play 
                (do 
                    (move Select 
                        (from 
                            (sites Mover) 
                            if:(> (count at:(from)) 1)
                        )
                        (then 
                            (sow
                                if:(= (count at:(to)) 4)
                                apply:(fromTo 
                                    (from (to)) 
                                    (to (mapEntry (mover))) 
                                    count:(count at:(to))
                                )
                                includeSelf:False
                                backtracking:True
                            )
                        )
                    )
                    ifAfterwards:"NoMovesNext"
                )
            )
        )
        }
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Wa'aché Waledat is a two-row mancala-style board game played in Eritrea. It is typically played only by men and boys. It contains some of the rule mechanisms common to other Gabata games of Ethiopia.2x6 board. Three counters per hole. Sowing occurs in an anti-clockwise direction when starting from the right three holes of a player's row, or in a clockwise direction when starting from the player's left three holes. When the final counter falls into an occupied hole, these are picked up and sowing continues, except when this hole is made to contain four counters, in which case these counters are captured and the player takes another turn. These captures may not be made on the first turn. When the final counter lands in an empty hole, the turn ends. Play continues until one player is without counters in their row. The opponent then captures the remaining counters in their row, and the player that has captured the most counters wins. 
(game "Wa'ache Waledat"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Bottom))      
        (regions "Home" P2 (sites Top))      
        (regions "RightHome" P1 (intersection (expand (sites Right) steps:2) (sites Bottom))) 
        (regions "RightHome" P2 (intersection (expand (sites Right) steps:2) (sites Top)))  
        (regions "LeftHome" P1 (intersection (expand (sites Left) steps:2) (sites Bottom))) 
        (regions "LeftHome" P2 (intersection (expand (sites Left) steps:2) (sites Top)))  
        (hand Each)
    }) 
    (rules 
        (start (set Count 3 to:(sites Track)))
        
        (play 
            (or
                (if (or (>= 0 (var "Direction")) (= 1 (var "Direction")))
                    (move Select
                        (from
                            (if (and ("SameTurn") (= 1 (var "ContinueSowing")))
                                "LastHoleSowed" 
                                (sites Mover "RightHome")
                            )
                            if:(> (count at:(from)) 0)
                        )
                        (then
                            (sow
                                "TrackCCW"
                                apply:(if (< 1 (count at:(to)))
                                    (and {
                                        (moveAgain)
                                        (set Var "Direction" 1)
                                        (set Var "ContinueSowing" 1)
                                        (if (and (= 4 (count at:(to))) (< 2 (count Turns)))
                                            (and
                                                (fromTo
                                                    (from (to))
                                                    (to (handSite Mover))
                                                    count:4
                                                )
                                                (set Var "ContinueSowing" 0)
                                            )
                                        )
                                    })
                                    (set Var "Direction" 0)
                                )	
                            )
                        )
                    )
                )
                (if (or (>= 0 (var "Direction")) (= 2 (var "Direction")))
                    (move Select
                        (from
                            (if (and ("SameTurn") (= 1 (var "ContinueSowing")))
                                "LastHoleSowed" 
                                (sites Mover "LeftHome")
                            )
                            if:(> (count at:(from)) 0)
                        )
                        (then
                            (sow
                                "TrackCW"
                                apply:(if (< 1 (count at:(to)))
                                    (and {
                                        (moveAgain)
                                        (set Var "Direction" 2)
                                        (set Var "ContinueSowing" 1)
                                        (if (and (= 4 (count at:(to))) (< 2 (count Turns)))
                                            (and
                                                (fromTo
                                                    (from (to))
                                                    (to (handSite Mover))
                                                    count:4
                                                )
                                                (set Var "ContinueSowing" 0)
                                            )
                                        )
                                    })
                                    (set Var "Direction" 0)
                                )	
                            )
                        )
                    )
                )
                (then
                    (if ("OneRowEmpty")
                        (and 
                            (forEach Site (sites P1 "Home")
                                (fromTo
                                    (from (site))
                                    (to (handSite P1))
                                    count:(count at:(site))
                                )
                            )
                            (forEach Site (sites P2 "Home")
                                (fromTo
                                    (from (site))
                                    (to (handSite P2))
                                    count:(count at:(site))
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" ("NoPieceOnBoard")))
    )
)

Describe the mechanics of the following Ludii game
(game "Seesaw Draughts"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Disc" P1 N)
        (piece "Disc" P2 S) 
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    })
    (rules
        (start { 
            (place "Disc1" (difference (expand (sites Bottom) steps:2) (sites Phase 1)))
            (place "Disc2" (difference (expand (sites Top) steps:2) (sites Phase 1)))
        })
        (play
            (priority 
                (forEach Piece "Disc"
                    ("Capture")
                    top:True
                )
                (forEach Piece "Disc"
                    ("Step")
                    top:True
                )
            )
        )
        (end ("NoMoves" Loss))
    )
)
Seesaw Draughts is a Draughts variant invented in 2021 by Alek Erickson and Michael Amundsen, and it is based on their game Seesaw.In Seesaw Draughts, when a man reaches the rank farthest away in its stepping direction, its capture range is increased and it changes the direction it steps in. It can thereby promote again if it reaches the opposite rank.
            
            The mechanism is implemented like this: All men are stacks. Single pieces are stacks of size 1. Every time a man promotes a piece is added to it, so it's stack size increases by 1. The following two-fold meaning of stack size is the key idea:
        1) Odd stacks step forwards and even stacks step backwards.
    2) A stack of size n can capture a piece up to n steps away in a straight line provided that there are no pieces between the capturing piece and its target, and that the square immediately behind the target in the capture direction is empty. The capturing piece must land there.
    
    Thus, the men gradually acquire the capturing power of a king in Thai Checkers as they seesaw up and down the board.
    
    There is no obligation to choose the capture sequence that maximizes the number of pieces captured. We deem this calculation a bit too demanding when a stack's range is a function of its size.
    
Other than this, the rules are as in Brazillian Draughts/Checkers, which is like International Draughts, but on 8x8. 

Construct a Ludii game based on the following description
Half Chess is a game with rules as described by John Groeneman, from the late 1960s. It is played on a 4x8 Chess board without the pawns.Half Chess is played with the same rules as chess. 
(game "Half Chess" 
    (players 2) 
    (equipment { 
        (board (rectangle 4 8)) 
        
        ("ChessRook" "Rook" (then (set Counter)))
        ("ChessKing" "King" (then (set Counter)))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
    }) 
    (rules 
        (start { 
            (place "Rook1" {"H1" "H4"}) (place "Knight1" {"G1" "G4"}) (place "Bishop1" {"G2" "G3"}) (place "Queen1" coord:"H3") (place "King1" coord:"H2") 
            (place "Rook2" {"A1" "A4"}) (place "Knight2" {"B1" "B4"}) (place "Bishop2" {"B2" "B3"}) (place "Queen2" coord:"A3") (place "King2" coord:"A2") 
        })
        
        (play (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King" Mover))))
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Hexagonal GoThe board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players total the number of intersections their pieces occupy or surround. The player with the highest total wins. For more info on this version please google Hexagonal Go. Hex Grid - Standard Order 3 board
(game "HexGo"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Ball" P1)
        (piece "Ball" P2)
    })	
    (rules 
        (meta (no Repeat))
        (play 
            (or
                (do
                    (move Add
                        (to (sites Empty))
                        (then "CaptureSurroundedPiece")
                    )
                    ifAfterwards:("HasFreedom" Orthogonal)
                )
                (move Pass)
            )
        )  
        (end
            (if (all Passed)
                (byScore {
                    (score P1 (+ (score P1) (size Territory P1))) 
                    (score P2 (+ (score P2) (size Territory P2)))
                })
            )
        )
    )	
    
)

Construct a Ludii game based on the following description
Damas is a Draughts game known from at least sixteenth century Spain. In it, the king has a long move, which influenced later Draughts games and may have even inspired the long queen and bishop in Chess.8x8 checkered board. twelve pieces per player, placed on the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space. Captures are compulsory, multiple captures are possible, the maximum capture possible is required, and failure to do so is penalized by the huff, where the piece that should have made the capture is itself captured. When a piece reaches the opposite edge of the board from where it started, it becomes a king. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins. 
(game "Damas" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 8)) 
    (rules 
        ("BlackCellsSetup" 3)
        
        (play 
            (if ("SameTurn")
                (if "IsUnpromoted"
                    (max Moves
                        ("HopCapture" (from (last To)) (directions {FR FL})
                            (then
                                (if (is In (last To) (sites Next))
                                    (and
                                        (promote (last To) (piece "DoubleCounter") Mover)
                                        ("ReplayIfCanMove" ("HopCaptureDistance" (from (last To)) Diagonal))
                                    )
                                    ("ReplayIfCanMove" ("HopCapture" (from (last To)) (directions {FR FL})))
                                )
                            )
                        )
                    )
                    (max Moves 
                        ("HopCaptureDistance" (from (last To)) Diagonal ~
                            (then ("ReplayIfCanMove" ("HopCaptureDistance" (from (last To)) Diagonal)))
                        ) 
                    )
                )
                
                (do 
                    ("RememberSiteWithPossibleCapture") 
                    next:(or {
                        
                        (forEach Piece "Counter"
                            (max Moves
                                ("HopCapture" (from) (directions {FR FL})
                                    (then
                                        (and
                                            "StoreCapturingPiece"
                                            (if (is In (last To) (sites Next))
                                                (and
                                                    (promote (last To) (piece "DoubleCounter") Mover)
                                                    ("ReplayIfCanMove" ("HopCaptureDistance" (from (last To)) Diagonal))
                                                )
                                                ("ReplayIfCanMove" ("HopCapture" (from (last To)) (directions {FR FL})))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (forEach Piece "DoubleCounter"
                            (max Moves 
                                ("HopCaptureDistance" (from) Diagonal ~
                                    (then 
                                        (and
                                            "StoreCapturingPiece"
                                            ("ReplayIfCanMove" ("HopCaptureDistance" (from (last To)) Diagonal))
                                        )
                                    )	
                                )
                            )
                        )
                        
                        (forEach Piece "Counter"
                            ("StepToEmpty" 
                                (directions {FR FL}) 
                                (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                            )
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal))
                    })
                    (then
                        (and
                            (if (and (!= ("LastCapturingPiece") (last To)) (not (is In (last To) ("SitesWithPossibleCaptureInPreviousTurn"))))
                                (remove ("SitesWithPossibleCaptureInPreviousTurn"))
                            )
                            (if (and (!= ("LastCapturingPiece") (last To)) (is In (last From) ("SitesWithPossibleCaptureInPreviousTurn")))
                                (remove (last To))
                            )
                        )
                    )
                )
            )
        ) 
        
        (end ("ForEachPlayerNoMovesLoss"))
    )
)

Construct a Ludii game based on the following description
Yovodi is a two-row mncala-style board game played by the Ewe people of Togo and Ghana.2x6 board with two stores. Four counters in each hole. Sowing occurs in a clockwise direction. When the final counter of a sowing lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the player's own row, the contents of the hole opposite it in the opponent's row are captured. If the final counter lands in an empty hole in the opponent's row, the opponent captures the counters in the hole opposite it in the player's row. The player who captures the most counters wins. 
(game "Yovodi"
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            (track "Track" "6,W,N,E" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))
        (play 
            (move Select 
                (from 
                    (if ("SameTurn") 
                        ("LastHoleSowed") 
                        (sites Mover) 
                    ) 
                    if:(< 0 (count at:(from)))
                )
                (then 
                    (sow 
                        apply:(if (> (count at:(to)) 1)
                            (moveAgain)
                            (if (is In (to) (sites Mover))
                                (fromTo 
                                    (from ("OppositePitTwoRows" (to))) 
                                    (to (mapEntry (mover))) 
                                    count:(count at:("OppositePitTwoRows" (to)))
                                )
                                (fromTo 
                                    (from ("OppositePitTwoRows" (to))) 
                                    (to (mapEntry (next))) 
                                    count:(count at:("OppositePitTwoRows" (to)))
                                )
                            )
                        )
                    )
                )
            )
        )
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )	
)

Construct a Ludii game based on the following description
French newspapers in the 19th century had forms of this game, and it has appeared consistently since 1979. Nikoli began publishing Sudoku (\Played on a 9x9 grid divided into 3x3 groups of 9 or \ 
(game "Sudoku" 
    (players 1) 
    (equipment { 
        (board (square 9) (values Cell (range 1 9))) 
        (regions {Columns Rows SubGrids})
    }) 
    (rules
        (start <Challenge>)
        (play (satisfy (all Different)))
        (end (if (is Solved) (result P1 Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Tank Tactics" 
    (players <Players:numPlayers>) 
    (equipment { 
        (board (rectangle <Board:size>)) 
        (hand Each)
        (piece "Tank" Each (or {"Move" "Shoot" "Trade" "Upgrade"}) maxState:100)
    }) 
    (rules 
        (meta (passEnd NoEnd))
        (start { 
            (set Score Each 1)
            <Players:setupRules>
        })
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        (phase "Movement" 
            (play 
                (or 
                    (forEach Piece)
                    "Pass"
                )
            )
        )}
        (end 
            (forEach NonMover 
                if:(no Pieces Player) (result Player Loss)
            )
        )
    )
)
Inspired by a prototype game idea presented at GDC13.Each player controls a tank with three health and an initial shooting range of two spaces. 
            Each player gains one action point at the start of their turn. 
            Players may use an action point during their turn to perform one of four actions:
            - Move their tank to an adjacent space.
            - Shoot at another tank within shooting range, deducting one point of health.
            - Trade with another tank within shooting range, increasing the owning players action points by one.
            - Increase the shooting range of their tank by one space.
            Players can pass to conserve action points between turns.
        A player loses if their tank reaches zero health. 2 players. The game is played on a 5x10 board.

Construct a Ludii game based on the following description
Brain Coral is a placement game based on the principle of placing pieces, such that afterwards, every site of the board remains connected to an empty site at the perimeter via a series of empty sites.                 Scoring is based on the size of the largest group plus a bonus factor.            The standard bonus factor is the number of your own groups.           Thus enlarging your largest group has the same value as creating a cloud of singletons, and anything else -- other than forcing your opponent to add to or join together non-largest groups, -- is a wasted opportunity.              Basic strategy is either    -- A: to form a defensive cloud to break opponent's efforts into multiple regions, and then, to connect your remaining dots into a single series; or else    -- B: to create a large group for as long as you can, then cloud the other areas in self-blocking ways.             The other bonus options are simpler, and thus need larger boards to be interesting:        Bonus for number of opponent's groups, makes play highly cohesive -- you need to form one big group, -- but with an emphasis on controlling empty teritory, because the opponent is penalised when forced to place isolated pieces at the end.             Playing without any bonus play is similar, but decided earlier, as territory is not an issue, only main group size.        Tiebreakers:    The standard tiebreaker is for the underdog to win based on the largest cascading group size without bonus.     If all groups are paired in size with the opponent, last to play wins.     For informal play, the tie breaker simplified as last-to-place.Goal: Score the most points: 
            -- One point for each stone in one's largest group.
            -- Bonus points are also added to the scores according to the selected option.
            
            The board starts empty. 
            
            Players take turns in alternation, placing one of their own stones onto an empty site. 
            
            Restriction on placement:
            Every site of the board must remain connected to an empty perimeter site via a continuous path of empty sites.
            
            There is no passing. 
            
            The game ends when no more placements can be made.  
            
            Players score one point for every stone in their largest group, then, if applicable, score bonus points according to the selected option.
            
            Bonus Options are:
            -- Count of one's own groups. Standard
            -- Count of the opponent's groups
            -- No Bonus
            
            The player with the higher score wins. 
            
            If the scores are tied, the game is decided by the tiebreaker option used: 
            A: Cascading largest group LOSES -- i.e. negative scores -- This excludes tied pairs; If all groups are paired, last to place. 
        B: Last player to have placed a stone. Order 3 board - about 5 moves each Triangle-Square N-2 all directions connect paths to edge - Orthogonal only form groups, about 10% more moves Scoring Option: Score the size of your largest group, then score an additional point for every group you have on the board. Tiebreaker is largest group (excluding tied pairs) LOSES. If all are paired, last placement wins.
(game "Brain Coral"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Ball" Each)
        (piece "Disc" Each)
    })
    (rules
        (start (set Score Each 0))
        (play
            (do
                (move Add (to (sites Empty)))
                ifAfterwards:("AllHave1Connection2Edge" (sites Around (last To) "ConnectionDirection" includeSelf:True)) 
                (then <Scoring:selScoring>) 
        ))
        (end 
            (if (no Moves Next) {
                (if 
                    (= (score Mover) (score Next))
                    <TieScoring:finalTie>
                )
                (if 
                    (!= (score Mover) (score Next))
                    (byScore)
                )
            })
        )
    )
)

Construct a Ludii game based on the following description
Small draughts-like game invented by Martin Gardner on an unusual board.Players take turns moving one of their pieces to an adjacent empty point, forwards or sideways. A piece can hop over an adjacent enemy piece to an empty point immeidately beyond it, forwards or sideways, and must do so if possible. Only one hope per turn is allowed. If a piece reaches the far point of the board, it is promoted to a king which can also move and hop backwards. Win by eliminating all enemy pieces. The game is drawn if both players are reduced to a single king. 
(game "Game of Solomon" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board
            (renumber 
                (splitCrossings (add (regular Star 6) edges:{{0 5} {1 4} {2 3}}))
            )
            use:Vertex
        ) 
        (piece "Counter" Each) 
        (piece "DoubleCounter" Each)
        (regions "Palace1" P1 (sites {"E7"})) 
        (regions "Palace2" P2 (sites {"E1"})) 
    }) 
    
    (rules 
        (start {
            (place "Counter1" (sites {"E1" "A2" "D2" "E2" "F2" "I2"}))
            (place "Counter2" (sites {"E7" "A6" "D6" "E6" "F6" "I6"}))
        })
        
        (play
            (priority {
                ("MoveChoice" "HopCaptureForwards" "HopCapture")
                ("MoveChoice" "StepToEmptyForwards" "StepToEmpty")
            })
        )
        
        (end {
            ("BlockWin")
            (if 
                (and {
                    (= 1 (count Pieces P1)) 
                    (= 1 (count Pieces P2)) 
                    (= 1 (count Pieces P1 "DoubleCounter")) 
                    (= 1 (count Pieces P2 "DoubleCounter")) 
                }) 
                (result Mover Draw)
            )
        }) 
    )
)

Construct a Ludii game based on the following description
Andada is a two-row mancala-style board game played by the Kunama people of western Eritrea. It is typically played by elders. It has an ending condition that is unusual among mancala-style games, in that the winner is determined by the first to clear their counters from the board once players only have single counters remaining.2x12, 15, 18, 21, or 24 board. Two counters per hole. Typically played by a team of players, who consult each other about the moves to be made. Sowing occurs most commonly in an anti-clockwise direction, but can be played clockwise if the players agree. Play begins with one player picking up the counters in one of the holes in their row and sowing them, then picking up the counters in the hole following the one in which the last counter was sown, and continuing to sow in this way until there is a pattern of holes with three counters alternating with empty holes. The players then decide who gets to play first. Players sow counters from a hole in their row in the agreed-upon direction. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the last counter falls into an empty hole, the sowing ends. If the sowing ends in the player's own row, any counters in the opponent's hole opposite are captured. Once both players are reduced to only single counters in their holes, when a player reaches the end of their row with a counter, it is captured instead of continuing to sow it to the opponent's rows. The player who is the last in possession of counters wins. Each player has 12 holes and sow anti-clockwise.
(game "Andada" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" <Board:trackDirection> loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 2 to:(sites Track)))
        
        phases:{
        (phase "Opening"
            (play 
                (move Select 
                    (from 
                        (if ("SameTurn") 
                            (sites {("NextHole" ("PlayFromLastHole"))})
                            (sites Mover) 
                        )
                        if:(> (count at:(from)) 0)
                    )
                    (then (sow (then (if (is Occupied ("NextHole" ("PlayFromLastHole"))) (moveAgain)))))
                )	
            )
            
            (nextPhase (is Mover P2) "Playing")
        )
        
        (phase "Playing"
            (play 
                (move Select 
                    (from 
                        (if ("SameTurn") 
                            (sites {"PlayFromLastHole"})
                            (sites Mover) 
                        )
                        if:(> (count at:(from)) 0)
                    )
                    (then 
                        (sow
                            apply:(if (= 1 (count at:(to)))
                                (if ("OnlyOneCounterInEachHole")
                                    (if (is In ("NextHole" (to)) (sites Next))
                                        (fromTo 
                                            (from (to)) 
                                            (to (handSite Mover)) 
                                            count:(count at:(to))
                                        )
                                    )
                                    (if (and (is Occupied ("OppositePit" (to))) (is In (to) (sites Mover)))
                                        (fromTo 
                                            (from ("OppositePit" (to))) 
                                            (to (handSite Mover)) 
                                            count:(count at:("OppositePit" (to)))
                                        )
                                    )
                                )
                                (moveAgain)
                            )
                        )		
                    )
                )		
            )
            (end
                (forEach Player
                    if:("NoCounters" Player)
                    (result Player Loss)
                )
            )
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Triodi (Diagonal)"
    (players 2)
    
    (equipment { 
        (board (concentric Square rings:3 joinCorners:True) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3" Orthogonal exact:True)))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:9))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True)) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("HavingLessPiecesLoss" Next 2))
    )
)
Triodi is a game of alignment played in Greece. This version of it includes diagonal lines on the board.Three concentric squares, the corners and midpoints of the squares connected with lines. Nine pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, the players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row along the lines, the player removes any one of the opponent's pieces. The player who reduces the opponent to two pieces wins.
         

Construct a Ludii game based on the following description
Shatera is a game with replacement captures played by the Kalmyk people in the eighteenth century. It was typically played by adult men in their homes.Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space forward or two on their first turn, capture diagonally one space forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. Players move three pieces on their first turn. Players capture pieces by moving onto a space occupied by an opponent's piece. When a king can be captured on the next turn, it is in check, and the king must not be in check at the beginning of the opponent's next turn. If this is not possible, it is checkmate, and the opponent wins.
         
(game "Shatera" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        (piece "Pawn" Each 
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty")
                )
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                }
            )
        )
        
        (piece "Rook" Each 
            (move
                Slide 
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "King" Each 
            (move
                Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "Bishop" Each 
            (move
                Slide 
                Diagonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "Knight" Each 
            (move
                Leap 
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "Queen" Each 
            (move
                Slide 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPiece"
                ) 
            ) 
        )
        
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8") 
        })
        
        phases:{
        (phase "Opening" 
            (play
                (do 
                    (forEach Piece)
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                    (then
                        (and
                            (set Value Mover (+ 1 (value Player Mover)))
                            (if (!= (value Player Mover) 1) (moveAgain))
                        )
                    )
                )
            )
            (nextPhase Mover (= 2 (value Player Mover)) "Playing")
        )
        (phase "Playing"
            (play 
                (if "SameTurn"
                    (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                    (do 
                        (forEach Piece)
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
            )
        )
        }
        
        (end 
            (if (and 
                    ("IsInCheck" "King" Next)
                    ("NextCanNotMove")
                ) 
                (result Mover Win)
            ) 
        )
    )
)

Construct a Ludii game based on the following description
Akṣadyūta is a scoring game that plays a central role in the Indian epic Mahabharata. While the Mahabharata was an oral tradition which was written down much later, one of its key events is a game of Akṣadyūta in which Shakuni won the kingdom from Yudhishthira. Later Indian sources often confuse the game as that of Pachisi or Chaupar, but the text clearly describes a game of a different nature.There is a large number of akṣas (beans) in a container, divisible by five. One player grasps a random number of them, and throws them onto a mat. The beans grabbed by the player is a \ The game is played with the rules of Syed.
(game "Aksadyuta"
    (players 2)
    (equipment {
        (board
            (square 1)
        )
        (piece "Bean" Shared)
        (hand Each)
    })
    (rules 
        (start (place "Bean" 0 count:55))
        (play 
            (move 
                (from (sites Board))
                (to (handSite Mover))
                count:(value Random (range 1 (count at:0)))
            )
        )
        (end {
            (if (is Mover P2) {
                (if (and ("Krta" (handSite P1)) (not ("Krta" (handSite P2)))) (result P1 Win))
                (if (and ("Krta" (handSite P2)) (not ("Krta" (handSite P1)))) (result P2 Win))
                
                (if (and ("Kali" (handSite P1)) (not ("Kali" (handSite P2)))) (result P1 Loss))
                (if (and ("Kali" (handSite P2)) (not ("Kali" (handSite P1)))) (result P2 Loss))
                
                (if (and ("Treta" (handSite P1)) ("Dvapara" (handSite P2))) (result P1 Win))
                (if (and ("Treta" (handSite P2)) ("Dvapara" (handSite P1))) (result P2 Win))
                
                (if (and ("Krta" (handSite P1)) ("Krta" (handSite P2))) (result Mover Draw))
                (if (and ("Kali" (handSite P1)) ("Kali" (handSite P2))) (result Mover Draw))
                (if (and ("Dvapara" (handSite P1)) ("Dvapara" (handSite P2))) (result Mover Draw))
                (if (and ("Treta" (handSite P1)) ("Treta" (handSite P2))) (result Mover Draw))
            })
        })
    )
)

Construct a Ludii game based on the following description
The Monty Hall problem is a brain teaser, in the form of a probability puzzle, loosely based on the American television game show Let's Make a Deal and named after its original host, Monty Hall.Monty Hall asks to choose one of three doors. One of the doors hides a car and the other two doors have a goat. You select which door you pick, but you don’t open it right away.
            
            The game opens one of the other two doors, and there is no prize behind it.
            
        At this moment, there are two closed doors. You can keep the same choice or selecting the other door. If you get the car you win if not you loss. 
(game "Monty Hall Problem"
    (players 1)
    (equipment {
        (board (rectangle 1 3))
        (piece "Car" Shared)
        (piece "Goat" Shared)
    })
    
    (rules
        (start {
            (place Random {"Car"})
            (place Random {"Goat"} count:2)
            (set Hidden What (sites Board) to:P1)
        })
        
        phases:{
        (phase "FirstChoice"
            (play 
                (move Select 
                    (from (sites Board))
                    (then
                        (set Hidden What 
                            (sites Random 
                                (forEach 
                                    (sites Board) 
                                    if:(and 
                                        (!= (site) (last To))
                                        (!= (id "Car" Shared) (what at:(site)))
                                    )
                                )
                                num:1
                            ) 
                            False 
                            to:P1
                        )
                    )
                )
            )
            (nextPhase "FinalChoice")
        )
        
        (phase "FinalChoice"
            (play 
                (move Select 
                    (from (sites Board)) 
                    (then 
                        (set Hidden What (sites Board) False to:P1)
                    )
                )
            )
            (end {
                (if 
                    ("IsPieceAt" "Car" Shared (last To))
                    (result P1 Win) 
                )
                (if 
                    ("IsPieceAt" "Goat" Shared (last To))
                    (result P1 Loss) 
                )
            })
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Addi Kul"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board (square 7))
        (piece "Marker" Each
            (or
                ("StepToEmpty" (directions {Rightward Leftward Forwards}))
                ("HopCapture")
            )
        )
    })
    (rules
        (start {
            (place "Marker1" (expand (sites Bottom) steps:2))
            (place "Marker2" (expand (sites Top) steps:2))
        })
        (play (forEach Piece))
        (end ("CaptureAll" Next))
    )
)
'Addî Kûl is a capturing game played in Tunisia by men. The board is typically made in the sand, and date seeds, stones, or camel droppings are used as pieces.7x7 board. 21 pieces per player, which begin in the three rows closest to each player. The central row of the board remains empty. Players alternate turns moving one of their pieces forward, diagonally, or horizontally on the board. When a player's piece is next to an opponent's piece with an empty space immediately on the opposite side of it, the player's piece may hop over the opponent's piece to capture it. The player who captures all of the opponent's pieces wins. 

Construct a Ludii game based on the following description
Muvalavala is a four-row mancala-style board game played in Southwest Africa, particularly among the Luena and Mbunda people. The game is played with holes dug into the ground instead of on a board.4x6-16 board. Play begins with two counters in each hole. The first move must be from the inner row. Play begins from any of the player's holes, sowing clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues. Captures are made when the final counter falls into an empty hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. If the final counter falls into an empty hole and a capture cannot happen, the turn is over. Play ends when one player cannot move. Each player has 6 holes.
(game "Muvalavala (Luena)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" <Board:track1> loop:True P1)
            (track "Track2" <Board:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        phases:{
        (phase "Opening" 			 	
            ("PlayFrom" "Inner")
            (nextPhase (>= (count Turns) 2) "Playing")
        )
        (phase "Playing" 
            ("PlayFrom" "Home")
        )
        }
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Shogi is a capturing game that is native to Japan. Early evidence suggests it was played in some recognizable form during the Heian Period. It has been hugely popular since then in Japan, and today is known throughout the world. It originated ultimately from Indian Chaturanga, like many other games such as Chess, Shatranj, and Xiangqi.Pieces move as follows: Osho(1): moves one space in any direction Hisha(1): moves any number of spaces orthogonally. Kakugyo(1): moves any number of spaces diagonally. Kinsho(2): moves one square in any direction except diagonally backwards. Ginsho (2): moves one square diagonally or one square forward orthogonally. Keima(2): moves one space forward and then one space diagonally forward. Kyosha(2): moves any number of spaces only forward or backward. Fuhyo(9): moves one space forward. Pieces are promoted when reaching the opposite third of the board. Pieces are captured when an opponent's piece moves to the space it occupies. Captured pieces are held and can re-enter the game under the control of the capturing player as their turn. The goal is to capture the other player's king. 
(game "Shogi" 
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        (board (square 9))
        
        
        (piece "Osho" Each ("StepMove"))
        
        
        (piece "Fuhyo" Each 
            ("StepMove" 
                Forward 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InLastRank" (last To)) 
                            ("Promote") 
                            (moveAgain) 
                        ) 
                    ) 
                )
            )
        )
        
        
        (piece "Ginsho" Each ("StepMove" (directions {Forward BL BR FL FR}) "CanPromote"))
        
        
        (piece "Hisha" Each ("SlideMove" Orthogonal "CanPromote"))
        
        
        (piece "Kakugyo" Each ("SlideMove" Diagonal "CanPromote"))
        
        
        (piece "Keima" Each 
            (forEach Direction 
                Forward 
                (to 
                    if:True 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL}) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (add 
                                                (piece (mapEntry "Captured" (what at:(to)))) 
                                                (to (mapEntry "Where" (what at:(to))))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                ) 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InTwoFurthestRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                ) 
            ) 
        )
        
        
        (piece "Kyosha" Each
            ("SlideMove" 
                Forward 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InLastRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                )
            ) 
        )
        
        
        ("ShogiGold" "Kinsho" "CapturePiece")
        
        
        ("ShogiGold" "Tokin" "CapturePiece")
        
        
        ("ShogiGold" "Narigin" "CapturePiece")
        
        
        (piece "Ryuo" Each (or ("SlideMove" Orthogonal) ("StepMove" Diagonal)))
        
        
        (piece "Ryuma" Each (or ("SlideMove" Diagonal) ("StepMove" Orthogonal)))
        
        
        ("ShogiGold" "Narikei" "CapturePiece")
        
        
        ("ShogiGold" "Narikyo" "CapturePiece")
        
        (regions "LastRankP1" P1 (sites Top))
        (regions "LastRankP2" P2 (sites Bottom))
        (regions "TwoFurthestRankP1" P1 (expand (sites Top)))
        (regions "TwoFurthestRankP2" P2 (expand (sites Bottom)))
        (regions "Promotion" P1 (expand (sites Top) steps:2))
        (regions "Promotion" P2 (expand (sites Bottom) steps:2))
        (map "Where" {
            (pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) 
            (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) 
            (pair (id "Hisha" P1) (handSite P2 2)) (pair (id "Hisha" P2) (handSite P1 2)) 
            (pair (id "Kakugyo" P1) (handSite P2 3)) (pair (id "Kakugyo" P2) (handSite P1 3)) 
            (pair (id "Keima" P1) (handSite P2 4)) (pair (id "Keima" P2) (handSite P1 4)) 
            (pair (id "Kyosha" P1) (handSite P2 5)) (pair (id "Kyosha" P2) (handSite P1 5)) 
            (pair (id "Kinsho" P1) (handSite P2 6)) (pair (id "Kinsho" P2) (handSite P1 6)) 
            (pair (id "Tokin" P1) (handSite P2)) (pair (id "Tokin" P2) (handSite P1)) 
            (pair (id "Narigin" P1) (handSite P2 1)) (pair (id "Narigin" P2) (handSite P1 1)) 
            (pair (id "Ryuo" P1) (handSite P2 2)) (pair (id "Ryuo" P2) (handSite P1 2)) 
            (pair (id "Ryuma" P1) (handSite P2 3)) (pair (id "Ryuma" P2) (handSite P1 3)) 
            (pair (id "Narikei" P1) (handSite P2 4)) (pair (id "Narikei" P2) (handSite P1 4)) 
            (pair (id "Narikyo" P1) (handSite P2 5)) (pair (id "Narikyo" P2) (handSite P1 5)) 
        })
        (map "Captured" { 
            (pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) 
            (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) 
            (pair (id "Hisha" P1) (id "Hisha" P2)) (pair (id "Hisha" P2) (id "Hisha" P1)) 
            (pair (id "Kakugyo" P1) (id "Kakugyo" P2)) (pair (id "Kakugyo" P2) (id "Kakugyo" P1)) 
            (pair (id "Keima" P1) (id "Keima" P2)) (pair (id "Keima" P2) (id "Keima" P1)) 
            (pair (id "Kyosha" P1) (id "Kyosha" P2)) (pair (id "Kyosha" P2) (id "Kyosha" P1)) 
            (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) 
            (pair (id "Tokin" P1) (id "Fuhyo" P2)) (pair (id "Tokin" P2) (id "Fuhyo" P1)) 
            (pair (id "Narigin" P1) (id "Ginsho" P2)) (pair (id "Narigin" P2) (id "Ginsho" P1)) 
            (pair (id "Ryuo" P1) (id "Hisha" P2)) (pair (id "Ryuo" P2) (id "Hisha" P1)) 
            (pair (id "Ryuma" P1) (id "Kakugyo" P2)) (pair (id "Ryuma" P2) (id "Kakugyo" P1)) 
            (pair (id "Narikei" P1) (id "Keima" P2)) (pair (id "Narikei" P2) (id "Keima" P1)) 
            (pair (id "Narikyo" P1) (id "Kyosha" P2)) (pair (id "Narikyo" P2) (id "Kyosha" P1)) 
        })
        (map "Promoted" { 
            (pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) 
            (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) 
            (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) 
            (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2)) 
            (pair (id "Keima" P1) (id "Narikei" P1)) (pair (id "Keima" P2) (id "Narikei" P2)) 
            (pair (id "Kyosha" P1) (id "Narikyo" P1)) (pair (id "Kyosha" P2) (id "Narikyo" P2)) 
        })
        
        (hand Each size:7)
    })
    
    (rules 
        (start { 
            (place "Osho1" coord:"E1") (place "Kinsho1" {"D1" "F1"}) (place "Ginsho1" {"C1" "G1"}) (place "Keima1" {"B1" "H1"}) (place "Kyosha1" {"A1" "I1"}) (place "Kakugyo1" coord:"B2") (place "Hisha1" coord:"H2") (place "Fuhyo1" (sites Row 2))
            (place "Osho2" coord:"E9") (place "Kinsho2" {"D9" "F9"}) (place "Ginsho2" {"C9" "G9"}) (place "Keima2" {"B9" "H9"}) (place "Kyosha2" {"A9" "I9"}) (place "Kakugyo2" coord:"H8") (place "Hisha2" coord:"B8") (place "Fuhyo2" (sites Row 6))
        })
        
        (play
            (if ("SameTurn")
                (or
                    ("Promote")
                    (move Pass)
                )
                (do 
                    (or {
                        (move 
                            (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) 
                            (to (sites Empty))
                        ) 
                        ("PlacePawn" Mover Next)
                        ("PlaceLance" Mover)
                        ("PlaceKnight" Mover) 
                        (forEach Piece) 
                    })
                    ifAfterwards:(not ("IsInCheck" "Osho" Mover))
                )
            )
        )
        
        (end {
            (if (and 
                    ("IsInCheck" "Osho" Next)
                    ("NextCannotMove")
                ) 
                (result Mover Win)
            ) 
            ("BlockWin")
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Gygoreg"
    (players 2)
    (equipment {
        (board (square Diamond <Size>))
        (piece "Disc" Each)
    })
    (rules
        (start {
            (place "Disc1" (forEach (sites Phase 0) if:(is Odd (site))))
            (place "Disc2" (forEach (sites Phase 0) if:(is Even (site))))
        })
        (play
            (or
                ("Place")
                ("Remove")
            )
        )
        (end {
            ("SingleGroupWin" P1 Orthogonal)
            ("SingleGroupWin" P2 Orthogonal)
        })
    )
)
Gygoreg is a deceptively simple unification game invented by Mike Zapawa in 2020.Each turn you must perform exactly one of the following two actions: 
            
            1. Add a friendly piece orthogonally adjacent to one of your pieces. 
            2. Remove an enemy group.
            
        As soon as one player only has 1 group, the game is over and that player is the winner. A size 4 board is currently selected

Describe the mechanics of the following Ludii game
(game "Mlabalaba"
    (players 2)
    
    (equipment { 
        (board (concentric Square rings:3 joinCorners:True) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            (if (= 3 (count Pieces Mover))
                (move 
                    (from (from))
                    (to (sites Empty))
                )
                ("StepToEmpty")
                (then ("ReplayIfLine3" Orthogonal)) 
            )
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal)) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (forEach Piece)
                )
            )
        )
        }
        
        (end
            (forEach NonMover
                if:(= 2 (count Pieces Player))
                (result Player Loss)
            )
        )
    )
)
Mlabalaba (more frequently known as Morabaraba) is an alignment game played in South Africa.Three concentric squares, with lines connecting the corners and midpoints of the squares. Twelve pieces per player. In the first phase, players take turns placing pieces on an empty spot on the board. If they place three pieces so they are in a line, forming a \ 

Construct a Ludii game based on the following description
Dongjintian is a two-row mancala-style board game played in China. It was described to Vernon Eagle by Wang Hongbin. 2x5 board. Five counters per hole. Sowing can happen in either direction. When the last counter falls into a hole, sowing continues if there are counters in the following holes; these are picked up and sowing continues from there. When the hole after the end of a sowing is empty, the counters in the next hole following it are captured. If a pattern of alternating empty and occupied holes continues after this, the counters in the occupied holes are captured, until there are two occupied or two empty holes in a row. The player who captures the most counters wins. 
(game "Dongjintian" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 5 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "4,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start (set Count 5 to:(sites Track)))
        
        (play 
            (or
                (if (or (>= 0 (var "Direction")) (= (var "Direction") 1))
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                (sites {("NextHoleFrom" "LastHoleSowed" "TrackCCW" 1) })
                                (sites Mover) 
                            ) 
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                "TrackCCW"
                                apply:(if (is Occupied ("NextHoleFrom" (to) "TrackCCW" 1))
                                    (and
                                        (moveAgain)
                                        (set Var "Direction" 1)
                                    )
                                    (if 
                                        (and
                                            (is Empty ("NextHoleFrom" (to) "TrackCCW" 1))	
                                            (is Occupied ("NextHoleFrom" (to) "TrackCCW" 2))		
                                        )
                                        (and
                                            ("CaptureMove" "TrackCCW")	
                                            (set Var "Direction" 0)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (if (or (>= 0 (var "Direction")) (= (var "Direction") 2))
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                (sites {("NextHoleFrom" "LastHoleSowed" "TrackCW" 1) })
                                (sites Mover) 
                            ) 
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                "TrackCW"
                                apply:(if (is Occupied ("NextHoleFrom" (to) "TrackCW" 1))
                                    (and
                                        (moveAgain)
                                        (set Var "Direction" 2)
                                    )
                                    (if 
                                        (and
                                            (is Empty ("NextHoleFrom" (to) "TrackCW" 1))	
                                            (is Occupied ("NextHoleFrom" (to) "TrackCW" 2))		
                                        )
                                        (and
                                            ("CaptureMove" "TrackCW")	
                                            (set Var "Direction" 0)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (<= (count Pieces All in:(sites Board)) 1)))
    )
)

Construct a Ludii game based on the following description
Asalto is a hunt game known from early modern Europe.Played on the Fox and Geese board, but the top arm of the cross is surrounded by a double line, indicating it is a fortress, in which one player puts two officers. The opponent has 24 pieces, which occupy the points outside the fortress. Officers may capture one of the opponent's pieces by hopping over it to an empty space immediately on the opposite side of the opponent's piece. If the officer does not capture when it is possible, it is huffed. The soldiers win by occupying all of the points in the fortress or by blocking the officers from being able to move; the officers win by capturing enough soldiers to prevent this. 
(game "Asalto" 
    (players 2) 
    (equipment { 
        ("CrossBoard" 3 7 use:Vertex diagonals:Alternating)
        (piece "Marker" P1 (or ("HopCapture") "StepToEmpty"))
        (piece "Marker" P2 "StepToEmpty") 
    }) 
    (rules 
        (start {
            (place "Marker1" (sites {"C6" "E6"}))
            (place "Marker2" (union (expand (union (sites Right) (sites Left))) (expand (sites Bottom) steps:3)))
        })
        
        (play
            (if (is Mover P1)
                (do
                    ("RememberSiteWithPossibleCapture") 
                    next:(forEach Piece)
                    (then 
                        (and
                            (if (!= 0 (count Sites in:(sites (values Remembered "From")))) 
                                (if (= 1 (count Steps (last From) (last To)))
                                    (and
                                        (forEach Site (sites (values Remembered "From"))
                                            (remove (site))
                                        )
                                        (if (is In (last From) (sites (values Remembered "From")))
                                            (remove (last To))
                                        )
                                    )
                                )
                            )
                            (forget Value All)
                        )
                    )
                )
                (forEach Piece)
            )
        )
        
        (end {
            (if (no Pieces P2) (result P1 Win))
            (if
                (or
                    (or (no Pieces P1) (no Moves P1))
                    (all Sites (expand (sites Top) steps:2) if:(= (who at:(site)) P2))
                )
                (result P2 Win)
            )
        }) 
    )
)

Construct a Ludii game based on the following description
Kaooa is a hunt game documented in the early twentieth century in India, but it is probably much older, as graffiti with the pattern of the board have been found at sites such as medieval Vijayanagara.Played on a five-pointed star shaped board. One player plays with one piece, the \ The game starts with 3 discs for the second player.
(game "Kaooa" 
    (players 2) 
    (equipment { 
        ("StarBoard" 5)
        (hand Each) 
        (piece "Marker" P1 (or ("HopSequenceCapture") "StepToEmpty")) 
        (piece "Marker" P2 "StepToEmpty") 
    }) 
    (rules 
        (start {
            (place "Marker1" (handSite P1) count:1)
            (place "Marker2" (handSite P2) count:<Num>)
        })
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                ) 
            )
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        ("PhaseMovePiece" "Movement"
            (end ("NoMoves" Loss))
        )
        }
    )
)

Construct a Ludii game based on the following description
This game is a hunt game played by the Mao Naga people of Manipur, India in the early twentieth century.5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting two sides of the triangle. One player plays as twenty people, stacked five each in the four points where the diagonals cross in each quadrant. The other player plays as two tigers, which are placed on the midpoints of the sides without triangles. Players alternate turns moving one piece to an adjacent spot along the lines of the board. The tiger may hop over one of the people to an empty point on the opposite side immediately adjacent to it along the lines of the board. When the tiger hops over one of the stacks, it captures only one of the people. The tigers win by capturing all the people, the people win by blocking the tigers from being able to move. 
(game "Mao Naga Tiger Game"
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (piece "Human" P1 "StepToEmpty")
        (piece "Tiger" P2 (or "StepToEmpty" "HopCapture"))
    }) 
    (rules 
        (start {
            (place Stack "Human1" (sites {"B4" "B6" "D4" "D6"}) count:5)
            (place "Tiger2" (sites {"A5" "E5"}))
        })
        
        (play (forEach Piece top:True))
        
        (end ("NoMovesP2NoPiecesP1"))
    )
)

Construct a Ludii game based on the following description
Koruböddo is a capturing game played in Somalia in the early twentieth century. 5x5 board. Twelve pieces per player, arranged in the two rows in front of each player, and in the right two squares in the central row (the central space is empty). Players alternate turns moving a piece to an adjacent orthogonal space. The player may capture an opponent's piece by hopping over it in an orthogonal direction. Multiple hops are allowed in the same turn, but captures are not compulsory, The player who captures all of their opponent's pieces wins. 
(game "Koruboddo" 
    (players 2) 
    (equipment { 
        (board (square 5))
        (piece "Marker" Each 
            (or 
                ("HopOrthogonalSequenceCapture")
                ("StepOrthogonalToEmpty")
            )
        )
    }) 
    (rules 
        (start { 
            (place "Marker1" (union {(sites Row 0) (sites Row 1) (sites {"A3" "B3"})}))
            (place "Marker2" (union {(sites Row 3) (sites Row 4) (sites {"D3" "E3"})}))
        })
        
        (play 
            (if "SameTurn"
                (or
                    ("HopOrthogonalSequenceCaptureAgain")
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Zuz Mel (7x7)"
    (players 2)
    (equipment {
        (board (square 7))
        (piece "Marker" Each 
            (or 
                ("HopOrthogonalSequenceCapture")
                (move Slide Orthogonal)
            )
        )
    })
    (rules
        
        (start {
            (place "Marker1" (union (expand (sites Bottom) steps:2) (sites {"F4" "G4" "E4"})))
            (place "Marker2" (union (expand (sites Top) steps:2) (sites {"A4" "B4" "C4"})))
        })
        
        (play
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("CaptureAll" Next))
    )
)
Zuz Mel (\7x7 board. 24 pieces per player. Pieces begin in the rows closest to the player, and the three spaces to the right of the central space. Players alternate turns moving a piece orthogonally any distance. A player may capture an opponent's adjacent piece by hopping over it in an orthogonal direction to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of the opponent's pieces wins. 

Construct a Ludii game based on the following description
Parsi Chess is the name given by Murray to the style of Chess played in southern India in the nineteenth century. It has particular rules regarding pawn movement and promotion, as well as end of game situations.8x8 board, marked as in Chaturanga. Pieces move according to specialized moves, as follows: Pawns (x8): can move one space forward, or one space diagonally to capture. The pawns in front of the Raja, Vizier, or Chariot may move two spaces on their first move, but only if the piece which began on the space behind them remains on that spot. Chariot (or Boat): any number of spaces orthogonally; Elephant (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Raja (x1): can move one space orthogonally or diagonally, but can also move like the horse once in the game, if it has not yet been checked. It cannot take a piece with this move. The pieces are arranged as in Chess, except the Vizier is place to the left of the Raja on both sides. Players capture pieces by moving onto a space occupied by an opponent's piece. When a Pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When promoted to a Horse, the piece may immediately make a Horse's move. When a player can capture the opponent's Raja on the next turn, the Raja is in Check, the opponent's next move must free the Raja from Check. If the opponent cannot, it is Checkmate and the player wins. If a player captures all of the opponent's pieces aside from the Raja, it is a draw, or Boorj. When both players are left with only a Raja, it is a draw. Players are not allowed to stalemate the opponent. Perpetual check is not allowed, a player must make another move if such a state is entered. 
(game "Parsi Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8))
        
        (piece "Pawn" Each 
            (or { 
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    (if (= 1 (state at:(ahead (from) Backward)))
                        ("DoubleStepForwardToEmpty")
                    )
                )
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                }
                (then
                    (if (is In (last To) (sites Mover "Promotion")) 
                        (promote (last To) (piece "PromotedPiece"))
                    )
                )
            )
        )
        ("ChessRook" "Boat" ~ "RememberPieceHasMoved")
        (piece "King_noCross" Each 
            (or
                ("StepToNotFriend")
                (if (!= (value Player Mover) (mover))
                    ("LeapToEmpty" "KnightWalk" (then (set Value Mover (mover))))
                )
                "RememberPieceHasMoved"
            )
        )
        ("ChessBishop" "Elephant")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Ferz_noCross" ~ "RememberPieceHasMoved")
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Boat1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1" state:1) (place "King_noCross1" coord:"E1" state:1) 
            (place "Boat2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8" state:1) (place "King_noCross2" coord:"D8" state:1) 
        })
        
        (play 
            (do 
                (forEach Piece) 
                ifAfterwards:(and (can Move (forEach Piece Next)) (not ("IsInCheck" "King_noCross" Mover)))
                (then
                    (if (!= (next) (value Player Next))
                        (if ("IsInCheck" "King_noCross" Next)
                            (set Value Next (next))
                        )
                    )
                )
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (= 1 (count Pieces Next)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Ngulungu is a board game played by Basanga and Baluba children in the Katanga province of the Democratic Republic of Congo. The game has a predetermined outcome, but often children will make a mistake, making the game somewhat unpredictable for them.4x7 board, using only the outer two rows. Three counters in each hole. Sowing occurs in an anticlockwise direction. The first player takes the counters out of their leftmost hole and sows them. Instead of each player owning a row of holes, they own the series of holes which currently contain their counters. Players always sow from the rearmost of their holes. When the frontmost two holes of a player's sequence contain one counter each, the player gets another turn. When a player sows into the rear holes of the opponent, the player takes ownership of those holes. When one player is reduced to one counter, they jump to the nearest corner hole in the direction of play, and continue jumping from corner to corner until they capture counters belonging to the opponent, at which point they revert to the normal playing style. The first player to capture all their opponent's pieces wins. 
(game "Ngulungu" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 7 store:None
            {
            (track "Track" "0,E,27,W" loop:True)
            (track "TrackCorner" "0,6,27,21" loop:True)
            (track "ReverseTrack" "6,W,21,E" loop:True)
            } 		
        )
        (piece "Seed" Each)
    }) 
    (rules 
        (start {
            (place "Seed1" (sites Bottom) counts:{3})
            (place "Seed2" (sites Top) counts:{3})
        })
        
        (play 
            (if (and (all Sites (sites Occupied by:Mover) if:(is In (sites Corners))) (= 1 (count Pieces Mover)))
                (move
                    (from ("LeftMost"))
                    (to 
                        (trackSite FirstSite "TrackCorner" from:(from) if:("IsEnemyAt" (to)))
                        (apply
                            (and
                                (remove (to) count:(count at:(to)))
                                (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to)))
                            )	
                        )	
                    )
                )
                (move Select 
                    (from 
                        ("LeftMost") 
                    )
                    (then 
                        (sow
                            sowEffect:(if (and (!= (mover) (what at:(to))) (is Occupied (to)))
                                (and
                                    (remove (to) count:(count at:(to)))
                                    (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to)))
                                )
                            )
                            apply:(if (and (= 1 (count at:("NextHoleFrom" (to) "ReverseTrack" 1))) (= 1 (count at:(to))))
                                (moveAgain)
                            )
                        )
                    )
                )
            )		
        )
        
        (end
            (forEach NonMover
                if:(no Pieces Player)
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
The Six Insect Game, the Chinese name for which was not reported, is a capturing game played in Chengdu, China.4x4 board. Six pieces per player, which begin on opposite rows of the board and in the two outer squares in the row in front of it. Players alternate turns moving a piece orthogonally to an adjacent space on the board. When a player moves a piece such that it creates three in a row: two of their own pieces (which must be adjacent to one another) and one of the opponent's pieces (which must have a vacant space on the opposite side of it), the opponent's piece is captured. However, when the opponent's piece moves in line with two of the player's piece on the opponent's turn, the player does not capture the opponent's piece. The player who captures all of the opponent's pieces wins.
         
(game "Six Insect Game"
    (players 2)
    (equipment {
        (board (square 4))
        (piece "Marker" Each
            ("StepToEmpty" Orthogonal (then ("Line3WithSingleOpponent")))
        )
    })
    (rules 
        (start {
            (place "Marker1" (union (intersection (union (sites Right) (sites Left)) (sites Row 1)) (sites Bottom)))
            (place "Marker2" (union (intersection (union (sites Right) (sites Left)) (sites Row 2)) (sites Top)))
        })
        (play (forEach Piece))
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Iyogh is a two-row mancala-style board game plauyed by the Kukuma people in Nigeria. It was documented in the early twentieth century.2x8 board. Four counters in each hole. Play begins with both players placing all of the counters in the rightmost three holes in their row into the rightmost hole. Counters are sown in an anti-clockwise fashion, but they can be sown clockwise only if it leads to a capture. Counters are captured when the final counter is sown into a hole opposite a hole containing one or three counters, and those are take. If the hole opposite the next hole also contains one or three, these are also taken, continuing until a hole with any other number of counters is reached. Instead of taking counters from one of their holes, a player may sow any or all of the counters they have captured, beginning from the leftmost hole. The same rules for sowing apply. The game ends when one player has no counters in their holes. 
(game "Iyogh" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "7,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top)) 
        (hand Each)
        (map "LeftMost" {(pair P1 0) (pair P2 15)})
        (map "RightMost" {(pair P1 7) (pair P2 8)})
        (regions "RightMost" P1 (sites {5 6})) 
        (regions "RightMost" P2 (sites {9 10})) 
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        phases:{
        (phase "Opening"
            (play 
                (move
                    (from (sites Mover "RightMost") if:(is Occupied (from)))
                    (to (mapEntry "RightMost" Mover))
                    count:(count at:(from))
                )
            )
            (nextPhase Mover (all Sites (sites Mover "RightMost") if:(is Empty (site))) "Sowing")
        )
        (phase "Sowing"
            (play 
                (or {
                    (if (is Occupied Cell (handSite Mover))
                        (forEach Value min:1 max:(count Cell at:(handSite Mover))
                            (do (set Var "NumToSow" (value))
                                next:(move
                                    (from Cell (handSite Mover))
                                    (to (mapEntry "LeftMost" Mover))
                                    count:(value)
                                    (then
                                        (and
                                            (sow
                                                count:(var "NumToSow")
                                                "TrackCCW"
                                                if:(or
                                                    (= 1 (count at:("OppositePitTwoRows" (to))))
                                                    (= 3 (count at:("OppositePitTwoRows" (to))))
                                                )
                                                apply:(if (or
                                                        (= 1 (count at:("OppositePitTwoRows" (to))))
                                                        (= 3 (count at:("OppositePitTwoRows" (to))))
                                                    )
                                                    (fromTo
                                                        (from ("OppositePitTwoRows" (to)))
                                                        (to (handSite Mover))
                                                        count:(count at:("OppositePitTwoRows" (to)))
                                                    )
                                                )
                                                forward:True
                                            )	
                                            (set Var "NumToSow" 0)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (if (is Occupied Cell (handSite Mover))
                        (forEach Value min:1 max:(count Cell at:(handSite Mover))
                            (do (set Var "NumToSow" (value))
                                next:(move
                                    (from Cell (handSite Mover)
                                        if:(or
                                            (= 1 (count at:("OppositePitTwoRows" ("NextHoleFrom" (mapEntry "LeftMost" Mover) "TrackCW" (value)))))
                                            (= 3 (count at:("OppositePitTwoRows" ("NextHoleFrom" (mapEntry "LeftMost" Mover) "TrackCW" (value)))))
                                        )
                                    )
                                    (to (mapEntry "LeftMost" Mover))
                                    count:(value)
                                    (then
                                        (and
                                            (sow
                                                count:(var "NumToSow")
                                                "TrackCW"
                                                if:(or
                                                    (= 1 (count at:("OppositePitTwoRows" (to))))
                                                    (= 3 (count at:("OppositePitTwoRows" (to))))
                                                )
                                                apply:(if (or
                                                        (= 1 (count at:("OppositePitTwoRows" (to))))
                                                        (= 3 (count at:("OppositePitTwoRows" (to))))
                                                    )
                                                    (fromTo
                                                        (from ("OppositePitTwoRows" (to)))
                                                        (to (handSite Mover))
                                                        count:(count at:("OppositePitTwoRows" (to)))
                                                    )
                                                )
                                                forward:True
                                            )	
                                            (set Var "NumToSow" 0)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (move Select
                        (from 
                            (sites Mover) 
                            if:(< 0 (count at:(from)))
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                if:(or
                                    (= 1 (count at:("OppositePitTwoRows" (to))))
                                    (= 3 (count at:("OppositePitTwoRows" (to))))
                                )
                                apply:(if (or
                                        (= 1 (count at:("OppositePitTwoRows" (to))))
                                        (= 3 (count at:("OppositePitTwoRows" (to))))
                                    )
                                    (fromTo
                                        (from ("OppositePitTwoRows" (to)))
                                        (to (handSite Mover))
                                        count:(count at:("OppositePitTwoRows" (to)))
                                    )
                                )
                                forward:True
                            )
                        )
                    )
                    (move Select
                        (from 
                            (sites Mover) 
                            if:(and 
                                (< 0 (count at:(from)))
                                (or
                                    (= 1 (count at:("OppositePitTwoRows" ("NextHoleFrom" (from) "TrackCW" (count at:(from))))))
                                    (= 3 (count at:("OppositePitTwoRows" ("NextHoleFrom" (from) "TrackCW" (count at:(from))))))
                                )
                            )
                        )
                        (then 
                            (sow
                                "TrackCW"
                                if:(or
                                    (= 1 (count at:("OppositePitTwoRows" (to))))
                                    (= 3 (count at:("OppositePitTwoRows" (to))))
                                )
                                apply:(if (or
                                        (= 1 (count at:("OppositePitTwoRows" (to))))
                                        (= 3 (count at:("OppositePitTwoRows" (to))))
                                    )
                                    (fromTo
                                        (from ("OppositePitTwoRows" (to)))
                                        (to (handSite Mover))
                                        count:(count at:("OppositePitTwoRows" (to)))
                                    )
                                )
                                forward:True
                            )
                            
                        )
                    )
                })
            )
        )
        }
        
        (end 
            (forEach Player
                if:("NoPiecesInPlayerSide" Player)
                (result Player Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Three Men's Morris"
    (players 2) 
    (equipment {
        ("ThreeMensMorrisBoard")
        (hand Each)
        (piece "Marker" Each <Piece>)
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win"))
    )
)
Three Men's Morris is a simple alignment game that is still played today, that has been played in Europe for centuries. It may also appear in  Roman sources, and similar boards have been found as graffiti at Roman sites.3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Each player has three pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they win. Once all pieces are place, players take turns moving pieces one spot to an adjacent point along the lines trying to make three in a row. The pieces can move to any empty sites.

Construct a Ludii game based on the following description
Fart is an alignment game played by young people in El Oued, Algeria. This version requires the player to place seven of their pieces in a row.7x7 board. 24 pieces per player. Players alternate turns placing two pieces on the board. When all of the pieces are placed, players alternate turns moving one piece orthogonally any distance. The first player to place seven of their pieces in an orthogonal or diagonal line wins.
         
(game "Fart (7x7)"
    (players 2)
    (equipment {
        (board (square 7))
        (piece "Marker" Each (move Slide Orthogonal))
        (hand Each)
    })
    (rules
        (start (place "Marker" "Hand" count:24))
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover))
                    (to (difference (sites Board) (centrePoint)) if:(is Empty (to)))
                    (then (if ("NewTurn") (moveAgain)))
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Move")
        )
        (phase "Move" (play (forEach Piece)))
        }
        (end (if (is Line 7) (result Mover Win)))
    )	
)

Construct a Ludii game based on the following description
Triodi is a name for alignment games in Greece. This game is played by children on the island of Chios.3x3 intersecting lines. Three pieces per player. Players alternate turns placing a piece on the board. When all of the pieces have been placed, the players alternate turns moving a piece to an empty adjacent spot. A piece which is surrounded on opposite sides by pieces belonging to the opponent cannot be moved. The player who places three of their stones in a row along one of the lines wins. 
(game "Triodi (Chios)"
    (players 2)
    
    (equipment { 
        (board (square 3) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            (if 
                (not ("Surrounded"))
                ("StepToEmpty")
            )
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("Line3Win"))
    )
)

Describe the mechanics of the following Ludii game
(game "Tasholiwe"
    (players <Player:num>)
    (equipment {
        ("FortyStonesWithFourGapsBoard"
            {
            (track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True)
            (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)
            }
        )
        (map "Throw" {(pair 0 10) (pair 1 3) (pair 2 2) (pair 3 5)})
        <Player:startPos>
        (regions "AllSites" (sites Board Vertex))
        (piece "Stick" Each)
        ("StickDice" 3)
        (hand Each)
    })
    (rules 
        (start {
            <Player:init>
        })
        (play 
            ("RollMove" 
                (if (or (is Mover P1) (is Mover P2))
                    (forEach Piece ("Move" "TrackCCW"))
                    (forEach Piece ("Move" "TrackCW"))
                )
                (then 
                    (do
                        (if ("MadeACompleteCircuit") 
                            (addScore Mover 1) 
                            (then 
                                (if (= (score Mover) 4) 
                                    (remove (last To))
                                )
                            )
                        )
                        next:(if (and (!= 4 (score Mover)) (= 10 ("ThrowValue"))) (moveAgain))
                    )
                )
            )
        )
        (end (if (>= (score Mover) 4) (result Mover Win)))
    )
)
Tasholiwe is a race game played by the Zuni people of the southwest United States. Two or four people play, each player playing as a piece representing the four directions and seasons.Forty stones, arranged in a circle, with a larger gap (called a door) after every tenth stone. Two or four players, each player playing with one piece. Each piece begins in one of the doors: north/winter is yellow, west/spring is blue, south/summer is red, east/autumn is white. North and west move anti-clockwise around the circle, south and east move clockwise. Three sticks, red on one side and black on the other, used as dice, the throws are as follows: three red = 10, three black = 5, two red and one black = 3, two black and one red = 2. A throw of 10 grants the player another throw. When a player lands on a spot occupied by an opponent, the opponent's piece is sent back to start. The first player to complete four circuits of the board wins. Circuits are usually counted with beans or corn. The game has 2 players.

Describe the mechanics of the following Ludii game
(game "Shataranja"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 10)) 
        ("ChessPawn" "Pawn" ~
            (then
                (if (is In (last To) (sites Mover "Promotion")) 
                    (and
                        (promote (last To) (piece "Bishop_noCross") Mover)	
                        (fromTo (from (last To)) (to (last From)))
                    )
                )
            )
        )
        ("ChessRook" "Rook")
        ("ChessKing" "King_noCross")
        ("ChessRook" "Elephant")
        ("ChessKnight" "Knight")
        ("ChessKing" "Queen")
        (piece "Ferz_noCross" Each 
            (or
                ("SlideCapture")
                ("LeapCapture" "KnightWalk")
            )
        )
        ("ChessQueen" "Bishop_noCross")
        (piece "Commoner" Each 
            (or
                ("SlideCapture" Diagonal)
                ("LeapCapture" "KnightWalk")
            )		
        ) 
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (difference (sites Row 1) (sites {"E2" "F2"})))
            (place "Pawn2" (difference (sites Row 8) (sites {"E2" "F2"})))
            (place "Queen1" {"E2" "F2"})
            (place "Queen2" {"E9" "F9"})
            (place "Rook1" {"A1" "J1"}) (place "Knight1" {"B1" "I1" "E3" "F3"}) (place "Elephant1" {"C1" "H1"}) (place "Ferz_noCross1" coord:"E1") (place "Commoner1" coord:"G1") (place "Bishop_noCross1" coord:"D1") (place "King_noCross1" coord:"F1") 
            (place "Rook2" {"A10" "J10"}) (place "Knight2" {"B10" "I10" "E8" "F8"}) (place "Elephant2" {"C10" "H10"}) (place "Ferz_noCross2" coord:"F10") (place "Commoner2" coord:"D10") (place "Bishop_noCross2" coord:"G10") (place "King_noCross2" coord:"E10") 
        })
        
        (play 
            (if (no Moves Mover)
                (move Remove
                    (difference (sites Occupied by:Next) (where "King_noCross" Next))
                )
                (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (and {
                    (no Pieces Next "Ferz_noCross")
                    (no Pieces Next "Queen")
                    (no Pieces Next "Knight")
                    (no Pieces Next "Bishop_noCross")
                    (no Pieces Next "Elephant")
                    (no Pieces Next "Rook")
                    (no Pieces Next "Commoner")
                })
                (result Mover Win) 
            ) 
        })
    )
)
Shataranja is a replacement capture game played in India, described in the nineteenth century. It was played on a 10x10 board.10x10 board. Pieces move as follows: Raja (x1): moves one space in any direction; Crown Prince (placed to the left of the Raja, x1): moves like any of the other pieces; Kotwal (Police Chief, placed to the right of the Raja, x1): Moves like the Elephant and the Vaha; Mantri (x1): moves any distance orthogonally or diagonally; Elephant (x2): moves diagonally any distance; Vaha (two placed in front of the Queens, x4): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Chariot (x2): moves orthogonally any distance; Queen (placed in front of the Raja and Crown Prince, x2): move one square orthogonally or diagonally; Padati (placed in the second row, except for the central two squares, x8): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja).
         

Construct a Ludii game based on the following description
Kisolo is a term used for some four-row mancala-style board games in central Africa. This version was played by the Lali people of Republic of Congo in the twentieth century.4x8 board. Four counters in each of the holes in each player's inner row. Sowing occurs in an anti-clockwise direction, with the first counter being sown into the hole from which the counters were picked up. When the final counter lands in an empty hole, the player's turn ends. When the final counter lands in an occupied hole in the inner row, the player captures the counters in the opponent's opposite inner row hole, and continues sowing with these counters and the counters in the hole where the final counter was dropped.. When the final counter lands in an occupied hole but a capture is not possible, these counters are picked up and sowing continues. Play continues until one player can no longer play, and the opponent wins. 
(game "Kisolo (Lali)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "16,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 4 to:(union (sites P1 "Inner") (sites P2 "Inner")))
        )
        
        (play 
            (move Select
                (from 
                    (if ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover "Home") 
                    ) 
                    if:(< 1 (count at:(from)))
                )
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (> (count at:(to)) 1)
                            (and
                                (moveAgain)
                                (if (and
                                        (!= (count at:("OppositePit" (to))) 0) 
                                        (is In (to) (sites Mover "Inner"))	
                                    )
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (to)) 
                                        count:(count at:("OppositePit" (to)))
                                    )
                                )
                            )
                        )
                        origin:True
                    )
                )
            )
        )
        
        (end 
            (if (and (!= (next) (mover)) (no Moves Next))
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Rumi Shatranj is a variation of Shatranj played in India. \8x8 board. The pieces move as follows, with the number per player: King (x1): moves one space orthogonally or diagonally; Counselor (x1): One square diagonally, but may move two spaces forward orthogonally on the first move, jumping over the Soldier in front of it on the first move of the game; Rook (x2): Any number of spaces orthogonally; Elephant (x2): Two squares diagonally, jumping over the first, cannot capture another Elephant; Horse (x2): Moves as a chess knight. Soldier (x8): Moves one space forward orthogonally; one space forward diagonally to capture. The Soldier in front of the Counselor may jump to the space in front of the Counselor when it has used its special move on the first turn, this must be done as the second move of the game, i.e. on the next turn after the Counselor had made its special move. No en passant. Soldiers promote to Counselor when reaching the eighth rank. No castling. Stalemate results in a win for player causing it. The player who checkmates the king wins.
         
(game "Rumi Shatranj"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (hand Each size:5)
        ("ChessKing" "King_noCross")
        ("ChessRook" "Rook")
        (piece "Elephant" Each
            (move Hop Diagonal 
                (between if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        (and ("IsEnemyAt" (to)) (not ("IsPieceAt" "Elephant" Next (to))))
                    ) 
                    (apply (remove (to)))
                ) 
            )
        )
        ("ChessKnight" "Knight")
        ("ChessPawn" "Pawn" ~ (then ("ReplayInMovingOn" (sites Mover "Promotion"))))
        (piece "Ferz_noCross" Each ("StepToNotFriend" Diagonal))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        
        phases:{
        (phase "OpeningCounselor" 
            (play 
                (forEach Piece "Ferz_noCross"
                    (move Hop Forward 
                        (between if:True) 
                        (to 
                            if:(is Empty (to)) 
                            (apply (remove (to)))
                        ) 
                    )
                )
            )
            (nextPhase Mover "OpeningSoldier")
        )
        (phase "OpeningSoldier" 
            (play 
                (forEach Piece "Pawn"
                    (if 
                        (is In (from) (sites {"D2" "D7"}))
                        (move Hop Forward 
                            (between if:True) 
                            (to 
                                if:(is Empty (to)) 
                                (apply (remove (to)))
                            ) 
                        )
                    )
                )
            )
            (nextPhase Mover "Playing")
        )
        (phase "Playing" 
            (play 
                (if "SameTurn"
                    (move Promote (last To) (piece "Ferz_noCross") Mover)
                    (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
                )
            )
        )
        }
        (end {
            ("Checkmate" "King_noCross")
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
Kiôz is a capturing game played in the Levant in the seventeenth century. It is closely related to the game of Tab, which is still played in the region.4x22 board. 22 pieces per player, four kings and eighteen regular pieces. Kings have no difference in movement or power than regular pieces. Moves are determined by four two-sided sticks, black on one side and white on the other. The moves are determined by the number of white sides that land face up: 1= a move of 1. A throw of 1 is known as \ 
(game "Kioz"
    (players 2)
    (equipment {
        (board 
            (rectangle 4 22)
            {
            (track "Track1" "0,E,N1,W," P1 directed:True)
            (track "Track2" "87,W,S1,E" P2 directed:True)
            (track "MiddleTrack" "44,E,S1,W" loop:True)
            }
        )
        ("StickDice" 4)
        (piece "Marker" Each)
        (piece "King" Each)
        (map "Throw" {(pair 0 4) (pair 1 1) (pair 2 2) (pair 3 2) (pair 4 6)})
        (regions "Home" P1 (sites Bottom))
        (regions "Home" P2 (sites Top))
    })
    (rules 
        (start { 
            (place "Marker1" (intersection (sites Bottom) (expand (sites Left) steps:17)))
            (place "King1" (intersection (sites Bottom) (expand (sites Right) steps:3)))
            (place "Marker2" (intersection (sites Top) (expand (sites Right) steps:17)))
            (place "King2" (intersection (sites Top) (expand (sites Left) steps:3)))
        })
        (play 
            ("RollMove"
                (if ("Tab")
                    (priority {
                        (forEach Piece ("Move" (not ("PieceActivated" (from)))))
                        (forEach Piece ("Move"))
                    })
                    (forEach Piece ("Move"))
                )
                (then 
                    (if ("SpecialThrows")
                        (moveAgain)
                    )
                )
            )
        )
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Bam Blang Beh Khla" 
    (players 2) 
    (equipment { 
        (board
            (add
                (remove
                    (merge {
                        (shift 0.4 -1 (scale 0.6 (rectangle 1 3)))
                        (shift 0.2 0 (scale 0.8 2 (wedge 2)))
                        (shift 0 -0.5 (scale 1 2.5 (wedge 2)))
                        }
                    )
                    edges:{{3 8} {3 7} {3 9}}
                )
                edges:{{6 9} {4 7} {1 8}}
            )
            use:Vertex
        )
        (piece "Tiger" P1 (or "HopCapture" "StepToEmpty"))
        (piece "Goat" P2 "StepToEmpty")
    }) 
    (rules 
        (start {
            (place "Tiger1" (sites Top))
            (place "Goat2" (sites Bottom))
        })
        (play (forEach Piece))
        
        (end ("NoMovesP1NoPiecesP2"))
    )
)
Bam Bang Beh Khla (\An isosceles triangle, with a line intersecting the two equal sides, another line drawn from the apex to the midpoint of this line. A line extending below the base, and another line perpendicular to this one. One player plays as the tiger, and another player as three goats. The tiger begins at the apex of the triangle, the goats on the three points on the bottom line (the two ends and the place where it intersects with the other line. Players alternate turns moving a piece to an empty adjacent spot. The tiger may capture a goat by hopping over it to an empty adjacent spot along the lines of the board. The tiger wins by capturing all of the goats; the goats win by blocking the tiger from being able to move. 

Construct a Ludii game based on the following description
A variant of Amazons played on a hex board.Movement is the same as regular amazons. You can move or shoot as many spaces as you want in any orthogonal or diagonal direction. With a hex board you have 6 orthogonal lines of movement (green) as well as 6 diagonal lines of movement (blue).
            
            Like in the original, Amazons still cannot move or shoot through other arrows or other amazons. However the diagonals are a little bit more tricky than the original. If the two orthogonal spaces next to the diagonal line are blocked, than the amazon can no longer use (or continue along) this diagonal. This is important because it reduces the movement capabilities of the amazons and allows a wall of connected arrows to become impenetrable.
            
            One final rule, in order to balance the game (white has first move advantage). On whites first turn he/she can only move an amazon but not shoot an arrow afterwards. This prevents potential too strong opening moves.
            
        The first player to block the opponent wins. 
(game "Hex Amazons" 
    (players 2) 
    (equipment { 
        (board (hex 7)) 
        (piece "Queen" Each ("QueenMove" (then (moveAgain))))
        (piece "Dot" Neutral)
    }) 
    (rules 
        (start { 
            (place "Queen1" {"B2" "G2" "E5" "B7"})
            (place "Queen2" {"L12" "G12" "L7" "I9"})
        })
        
        phases:{
        (phase "Opening" P1
            (play (forEach Piece "QueenMove"))
            (nextPhase Mover "Playing")
        )
        (phase "Playing" 
            (play 
                (if ("SameTurn")
                    (or
                        (move Shoot (piece "Dot0"))
                        (move Shoot (piece "Dot0") Diagonal
                            (between if:(is Empty (between)))
                            (to if:("ToEmptyAndNotBlocked"))
                        )
                    )
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("BlockWin")) 
    )
)

Describe the mechanics of the following Ludii game
(game "Duidoku" 
    (players 2) 
    (equipment { 
        (board (square 9)) 
        (piece "1" Neutral)
        (piece "2" Neutral)
        (piece "3" Neutral)
        (piece "4" Neutral)
        (piece "5" Neutral)
        (piece "6" Neutral)
        (piece "7" Neutral)
        (piece "8" Neutral)
        (piece "9" Neutral)
        (regions "Square0" (sites { 0..2 9..11 18..20}))
        (regions "Square1" (sites { 3..5 12..14 21..23}))
        (regions "Square2" (sites { 6..8 15..17 24..26}))
        (regions "Square3" (sites {27..29 36..38 45..47}))
        (regions "Square4" (sites {30..32 39..41 48..50}))
        (regions "Square5" (sites {33..35 42..44 51..53}))
        (regions "Square6" (sites {54..56 63..65 72..74}))
        (regions "Square7" (sites {57..59 66..68 75..77}))
        (regions "Square8" (sites {60..62 69..71 78..80}))
    }) 
    (rules
        (play
            (or {
                ("AddPiece" "1")
                ("AddPiece" "2")
                ("AddPiece" "3")
                ("AddPiece" "4")
                ("AddPiece" "5")
                ("AddPiece" "6")
                ("AddPiece" "7")
                ("AddPiece" "8")
                ("AddPiece" "9")
            })
        )
        (end { 
            (if (all Sites (sites Board) if:(is Occupied (site))) (result Mover Draw))
            ("BlockWin")
        })
    )
)
Duidoku is a two-player version of Sudoku. The player to play the last possible legal move wins the game.  The other player loses.  Unless, that is, the board is completely full, in which case the game is a tie. 

Describe the mechanics of the following Ludii game
(game "Fart (5x5)"
    (players 2)
    (equipment {
        (board (square 5))
        (piece "Marker" Each (move Slide Orthogonal))
        (hand Each)
    })
    (rules
        (start (place "Marker" "Hand" count:12))
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover))
                    (to (difference (sites Board) (centrePoint)) if:(is Empty (to)))
                    (then (if ("NewTurn") (moveAgain)))
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Move")
        )
        (phase "Move" (play (forEach Piece)))
        }
        (end (if (is Line 5) (result Mover Win)))
    )	
)
Fart is an alignment game played by young people of El Oued, Algeria. In this version, players must place their pieces in a row of five to win.5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on the board. When all of the pieces are placed, players alternate turns moving one piece orthogonally any distance. The first player to place five of their pieces in an orthogonal or diagonal line wins.
         

Describe the mechanics of the following Ludii game
(game "Bargese" 
    (players 2) 
    (equipment { 
        ("PachisiBoard" 
            {
            (track "Track1" "26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P1 directed:True)
            (track "Track2" "27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P2 directed:True)
            }
        )
        (hand Each) 
        ("StickDice" 6)
        (piece "Pawn" Each
            (if (and {
                    (>= 0 (var "EnteredPiece"))
                    ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) 1)) 
                    (or ("Bange") ("Dust"))
                })
                (move Remove (from) level:(level)
                    (then (set Var "EnteredPiece" 1))
                )
                (if (and 
                        (>= 0 (var "EnteredPiece"))
                        ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) 2)) 
                    )
                    (move
                        (from (from))
                        (to ("SiteToMoveOnTrack" from:(from) 1))
                    )
                    (move 
                        (from (from) level:(level))
                        (to
                            ("SiteToMoveOnTrack" from:(from) (if (< 0 (var "EnteredPiece")) (- ("ThrowValue") 1) ("ThrowValue")))
                            if:(not (and (is In (to) (sites "SafeSites")) ("IsEnemyAt" (to))))
                            ("HittingStackCapture" (handSite (who at:(to) level:(level))))
                        )
                        (then (set Var "EnteredPiece" 0))
                    )
                )
            )		
        )
        (map "Throw" {(pair 0 6) (pair 1 11) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 12)})
        (map "DefaultEntry" {(pair P1 26) (pair P2 27)})
        (map "XEntry" {(pair P1 2) (pair P2 48)})
        (regions "SafeSites" (sites {60 62 16 48 87 89 37 2}))
    }) 
    (rules 
        (start { 
            (place Stack "Pawn1" (handSite P1) count:4)
            (place Stack "Pawn2" (handSite P2) count:4)
        })
        
        (play 
            (do (if (>= 0 (var "EnteredPiece")) (roll))
                next:(if (can Move ("Move")) ("Move") (move Pass (then (set Var "EnteredPiece" 0))))
                (then 
                    (if ("IsSpecialThrow")
                        (moveAgain)
                    )
                )
            )
        )
        
        (end ("EscapeWin"))
    )
)
Bargese is a race game played by Syrian women typically played on velveteen cloth with the game board embroidered, and metal pieces which take the shape of soldiers and horses. The throws of the cowrie shells have Persian names, suggesting that the game came to Syria through Iran.Four 3x8 rectangles, arranged in a cross. In the outer rows of each arm, the third square from the outer corners is marked with an X. In two opposite arms, the bottom left corner is marked with \ 

Construct a Ludii game based on the following description
This game is documented in Alfonso X's Libro de los Juegos. It is one of the earliest hunt games that has documented rules, and was played in thirteenth century Spain. One player is the rabbit, and the other player plays with twelve other pieces. They may also play with either ten or eleven pieces instead of twelve. The pieces move along the lines. The goal is to corner the rabbit so that it cannot move. The rabbit may hop over the other pieces to capture them. The rabbit wins by reducing the opponent to nine pieces. Played on a Alquerque Board. The hare can jump to capture.
(game "Cercar La Liebre" 
    (players 2) 
    (equipment { 
        <Board>
        (piece "Counter" P1 "StepToEmpty") 
        (piece "Hare" P2 (or <Jump:hare> (if "SameTurn" (move Pass) "StepToEmpty")))
    }) 
    (rules 
        (start { 
            (place "Counter1" (union {(expand (sites Bottom)) (sites {"A3" "E3"})}))
            (place "Hare2" (centrePoint))
        })
        
        (play (forEach Piece)) 
        
        (end ("NoMovesLossAndLessNumPiecesPlayerLoss" P1 9))
    )
)

Describe the mechanics of the following Ludii game
(game "El Cazador" 
    (players {(player S) (player N)}) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Human" P1
            (or 
                ("HopCapture") 
                ("StepToEmpty")
            )		
        )
        (piece "Hen" P2 ("StepToEmpty" (directions {Rightward Leftward Forwards})))
    }) 
    
    (rules 
        (start { 
            (place "Human1" (centrePoint))
            (place "Hen2" (union {(expand (sites Bottom)) (sites {"D3" "E3"}) }))
        })
        
        (play (forEach Piece))
        
        (end ("NoMovesP1NoPiecesP2")) 
    )
)
El Cazador is a hunt game played on the island of La Palma in the Canary Islands. 5x5 intersecting lines with diagonals drawn in the quadrants. One player plays as one hunter, placed in the central spot. The other player plays as twelve birds, which are placed in the two rows closest to the player and the two spots on the right hand side in the central row. The hunter may move in any direction along the lines of the board. The hunter may capture birds by hopping over them to an empty spot on the opposite side along the lines of the  board. The birds may move forward orthogonally or diagonally. The birds win by blocking the hunter from being able to move; the hunter wins by capturing all of the birds or when it is no longer possible for the birds to capture the hunter. 

Construct a Ludii game based on the following description
Sig is a word used for several games played throughout North Africa. This game, played in the Tidikelt region of Algeria, alows captures only in opponent's home rows. The playing spaces represent plots of cultivated gardens and the pieces are water flowing through them.Three rows of holes, arranged vertically, the outer two have twelve holes and the central one has thirteen. Twelve pieces per player, which begin in the outer rows. Four sticks, black on one side and white on the other, the number of white faces up is the value of the throw; all black faces up = 6. A player must throw a 1 (sig) to unlock a piece, which moves from the top hole in the player's row to the top hole of the central row. When a piece reaches the thirteenth space in the central row, they must throw a sig to enter the opponent's home row, at the bottom hole in that row, and proceed up that row to the top and then back into the central row. When entering the opponent's row, the opponent's piece in their bottom hole is sent to the next available hole in their row. In the central row, when a piece lands on a hole with an opponent's piece, the opponent's piece is sent back to start in their home row. A player landing on a hole occupied by an opponent in the home row captures the opponent's piece. The player who captures all of the opponent's pieces wins. The game is played with 4 dice.
(game "Sig (Tidikelt)"
    (players 2)
    (equipment {
        (board 
            (merge {
                (rectangle 12 3) 
                (shift 1 -1 (rectangle 13 1)) 
            })
            {
            (track "HomeTrack1" "0,N,E1,S" P1 directed:True)
            (track "HomeTrack2" "2,N,W1,S" P2 directed:True)
            (track "EnemyTrack1" "2,N,W1,S" P1 directed:True)
            (track "EnemyTrack2" "0,N,E1,S" P2 directed:True)
            }
            use:Vertex
        )
        (piece "Stick" Each)
        (regions "AllSites" (sites Board))
        ("StickDice" <Dice:num>)
        <Dice:throwValues>
        (map "FirstEnemySite" {(pair P1 2) (pair P2 0)})
        (regions "Home" P1 (sites Left))
        (regions "Home" P2 (sites Right))
    })
    (rules 
        (start { 
            (place "Stick1" (sites Left))
            (place "Stick2" (sites Right))
        })
        (play 
            ("RollMove"
                (or
                    (if (and ("Sig") (= (mover) (who at:("BottomSite"))))
                        (move 
                            (from ("BottomSite"))
                            (to 
                                (mapEntry "FirstEnemySite" (mover))
                                if:(not (is Friend (mapEntry "FirstEnemySite" (mover))))
                                "CaptureEnemyPieceInEntering"
                            )
                        )
                    )
                    (forEach Piece ("Move"))
                )
            )
        )
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Mangola" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "23,W,N1,E" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))         
        (regions "Home" P2 (sites Track "TrackCCW2"))         
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom)))  
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top)))   
        (regions "LeftMost" P1 (intersection (sites Left) (sites Track "TrackCCW1"))) 
        (regions "LeftMost" P2 (intersection (sites Right) (sites Track "TrackCCW2"))) 
        (regions "EndHoles" P1 (intersection (union (sites Left) (sites Right)) (sites Track "TrackCCW1"))) 
        (regions "EndHoles" P2 (intersection (union (sites Left) (sites Right)) (sites Track "TrackCCW2"))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))
        )
        
        phases:{
        (phase "Opening1"
            (play
                (move Select
                    (from 
                        (if ("SameTurn") 
                            "PlayFromNextLastHole" 
                            (sites Mover "LeftMost") 
                        ) 
                        if:(> (count at:(from)) 0)
                    )
                    (then 
                        (sow
                            numPerHole:2
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (is Occupied ("NextHoleFrom" (to) "TrackCCW" 1)) (moveAgain))
                        )
                    )
                )
            )
            (nextPhase Mover (not (is Next Mover)) "Opening2")
        )
        (phase "Opening2"
            (play
                (move Select
                    (from 
                        (if ("SameTurn") 
                            (sites {(var "Replay") })
                            (sites Mover "EndHoles") 
                        ) 
                        if:(> (count at:(from)) 1)
                    )
                    (then 
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (and {
                                    (moveAgain)
                                    (set Var "Replay" (to))
                                    (if 
                                        (and {
                                            (is In (to) (sites Mover "Inner"))
                                            (is Occupied ("OppositeOuterPit" (to)))
                                            (is Occupied ("OppositePit" (to)))
                                        })	
                                        (and {
                                            (fromTo
                                                (from ("OppositeOuterPit" (to)))
                                                (to ("NextHoleFrom" ("FirstEmptyHole" (to)) "TrackCCW" 1))
                                                count:(count at:("OppositeOuterPit" (to)))
                                            )
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to ("NextHoleFrom" ("FirstEmptyHole" (to)) "TrackCCW" 1))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (sow
                                                ("NextHoleFrom" ("FirstEmptyHole" (to)) "TrackCCW" 1)
                                                count:(+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))))
                                                "TrackCCW"
                                                owner:(mover)	
                                            )
                                        })		
                                    )
                                })
                                (fromTo
                                    (from (to))
                                    (to ("NextHoleFrom" (to) "TrackCCW" 1))
                                    count:1
                                )
                            )
                        )
                    )
                )
            )
            
            (nextPhase Mover (not (is Next Mover)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            (sites {(var "Replay")})
                            (sites Mover "Home") 
                        ) 
                        if:(> (count at:(from)) 1)
                    )
                    (then 
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (and {
                                    (moveAgain)
                                    (set Var "Replay" (to))
                                    (if 
                                        (and {
                                            (is In (to) (sites Mover "Inner"))
                                            (is Occupied ("OppositeOuterPit" (to)))
                                            (is Occupied ("OppositePit" (to)))
                                        })	
                                        (and {
                                            (fromTo
                                                (from ("OppositeOuterPit" (to)))
                                                (to ("NextHoleFrom" ("FirstEmptyHole" (to)) "TrackCCW" 1))
                                                count:(count at:("OppositeOuterPit" (to)))
                                            )
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to ("NextHoleFrom" ("FirstEmptyHole" (to)) "TrackCCW" 1))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (sow
                                                ("NextHoleFrom" ("FirstEmptyHole" (to)) "TrackCCW" 1)
                                                count:(+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))))
                                                "TrackCCW"
                                                owner:(mover)	
                                            )
                                        })		
                                    )
                                })
                                (fromTo
                                    (from (to))
                                    (to ("NextHoleFrom" (to) "TrackCCW" 1))
                                    count:1
                                )
                            )
                        )
                    )
                )
            )
            
        )
        }
        (end ("ForEachPlayerNoMovesLoss"))
    )
)
Mangola is a four-row mancala-style board game from the Democratic Republic of Congo. It was documented in the mid-twentieth century by Suzanne Comhaire-Sylvain. Adults play it on boards, children, including girls, scoop holes out of the ground to play.4x8 board. Two counters in each hole. Play begins with each player taking the two counters in the leftmost hole of either the inner or outer row and placing them both in the following hole in an anti-clockwise direction, and continuing with the two counters in the next hole, until there is an alternating pattern of holes with four counters followed by empty holes in all of the player's holes. On the next turn, the player sows from one of the holes on the end of one of their rows. Sowing occurs in an anti-clockwise direction. After this turn, sowing can be from any hole on the player's side of the board. Single counters cannot be sown.  When the final counter falls into an occupied hole, the player picks up these counters and continues to sow. When the final counter is supposed to fall into an empty hole, it is not placed there but placed in the next hole. When the final counter falls into an occupied hole in the inner row, any counters in the opponent's two holes opposite are captured. These are then sown on the player's side of the board, beginning with the first occupied hole immediately after an empty hole before the hole from which the capture was made. Play continues until one player can no longer play, and the opponent wins. 

Construct a Ludii game based on the following description
Liu Tsi is a simple game of alignment played in China during the seventeenth century, but which is likely much older.3x3 intersecting lines, with diagonals. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. Once all of the pieces are placed, the players alternate turns moving a piece to an empty adjacent spot along the lines. The first player to place three pieces in a line wins. 
(game "Liu Tsi"
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 3 3)
        (hand Each)
        (piece "Marker" Each "StepToEmpty")
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
Bashni is a game with leaping captures played in Russia during the nineteenth century. It is the inspiration behind the game Lasca. Instead of removing pieces from the board when they are captured, they are stacked underneath the capturing piece.8x8 board. Twelve pieces per player. Pieces begin on the dark spaces. White plays first. Players alternate turns moving their pieces diagonally one space forward to an empty space. A piece may capture an opponent's piece by hopping over it to an empty space on the opposite side of the opponent's piece, in a forward direction only. When pieces are captured, they are placed underneath the piece making the capture, forming a stack, controlled by the player whose piece is on top, the \ 
(game "Bashni"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8))
        (piece "Counter" Each)
        (piece "CounterStar" Each)
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    
    (rules 
        ("BlackCellsSetup" 3)
        
        (play
            (if "SameTurn"
                (if "IsUnpromoted" 
                    ("HopStackEnemyCaptureTop"
                        (from (last To)) 
                        (directions {FR FL}) 
                        (then 
                            ("PromoteIfReach" (sites Next) "CounterStar"
                                ("ReplayIfCanMove"
                                    ("HopStackEnemyCaptureTop"
                                        (from (last To)) 
                                        (directions {FR FL}) 
                                    )
                                )
                            ) 
                        )
                    ) 
                    (move Hop
                        (from (last To)) 
                        Diagonal 
                        (between 
                            before:(count Rows)
                            after:(count Rows)
                            if:(and (not (is In (between) (last Between))) ("IsEnemyAt" (between)))
                            (apply (fromTo (from (between)) (to)))
                        ) 
                        (to if:(and 
                                (is In (from) (sites Occupied by:Mover)) 
                                (is Empty (to))
                            )
                        ) 
                        stack:True 
                        (then
                            ("ReplayIfCanMove"
                                (hop 
                                    (from (last To)) 
                                    Diagonal 
                                    (between 
                                        before:(count Rows)
                                        after:(count Rows)
                                        if:(and (not (is In (between) (last Between))) ("IsEnemyAt" (between)))
                                        (apply (fromTo (from (between)) (to)))
                                    ) 
                                    (to if:(and 
                                            (is In (from) (sites Occupied by:Mover)) 
                                            (is Empty (to))
                                        )
                                    ) 
                                    stack:True
                                )
                            ) 
                        )
                    ) 
                )
                (priority {
                    (or { 
                        (forEach Piece "Counter" ("Hop" (directions {FR FL})) top:True (then ("PromoteIfReach" (sites Next) "CounterStar")))
                        (forEach Piece "CounterStar" ("HopDistance" Diagonal) top:True)
                    })
                    
                    (or { 
                        (forEach Piece "Counter" ("StepStackToEmpty" (directions {FR FL})) top:True (then ("PromoteIfReach" (sites Next) "CounterStar")))
                        (forEach Piece "CounterStar" (move Slide Diagonal stack:True) top:True)
                    })
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Gol Ekuish is a game from India with leaping captures like many others in South Asia and beyond. The board consists of seven concentric circles divided by three diameters.Each player begins with 21 pieces, arranges on the 21 intersections of three consecutive radii. Players alternate turns moving to an empty adjacent spot. Captures are made by hopping over an opponent's piece. The player who captures all of the other player's pieces wins. 
(game "Gol Ekuish" 
    (players 2) 
    (equipment { 
        (board (concentric {1 6 6 6 6 6 6 6}) use:Vertex)
        (piece "Counter" Each 
            (or 
                ("HopRotationalCapture")
                ("StepRotationalToEmpty")
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Counter1" (sites {2..4 8..10 14..16 20..22 26..28 32..34 38..40}) )
            (place "Counter2" (sites {1 7 13 19 25 31 37 5 6 11 12 17 18 23 24 29 30 35 36 41 42}))
        })
        
        (play (forEach Piece))
        (end ("NoMoves" Loss)) 
    )
)

Construct a Ludii game based on the following description
Shanzak Kammar is a capturing game played in Central Asia. It was particularly popular in Samarkand in the nineteenth century, and was often played on a board drawn on the ground with clay pieces, coins, or pebbles.5x5 intersecting lines. Two triangles on opposite sides of the square, with the apex intersecting with the midpoint of opposite sides. A line is drawn from the apex , bisecting the base, and another line bisecting this one and the opposite two sides of the triangle. Lines are drawn through the apex, extending the sides of the triangle to the midpoint of the adjacent side. Sixteen pieces per player, which begin on the points of the board closes to the player. Players alternate turns moving a piece to an empty adjacent spot orthogonally or diagonally, even when there are not lines connecting the adjacent points. A player's piece may hop over an opponent's piece to an empty space immediately on the opposite side of it to capture it. The player who occupies all of the points in the opponent's triangle wins.  
(game "Shanzak Kammar"
    (players 2) 
    (equipment { 
        (board 
            (add
                ("AlquerqueGraphWithBottomAndTopTriangles") 
                edges:{{5 1} {1 7} {7 3} {3 9} {13 9} {7 13} {11 5} {15 11} {11 17} {7 11} {17 13} {13 19} {23 19} {23 17} {17 21} {15 21}}
            )
            use:Vertex
        )
        (piece "Marker" Each (or "StepToEmpty" "HopCapture"))
        (regions "Goal" P1 (expand (sites Top)))
        (regions "Goal" P2 (expand (sites Bottom)))
    }) 
    (rules 
        (start {
            (place "Marker1" (expand (sites Bottom) steps:3))
            (place "Marker2" (expand (sites Top) steps:3))
        })
        
        (play (forEach Piece))
        
        (end (if (= 6 (count Pieces Mover in:(sites Mover "Goal"))) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
After starting from the centers of the rings there are three important rules:    # STEP-Length: Sum of the pips of your color on occupied sites on the track of colored ring-sites. Each step moves orthogonal forward, left or right.    # STARTER-Generation: Reach same color of friendly piece in opposite ring to get an additional Starter to your base.    # CAPTURE-Move: Reach same color of enemy piece in opposite ring to capture it directly. Captured pieces form a stack and have to be brought to the center between the rings to send them to jail.    WIN = Get 3 Prisoners or Extinction of opponent.    See details in rules section.Pieces start from the centers of the rings to the colored positions and later move orthogonal forward, left or right. The total STEP-length is equal to the sum of the pips of a players color on all the positions occupied by their pieces.
            If you can move you have to do so, even if it is a bad move.
            If you stalemate yourself, the other player can move until you can move again.
            
            STARTER-generation: If you reach the same color of one of your own pieces in the opposite ring, you get a new starter to your base (center of the rings) from your reserve. This also works from the base with a start-move (base to own ring).
            
            To CAPTURE an enemy, you need to be able to reach the same color of the enemy-piece in the opposite ring, then the possibility to directly capture the enemy on its board-position will be available.
            Capturing is not mandatory, you can also just go to the opposite-color position (move 'into the shadow'). Capturing with a start-move from the base is not possible.
            RingCapture: with steplenght 8 you could theoretically move in a circle to your own position, but as normal move this is not allowed.
            But if there is an enemy-piece on the opposite same color, the (ring-)capture-move ist allowed! For steplengths of 12 or 14 etc this is also possible from some other positions.
            
            The captured pieces remain under the attacker in a stack and have to be brought to the Transmitter (field in the middle of the board) with the according steplength.
            If you reach the transmitter, your pieces in the stack go back to base as starters, and the enemies land in your prison.
            First player to make 3 prisoners wins.
            
            Only pieces with a captured enemy can land on the Transmitter for prisonertransport. (Exception: #LastMan)
            Single pieces just step over it. With high steplength you can move in circles or to the other side and back, but not turn 180 degrees.
            
            Special Rules to balance the Start:
            From the Start-situation (or later, when there are temporarily no picese on colored positions) you cannot copy the move of the enemy, ie move to the same color with your first piece.
            
            #CounterAttack: If your first starter is attacked immediately (by the first enemy move), you are allowed to start also to the colors in the enemy-ring with your second starter. In this case, there is no Starter generation, if you move to the opposite color of your first piece (to protect it from capturing).
            
            Special Rules for Endgame:
            #LastMan: If you are left with just a single piece on the colored board positions (and no starter on your base), you may enter the Transmitter to move the piece to your base and get a second starter (if you still have one in your reserve)!
            
            #PrisonerExchange: Move a prisoner to your (empty) homebase, and you get an additional Starter taken from your reserve & the prisoner goes back to his reserve. You have to move this new starter immediately: the PrisonerExchange itself counts not as a full move.
            
            History : 'Mensa Spiel' invented by Andreas Pichler (Mensa Austria).
            Ludii file implemented by Franz Pichler. (June 2022)
            
            Strategy : Early starter-generation is important to have more options.
            Indirect or dynamic defense is sometimes best: if you are captured, to be able to capture back or dominate the opponent with controlling many positions is vital.
            In general, a move that attacks an enemy-piece and would make possible a Starter-Generation in the next move simultaneously, is good.
            
            But be aware: almost all moves change the steplength and attack & defence-patterns, ie. the whole situation.
        This makes it complicated to calculate, but entertaining to play. White player starts the game. Sudden Death Match: 1 Prisoner ends it all.
(game "MensaSpiel"
    (players 2)
    (equipment { (board (remove (rectangle 5 7) cells:{2 4  7 8 9   11 12 13   17 31} )  )
        
        (regions "Base" P1   {<Starter:Bas1>})     (regions "Base" P2   {<Starter:Bas2>})
        (regions "Prison" P1 {<Starter:Pri1>})     (regions "Prison" P2 {<Starter:Pri2>})
        (regions "Reserve" P1 {<Starter:Res1>})    (regions "Reserve" P2 {<Starter:Res2>})
        (regions "HomeRing" P1 <Starter:Hom1>)     (regions "HomeRing" P2 <Starter:Hom2>)
        (regions "SitesLastMan" P1 <Starter:Las1>) (regions "SitesLastMan" P2 <Starter:Las2> )
        (regions "Rings" {6..12 14 16 18..24}) (regions "RingsplusT" {6..12 14 15 16 18..24}) (regions "RingsplusBase" {6..24})
        
        (map "PipsP1" {6..24} {4 1 3 2 2 1 2 0 3 0 1 0 1 3 2 2 2 0 3})
        (map "PipsP2" {6..24} {0 3 1 2 2 3 2 0 1 0 3 0 3 1 2 2 2 4 1})
        (map "Attacks1" {6..24} {10 23 9 12 8 6 9 0 16 0 7 0 12 11 11 16 7 21 6 })
        (map "Attacks2" {6..24} {10 18 22 14 19 19 24 0 23 0 14 0 20 24 22 18 20 21 8 })
        (map "SameColor" {6..24} {23 24 18 20 21 14 22 0 11 0 19 0 8 16 9 10 12 6 7 })
        (map "Step1c" {14 16 }{15 15})
        (map "Step2a" {6..24} {19 14 6 22 18 24 20 0 20 0 23 0 23 21 14 19 24 18 11 })
        (map "Step2b" {6..24} {8 12 21 11 16 9 7 0 7 0 10 0 10 6 12 8 9 16 22 })
        (map "Step2c" {8 14 21 16 9 22} {15 16 15 14 15 15 })
        (map "Step3a" {6..24} {20 19 12 23 22 23 21 0 19 0 24 0 9 14 8 12 10 9 10 })
        (map "Step3b" {6..24} {14 21 20 18 24 16 8 0 6 0 11 0 22 7 6 7 18 11 16 })
        (map "Step3c" {7..23} {15 16 14 15 0 0 0 22 0 8 0 0 0 15 16 14 15 }) 
        (map "Step3d" {14 16} {9 21 })
        (map "Step4a" {6..24} {21 20 19 24 23 22 14 0 12 0 18 0 16 8 7 6 11 10 9 })
        (map "Step4b" {6..24} {15 16 9 8 14 15 0 0 10 0 7 0 0 15 16 9 8 14 15 })
        (map "Step4c" {8 14 21 9 16 22} {22 23 22 21 20 21 })
        (map "Step5c" {6..24} {16 9 10 7 8 14 15 0 11 0 6 0 15 16 9 10 7 8 14 })
        (map "Step5d" {7..23} {22 23 20 21 0 0 0 24 0 19 0 0 0 22 23 20 21 })
        (map "Step6c" {6..24} {9 10 11 6 7 8 16 0 18 0 12 0 14 9 10 11 6 7 8 })
        (map "Step6d" {6..24} {22 23 24 19 20 21 0 0 0 0 0 0 0 22 23 24 19 20 21 })
        (map "Step6e" {6 19 11 24} {15 15 15 15 })
        (map "Step7a" {6..24} {7 8 14 10 11 18 6 0 8 0 9 0 11 12 19 14 16 22 18 })
        (map "Step7b" {6..24} {12 6 7 16 9 10 19 0 21 0 22 0 24 20 21 20 23 24 23 })
        (map "Step7c" {6..24} {10 11 18 12 6 7 9 0 11 0 6 0 8 10 11 18 12 6 7 })
        (map "Step7d" {6..24} {23 24 0 0 19 20 22 0 24 0 19 0 21 23 24 0 0 19 20  })
        (map "Step7e" {6 19 7 20 10 23 11 24} {16 16 15 15 15 15 14 14 })
        (map "Step8a" {6..24} {11 18 11 6 12 6 10 0 10 0 7 0 7 11 18 11 6 12 6 })
        (map "Step8b" {6..24} {24 16 24 19 14 19 23 0 23 0 20 0 20 24 16 24 19 14 19 })
        (map "Step8c" {6 19 8 21 9 22 11 24} {9 9 15 15 15 15 8 8 })
        (map "Step8d" {6 19 11 24} {22 22 21 21 })
        (map "Step9c" {6..24} {18 11 10 7 6 12 11 0 9 0 8 0 6 18 11 10 7 6 12 })
        (map "Step9d" {6..24} {10 24 23 20 19 7 24 0 22 0 21 0 19 23 24 23 20 19 7 })
        (map "Step9e" {6..24} {23 9 16 14 8 20 0 0 15 0 15 0 0 10 9 16 14 8 20 })
        (map "Step9f" {20 7 10 23} {22 22 21 21 })
        (map "Step10c" {6..24} {11 10 9 8 7 6 18 0 16 0 14 0 12 11 10 9 8 7 6 })
        (map "Step10d" {6..24} {24 23 22 21 20 19 0 0 0 0 0 0 0 24 23 22 21 20 19 })
        (map "Step10e" {21 8 9 22} {15 15 15 15 })
        (map "Step11c" {6..24} {10 11 10 7 6 7 11 0 9 0 8 0 6 10 11 10 7 6 7 })
        (map "Step11d" {6..24} {23 24 23 20 19 20 24 0 22 0 21 0 19 23 24 23 20 19 20 })
        (map "Step11e" {6..24} {18 9 16 14 8 12 0 0 15 0 15 0 0 18 9 16 14 8 12 })
        (map "Step11f" {7 10 20 23} {22 21 22 21 })
        (map "Step11g" {7 10 20 23} {15 15 15 15 })
        (map "Step12b" {6..24} {11 18 11 6 12 6 10 0 10 0 7 0 7 11 18 11 6 12 6 })
        (map "Step12c" {6..24} {24 16 24 19 14 19 23 0 23 0 20 0 20 24 16 24 19 14 19 })
        (map "Step12d" {6 19 8 21 9 22 11 24} {9 9 9 9 8 8 8 8 })
        (map "Step12e" {6 19 8 21 9 22 11 24} {22 22 22 22 21 21 21 21 })
        (map "Step12f" {6 19 8 21 9 22 11 24} {15 15 15 15 15 15 15 15 })
        (map "Step12g" {14 16} {11 19 })
        (map "Step13c" {6..24} {10 11 10 7 6 7 9 0 11 0 6 0 8 10 11 10 7 6 7 })
        (map "Step13d" {6..24} {23 24 23 20 19 20 22 0 24 0 19 0 21 23 24 23 20 19 20 })
        (map "Step13e" {6..24} {16 9 14 16 8 14 15 0 8 0 9 0 15 16 9 14 16 8 14 })
        (map "Step13f" {7..23} {22 18 12 21 0 0 0 21 0 22 0 0 0 22 18 12 21 })
        (map "Step14c" {6..24} {9 10 11 6 7 8 16 0 18 0 12 0 14 9 10 11 6 7 8 })
        (map "Step14d" {6..24} {22 23 24 19 20 21 0 0 0 0 0 0 0 22 23 24 19 20 21 })
        (map "Step14e" {6 19 11 24} {15 15 15 15 })
        (map "Step14f" {8 9 21 22} {18 20 10 12 })
        (map "Step15c" {6..24} {10 11 18 12 6 7 9 0 11 0 11 0 8 10 11 18 12 6 7 })
        (map "Step15d" {6..24} {23 24 20 23 19 20 22 0 24 0 24 0 21 23 24 7 10 19 20 })
        (map "Step15e" {6..24} {16 21 10 7 22 16 15 0 6 0 6 0 15 16 8 10 7 9 16 })
        (map "Step15f" {6..24} {14 9 23 20 8 14 0 0 19 0 19 0 0 14 9 23 20 8 14 })
        (map "Step16c" {6..24} {9 20 15 15 23 8 14 0 12 0 18 0 16 9 7 15 15 10 8 })
        (map "Step16d" {6 19 8 21 9 22 11 24} {22 22 6 6 11 11 21 21 })
        (map "Step16e" {6 19 8 21 9 22 11 24} {8 8 9 9 8 8 9 9 })
        (map "Step16f" {6 19 8 21 9 22 11 24} {21 21 19 19 21 21 22 22 })
        (map "Step16g" {6 19 8 21 9 22 11 24} {15 15 22 22 24 24 15 15 })
        (map "Step17c" {6..24} {10 11 10 7 6 7 8 0 6 0 11 0 6 10 6 10 7 6 7 })
        (map "Step17d" {6..24} {23 9 12 14 8 12 11 0 9 0 8 0 9 23 9 12 14 8 10 })
        (map "Step17e" {6..24} {18 15 16 18 15 16 21 0 15 0 15 0 19 18 11 16 18 11 16 })
        (map "Step17f" {6..24} {14 19 23 20 19 20 24 0 19 0 21 0 22 14 15 23 20 15 12 })
        (map "Step17g" {6..24} {20 22 0 0 21 23 0 0 22 0 24 0 0 7 22 0 0 19 20 })
        (map "Step17h" {7 10 20 23} {24 24 24 21 })
        (map "Step18c" {6..24} {11 10 9 8 7 6 18 0 16 0 14 0 12 8 10 6 8 7 6 })
        (map "Step18d" {6..24} {21 23 15 15 20 19 0 0 0 0 0 0 0 11 23 9 11 20 9 })
        (map "Step18e" {6 19 8 21 22 9 11 24} {24 24 19 15 15 21 22 19 })
        (map "Step18f" {8 21 22 9} {22 22 21 24 })
        (map "Step18g" {6 19 11 24} {23 16 14 7 })
        (map "Step19c" {6..24} {7 6 7 7 6 7 6 0 8 0 8 0 6 10 9 10 7 6 7} )
        (map "Step19d" {6..24} {10 8 10 10 8 10 11 0 9 0 9 0 11 12 11 14 14 8 12} )
        (map "Step19e" {6..24} {12 9 14 14 9 12 19 0 15 0 15 0 19 18 15 16 16 15 18} )
        (map "Step19f" {6..24} {18 11 16 16 11 18 24 0 21 0 21 0 24 20 19 20 20 19 20} )
        (map "Step19g" {6..24} {23 15 23 20 15 20 0 0 22 0 22 0 0 23 21 23 23 21 23} )
        (map "Step19h" {7 10 20 23} {22 19 22 22 } )
        (map "Step19i" {7 10 20 23} {24 21 24 24 } )
        (map "Step20b" {6..24} {9 16 9 6 12 6 10 0 10 0 7 0 7 6 16 8 6 12 6} )
        (map "Step20c" {6..24} {11 18 11 8 14 8 23 0 23 0 20 0 20 9 18 9 8 14 8} )
        (map "Step20d" {6..24} {15 0 15 15 0 15 0 0 0 0 0 0 0 11 0 11 9 0 11} )
        (map "Step20e" {6..24} {19 0 21 19 0 19 0 0 0 0 0 0 0 15 0 15 15 0 15} )
        (map "Step20f" {6..24} {22 0 22 21 0 21 0 0 0 0 0 0 0 22 0 22 19 0 19} )
        (map "Step20g" {6..24} {24 0 24 22 0 24 0 0 0 0 0 0 0 24 0 24 21 0 21} )
        
        (piece "Prisoner" Each  "PrisonerExchange" )
        (piece "Starter"  Each  "StartMove" ) (piece "Reserve"  Each )
        (piece "Cone"  Each (if "IsLastMan" (or "LastMan" "ConeMove" ) "ConeMove" ))
    })
    
    (rules
        (start {
            (place Stack "Starter1" <Starter:Bas1> count:3 )
            (place Stack "Starter2" <Starter:Bas2> count:3 )
            (place Stack "Reserve1" <Starter:Res1> count:6 )
            (place Stack "Reserve2" <Starter:Res2> count:6 )
        })
        
        (play   (do   (if "RingsAreEmpty" (and {(set Var "StartS" 0 ) (set Var "CntrAttack"  0 )   }))
                next:(if ( "SameTurn") "StartMove"
                    (forEach Piece top:True )
                )
            )
        )
        
        (end  { (if "Extinction" (result Mover Win) )
            (if (>= (count Pieces Mover in:(sites "Prison")) <Num:pris>) (result Mover Win) )
            
        })
    )
)

Construct a Ludii game based on the following description
Gundru is a capturing game played in Tibet by adults. It employs the custodial capturing mechanism.9x9 intersecting lines, pieces are played on the intersections. 16 pieces per player, one player is black, the other white. Pieces begin placed on the edge of the board: Black on the top and right, white on the bottom and left. Sixteen others are held in reserve for each player. Pieces move any distance orthogonally along the lines. Opponent's pieces are captured when they are surrounded by two of a player's pieces. When this is done, the surrounded player's pieces are removed and replaced with the pieces of the player that surrounded them. If multiple opponent's pieces are in a line and the other player places their pieces at either end of the line, all the pieces in between are captured. When a player is reduced to one piece, it gains the ability to capture by jumping. The player that removes all of their opponent's pieces wins. 
(game "Gundru"
    (players 2)
    (equipment {
        (board (square 9) use:Vertex)
        (piece "Marker" Each 
            (or
                (if (= 1 (+ (count Cell at:(handSite Mover)) (count Pieces Mover)))
                    ("HopCapture")
                )
                (move Slide
                    (then 
                        (custodial 
                            (from (last To))
                            (between 
                                (range 1 (count Rows))
                                if:("IsEnemyAt" (between))
                                (apply
                                    (and
                                        (remove (between))
                                        (fromTo 
                                            (from (handSite Mover))
                                            (to (between))
                                        )
                                    )
                                )
                            )
                            (to if:("IsFriendAt" (to)))
                        )
                    )
                )
            )
        )
        (hand Each)
    })
    (rules 
        (start {
            (place "Marker" "Hand" count:16)
            (place "Marker1" (union (sites Top) (difference (sites Right) (sites Bottom))))
            (place "Marker2" (union (sites Bottom) (difference (sites Left) (sites Top))))
        })
        (play (forEach Piece))
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Pentalpha is a solitaire game played on Crete in the early twentieth century. The board is a five-pointed star. The player has nine pieces. The player attempts to place all the pieces on the board. The player choses a point, then moves the piece two spaces in a straight line. The piece may move through a spot occupied by another piece, but must land on an empty space. The player wins by successfully placing all nine pieces.
         
(game "Pentalpha"
    (players 1) 
    (equipment { 
        ("StarBoard" 5)
        (hand Each) 
        (piece "Marker" P1 ("HopFriendCapture")) 
    })
    (rules 
        (start 
            (place "Marker" (handSite P1) count:9)
        )
        
        (play 
            (if (is Even (count Moves))
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                    (then (moveAgain))
                ) 
                (forEach Piece
                    (if (= (from) (last To))
                        (move Hop 
                            (between 
                                if:(or ("IsFriendAt" (between)) (is Empty (between)))
                            )
                            (to if:(is Empty (to)))
                        )
                    )
                )
            )
        )
        (end { 
            (if (and (is Even (count Moves)) ("HandEmpty" Mover)) (result Mover Win))
            (if (no Moves Next) (result Mover Loss))
        })
    )		
)

Construct a Ludii game based on the following description
Kyoto shogi is a modern variant of Shogi. It was invented by Tamiya Katsuya.Kyoto shogi is played like standard Shogi, but with a reduced number of pieces on a 5×5 board. However, the pieces alternately promote and demote with every move, and the promotion values are entirely different from standard Shogi.Two players play on a board ruled into a grid of 5 ranks (rows) by 5 files (columns).
            
            Each player has a set of 5 wedge-shaped pieces, of slightly different sizes. From largest to smallest (most to least powerful) they are: 1 king, 1 gold general, 1 silver general, 1 tokin, 1 pawn.
            
            There is no promotion zone in Kyoto shogi. Every time a piece makes a move it alternately promotes and reverts to its unpromoted state. Promotion is effected by turning the piece over after it moves, revealing the name of its promoted rank; demotion is effected by turning the piece back.
            
            The promotion rules and values are reminiscent of microshogi and entirely different from standard shogi: A king cannot promote. A tokin promotes to a lance and vice versa. A silver general promotes to a bishop and vice versa. A gold general promotes to a knight and vice versa. A pawn promotes to a rook and vice versa.
            
            A piece is allowed to move, capture or be dropped in a manner that will prevent it from moving on a subsequent turn, which is illegal in standard shogi. For example, a rook can move onto the farthest rank, becoming a pawn and unable to move further. Such pieces may be captured as any other.
            
            A captured piece may be dropped with either side facing up. There are no restrictions on where pieces can be dropped, other than that the square must be empty. So unlike in regular Shogi, pieces can be dropped in places where they can never move again, pawns can be dropped in files that already contain a pawn, and checkmate can be delivered through a pawn drop.
            
        The conditions to win are the same of the conditions of Shogi by checkmating the King. 
(game "Kyoto Shogi" 
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        (board (square 5))
        
        
        (piece "Osho" Each ("StepMove"))
        
        
        (piece "Fuhyo" Each 
            ("StepMove" 
                Forward 
                (then "Promote")
            )
        )
        
        
        (piece "Ginsho" Each ("StepMove" (directions {Forward BL BR FL FR}) (then "Promote")))
        
        
        (piece "Hisha" Each ("SlideMove" Orthogonal (then "Promote")))
        
        
        (piece "Kakugyo" Each ("SlideMove" Diagonal (then "Promote")))
        
        
        (piece "Keima" Each 
            (forEach Direction 
                Forward 
                (to 
                    if:True 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL}) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (add 
                                                (piece (mapEntry "Captured" (what at:(to)))) 
                                                (to (mapEntry "Where" (what at:(to))))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                ) 
                (then "Promote") 
            ) 
        )
        
        
        (piece "Kyosha" Each
            ("SlideMove" 
                Forward 
                (then "Promote")
            ) 
        )
        
        
        ("ShogiGold" "Kinsho" "CapturePiece" (then "Promote"))
        
        
        ("ShogiGold" "Tokin" "CapturePiece" (then "Promote"))
        
        (map "Where" { 
            (pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) 
            (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) 
            (pair (id "Kinsho" P1) (handSite P2 2)) (pair (id "Kinsho" P2) (handSite P1 2)) 
            (pair (id "Tokin" P1) (handSite P2 3)) (pair (id "Tokin" P2) (handSite P1 3)) 
            (pair (id "Hisha" P1) (handSite P2)) (pair (id "Hisha" P2) (handSite P1)) 
            (pair (id "Kakugyo" P1) (handSite P2 1)) (pair (id "Kakugyo" P2) (handSite P1 1)) 
            (pair (id "Keima" P1) (handSite P2 2)) (pair (id "Keima" P2) (handSite P1 2)) 
            (pair (id "Kyosha" P1) (handSite P2 3)) (pair (id "Kyosha" P2) (handSite P1 3)) 
        })
        
        (map "Captured" { 
            (pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) 
            (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1))
            (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) 
            (pair (id "Tokin" P1) (id "Tokin" P2)) (pair (id "Tokin" P2) (id "Tokin" P1)) 
            (pair (id "Hisha" P1) (id "Fuhyo" P2)) (pair (id "Hisha" P2) (id "Fuhyo" P1)) 
            (pair (id "Kakugyo" P1) (id "Ginsho" P2)) (pair (id "Kakugyo" P2) (id "Ginsho" P1)) 
            (pair (id "Keima" P1) (id "Kinsho" P2)) (pair (id "Keima" P2) (id "Kinsho" P1)) 
            (pair (id "Kyosha" P1) (id "Tokin" P2)) (pair (id "Kyosha" P2) (id "Tokin" P1)) 
        })
        
        (map "Promoted" { 
            (pair (id "Fuhyo" P1) (id "Hisha" P1)) (pair (id "Fuhyo" P2) (id "Hisha" P2)) 
            (pair (id "Ginsho" P1) (id "Kakugyo" P1)) (pair (id "Ginsho" P2) (id "Kakugyo" P2)) 
            (pair (id "Keima" P1) (id "Kinsho" P1)) (pair (id "Keima" P2) (id "Kinsho" P2)) 
            (pair (id "Kyosha" P1) (id "Tokin" P1)) (pair (id "Kyosha" P2) (id "Tokin" P2)) 
            (pair (id "Hisha" P1) (id "Fuhyo" P1)) (pair (id "Hisha" P2) (id "Fuhyo" P2)) 
            (pair (id "Kakugyo" P1) (id "Ginsho" P1)) (pair (id "Kakugyo" P2) (id "Ginsho" P2)) 
            (pair (id "Kinsho" P1) (id "Keima" P1)) (pair (id "Kinsho" P2) (id "Keima" P2)) 
            (pair (id "Tokin" P1) (id "Kyosha" P1)) (pair (id "Tokin" P2) (id "Kyosha" P2)) 
        })
        
        (hand Each size:4)
    })
    
    (rules 
        (start { 
            (place "Osho1" coord:"C1") (place "Tokin1" coord:"A1") (place "Ginsho1" coord:"B1") (place "Kinsho1" coord:"D1") (place "Fuhyo1" coord:"E1")
            (place "Osho2" coord:"C5") (place "Tokin2" coord:"E5") (place "Ginsho2" coord:"D5") (place "Kinsho2" coord:"B5") (place "Fuhyo2" coord:"A5")
        })
        
        (play
            (if ("SameTurn")
                ("PromoteDecision")
                (do 
                    (or
                        ("PlacePiece" Mover) 
                        (forEach Piece) 
                    )
                    ifAfterwards:(not ("IsInCheck" "Osho" Mover))
                )
            )
        )
        
        (end {
            (if (and 
                    ("IsInCheck" "Osho" Next)
                    ("NextCannotMove")
                ) 
                (result Mover Win)
            ) 
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
T'mbl is an alignment game played by Chaamba children of Algeria. 3x3 intersecting lines, with diagonals drawn in the square. Three pieces per player, which begin on the three points on opposite sides of the board. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. The first player to place three of their pieces in a row along one of the lines which is not one of the sides of the square, wins. 
(game "T'mbl"
    (players 2) 
    (equipment {
        (board (square 3 diagonals:Alternating) use:Vertex)
        (piece "Marker" Each ("StepToEmpty"))
    }) 
    (rules 
        (start {
            (place "Marker1" (sites Top))
            (place "Marker2" (sites Bottom))
        })
        (play (forEach Piece))
        (end (if (and (is In (centrePoint) (sites Occupied by:Mover)) (is Line 3)) (result Mover Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Tsoro (Additional Capture)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites Top) (sites Bottom))))
        
        (play 
            (if (< 0 ("NumCapture"))
                (move Remove
                    (forEach (sites Next) if:(< 0 (count at:(site))))
                    (then 
                        (and
                            (if (< 1 ("NumCapture")) (moveAgain))
                            (set Var (- ("NumCapture") 1))
                        )
                    )
                )
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover "Home") 
                        ) 
                        if:(if "AHoleHasMoreThanOneCounter"
                            (> (count at:(from)) 1)
                            (and (= (count at:(from)) 1) (= 0 (count at:("NextHoleFrom" (from) Mover)))) 
                        )
                    )
                    (then 
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (= (count at:(to)) 1)
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (> (count at:("OppositePit" (to))) 0) 
                                        (and {
                                            (remove ("OppositePit" (to))) 
                                            (if 
                                                (> (count at:("OppositeOuterPit" (to))) 0) 
                                                (remove ("OppositeOuterPit" (to))) 
                                            ) 
                                            (moveAgain)
                                            ("HaveToMakeExtraCapture")
                                        }) 
                                    ) 
                                )
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)
Tsoro is a word used for several regional variations of four-row mancala-style board games in Zimbabwe. In this version, players make additional captures when the standard capture is triggered.4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Before the game starts, players choose to make additional captures from one, two, or three holes. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. The player then captures again, from the agreed-upon number of extra holes, chosen from any of the opponent's holes. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. 1 extra capture. 6 Holes per row.

Construct a Ludii game based on the following description
Mastermind is a code-breaking game for two players.At the beginning of the game, the first player places 4 pieces of any colour in the bottom row. These pieces will be hidden to the second player during all the game.
            
            The objective of the second player (called codebreaker) is to try to guess the pattern, in both order and color, within a specific number of tries (corresponding to the number of rows). Each guess is made by placing a row of code pegs on the board.
        Once placed, a feedback on his last try is provided by placing from zero to four key pegs in the small holes of the row with the guess. A black key peg is placed for each code peg from the guess which is correct in both color and position. A white key peg indicates the existence of a correct color code peg placed in the wrong position. P2 has 4 tries.
(game "Mastermind"
    (players 2)
    (equipment {
        (board
            (merge {
                (rectangle (+ 1 "NumRow") "NumColumn")
                (shift "NumColumn" 0.75 
                    (repeat "NumRow" 1 
                        step:{{1 0} {0 1}} 
                        (poly {{0 0} {0 0.5} {0.5 0.5} {0.5 0}})
                    )
                )
            })
            use:Vertex
        )
        (piece "Marker1" Shared)
        (piece "Marker2" Shared)
        (piece "Marker3" Shared)
        (piece "Marker4" Shared)
        (piece "Marker5" Shared)
        (piece "Marker6" Shared)
        (piece "Marker7" Shared)
        (piece "Marker8" Shared)
        
        (piece "Disc1" Shared)
        (piece "Disc2" Shared)
        
        (hand Shared size:8)
    })
    (rules
        (start {
            (place "Marker1" (handSite Shared))
            (place "Marker2" (handSite Shared 1))
            (place "Marker3" (handSite Shared 2))
            (place "Marker4" (handSite Shared 3))
            (place "Marker5" (handSite Shared 4))
            (place "Marker6" (handSite Shared 5))
            (place "Marker7" (handSite Shared 6))
            (place "Marker8" (handSite Shared 7))
        })
        
        phases:{
        (phase "Placement" P1
            (play 
                (move
                    (from (sites Hand Shared))
                    (to (intersection (sites Empty) (sites Bottom)))
                    copy:True
                    (then
                        (and {
                            (set Hidden at:(last To) to:P2)
                            (if ("CombinationToFindPlaced")
                                (set Var 0) 
                                (moveAgain)
                            )
                        })
                    )
                )
            )
        )
        (phase "Finding" P2
            (play
                (move
                    (from (sites Hand Shared))
                    (to (intersection (sites Empty) (sites Row ("RowToPlace"))))
                    copy:True
                    (then
                        (and 
                            (moveAgain)
                            (if ("CombinationPlaced")
                                (and
                                    (forEach Value min:0 max:(- "NumColumn" 1)
                                        (if ("RightPositionAndColor")
                                            ("AddBlackHint")
                                            (if ("ColorInSolution")
                                                ("AddWhiteHint")
                                            )
                                        )
                                    )
                                    (set Var (+ 1 ("NumTry")))
                                    (then
                                        (if (or ("CombinationFound") (>= "NumTry" "NumRow"))
                                            (forEach Site (sites Bottom)
                                                (set Hidden at:(site) False to:P2)	
                                            )
                                        )		
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end {
                (if ("CombinationFound") (result P2 Win))
                (if (>= "NumTry" "NumRow") (result P1 Win))
            })
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Merimueng-rimueng" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (hand P2) 
        (piece "Tiger" P1 
            (or {
                ("StepToEmpty")
                ("BigHop" ("IsEnemyAt" (between))) 
            })
        ) 
        (piece "Sheep" P2 "StepToEmpty") 
    }) 
    (rules 
        (start {
            (place "Sheep2" (difference (expand (sites Centre)) (centrePoint)))
            (place Stack "Sheep2" (handSite P2) count:15)
            (place Stack "Tiger1" (sites Centre) counts:{2})
        })
        
        phases:{
        (phase "Movement"
            (play (forEach Piece top:True))
            
            (end ("NoMovesP1NoPiecesP2"))
            
            (nextPhase 
                (and 
                    ("HandOccupied" P2) 
                    (< (count Sites in:(sites Occupied by:P2 container:"Board")) 8)
                ) 
                "Placement"
            )
        )
        
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                    (then (moveAgain))
                ) 
            )
            (nextPhase 
                (or 
                    ("HandEmpty" P2) 
                    (= (count Sites in:(sites Occupied by:P2 container:"Board")) 8)
                ) 
                "Movement"
            )
        )
        }
    )
)
Merimuëng-Rimuëng (\5x5 intersecting lines, with diagonals drawn in the four quadrants of the board. Two triangles, their apices intersecting the main board at opposite midpoints. The bast of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. one player plays as two tigers, which start on the central point. The other player has 23 sheep, eight of which start on the board, on the points immediately adjacent to the tigers. Pieces move one space along the lines to an empty adjacent spot. The tigers may capture an unbroken line of sheep in one direction, provided there is an unoccupied space at the opposite end of the line. The player with the sheep replaces any captured sheep from those remaining in their hand. The tigers win when they capture all of the sheep; the sheep win when they block the tigers from being able to move. 

Describe the mechanics of the following Ludii game
(game "Barjis" 
    (players 4) 
    (equipment { 
        ("PachisiBoard" 
            {
            (track "Track1" "96,9,S,E1,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N8" P1 directed:True)
            (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E8" P2 directed:True)
            (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S8" P3 directed:True)
            (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W8" P4 directed:True)
            } 
        )
        (hand Each) 
        ("StickDice" 6)
        (piece "Pawn" Each
            (if ("IsOffBoard" ("NextSiteOnTrack" ("ThrowValue")))
                (move Remove (from))
                (move 
                    (from (from))
                    (to 
                        ("NextSiteOnTrack" ("ThrowValue"))
                        if:(or 
                            (is Empty (to))
                            (and 
                                ("IsEnemyAt" (to))
                                (not (is In (to) (sites "SafeSites")))	
                            )
                        )
                        ("HittingCapture" (handSite (who at:(to)))) 
                    )
                )	
            )
        )
        (map "Throw" {(pair 0 6) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 12)})
        (regions "SafeSites" (sites {60 62 16 48 87 89 37 2}))
    }) 
    (rules 
        (start (place "Pawn" "Hand" count:4))
        (play 
            ("RollMove" 
                (or 
                    (forEach Piece) 
                    (if (and ("IsSpecialThrow") (is Occupied (handSite Mover)))
                        ("EnterAPiece")
                    )
                )
            )
        )
        
        (end ("EscapeWin"))
    )
)
Barjis is a race game that was played by Arab residents of Palestine in the early twentieth century. Played exclusively by women and children, it is very similar to other cross-shaped race games that were particularly popular in South and Southeast Asia.Four 3x8 rectangles, arranged in a cross. The third square in the outer rows of each arm, counting from the outer corners, are marked. Four players, each with four pieces. Pieces enter the board from the center of the board, down the central row of the player's arm, around the board in an anti-clockwise direction, and then back up the central row to the central space. Six cowries used as dice, the throws are as follows: one mouth up = 10; two mouths up = 2; three mouths up = 3; four mouths up = 4; five mouths up = 25; six mouths up = 12; zero mouths up = 6. Throws of 10 and 25 allow a player to enter a piece onto the board. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. Pieces on the same spot as another piece belonging to the player and pieces on marked squares are safe from being sent to start. The player who moves all of their pieces off the board first wins. 

Construct a Ludii game based on the following description
This game is played on a 5x5 board. Game starts with an initial setup position.On each turn, each player must move two friendly stones to adjacent (diagonal or orthogonal) empty cells, both in the same direction. Stones cannot move into the restricted points on the game board.
            
        The player that first moves 5 stones to the last row wins the game. 
(game "Tandems"
    (players 2)
    (equipment {
        (board (square 5))
        (piece "Pawn" Each
            (move Step
                (to
                    if:(and {
                        (is Empty (to))
                        (not (is In (to) (sites "RedDots")))
                        ("CanMoveAnotherStone" (from) (to))
                    })
                )
                (then (moveAgain))
            )
        )
        (regions "RedDots" (sites {"B2" "B4" "D2" "D4"}))
    })
    (rules
        (start {
            (place "Pawn1" (sites Bottom))
            (place "Pawn2" (sites Top))
        })
        (play
            (if ("SameTurn")
                (forEach Site (difference (sites Occupied by:Mover) (last To))
                    (move Step 
                        (from (site))
                        ("LastDirection" Cell)
                        (to 
                            if:(and 
                                (is Empty (to))
                                (not (is In (to) (sites "RedDots")))
                            )		
                        )
                    )
                )
                (forEach Piece)
            )
        )
        (end {
            (if (and (is Mover P1) (all Sites (sites Occupied by:P1) if:(is In (site) (sites Top)))) (result P1 Win))
            (if (and (is Mover P2) (all Sites (sites Occupied by:P2) if:(is In (site) (sites Bottom)))) (result P2 Win))
        })
    )
)

Construct a Ludii game based on the following description
Tap Urdy is a two-row mancala-style board game played in Turkmenistan during the early twentieth century. The game is played in holes dug into the ground, and the counters are typically sheep droppings.2x6 board. Four counters in each hole. Players sow counters in a clockwise directions from one of the holes in their opponent's row. When the final counter lands in an occupied hole, the contents of that hole are picked up and sowing continues, unless the next hole is empty, in which case the contents of the next hole after the empty hole are captured. When the final counter falls in an empty hole, the turn ends. Play continues until all of the holes are empty in one of the rows. The player who captured the most counters wins. 
(game "Tap Urdy"
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "5,W,N,E" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (hand Each)
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))
        (play 
            (move
                Select 
                (from 
                    (if 
                        ("SameTurn") 
                        ("LastHoleSowed") 
                        (sites Next) 
                    ) 
                    if:(< 0 (count at:(from)))
                )
                (then 
                    (sow 
                        apply:(if (and (!= (count at:("NextHoleFrom" (to) 1)) 0) (> (count at:(to)) 1))
                            (moveAgain)
                            (if (and (= (count at:("NextHoleFrom" (to) 1)) 0) (> (count at:(to)) 1))
                                (fromTo 
                                    (from ("NextHoleFrom" (to) 2)) 
                                    (to (handSite (mover))) 
                                    count:(count at:("NextHoleFrom" (to) 2))
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" ("OneRowIsEmpty")))
    )	
)

Construct a Ludii game based on the following description
Atomic chess is a chess variant. Standard rules of chess apply, but all captures result in an \In standard chess, the captured piece is removed from the board and the capturing piece takes its place. In atomic chess, a capture causes an \ 
(game "Atomic Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        (piece "Pawn" Each 
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
                )
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                "EnPassant"
                }
                (then
                    (and
                        (if (is In (last To) (sites Mover "Promotion")) 
                            (moveAgain)
                        )
                        (set Counter)
                    )
                )
            )
        )
        
        (piece "Rook" Each 
            (move Slide 
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
                ("RememberPieceHasMoved")
            )
        )
        (piece "King" Each 
            (move Step 
                (to 
                    if:(is Empty (to))
                ) 
                ("RememberPieceHasMoved")
            )
        )
        (piece "Bishop" Each 
            (move Slide 
                Diagonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    ("CaptureToPieceAndResetCounter")
                ) 
            )
        )
        (piece "Knight" Each 
            (move Leap 
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    ("CaptureToPieceAndResetCounter")
                ) 
            )
        )
        (piece "Queen" Each 
            (move Slide 
                (to 
                    if:("IsEnemyAt" (to)) 
                    ("CaptureToPieceAndResetCounter")
                ) 
            ) 
        )
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        ("Castling")
                    )
                    ifAfterwards:(and
                        (not ("IsInCheck" "King" Mover))
                        ("IsNotOffBoard" (where "King" Mover))
                    )
                )
            )
        )
        
        (end {
            (if (or
                    (and 
                        ("IsInCheck" "King" Next)
                        ("NextCanNotMove")
                    ) 
                    ("IsOffBoard" (where "King" Next))
                )
                (result Mover Win)
            ) 
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Katra" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" <Board:CCW2> loop:True P2)
            (track "TrackCW1" <Board:CW1> loop:True P1)
            (track "TrackCW2" <Board:CW2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1")) 
        (regions "Home" P2 (sites Track "TrackCCW2")) 
        (regions "Outer" P1 (sites Bottom))   
        (regions "Outer" P2 (sites Top))    
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        (play
            (or
                (if (!= (value Player Mover) 2)
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                (sites {(var "Replay")})
                                (sites Mover "Home") 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then
                            (and
                                (sow
                                    "TrackCCW"
                                    owner:(mover)
                                    apply:(if (< 1 (count at:(to)))
                                        (if (is In (to) (sites Mover "Outer"))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                            (if (< 1 (count at:("OppositePit" (to))))
                                                (and {
                                                    (fromTo
                                                        (from ("OppositePit" (to)))
                                                        (to (to))
                                                        count:(count at:("OppositePit" (to)))
                                                    )
                                                    (moveAgain)
                                                    (set Var "Replay" (to))
                                                })
                                                (if (< 1 (count at:("OppositeOuterPit" (to))))
                                                    (and {
                                                        (fromTo
                                                            (from ("OppositeOuterPit" (to)))
                                                            (to (to))
                                                            count:(count at:("OppositeOuterPit" (to)))
                                                        )
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                    })
                                                )
                                            )
                                        )
                                    )
                                )
                                (if (!= (value Player Mover) 1)
                                    (set Value Mover 1)
                                )
                            )
                        )
                    )
                )
                
                (if (!= (value Player Mover) 1)
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                (sites {(var "Replay")})
                                (sites Mover "Home") 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then
                            (and
                                (sow
                                    "TrackCW"
                                    owner:(mover)
                                    apply:(if (< 1 (count at:(to)))
                                        (if (is In (to) (sites Mover "Outer"))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                            (if (< 1 (count at:("OppositePit" (to))))
                                                (and {
                                                    (fromTo
                                                        (from ("OppositePit" (to)))
                                                        (to (to))
                                                        count:(count at:("OppositePit" (to)))
                                                    )
                                                    (moveAgain)
                                                    (set Var "Replay" (to))
                                                })
                                                (if (< 1 (count at:("OppositeOuterPit" (to))))
                                                    (and {
                                                        (fromTo
                                                            (from ("OppositeOuterPit" (to)))
                                                            (to (to))
                                                            count:(count at:("OppositeOuterPit" (to)))
                                                        )
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                    })
                                                )
                                            )
                                        )
                                    )
                                )
                                (if (!= (value Player Mover) 2)
                                    (set Value Mover 2)
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end "ForEachNonMoverNoMovesLoss")
    )
)
Katra is a four-row mancala-style game board played in Madagascar. This version was observed being played by the Sakalava people in the early twentieth century.4x6, 8, or 10 holes. Eight is most common. Two counters in each hole. Sowing begins from any hole on the player's side, in either direction, but the direction chosen on the first turn must be maintained throughout the game. If the final counter lands in an empty hole, the turn ends. If the final counter lands in the outer row in an occupied hole, these are picked up and sowing continues. If the final counter lands in an occupied hole in the inner row, and the opponent's inner row hole opposite contains more than one counter, these are captured and the sowing continues from the hole from which the capture was made using the captured counters and the final counter from the sowing that caused the capture. If the opponent has no counters in any of their inner row holes, the counters in their outer row holes can be captured, in the same manner.
            
        Evidence Map Each player has 6 holes on each row.

Construct a Ludii game based on the following description
Provincial is a European Tables game from medieval England. It was described in a fourteenth century manuscript with seveal similar games.2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Three six-sided dice. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions, one from their bottom right to the top right, the other from their bottom left to their top left. Pieces begin on the board, each player with eight pieces on the sixth and seven on the seventh point of their track. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the beginning of the player's track. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins.
         
(game "Provincial" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" ("BackgammonTracksWithBar")) 
        (dice num:3)
        (map {(pair 1 19) (pair 2 6)}) 
        (piece "Disc" Each) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 7 count:8)
            (place Stack "Disc1" 5 count:7)
            (place Stack "Disc2" 20 count:8) 
            (place Stack "Disc2" 18 count:7) 
        })
        
        (play 
            ("RollEachNewTurnMove"
                (forEach Die
                    if:("DieNotUsed")
                    (forEach Site
                        (sites Occupied by:Mover)
                        (if ("CanEscape" ("NextSiteFrom" (site))) 
                            ("RemoveAPiece")
                            (move 
                                (from (site))
                                (to ("NextSiteFrom" (site))
                                    if:("NoEnemyOrOnlyOne" (to))
                                    ("HittingCapture" ("Bar"))
                                )
                            )
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (result Mover Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Welschschach"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (piece "King_noCross"
            (move Step
                (to if:(and (not ("IsFriendAt" (to)))
                        (if (not (is In (to) (sites Next "Promotion")))
                            True
                            (not ("IsPieceAt" "Pawn" Next (to)))
                        )
                    )
                    ("CaptureEnemyToPiece")
                )
            )			
        )
        (piece "Queen"
            (move Step
                Diagonal
                (to if:(and (not ("IsFriendAt" (to)))
                        (if (not (is In (to) (sites Next "Promotion")))
                            True
                            (!= (what at:(to)) (id "Pawn" Next))
                        )
                    )
                    ("CaptureEnemyToPiece")
                )
            )	
        )
        (piece "Bishop_noCross"
            (move Hop Diagonal 
                (between if:True) 
                (to if:(and (not ("IsFriendAt" (to)))
                        (if (not (is In (to) (sites Next "Promotion")))
                            True
                            (!= (what at:(to)) (id "Pawn" Next))
                        )
                    )
                    ("CaptureEnemyToPiece")
                )
            )		
        )
        (piece "Knight"
            (move Leap 
                "KnightWalk" 
                (to 
                    if:(and (not ("IsFriendAt" (to)))
                        (if (not (is In (to) (sites Next "Promotion")))
                            True
                            (!= (what at:(to)) (id "Pawn" Next))
                        )
                    )
                    "CaptureEnemyToPiece"
                ) 
            )		
        )
        (piece "Rook"
            (move Slide 
                Orthogonal
                (to 
                    if:(and (not ("IsFriendAt" (to)))
                        (if (not (is In (to) (sites Next "Promotion")))
                            True
                            (!= (what at:(to)) (id "Pawn" Next))
                        )
                    )
                    "CaptureEnemyToPiece"
                ) 
            )		
        )
        (piece "Pawn"
            (if (= 0 (state at:(from)))
                (or 
                    "StepForwardToEmpty" 
                    "CaptureForwardDiagonal"
                    (then (if (is In (last To) (sites Mover "Promotion")) (set State at:(last To) 1)))
                )
                (move Slide Backward
                    (between (exact 2) if:(is Empty (between)))
                    (to if:(is Empty (to)))
                    (then
                        (if (is In (last To) (sites Start (piece (what at:(last To)))))
                            (promote (last To) (piece "Queen") Mover)
                        )
                    )
                )
            )
        ) 
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8") 
        })
        
        phases:{
        (phase "Opening" 
            (play
                (or {
                    (forEach Piece "Queen" 
                        (if (is In (from) (sites Start (piece (what at:(from)))))
                            (move Hop Diagonal 
                                (between (exact 1) if:True) 
                                (to if:(and (not ("IsFriendAt" (to)))
                                        (if (not (is In (to) (sites Next "Promotion")))
                                            True
                                            (!= (what at:(to)) (id "Pawn" Next))
                                        )
                                    )
                                    ("CaptureEnemyToPiece")
                                )
                            )	
                        )
                        Mover
                    )
                    (forEach Piece "Pawn" 
                        (if (is In (from) (intersection ("SpecialStartingPawns") (sites Start (piece (what at:(from))))))
                            ("DoubleStepForwardToEmpty")
                        )
                        Mover
                    )
                })
            )
            (nextPhase (= 8 (count Moves)) "Playing")
        )
        (phase "Playing"
            (play 
                (do
                    (forEach Piece)
                    ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
                )
            )
        )
        }
        
        (end ("Checkmate" "King_noCross"))
    )
)
Welschschach is a German Chess game played in the village of Ströbeck, and played by people who traveled to the village because of its reputation for Chess games.8x8. Each player begins with a complement of pieces, each with their own powers of movement as follows: King (x1): may move one space in any direction; Queen (x1): moves one space diagonally, may leap two spaces diagonally on its first move over any intervening pieces; Bishop (x2): moves diagonally two spaces, jumping over any intervening pieces; Knight (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Rook (x2): moves orthogonally any distance; Pawns (x8): move forward one space or diagonally forward one space to capture. Only the Rooks' and Queens' pawns may move forward two spaces for their first move. When a Pawn reaches the row on the opposite side of the board from which it began, it must move two spaces backward to the sixth row, then to the fourth, and then to the second, and then is promoted to Queen. It cannot jump over any pieces or taken a piece during these moves. A Pawn is immune from capture on the eight rank, but not on the others while making these promotion moves. Each player must move the Rooks' Pawns and Queens' Pawn in this way, as well as the jump of the Queen, in their first four moves. There is no castling. A piece is captured when an opponent's piece moves onto its space. The King is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's turn. When the king cannot move out of check, it is checkmated and the opponent wins. 

Construct a Ludii game based on the following description
Dum Blas is a game with leaping captures played in Malaysia during the early twentieth century.10x10 board, with red and white checkeres squares. Twenty pieces per player, which are arranged on the first four ranks closest to the player. Pieces move diagonally one space forward. Pieces may capture an opponent's piece by hopping over it diagonally to an empty adjacent square immediately on the other side of it. Pieces cannot capture in a backwards direction. The maximum number of pieces must be captured. If a player does not capture the maximum number of pieces, the other player may huff this piece, removing it from play. When a piece reaches the opposite edge of the board from where it started, it is promoted to king. Kings may move any distance diagonally, in a forward or backward direction. The player who captures all of their opponent's pieces wins. 
(game "Dum Blas" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 10)) 
    
    (rules 
        ("BlackCellsSetup" 4)
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves
                        ("HopInternationalDraughtsStyle" (from (last To))
                            (then 
                                ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To))) 
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                    )
                    (max Moves ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn))
                )
                (priority {
                    (max Moves
                        (or 
                            (forEach Piece "Counter"
                                ("HopInternationalDraughtsStyle" (from)
                                    (then 
                                        ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To))) 
                                            ("PromoteIfReach" (sites Next) "DoubleCounter")
                                        ) 
                                    ) 
                                ) 
                            )
                            (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture" before:(count Rows) after:(count Rows) at:EndOfTurn))
                        )
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal))
                    )
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Makvœr is a form of Draughts played in Denmark, known since the seventeenth century. It features orthogonal and diagonal movement, and the name suggests a relationship to Molkwerums Dans, or Frisian Draughts, in which pieces move similarly.8x8 board, twelve pieces per player, arranged on the black spaces. Pieces move diagonally one space, or may hop an opponent's piece to capture it. Pieces may also capture orthogonally, but must remain on the black spaces. When a piece reaches the opponent's edge of the board, the piece becomes a \ 
(game "Makvoer" 
    (players 2)
    (equipment { 
        (board (square 8)) 
        (piece "Counter" Each 
            (or {
                "StepDiagonalToEmpty" 
                "HopDiagonalCapture"
                (do
                    (move Hop 
                        Orthogonal 
                        (between 
                            before:1
                            after:2
                            if:("IsEnemyAt" (between))
                            (apply (remove (between)))
                        ) 
                        (to if:(is Empty (to))) 
                    )
                    ifAfterwards:(is In (last To) (sites Phase 0))
                )
                }
                (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
            )
        )
        (piece "DoubleCounter" Each
            (or
                (move Slide)
                ("HopCaptureDistance")
            )
        )
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    
    (rules 
        ("BlackCellsSetup" 3)
        
        (play (forEach Piece)) 
        
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
Cab e Quinal is a race game from medieval Spain that is related to other European Tables games. It is described in Alfonso X's Libro de los Juegos. In one version of the game, the players agree that one of the three dice will have the same value on every throw.2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. One player places all of their pieces on the sixth point of one of the quadrants of the board, and the other player places all of their pieces on the fifth point of the same quadrant. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Players move the pieces along the same track around the board, which ends on the quadrant on the other side of the board from the starting quadrant. When a piece is moved to a space occupied by a piece belonging to the opponent, the opponent's piece is sent back to the starting point. The first player to bear off all of their pieces from the board wins. All the pieces start in the first quadrant. The game involves 2 dice and the value of the third one is selected by the player.
(game "Cab e Quinal"
    (players 2)
    (equipment {
        ("TableBoard" "TableTracksSameDirectionWithHands")
        (dice d:6 num:<Dice:num>)
        (hand Each)
        (piece "Disc" Each <Dice:move>)
    })
    (rules 
        <Start:rules>
        
        (play
            ("RollEachNewTurnMove"
                (or 
                    (forEach Piece top:True) 
                    (forEach Piece container:(mover) top:True)
                    (then 
                        (if (or (= (value Player Mover) Undefined) (not (all DiceUsed)))
                            (moveAgain)
                            (if (and (all DiceUsed) (= (value Player Mover) 1))
                                (set Value Mover Undefined)
                            )
                        )
                    )
                )
            )
        )
        
        (end {
            ("EscapeWin")
            (if (and (no Moves P1) (no Moves P2)) (result Mover Draw))
        })
    )
)

Construct a Ludii game based on the following description
Diagonal Hex is a variant of Hex in which the connection between each stone is diagonal and not orthogonal.Players take turns placing their pieces on one space on the board, with the goal of connecting the opposite sides of the board corresponding to the color of their pieces with a line of pieces. The game is played on a 3x3 board. The board is a diamond tiling by hexagon. The game uses the swap rule. The first player to connect their two sides wins. The connection between two stones is using all the diagonal directions.
(game "Diagonal Hex" 
    (players 2) 
    (equipment { 
        (board 
            (<Board:type> <BoardSize>)
        ) 
        (piece "Marker" Each)
        (regions P1 { <Board:regionsP1> })
        (regions P2 { <Board:regionsP2> })
    }) 
    (rules 
        <Meta:rule>
        (play (move Add (to (sites Empty))))
        (end (if (is Connected <Connection:type> Mover) (result Mover <Result>))) 
    )
)

Construct a Ludii game based on the following description
Wali is a word used for several games played in West Africa. This particular version was played by the Songhai people of Mali and Niger. 5x6 board, made in the sand. One player plays with twelve sticks and the other with twelve pebbles. The player with the sticks plays first. Players alternate turns placing one of their pieces on an empty space on the board. Players are not permitted to place more than two of their own pieces in an orthogonal row on the board. When all of the pieces are placed, players alternate turns moving one of their pieces orthogonally one space. When a player successfully places three of their pieces in an orthogonal row of three, the player captures one of the opponent's pieces. The player who captures all of their opponent's pieces wins. 
(game "Wali"
    (players 2)
    (equipment {
        (board (rectangle 5 6))
        (hand Each)
        (piece "Stick" P1
            ("StepToEmpty" Orthogonal (then ("ReplayIfLine3" Orthogonal)))
        )
        (piece "Ball" Each
            ("StepToEmpty" Orthogonal (then ("ReplayIfLine3" Orthogonal)))
        )
    })
    (rules
        (start {
            (place "Stick1" (handSite P1) count:12) 
            (place "Ball2" (handSite P2) count:12) 
        })
        
        phases:{
        (phase "Placement"
            (play 
                (do
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty))
                    ) 
                    ifAfterwards:(not (is Line 3 Orthogonal))
                )
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        (phase "Movement"
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPiece")
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )	
)

Construct a Ludii game based on the following description
Mangala is the name of many mancala-style board games throughout Southwest Asia and North Africa. This particular one is a two-row game that was played in the Suez Peninsula during the early twentieth century.2x6 board. Eight counters in each hole; two holes in one player's row and one in the opponent's row are left empty. Sowing in an anti-clockwise direction. No captures in first two turns. If the last counter falls into a hole that is occupied, these are picked up and the sowing continues. When the last counter of a sowing falls into an empty hole, the counters in the opposite hole are captured. The player continues play by moving the counter that made the capture into the next hole, and continuing play. If the last counter falls into an empty hole and the opposite hole is also empty, the turn ends. The player who captures the most counters wins. 
(game "Mangala (Suez)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top)) 
        (hand Each)
    }) 
    (rules 
        (start (set Count 8 to:(sites Track)))
        
        phases:{
        
        (phase "Opening"
            (play
                (move Remove
                    (sites Mover)
                    count:(count at:(to))
                )
            )
            (nextPhase (<= 3 (count Turns)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (move Select
                    (from
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover)
                        )
                        if:(is Occupied (from))
                    )
                    (then
                        (sow
                            apply:(if (< 1 (count at:(to)))
                                (and
                                    (moveAgain)
                                    (set Var "Replay" (to))
                                )
                                (if (<= 7 (count Turns))
                                    (if (is Occupied ("OppositePitTwoRows" (to)))
                                        (and {
                                            (fromTo
                                                (from ("OppositePitTwoRows" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePitTwoRows" (to)))
                                            )
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        })
                                    )
                                )
                            )
                        )
                    )
                )
            )
            
            (end ("MancalaByScoreWhen" (no Moves Next)))
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Mono"
    (players 2)
    (equipment {
        (board (hex <Size>))
        (piece "Disc" Each)
    })
    (rules
        (meta (swap))
        (play
            (move Add
                (to (sites Empty))
                (then ("CountAndMarkOddGroupsMover"))
            )
        )
        (end
            (if 
                (is Full) {
                (if
                    (=
                        (count Groups if:(= (id P1) (who at:(to))))
                        (count Groups if:(= (id P2) (who at:(to))))
                    )
                    (byScore)
                )
                (if 
                    True 
                    (byScore {
                        (score P1 (- (count Groups if:(= (id P1) (who at:(to))))))
                        (score P2 (- (count Groups if:(= (id P2) (who at:(to))))))
                    })
                )
            })
        )
    )
)
Mono is a simple unification game of pure placement invented by Michael Amundsen in May 2022. It is a variant of Elea, by the same inventor.Players take turns placing a stone of their own color on any empty cell of a hexagonal grid of hexagons (a hexhex board). 
            The game is over when the board is full, and the player with the lower score wins. 
            If both players have the same number of groups, your score is your number of odd-sized groups, otherwise it is simply your number of groups.
            
            The running score only shows the number of odd groups (with a minus sign in front of it, for technical reasons).
            
        Groups of odd size is marked with a red outline. A size 3 board is currently selected

Construct a Ludii game based on the following description
Choko is a capturing game that was played in the Gambia River valley during the early twentieth century. Five rows of five holes. Each player has twelve sticks; one player's sticks are longer than the other player's. Players alternate turns placing one of their sticks in an empty hole on the board. A player may, on their turn, move a stick to an empty adjacent hole in an orthogonal direction instead of placing a stick. Players do not have to place all of their sticks before moving, but if they wish to place a stick after they have already moved, the opponent must also place a stick on their following turn. A player captures an opponent's stick by hopping over it in an orthogonal direction to an empty hole immediately on the opposite side of the opponent's stick. The player who captures all of the opponent's pieces wins. 
(game "Choko" 
    (players 2)
    (equipment {
        (board (square 5) use:Vertex)
        (piece "Stick" Each
            (or "StepOrthogonalToEmpty" "HopOrthogonalCapture")
        )
        (hand Each)
        (regions "AllSites" (sites Board))
    })
    (rules
        (start (place "Stick" "Hand" count:12))
        (play
            (if (is Pending)
                (move (from (handSite Mover)) (to (sites Empty)))
                (or
                    (if ("HandOccupied" Mover)
                        (move (from (handSite Mover)) (to (sites Empty)) (then (set Pending)))
                    )
                    (forEach Piece)
                )
            )
        )
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Gåsetavl is a name for several hunt games in Denmark. This version is played on a larger board with one fox and eighteen geese.28 squares arranged in a cross-shaped board. Diagonals are drawn in each 2x2 square. Pieces are played on the lines of the board. One player plays as a single fox, placed on the center of the third line from the top of one arm of the cross. The other player plays as eighteen geese, placed on the points on the opposite arm of the cross and the first horizontal line of the horizontal arms of the cross. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. The geese may not move backward. The fox may capture a goose by hopping over it to an empty spot immediately on the opposite side of the goose along the lines of the board. The geese win by blocking the fox from being able to move. The fox wins by capturing all the geese.
         
(game "Gasetavl (Gedved)"
    (players 2)
    (equipment {
        ("CrossBoard" 3 9 use:Vertex diagonals:Alternating)
        (piece "Fox" P1 (or ("HopCapture") ("StepToEmpty")))
        (piece "Geese" P2 N ("StepToEmpty" (directions {Rightward Forwards Leftward})))
    })
    (rules 
        (start {
            (place "Fox1" coord:"E7")
            (place "Geese2" 
                (sites {"D1" "E1" "F1" "D2" "E2" "F2" "D3" "E3" "F3"
                "A4" "B4" "C4" "D4" "E4" "F4" "G4" "H4" "I4"})
            )
        })
        (play (forEach Piece))
        (end ("NoMovesP1NoPiecesP2")) 
    )
)

Construct a Ludii game based on the following description
Magic square is a mathematical puzzle played on an n x n square grid.Numbers from 1 to n are placed in the squares. Each row and column must add up to the same number and numbers cannot repeat in the row, column, or square. 
(game "Magic Square" 
    (players 1) 
    
    (equipment { 
        (board (square <Challenge:size>) (values Cell (range 1 <Challenge:maxVal>))) 
        (regions {Columns Rows Diagonals}) 
    }) 
    
    (rules 
        (play 
            (satisfy {
                (all Different (sites Board))
                (is Sum <Challenge:sum>)
            })
        )
        
        (end (if (is Solved) (result P1 Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Morabaraba"
    (players 2)
    
    (equipment { 
        (board
            (remove
                (add 
                    (concentric Square rings:3 joinCorners:True)
                    vertices:{{0 0}}
                    edges:{{11 24} {16 24} {7 24} {12 24}}
                )
                edges:{{3 6} {8 5} {17 20} {15 18}}
            )
            use:Vertex
        ) 
        (hand Each)
        (piece "Marker" Each 
            (if (> (count Pieces Mover) 3)
                ("StepToEmpty")
                (move
                    (from)
                    (to (sites Empty)) 
                )
                (then ("ReplayIfLine3")) 
            )
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3")
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3")) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3")
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("HavingLessPiecesLoss" Next 2))
    )
)
Morabaraba is a game of alignment played in Southern Africa. It is typically played by men and boys, though sometimes played with girls in the home.Three concentric squares, with lines connecting the midpoints of the squares with the center of the square and four lines connecting the corners of the outer two squares. Twelve pieces per player. In the first phase, players take turns placing pieces on an empty spot on the board. If they place three pieces so they are in a line, forming a \ 

Construct a Ludii game based on the following description
Pente Grammai, or \2x5 board. Five pieces per player. Pieces played on the end of the lines. Two dice. Central line marked. Pieces move from the \ No capture.
(game "Pente Grammai" 
    (players 2)
    (equipment {
        (board 
            (add
                (scale 1.5
                    (merge {
                        (shift 2 0 (rectangle 2 1))
                        (shift 1.5 0 (rectangle 2 1))
                        (shift 1 0 (rectangle 2 1))
                        (shift 0.5 0 (rectangle 2 1))
                        (rectangle 2 1)
                    }) 
                )
                vertices:{{1.5 0.75}}
            )
            {
            (track "Track1" "8,6,4,2,0,1,3,5,7,9" loop:True P1)
            (track "Track2" "1,3,5,7,9,8,6,4,2,0" loop:True P2)
            }
            use:Vertex
        )
        (piece "Marker" Each <Play:movePiece>)
        (hand Each)
        (dice d:6 num:1)
        (map "Goal" {(pair P1 5) (pair P2 4)})
    })
    (rules 
        (start {
            (place Stack "Marker1" (handSite P1) count:5)
            (place Stack "Marker2" (handSite P2) count:5)
        })
        (play 
            ("RollMove"
                (priority {
                    <Play:enterBoard>
                    (forEach Piece)
                    }
                    (then 
                        (if (= (mapEntry "Goal" Mover) (last To))
                            (fromTo (from (last To)) (to "SacredLine"))
                        )
                    )
                )
            )
        )
        (end 
            (if 
                (all Sites (sites Occupied by:Mover) if:(= (site) "SacredLine"))
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Qelat is a two-row mancala-style board game played by the Beni Amir and Mensa people of Eritrea. This game is typically played by older men, and is played for large stakes. Instead of capturing counters, players create \2x6 board. Four counters in each hole. Sowing occurs in a clockwise direction when starting from the three holes on the left of the board, and in an anti-clockwise direction when starting from the three holes on the right. Sowing ends when the final counter is dropped, regardless of whether the hole is occupied or not. When the final counter is dropped into a hole containing three counters, thus making it contain four, the hole is captured. This can only be done if the hole is one of the end holes on either side of either row, or the penultimate holes on either side of the opponent's row. Sowing is not allowed from a captured hole. When no player is able to move, the player with the most counters in their captured holes wins. 
(game "Qelat (Beni Amir-Mensa)"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (regions "Left" P1 (intersection (expand (sites Left) steps:2) (sites Bottom))) 
        (regions "Left" P2 (intersection (expand (sites Right) steps:2) (sites Top))) 
        (regions "Right" P1 (intersection (expand (sites Right) steps:2) (sites Bottom))) 
        (regions "Right" P2 (intersection (expand (sites Left) steps:2) (sites Top)))  
    }) 
    (rules 
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (or 
                (move Select
                    (from (sites Mover "Left") if:(and (= 0 (state at:(from))) (is Occupied (from))))
                    (then
                        (sow
                            "TrackCW"
                            apply:(if (and {
                                    (is In (to) (union (expand (sites Right)) (expand (sites Left))))
                                    (= 4 (count at:(to)))
                                    (= 0 (state at:(to)))
                                })
                                (set State at:(to) (mover))
                            )
                        )
                    )
                )
                (move Select
                    (from (sites Mover "Right") if:(and (= 0 (state at:(from))) (is Occupied (from))))
                    (then
                        (sow
                            "TrackCCW"
                            apply:(if (and {
                                    (is In (to) (union (expand (sites Right)) (expand (sites Left))))
                                    (= 4 (count at:(to)))
                                    (= 0 (state at:(to)))
                                })
                                (set State at:(to) (mover))
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (and (no Moves P1) (no Moves P2))))
    )
)

Construct a Ludii game based on the following description
Terhüchü is a leaping capture game played on an expanded Alquerque board. It was played by the Naga people in the early twentieth century, but is likely to be much older.Played on a board similar to Perali Kotuma, with the addition of triangular extensions on the four corners. Play begins with nine pieces for each player. Pieces move along the lines to the next open space. Opponent's pieces can be captured by hopping over them. Within the triangular extensions, pieces may move two places at a time, in a straight line. The player to capture all of the opponent's pieces wins. 
(game "Terhuchu" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithEightTriangles")
        (piece "Marker" Each 
            (or {
                ("HopCapture")
                ("StepToEmpty")
                (if (not (is In (from) "SitesNotInTriangle"))
                    ("WithinTrianglePieceCanMoveDistanceTwo")
                )
            })
        )
    }) 
    (rules 
        (start { 
            (place "Marker1" (sites {"H3" "F6" "G6" "H6" "I6" "J6" "L6" "H8" "I8" "J8"}))
            (place "Marker2" (sites {"H10" "I10" "J10" "F12" "H12" "I12" "J12" "L12" "J15"}))
        })
        
        (play (forEach Piece))
        
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
La Libre Perseguida is a hunt game played in Spain. One player plays as the hare, and the other as three galgos (Spanish greyhounds).A square, with diagonals and lines connecting the midpoints. Two triangles on opposite sides of the triangle. One player plays as three galgos, which are placed on the three points of one of the triangles. The other player plays as one hare, which begins on the point between two of the galgos. The hare may move in any direction along the lines on the board, but must move to the central point of the board on its first move. The galgos may move forward orthogonally or diagonally; they may never move horizontally and may only move backwards if the galgo which starts on the apex of the triangle has moved and the piece to move backwards has not yet moved. If the galgos block the hare from being able to move, they win, if the hare moves past the galgos it wins. 
(game "La Liebre Perseguida"
    (players 2) 
    (equipment { 
        (board 
            (rotate 90 ("ThreeMensMorrisGraphWithLeftAndRightTriangles"))
            use:Vertex
        )
        (piece "Hare" P1 ("StepToEmpty" Orthogonal))
        (piece "Rabbit" P2 N 
            (or
                (if (= (state at:(from)) 1)
                    (move Step Backwards (to if:(and (is In (to) (sites Bottom)) (is Empty (to)))) (then "PieceHasMoved"))
                )
                ("StepToEmpty" Forwards (then "PieceHasMoved"))
            )
        )
        (regions "Home" P2 (sites {"B1" "C2" "A2"}))
        (regions "Home" P1 (sites {"B2"}))
    }) 
    
    (rules 
        (start {
            (place "Hare1" (sites P1))
            (place "Rabbit2" (sites P2) state:1)
        })
        (play (forEach Piece))
        (end {
            (if (no Moves P1) (result P2 Win))
            (if (is In (where "Hare" P1) (sites P2)) (result P1 Win))
        }) 
    )
)

Construct a Ludii game based on the following description
Oriath is a puzzle based on the graph-theoretic concept of regular graphs. A regular graph is a graph where each vertex has the same number of neighbours; i.e. every vertex has the same degree. Moreover, if a regular graph has k degree, then it's called a k-regular graph. Oriath has two versions: general and parameter-k. In both versions, the graph is initially uncoloured. Player alternate taking turns, in which the current player colours an uncoloured edge. In the general version, the last player to make a move such that the coloured graph becomes a regular graph wins. For the parameter-k version, the game is won by the last player to make a move such that the coloured graph is a k-regular graph. 
         The game is played on the Graph1. General version
(game "Oriath" 
    (players 1)
    (equipment { 
        (board <Board:type> use:Edge) 
    }) 
    
    (rules  	 
        (play    
            (move Add 
                (to Edge (sites Empty Edge))	   
            )    
        )
        (end {   
            <Version:result>
        })
    )
)

Construct a Ludii game based on the following description
Murus Gallicus is a breakthrough game of material balance, tactics, area control, and timing.On a player's turn he or she must perform one of the following actions:
            1) Move a tower (2-stack) by distributing its two stones into the two nearest cells in any one direction. Each destination cell must be empty or contain a single friendly stone. 
        2) Sacrifice a single tower stone to remove an adjacent enemy wall (1-stack). Sacrifice is not forced.
Goal: A player wins immediately by reaching any cell of his or her opponent's home row, or by stalemating his or her opponent. Stack limit is 2. Standard 7 x 8, one row Immediately after reaching goal.
(game "Murus Gallicus" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (<Board:shape>)) 
        (piece "Counter_isometric" Each) 
        
        (regions "RomanGoal1" P1 (sites Top))
        (regions "GaulGoal2" P2 (sites Bottom))
        
    }) 
    (rules
        (start {
            (place Stack "Counter_isometric1" (sites {<Board:rangeP1>}) count:2)
            (place Stack "Counter_isometric2" (sites {<Board:rangeP2>}) count:2)
        }) 
        
        (play
            (if ("SameTurn")
                (or
                    (move
                        (from (last From))
                        (to (last To)) 
                        stack:True    
                        (then 
                            (and 
                                (remove (last To)) 
                                (remove (last To)) 
                            )
                        )    
                    )    
                    (move Pass)
                )
                (forEach Piece "Counter_isometric"
                    (or  
                        {
                        "MoveTower"
                        "SacrificeCaptureWall"
                        
                        "SacrificeCaptureCatapult"
                        "ThrowStonetoEmpty"
                        "ThrowStonetoEnemy"
                        }
                    )
                    top:True
                )
            )   
        )
        
        (end {
            ("BlockWin")
            <End:event>
        })
    )
)

Construct a Ludii game based on the following description
This game plays on a 8x8 grid, with each player having 7 pawns and 1 King, which start lined up on opposite sides of the board. Each player can remove the other's pieces by moving onto them, as in chess.<a href=\ 1976 version
(game "Shogun" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        (piece "Pawn" Each 
            ("Move" 4)
        )
        
        (piece "King" Each 
            ("Move" 2)
        )
    }) 
    (rules 
        (start { 
            (place "Pawn1" coord:"A1" value:(value Random (range 1 4)))
            (place "Pawn1" coord:"B1" value:(value Random (range 1 4)))
            (place "Pawn1" coord:"C1" value:(value Random (range 1 4)))
            (place "Pawn1" coord:"D1" value:(value Random (range 1 4)))
            (place "Pawn1" coord:"F1" value:(value Random (range 1 4)))
            (place "Pawn1" coord:"G1" value:(value Random (range 1 4)))
            (place "Pawn1" coord:"H1" value:(value Random (range 1 4)))
            (place "King1" coord:"E1" value:(value Random (range 1 2))) 
            (place "Pawn2" coord:"A8" value:(value Random (range 1 4)))
            (place "Pawn2" coord:"B8" value:(value Random (range 1 4)))
            (place "Pawn2" coord:"C8" value:(value Random (range 1 4)))
            (place "Pawn2" coord:"E8" value:(value Random (range 1 4)))
            (place "Pawn2" coord:"F8" value:(value Random (range 1 4)))
            (place "Pawn2" coord:"G8" value:(value Random (range 1 4)))
            (place "Pawn2" coord:"H8" value:(value Random (range 1 4)))
            (place "King2" coord:"D8" value:(value Random (range 1 2))) 
        })
        
        (play 
            <CheckmateRule:Move>
        )
        
        (end
            (if 
                (or
                    <CheckmateRule:Ending>
                    (<= (count Pieces Next) 2)
                )
                (result Mover Win)
            ) 
        )
    )
)

Construct a Ludii game based on the following description
Troll is a two-player game played on an empty 8x8 square board:EDGES - Each player owns two opposite edges, say, the first player has top and bottom edges, while the second player has left and right edges.
            
            DROP - Each player drops one of his stones on an empty cell.
            - If at least one opponent stone is between that stone and another friendly stone (orthogonal or diagonal), then all opponent stones that were between those stones flip their colour.
            - Stones cannot be dropped on the opponent's edges (including corners).
            
            GOAL - Wins the first player who manages to do a path connecting his two opposite edges.
            - Two tiles diagonally aside are not continuous in a path.
        - The corners belong to both edges. 
(game "Troll"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Ball" Each)
        (regions P1 {(sites Top) (sites Bottom) })
        (regions P2 {(sites Left) (sites Right) })
    })
    (rules
        (play 
            (move Add
                (to
                    (if (is Mover P1)
                        (difference 
                            (sites Empty)
                            (union (sites Left) (sites Right))
                        )
                        (difference 
                            (sites Empty)
                            (union (sites Top) (sites Bottom))
                        )
                    )
                )
                (then
                    (custodial 
                        (from (last To)) 
                        (between 
                            if:("IsEnemyAt" (between)) 
                            (apply
                                (and
                                    (remove (between))
                                    (add (piece (id "Ball" Mover)) (to (between)))
                                )
                            )
                        )
                        (to if:("IsFriendAt" (to))) 
                    )
                )
            )
        )
        
        (end {
            (if ("ConnectedEdges" P1) (result P1 Win))
            (if ("ConnectedEdges" P2) (result P2 Win))
        }) 
    )
)

Construct a Ludii game based on the following description
Felli is a game with leaping captures from Morocco. It was documented by Moroccan immigrants to France who described the game as they played it in their childhood in Morocco.Each player's six pieces are set up on their respective triangle. 
                A piece is moved one space in any direction per turn onto an empty point along the lines of the board.
                A piece captures an enemy piece by hopping over it as in draughts.
        Only one piece may be used to move or capture per turn. Players alternate their turns throughout the game. Capturing is optional but pieces can promote.
(game "Felli" 
    (players 2) 
    (equipment { 
        (board 
            (graph
                vertices:{ {0 0} {2 0} {4 0} {1 1} {2 1} {3 1} {2 2} {1 3} {2 3} {3 3} {0 4} {2 4} {4 4}}
                edges:{ {0 1} {0 3} {1 2} {1 4} {2 5} {3 4} {3 6} {4 5} {4 6} {5 6} {6 7} {6 8} {6 9} {7 8} {7 10} {8 9} {8 11} {9 12}
                {10 11} {11 12}}
            )
            use:Vertex
        )
        
        (piece "Counter" Each)
        (piece "DoubleCounter" Each)
        (regions P1 (intersection (sites Corners) (sites Bottom)))
        (regions P2 (intersection (sites Corners) (sites Top)))
    }) 
    
    (rules 
        (start {
            (place "Counter1" (expand (sites Bottom)))
            (place "Counter2" (expand (sites Top)))
        })
        
        (play <Play>)
        
        (end ("NoMoves" Loss))
    )
)

Describe the mechanics of the following Ludii game
(game "Pachih" 
    (players 4) 
    (equipment {
        ("PachisiBoard"
            {
            (track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True)
            (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True)
            (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True)
            (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)
            }
        )
        ("StickDice" 7)
        (piece "Pawn" Each
            (if ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) ("ThrowValue")))
                (move Remove (from) level:(level))
                (move 
                    (from (from) level:(level))
                    (to
                        ("SiteToMoveOnTrack" from:(from) ("ThrowValue"))
                        if:True
                        (apply
                            (if (and (not (is In (to) (sites "SafeSites"))) ("IsEnemyAt" (to)))
                                (forEach Level (to) FromTop
                                    (fromTo
                                        (from (to) level:(level))
                                        (to (centrePoint))
                                    )
                                )
                            )
                        )
                    )
                )
            )		
        )
        (regions "SafeSites" (sites {60 62 2 37 87 89 16 48}))
        (map "Throw" {(pair 0 7) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 30) (pair 7 14)})
    }) 
    (rules 
        (start {
            (place Stack "Pawn1" 9 count:4)
            (place Stack "Pawn2" 26 count:4)
            (place Stack "Pawn3" 52 count:4)
            (place Stack "Pawn4" 27 count:4)
        })
        
        (play 
            ("RollMove"
                (forEach Piece)
                (then 
                    (if (and (< (value Player Mover) 2) ("IsSpecialThrow"))
                        (and (moveAgain) (set Value Mover (+ 1 (value Player Mover))))
                        (set Value Mover Undefined)
                    )
                )
            )
        )
        
        (end ("EscapeWin"))
    )
)
Pachih is a race game played by the Acehnese people of Sumatra played on a cross-shaped board. They recognize the origin of the game as being from India, and it is indeed similar to many games found in South Asia.Four 3x8 rectangles, arranged in a cross shape around a large central square. The third space, counting from the outer corner, in the two outer rows of each arm of the board are marked with an \ 

Describe the mechanics of the following Ludii game
(game "Padaivettu" 
    (players 2) 
    (equipment { 
        (board 
            (remove
                ("AlquerqueGraphWithFourTriangles")
                edges:{{20 16} {16 12} {12 8} {8 4} {0 6} {6 12} {12 18} {18 24}}
            )
            use:Vertex
        ) 
        (piece "Marker" Each
            (or
                ("StepToEmpty")
                ("HopCapture")
            )
        )
    }) 
    (rules 
        (start {
            (place "Marker1"
                (difference
                    (union 
                        (expand (sites Right)) 
                        (expand (sites Bottom) steps:4)
                    )
                    (expand (sites Centre) steps:2 W)
                )
            )
            (place "Marker2"
                (difference
                    (union 
                        (expand (sites Left)) 
                        (expand (sites Top) steps:4)
                    )
                    (expand (sites Centre) steps:2 E)
                )
            )
        })
        
        (play (forEach Piece))
        
        (end ("CaptureAll" Next))
    )
)
Padaivettu is a game of captures played by the Tamil people of southern India.5x5 intersecting lines. Triangles on each side, with the apex intersecting with the midpoint of the side of the square. A line is drawn from the apex to the base of each triangle, and a line bisecting it and the two opposite sides. A diamond is drawn within the square, the corners of which intersect with the apices of the triangles and the midpoint of each side is the center point of each quadrant of the square. 24 pieces per player, which begin on the points of the board closest to the player and in the triangle to their right and the right half of the central row. The central point is vacant. Players alternate turns moving a piece to an empty adjacent spot on the board. A piece may capture an opponent's piece by hopping over it to an empty adjacent spot immediately on the opposite side of the opponent's pieces along the lines on the board. The player who captures all of the opponent's pieces wins. 

Construct a Ludii game based on the following description
Jesön Mor' (the nine horses) is a game played in Mongolia. Two sides attempt to reach the central square on the board. 9x9 board. Nine horse-shaped pieces per player. Pieces begin in the spaces along opposite sides of the board. Pieces move orthogonally one space and then diagonally another, jumping over any intervening pieces. A player may capture one of the opponent's pieces by moving onto a space occupied by the opponent's piece. The goal is to move to the central space on the board. To win a knight as to reach the central square.
(game "Jeson Mor" 
    (players 2) 
    (equipment { 
        (board (square 9)) 
        (piece "Knight" Each 
            (move Leap 
                "KnightWalk"
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndCheckVictory"
                ) 
            )
        )
    }) 
    (rules 
        (start {
            (place "Knight1" (sites Bottom))
            (place "Knight2" (sites Top))
        })
        (play (forEach Piece))
        (end {
            (if (no Pieces Next) (result Mover Win))
            (if (is In <End:rule> (sites Centre)) (result Mover Win))
        })
    )
)

Construct a Ludii game based on the following description
Chaturanga is believed to be the earliest ancestor of Chess, Shogi, and many other similar games throughout the world. It is first documented in India, and the pieces (infantry, horses, elephants, and chariots) reflect the four divisions of the Indian army, who protect the counselor and king. Various Indian texts discuss the rules and problems, and it is also a popular theme in Indian art and literature.Played on an 8x8 board. 8 Bhata (or Padati; move like Chess pawns but without being able to move two on the first turn); 2 Ashva (horses; move like Chess knights); 2 Gaja (elephants; two spaces in any orthogonal direction, jumping over the first square); 2 Ratha (chariots; moves like a rook in chess); 1 Mantri (counselor; moves one square diagonally in any direction); 1 Raja (king; moves one square in any direction). These are set up along one edge of the board: Ratha-Ashva-Gaja-Mantri-Raja-Gaja-Ashva-Ratha, with the eight Bhata lined up in the row in front of these, as in chess. Players take turns moving. When one piece lands on the space occupied by another piece, it is captured. Play continues until one player's king cannot move without being captured. The elephants can jump only orthogonally.
(game "Chaturanga" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8))
        
        ("ChessPawn" "Pawn" ~ (then ("ReplayInMovingOn" (sites Mover "Promotion"))))
        ("ChessRook" "Rook")
        ("ChessKing" "King_noCross")
        (piece "Elephant" Each <Elephant>) 
        ("ChessKnight" "Knight")
        (piece "Ferz_noCross" Each ("StepToNotFriend" Diagonal))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8") 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece "Ferz_noCross") Mover)
                (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            ("MisereBlockWin")
            ("HavingLessPiecesLoss" Next 1)
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Lines of Action" 
    (players 2) 
    
    (equipment { 
        (board (square 8)) 
        (piece "Disc" Each 
            (or {
                ("MoveTo" (directions {N S}) "DistInColumn")
                ("MoveTo" (directions {W E}) "DistInRow")
                ("MoveTo" (directions {NE SW}) "DistInNESW")
                ("MoveTo" (directions {NW SE}) "DistInNWSE")
            })
        )
    }) 
    
    (rules 
        (start { 
            (place "Disc1" (difference (union (sites Top) (sites Bottom)) (sites Corners)))
            (place "Disc2" (difference (union (sites Right) (sites Left)) (sites Corners)))
        })
        
        (play (forEach Piece))
        
        (end { 
            (if (and (= 1 (count Groups if:(= (who at:(to)) P1))) (= 1 (count Groups if:(= (who at:(to)) P2)))) (result Mover <End:result>)) 
            (if (= 1 (count Groups if:(= (who at:(to)) P1))) (result P1 Win)) 
            (if (= 1 (count Groups if:(= (who at:(to)) P2))) (result P2 Win)) 
        }) 
    )
)
Lines of Action was invented by Claude Soucie in 1969. It is played on an 8x8 board with twelve pieces per player.A player wins by connecting all of one's pieces into a contiguous body so that they are connected orthogonally or diagonally. Players alternate moves. Pieces move orthogonally or diagonally. A piece moves exactly as many spaces as there are pieces (belonging to both the player and their opponent) on the line in which it is moving. A piece may jump over the player's own pieces, but not over one belonging to the opponent. A piece can capture piece belonging to the opponent by landing on it. If the two players make a group in the same turn, the game ends in a draw.

Construct a Ludii game based on the following description
Gala is a blockade game played among the Buginese and Makassarese people of Sulawesi in Indonesia.   5x5 board. Markings in the central square, each corner square, and the central square of each side. Black plays with thirteen pieces, white plays with ten. Black places the first piece on the central square, then players alternate turns placing a piece on their own half of the board. When all of the pieces are placed, players alternate turns moving pieces on space orthogonally. A piece is captured when it is surrounded on two opposite sides by opponent's pieces. Black wins if it can block white from being able to move. White wins if it is impossible for black to block them. 
(game "Gala"
    (players 2)
    (equipment {
        (board (square 5))
        (hand Each)
        (regions P1 (expand (sites Bottom) steps:2))
        (regions P2 (expand (sites Top) steps:2))
        (regions "MarkedCells" 
            (union {
                (sites Centre) 
                (sites Corners)
                (intersection (sites Outer) (sites Row (row of:(centrePoint))))
                (intersection (sites Outer) (sites Column (column of:(centrePoint))))
            })
        )
        (piece "Marker" Each ("StepOrthogonalToEmpty"))
    })
    (rules 
        (start {
            (place "Marker1" (handSite P1) count:10)
            (place "Marker2" (handSite P2) count:12)
            (place "Marker2" (centrePoint))
        })
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (intersection (sites Empty) (sites Mover))) 
                ) 
            ) 
            (nextPhase (and ("HandEmpty" P1) ("HandEmpty" P2)) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (forEach Piece
                    (then ("CustodialCapture"))
                )
            )
            
            (end {
                (if (no Moves P1) (result P2 Win))
                (if (< (count Pieces P2) 2) (result P1 Win))
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Safe Passage is a Chess puzzle created by Matthew Stephenson, inspired by the Safe Passage puzzle created by Karen Robinson.This Chess puzzle uses the same rules as Chess. To win this puzzle you have to swap the positions of the kings. However, if at any point it is possible to capture a piece, you lose. 
(game "Safe Passage" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        ("Castling")
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            (if (is Threatened) (result All Loss)) 
            (if (and ("IsPieceAt" "King" P2 4) ("IsPieceAt" "King" P1 60)) (result All Win))
        })
    )
)

Construct a Ludii game based on the following description
Shatranj at-Tamma is a game described in several manuscripts from the Medieval Islamic world. It is played similarly to Shatranj, with a 10x10 board and an extra piece, the Dabbaba. 10x10 board. The pieces move as follows, with the number per player: 1 x Shah (king): one space orthogonally or diagonally; 1 x Fers (counselor): one square diagonally; 2 x Rukh (rook): any number of spaces orthogonally; 2x Dabbaba: one space orthogonally or diagonally; 2 x Pil (elephant): two squares diagonally, jumping over the first. Cannot capture another Pil; 2 x Asb (horse): one square orthogonally, and then one square diagonally, jumping over any intervening pieces; 10 x Sarbaz (soldier): one space forward orthogonally or one space forward diagonally to capture. No en passant. Sarbaz begins in the third rank, and is promoted to Fers when reaching the tenth rank, only if the Fers has been captured. Otherwise, the other player captures it. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins. 
(game "Shatranj at-Tamma" 
    ("TwoPlayersNorthSouth") 
    (equipment {
        ("ChessPawn" "Pawn" ~ 
            (then
                (if (is In (last To) (sites Mover "Promotion")) 
                    (if ("IsOffBoard" (where "Queen" Mover))
                        (promote (last To) (piece "Queen") Mover)
                        (remove (last To))
                    )
                )
            )
        )
        ("ChessKing" "King_noCross")
        (piece "Queen" Each ("StepToNotFriend" Diagonal))
        ("ChessKnight" "Knight")
        ("ChessKing" "Wazir")
        ("ChessRook" "Rook")
        (piece "Elephant" Each
            (move Hop 
                Diagonal 
                (between if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        (and ("IsEnemyAt" (to)) (not ("IsPieceAt" "Elephant" Next (to))))
                    ) 
                    (apply (remove (to))) 
                )
            )		
        )
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
        (board (square 10))
    })
    (rules
        (start {
            (place "Pawn1" (sites Row 2))
            (place "Pawn2" (sites Row 7))
            (place "Rook1" (sites {"A1" "J1"}))
            (place "Rook2" (sites {"A10" "J10"}))
            (place "Knight1" (sites {"B1" "I1"}))
            (place "Knight2" (sites {"B10" "I10"}))
            (place "Elephant1" (sites {"C1" "H1"}))
            (place "Elephant2" (sites {"C10" "H10"}))
            (place "Wazir1" (sites {"D1" "G1"}))
            (place "Wazir2" (sites {"D10" "G10"}))
            (place "Queen1" coord:"E1")
            (place "Queen2" coord:"F10")
            (place "King_noCross1" coord:"F1")
            (place "King_noCross2" coord:"E10")
        })
        
        (play 
            (do
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        (end { 
            ("Checkmate" "King_noCross") 
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
<a href=\<a href=\ 
(game "Kriegsspiel" 
    (players 2) 
    (equipment { 
        (board (rectangle 33 49)) 
        (hand Each size:6)
        (piece "Mountain" Neutral) 
        (piece "Town" Neutral) 
        (piece "Forest" Neutral) 
        (piece "Triangle" Neutral) 
        (piece "Square" Neutral)
        (regions "HomeP1" P1 (expand (sites Left) steps:15))
        (regions "HomeP2" P2 (expand (sites Right) steps:15))
        
        (piece "CannonOutline" Each
            (or {
                ("ArtillerySlide" 6)
                ("ArtilleryShootStrong" (union (expand origin:(ahead (from)) Orthogonal) (expand origin:(ahead (from) steps:2) Orthogonal)))
                ("ArtilleryShootBridge" (union (expand origin:(ahead (from)) Orthogonal) (expand origin:(ahead (from) steps:2) Orthogonal)))
                "ArtilleryPanning"
            })
            maxState:100
            maxValue:10000
        )
        
        (piece "RegimentalOutline" Each
            (or {
                ("ArtillerySlide" 8)
                ("ArtilleryShootWeak" (expand origin:(ahead (from)) Orthogonal))
                ("ArtilleryEntrenched" (expand origin:(ahead (from)) Orthogonal))
                ("ArtilleryShootBridge" (expand origin:(ahead (from)) Orthogonal))
                "ArtilleryPanning"
            })
        )
        
        (piece "TinSoldier" Each
            (or {
                "InfantryMoves"
            })
        )
        
        (piece "Bishop" Each
            (or {
                "InfantryMoves"
                (if (= (state at:(from)) 1)
                    (move Promote (from) (piece {"RiderOutline"}) Mover)
                )
            })
            maxState:100
        )
        
        (piece "RiderOutline" Each 
            (or {
                "CavalryMoves"
                (if (= (state at:(from)) 1)
                    (move Promote (from) (piece {"Bishop"}) Mover)
                )
            })
        )
        
        (piece "WagonOutline" Each 
            (or {
                ("ArtillerySlide" 8)
                "BuildBridge"
                "DeconstructBridge"
                "BuildBridgeGround"
                "DeconstructBridgeGround"
                "ArtilleryPanning"
            })
        )
        
        (regions "WaterRegion" (sites {343 344 345 346 347 348 349 350 301 302 303 254 205 156 107 58 9 10 59 255 256 399 448 497 
                498 547 596 645 694 695 744 793 842 841 840 839 838 837 836 835 834 833 882 883 884 933 934 885 886 935 887 891 940 
                989 1038 1037 1036 1035 1034 1033 1032 1031 1030 1029 1079 1128 1083 1132 1181 1230 1087 1136 1185 1088 1186 1234 1233 
                1232 1281 1282 1283 1332 1331 1330 1379 1380 1381 1430 1431 1479 1528 1529 1578 1577 1569 1570 1571 1572 1573 1574 1575 
                1576 1520 1471 1524 1475 1426 1377 1376 1375 1326 1277 1228 1229 1279 1328 1089 1090 1091 1140 1189 1190 1239 1240 1289 
                1338 1339 1388 1437 1486 1535 1584 1042 1043 1044 1045 1046 997 948 949 950 951 952 953 1002 1003 1004 955 1005 1006 
                1055 1007 1008 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1300 1251 1202 1153 1104 1352 1401 1450 
                1499 1500 1501 1353 1354 1355 1306 1257 1208 1159 1110 1061 1012 963 1356 1357 1358 1359 1360 1361 1362 1411 1460 
                1509 1558 1557 1606 1607 1313 1314 1315 1266 1267 1268 1269 1270 1271 1272 1273 1217 1168 1119 1070 1118 1069 1020 
                971 922 921 872 823 774 775 776 777 778 779 780 781 782 783 734 733 732 731 730 729 725 681 682 683 676 627 578 579 
                580 581 582 583 584 585 586 587 537 488 529 480 431 382 333 284 235 186 137 88 39 87 38 185 40 41 42 43 44 45 46 47 
                96 145 92 141 190 239 288 337 386 435 484 533 236 237 286 335 384 383 334 285 240 241 290 339 388 387 430 528 527 
                526 525 476 427 574 573 572 571 570 619 668 667 666 665 664 663 614 613 612 661 710 759 808 857 906 611 610 561 609 
                608 607 512 426 377 376 327 278 277 276 275 274 273 272 271 270 269 268 267 266 265 264 263 262 261 260 259 258 257 
        463 414 365 316 604 653 555 506 457 408 359 310 215 166 117 116 228 179 130 81 32})) 
        (regions "MountainRegion" (sites {395 444 493 542 591 784 701 702 703 752 751 750 565 516 913 864 865 914 915 866 1299 1250 1296 1247 1394 1443 1492 1397 1446 1495 1502 1551 1503})) 
        (regions "TownRegion" (sites {449 450 451 452 400 351 352 562 513 563 564 515 1052 1101 1053 1054 1103 1264 1265 1216 1167 1166 1165 1164}))
        (regions "ForestRegion" (sites {499 500 501 790 791 1432 1433 1201 1200 1395 1396 415 416 220 221 184 183 825 826 1117 1116 1115})) 
        (regions "EntrenchmentRegion1" (sites {939 988 1086 1135 1184 1180 1131 1082 1425 1474 1523 1527 1478 1429})) 
        (regions "EntrenchmentRegion2" (sites {932 936 888 889 890 1081})) 
        (regions "EntrenchmentRegion3" (sites {677 628 530 481 432 534 485 436 191 142 93 187 138 89})) 
        (regions "EntrenchmentRegion4" (sites {726 727 728 680 684 535})) 
    }) 
    (rules 
        (meta (passEnd NoEnd))
        (start {
            (place "Mountain0" (sites "MountainRegion"))
            (place "Town0" (sites "TownRegion"))
            (place "Forest0" (sites "ForestRegion"))
            (place "Triangle0" (sites "EntrenchmentRegion1") rotation:2 value:0)
            (place "Triangle0" (sites "EntrenchmentRegion2") rotation:4 value:0)
            (place "Triangle0" (sites "EntrenchmentRegion3") rotation:6 value:0)
            (place "Triangle0" (sites "EntrenchmentRegion4") rotation:0 value:0)
            
            (place "TinSoldier1" 1617 count:76 state:3)
            (place "TinSoldier2" 1623 count:76 state:3)
            
            (place "RiderOutline1" 1618 count:20 state:3)
            (place "RiderOutline2" 1624 count:20 state:3)
            
            (place "CannonOutline1" 1619 count:10 state:3)
            (place "CannonOutline2" 1625 count:10 state:3)
            
            (place "RegimentalOutline1" 1620 count:5 state:3)
            (place "RegimentalOutline2" 1626 count:5 state:3)
            
            (place "WagonOutline1" 1621 count:10 state:3)
            (place "WagonOutline2" 1627 count:10 state:3)
            
            (place "Square0" 1622 count:20 state:3)
            (place "Square0" 1628 count:20 state:3)
            
            (set Hidden (sites Hand P1) to:P2)
            (set Hidden (sites Hand P2) to:P1)
            (set Hidden (sites P2 "Home") to:P1) 
            (set Hidden (sites P1 "Home") to:P2) 
        })
        phases:{
        (phase "Placement" 
            (play 
                (or {
                    ("PlacementMove" 0)
                    ("PlacementMove" 2)
                    ("PlacementMove" 4)
                    ("PlacementMove" 6)
                }) 
            )
            (nextPhase (= 20 (count in:(sites Hand P2))) "BridgePlacement")
        )
        (phase "BridgePlacement" 
            (play 
                (or
                    
                    (move 
                        (from (sites Occupied by:Neutral container:(mover) components:{"Square"})) 
                        (to 
                            (intersection {
                                (sites Mover "Home") 
                                (sites "WaterRegion") 
                                (sites Empty)
                            })
                        ) 
                        (then 
                            "EndBridgePlacementCheck"
                        )
                    )
                    
                    (move 
                        Select
                        (from (sites Occupied by:Neutral container:(mover) components:{"Square"})) 
                        (to 
                            (intersection 
                                (sites Mover "Home") 
                                (sites Occupied by:Mover container:"Board" components:{"WagonOutline"})
                            )
                            if:(< (value Piece at:(to)) 4)
                        ) 
                        (then 
                            (do
                                (and
                                    (set Value at:(last To) (+ (value Piece at:(last To)) 1))
                                    (set Count at:(last From) (- (count at:(last From)) 1))
                                )
                                next:"EndBridgePlacementCheck"
                            )
                        )
                    )
                )
            ) 
            (nextPhase ("HandEmpty" P2) "FireSpread")
        )
        (phase "FireSpread" 
            (play 
                (if (= (id Mover) 1)
                    (or ("FireSpreadMoves" "RegionFire1" "Fires1"))
                    (or ("FireSpreadMoves" "RegionFire2" "Fires2"))
                )
                
            )
            (nextPhase (was Pass) "Movement")
        )
        (phase "Movement" 
            (play 
                (or
                    (forEach Piece (then (and {(set State at:(last To) 0) (moveAgain)})))
                    (move Pass
                        (then
                            (and {
                                (forEach Site (sites Occupied by:Mover container:"Board")
                                    (if 
                                        (= (state at:(site)) 3)
                                        (set State at:(site) 1)
                                    )
                                )
                                "SetOccupiedEntrenchments"
                                (moveAgain)
                            })
                        )
                    )
                )
            )
            (nextPhase (was Pass) "Actions")
        )
        (phase "Actions" 
            (play 
                (or
                    (forEach Piece (then (and {(set State at:(last To) 0) (set State at:(last From) 0) (moveAgain)})))
                    (move Pass
                        (then 
                            (and {
                                (forEach Site (sites Occupied by:Mover container:"Board")
                                    (set State at:(site) 3)
                                )
                                "SetOccupiedEntrenchments"
                                ("CheckFireSites" Mover)
                            })
                        )
                    )
                )
            )
            (nextPhase (was Pass) "FireSpread")
        )
        }
        (end {
            (if (is In 1323 (sites Occupied by:P2 container:"Board")) (result P2 Win))
            (if (is In 293 (sites Occupied by:P1 container:"Board")) (result P1 Win))
        })
    )
)

Construct a Ludii game based on the following description
Ciri Amber is a multiplayer graph theory game, which is based on the principle of regular graphs. A graph is regular if all the vertices have the same degree. Ciri Amber can be played on any undirected and weighted graph. Initially, all the edges have the same colour. Each turn, a player removes a coloured edge and gets a score equals to the cost of that edge. The game is over when the graph becomes regular. The game is won by the player with the highest score.   The version of the game played with 2 players.
(game "Ciri Amber" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board <Board:type> use:Edge)
        (piece "Marker" Neutral) 
    }) 
    
    (rules
        (start
            <Board:start>
        )
        (play
            (move Remove
                (sites Occupied by:Neutral)
                (then 
                    (addScore Mover (cost Edge at:(last To)))
                )
            )
        )
        (end
            (if (is RegularGraph Neutral)	
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Sat Gol is a mancala-style board game in which the holes are arranged in a circle. It was played in central India during the early twentieth century.Seven holes, arranged in a circle. Four counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in a hole, the contents of the next hole are picked up and sowing continues with those counters. When the hole from which this new sowing would occur is empty, the counters in the next hole are captured and the turn ends. The next player begins to sow from the next available hole with counters after the last one played by the opponent. Play continues until no further captures can be made, and the player with the most counters wins. 
(game "Sat Gol"
    (players 2)
    (equipment {
        (board 
            (concentric {7}) 
            (track "Track" {0 1 3 5 6 4 2} loop:True)
            use:Vertex
        )
        (piece "Seed" Shared)
        (hand Each)
    })
    (rules
        (start (set Count 4 to:(sites Board)))
        (play 
            (move Select 
                (from 
                    (if 
                        ("SameTurn") 
                        (sites {("NextHoleFrom" ("LastHole") 1)})
                        (if (= 0 (count Moves))
                            (sites Board) 
                            (sites {(var)})
                        )
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow 
                        apply:(if (!= 0 (count at:("NextHoleFrom" (to) 1)))
                            (moveAgain)
                            (and
                                (if (!= 0 (count at:("NextHoleFrom" (to) 2)))
                                    (fromTo 
                                        (from ("NextHoleFrom" (to) 2))
                                        (to (handSite Mover))
                                        count:(count at:("NextHoleFrom" (to) 2))
                                    )
                                )
                                (if (!= 0 (count at:("NextHoleFrom" (to) 3)))
                                    (set Var ("NextHoleFrom" (to) 3))
                                    (if (!= 0 (count at:("NextHoleFrom" (to) 4)))
                                        (set Var ("NextHoleFrom" (to) 4))
                                        (if (!= 0 (count at:("NextHoleFrom" (to) 5)))
                                            (set Var ("NextHoleFrom" (to) 5))
                                            (if (!= 0 (count at:("NextHoleFrom" (to) 6)))
                                                (set Var ("NextHoleFrom" (to) 6))
                                                (set Pending)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        (end ("MancalaByScoreWhen" (is Pending)))
    )
)

Describe the mechanics of the following Ludii game
(game "Medieval Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn" ~ (then ("ReplayInMovingOn" (sites Mover "Promotion"))))
        ("ChessRook" "Rook")
        ("ChessKing" "King_noCross")
        (piece "Bishop_noCross" Each 
            (move Hop 
                Diagonal 
                (between if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        ("IsEnemyAt" (to))
                    ) 
                    (apply (remove (to))) 
                )
            )
        )
        ("ChessKnight" "Knight")
        (piece "Ferz_noCross" Each ("StepToNotFriend" Diagonal))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece "Ferz_noCross") Mover)
                (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (= (count Pieces Next) 1) (result Mover Win)) 
            ("BlockWin")
        })
    )
)
Chess first came to Europe in the Middle Ages, but at that time it was played differently than the modern game. Its rules more closely resemble the game of Shatranj, played in West Asia and probably the inspiration for the European game. New rules for the movement of the pieces started to become popular in the fifteenth century, which transformed the game into the rules played today.8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. 1 x Queen (counselor): One square diagonally. 2 x Rook (rook): Any number of spaces orthogonally. 2 x Fil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the eighth rank. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it.
         

Construct a Ludii game based on the following description
Veloop is an original game with a loop forming goal.                         There are two versions: this shorter Hexagonal grid game, and a longer game played on a square grid.            While the game in theory can cycle cooperatively, in practice it is decisive.                        The concept to form a loop by means of placements that also involve forced stone swapping. The swapping allows either surrounding an opponent's stone with a loop, or enveloping it into a loop by swapping, possibly forming the loop with the swap at the same time.                        The game, when played by competitive players, typically needs only a limited space. This is enforced with a minimal board. The board, in turn, affects play by providing greater security for pieces along the edges, and by forcing the board to reach densities that limit move choices.                        This area restriction is offset by a soft phase change that allows placement over existing opponent's pieces when no placement to an empty site would allow swapping. This phase greatly increases the opportunity for game-ending moves by opening up many move choices, but it also allows cycles. To ensure the game is finite, any given site may only be over-placed once.  (On a physical board this would be tracked by stacking, in this implementation, it is tracked by shading the site.)                        If there are no moves left for either player, the game is a draw. However, on all but the smallest board sizes offered here, games typically end with a winner, even before the piece replacement phase is reached.                     The larger size boards additionally minimize the edge effects and the transition to the replacement phase.  Playing on even larger boards, does not affect play very much.Goal: Form an orthogonally connected path of friendly stones that surrounds at least one non-friendly stone.
            
            Set-up:
            Two stones, one of each colour, are placed next to each other adjacent to the center of the board. 
            Then Black starts by taking one turn. After that players take DOUBLE turns in alternation.
            
            Play:  
            Each turn has two parts that both must be completed: A PLACEMENT and a SWAP.
            
            -- The PLACEMENT is made a knight's leap away from a selected stone of the same color.
            
            -- The SWAP is done by exchanging the contents of the 2 squares that lie between the selected stone and the placed stone. For a SWAP to be valid, the contents of these squares must be different, i.e.: two stones of different color, or an empty space and a stone. 
            
            If a turn cannot be completed with a placement to an empty position, the placement must be made by placing on top of an opponent's stone. 
            The placement and swap rules apply to the visible stones and must still be followed.
            
            Voluntary passing is not allowed. When neither player can move, the game ends in a draw.
            
            To help visualise the moves, the 'Show Last Move' option shows an arrow from the placement site to the supporting friendly piece and the swap pieces are to either side of this arrow. 
            
            Optional Variants: 
            -- Larger Board to reduce the strategic effect of the edge squares. / Smaller board to focus on stacked play as a significant part of the game.
        -- Normal single turn alternation for a more fine-grained experience, but with a first player advantage. 5x5 Square Turns alternate
(game "Veloop (Square)"
    (players 2)
    (equipment {
        (board (renumber (rotate 90 <Board:type>)) use:Cell)
        (piece "Disc" Each)
    })
    (rules
        (start {
            (place "Disc1" <Board:bStart>)
            (place "Disc2" <Board:wStart>)
        })
        (play
            (priority
                ("Placement" (sites Empty))
                ("Placement" (sites Occupied by:Next))
                (then 
                    ("MakeSwap")
                )
            )
        )
        (end 
            (if 
                (!= 0 (+ (score P1) (score P2)))
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Tawlbwrdd is a game in the tafl family mentioned in Peniarth Manuscript 158, describing a portion of the game as played in Wales during the sixteenth century.11x11 board. The king is placed in the centre of the board, with his defenders around him and the attackers at the edge of the board. The attackers move first. Pieces move orthogonally any number of spaces. A pieces is captured by surrounding it on two opposite sides, by an opponent's piece. It is possible to capture two or three pieces at once by so surrounding them. It is not possible to capture a row of pieces. The defending player wins the game by moving the king to any square on the edge of the board. The attacking player wins by capturing the king. The rules are describing with the Cyningstan ruleset.
(game "Tawlbwrdd" 
    (players 2) 
    (equipment { 
        (board (square 11)) 
        (regions "Fortresses" (sites Corners))
        
        (piece "Thrall" P1 
            (move Slide
                Orthogonal 
                (between if:"EmptyButNotCentreOrFortress")
                (then 
                    (or {
                        ("Custodial" "Thrall2")
                        (custodial 
                            (from (last To)) 
                            Orthogonal 
                            (between (max 1) if:("IsPieceAt" "Jarl" P2 (between)) "CaptureJarl")
                            (to if:"FriendOrCentreOrFortress")
                        )
                    })
                )
            )
        )
        (piece "Thrall" P2 
            (move Slide
                Orthogonal 
                (between if:"EmptyButNotCentreOrFortress")
                (then ("Custodial" "Thrall1")) 
            ) 
        ) 
        (piece "Jarl" P2 
            (move Slide
                Orthogonal 
                (then ("Custodial" "Thrall1")) 
            ) 
        ) 
        }
    ) 
    (rules 
        (start { 
            (place "Thrall1" {"D1" "E1" "F1" "G1" "H1" "F2" "A4" "A5" "A6" "A7" "A8" "B6" "K4" "K5" "K6" "K7" "K8" "J6" "F10" "D11" "E11" "F11" "G11" "H11" "F10"})
            (place "Thrall2" {"F3" "F4" "F5" "C6" "D6" "E6" "G6" "H6" "I6" "F7" "F8" "F9"})
            (place "Jarl2" (centrePoint))
        })
        
        (play (forEach Piece)) 
        
        (end {
            ("PieceTypeReachWin" "Jarl2" (sites Outer) P2)
            (if "JarlWasCaptured" (result P1 Win))
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Shatranj al-Husun"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board
            (merge {
                (square 10)
                (shift -1 -1 (square 1))
                (shift 10 -1 (square 1))
                (shift -1 10 (square 1))
                (shift 10 10 (square 1))
            })
        )
        ("ChessKing" "King")
        (piece "Queen" Each ("StepToNotFriend" Diagonal))
        ("ChessRook" "Rook")
        ("ChessKnight" "Knight")
        (piece "Elephant" Each
            (move Hop Diagonal 
                (between if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        (and ("IsEnemyAt" (to)) (not ("IsPieceAt" "Elephant" Next (to))))
                    ) 
                    (apply (remove (to)))
                ) 
            )		
        )
        ("ChessBishop" "Bishop")
        ("ChessPawn" "Pawn"
            (if (is In (from) (sites Start (piece (what at:(from)))))
                ("DoubleStepForwardToEmpty")
            )
            (then ("PromoteIfReach" (sites Mover "Promotion") "Queen"))
        )
        (regions "Promotion" P1 (sites Row 10))
        (regions "Promotion" P2 (sites Row 1))
        (regions "OppositeExtraSquares" P1 (sites Top))
        (regions "OppositeExtraSquares" P2 (sites Bottom))
    })
    (rules 
        (start {
            (place "Pawn1" (sites Row 2)) 
            (place "Pawn2" (sites Row 9))
            (place "Rook1" (sites {"B2" "K2"})) (place "Knight1" (sites {"C2" "J2"})) (place "Elephant1" (sites {"D2" "I2"})) (place "Bishop1" (sites {"E2" "H2"})) (place "King1" coord:"F2") (place "Queen1" coord:"G2")
            (place "Rook2" (sites {"B11" "K11"})) (place "Knight2" (sites {"C11" "J11"})) (place "Elephant2" (sites {"D11" "I11"})) (place "Bishop2" (sites {"E11" "H11"})) (place "King2" coord:"F11") (place "Queen2" coord:"G11")
        })
        (play 
            (do
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King" Mover))
            )
        )
        (end { 
            (if (is In (where "King" Mover) (sites Mover "OppositeExtraSquares"))
                (result Mover Draw)
            )
            ("Checkmate" "King")
            ("BlockWin")
        })
    )
)
Shatranj al-Husun is a game known from medieval manuscripts from the work of al-Amuli, a Persian Shatranj expert. It is played on an enlarged board with extra spaces where the Shah can move to force a draw.10x10 board, with an extra square placed diagonally behind each Rukh. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): One square diagonally. 2 x Rukh (rook): Any number of spaces orthogonally. 2x Dabbaba: any number of squares diagonally. 2 x Pil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Pil. 2 x Asb (horse): Moves as a Chess knight. 12 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the tenth rank. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins. If a player moves their king into one of the extra squares on the opposite side of the board, the game is a draw.
         

Construct a Ludii game based on the following description
Mwambulula is a four-row mancala-style board game played by the Bemba people of Zambia. It is notable because it begins immediately by holding counters in reserve to be entered into the board on a later turn.4x8 board. Two counters in each hole, the holes in the inner row are then vacated. These counters become the \ 
(game "Mwambulula" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "16,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        phases:{
        (phase "Opening"
            (play
                (move 
                    (from (sites Mover "Inner") if:(is Occupied (from)))
                    (to Cell (handSite Mover))
                    count:2
                )
            )
            (nextPhase Mover "NoSeedsInInner" "Sowing")
        )
        
        (phase "Sowing"
            (play
                (or
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                "LastHoleSowed" 
                                (sites Mover "Home") 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then
                            (sow
                                "Track"
                                owner:(mover)
                                apply:(if (< 1 (count at:(to)))
                                    (if (is In (to) (sites Mover "Inner"))
                                        (if (is Occupied ("OppositePitInner"))
                                            (and {
                                                (fromTo
                                                    (from ("OppositePitInner"))
                                                    (to (last From))
                                                    count:(count at:("OppositePitInner"))
                                                )
                                                (if (is Occupied ("OppositeOuterPitInner"))
                                                    (fromTo
                                                        (from ("OppositeOuterPitInner"))
                                                        (to (last From))
                                                        count:(count at:("OppositeOuterPitInner"))
                                                    )
                                                )
                                                (sow
                                                    (last From)
                                                    count:(+ (count at:("OppositePitInner")) (count at:("OppositeOuterPitInner")))
                                                    "Track"
                                                    owner:(mover)
                                                )
                                            })
                                            (moveAgain)
                                        )
                                        (if (is Occupied ("OppositeOuterPit" (to)))
                                            (and {
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                                (if (is Occupied ("OppositeOuterPitOuter"))
                                                    (fromTo
                                                        (from ("OppositeOuterPitOuter"))
                                                        (to (last From))
                                                        count:(count at:("OppositeOuterPitOuter"))
                                                    )
                                                )
                                                (sow
                                                    (last From)
                                                    count:(+ (count at:("OppositeOuterPit" (to))) (count at:("OppositeOuterPitOuter")))
                                                    "Track"
                                                    owner:(mover)
                                                )
                                            })
                                            (moveAgain)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (if (and ("NewTurn") (is Occupied Cell (handSite Mover)))
                        (move Select
                            (from Cell (handSite Mover))
                            (then
                                (forEach Site (sites Mover "Home")
                                    (fromTo
                                        (from Cell (handSite Mover))
                                        (to (site))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        (end "ForEachNonMoverNoMovesLoss")
    )
)

Construct a Ludii game based on the following description
Asi Keliya is a race game played in Sri Lanka in the early twentieth century. It is related to other race games played on a cross-shaped board in South Asia, but its board is smaller than others. Four 3x4 rectangles, arranged in a cross shape, with a large central square which has diagonals, and spaces in the four corners between each arm of the cross. Four players, played on two teams, with team members sitting on opposite sides of the board. Four pieces per player, with the colors red, black, yellow, and green. Six cowrie shells used as dice: five are white and one is yellow. The number of the mouths which are face-up determine the value of the throw, except for a throw of 3 when one of the cowries with the mouth down is the yellow one, in which case the throw is known as So-hatara, and counts as 4, but allows special moves because it is actually considered four individual throws of 1. When the player throws 1, 5, or So-hatara, the player receives an extra throw. A 1, 5, or So-hatara must be thrown to enter a piece on the board. The entirety of a throw must be used to move one piece, but separate throws in a turn can each be used individually to move a different piece. This does not apply when So-hatara is one of the throws; in this case, the total of the throw can be subdivided however the player sees fit. Pieces enter the board from the center, moving down the central track of their arm, then in an anti-clockwise direction around the board, and then back up the central row of their arm of the board to the central square. If a player lands on a space occupied by a piece of the opposing team, the opponent's piece is sent back to start. Pieces resting on the corner spaces between the arms of the cross cannot be sent to start in any circumstance. The first team who places all of their pieces in the central square wins.
         
(game "Asi Keliya"
    (players 4)
    (equipment {
        (board
            (merge {
                (add
                    (add
                        (merge {
                            (rectangle 3 4)
                            (shift 7 0 (rectangle 3 4))
                            (shift 3.5 3.5 (rotate 90 (rectangle 3 4)))
                            (shift 3.5 -3.5 (rotate 90 (rectangle 3 4)))
                        })
                        vertices:{{5.5 1.5}}
                    )
                    edges:{{4 76} {35 76} {19 76} {20 76}}
                )
                (shift 3 3 (square 1))
                (shift 7 3 (square 1))
                (shift 3 -1 (square 1))
                (shift 7 -1 (square 1))
            })
            {
            (track "Track1" "6,52,S,E,N3,E,N1,E,N,W3,N1,W1,N,W,S3,W1,S1,W,S,E3,S1,E1,S,E1,N3,End" P1 directed:True)
            (track "Track2" "7,11,W,S1,E3,S1,E1,S,E,N3,E1,N1,E,N,W3,N,W1,N,W2,S3,W1,S1,W,S1,E3,End" P2 directed:True)
            (track "Track3" "17,39,N,W1,S3,W1,S1,W,S,E3,S1,E1,S,E,N3,E,N1,E,N,W3,N,W1,N,W1,S3,End" P3 directed:True)
            (track "Track4" "21,26,E,N1,W3,N1,W1,N,W,S3,W1,S1,W,S,E3,S1,E1,S,E,N3,E1,N1,E,N1,W3,End" P4 directed:True)
            } 
        )
        (piece "Marker" Each ("Move" ("ThrowValue")))
        (hand Each)
        ("StickDice" 6)
        (map {(pair P1 6) (pair P2 7) (pair P3 17) (pair P4 21)})
        (regions "SafeSites" (sites {3 19 16 34}))
    })
    (rules 
        (start {
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
            (place "Marker" "Hand" count:4)
        })
        (play 
            (do (if (not ("PlayingSohatara")) (roll))
                next:(or 
                    (if ("SpecialThrows")
                        (move
                            (from (handSite Mover))
                            (to 
                                (mapEntry (mover))
                                if:(is Empty (mapEntry (mover)))
                            )
                        )
                    )
                    (if (or ("PlayingSohatara") ("Sohatara"))
                        (forEach Die 
                            if:("DieNotUsed")
                            (forEach Piece ("Move" (pips)))
                            (then 
                                (if (not (all DiceUsed))
                                    (and
                                        (set Pending)
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                        (forEach Piece)
                    )
                )
                (then 
                    (if ("SpecialThrows")
                        (moveAgain)
                    )
                )
            )
        )
        (end ("EscapeTeamWin"))
    )
)

Construct a Ludii game based on the following description
Chátur is a capturing game played on the island of Java. It is similar to other games which are derived from Indian Chaturanga, but it has more stringent promotion rules and more lenient castling moves.8x8 board. Pieces have special moves, as follows: Rátu (king), moves one square in any direction, but on the first move, if it has not been checked, may move two spaces in any direction or like a Járan; Pateh (minister), moves orthogonally or diagonally any number of spaces; Mántri (x2); move diagonally any distance; Járan (horse) x2, moves orthogonally one space then diagonal one space from there, jumping over any intervening pieces; Práhu (vessel) x2, moves orthogonally any distance; Bídak (pawn) x8: moves one square forward or one square forward diagonally to capture. May move two spaces forward orthogonally if it is that piece's first move. Upon reaching the opposite edge of the board, the Bídak must move backward diagonally three spaces before being promoted to Pateh, unless it is in one of the corner spaces, in which case it is promoted immediately. There is no limit to the number of Patehs on the board. To castle, the Práhu moves next to the Rátu, and then at any turn in the future the Rátu may move to the space on the other side of it, provided the Rátu has not yet been checked and that the space to which it moves remains available. The Rátu cannot be in check at the end of its turn. When this is unavoidable, it is checkmate and the opponent wins. If the Rátu is the only piece belonging to the player on the board, that player wins. 
(game "Chatur"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (piece "King_noCross"
            (or
                ("StepToNotFriend"
                    ~
                    (then
                        (if (not ("KingMovedOrCheckedBefore" (last To)))
                            ("RememberKingMovedOrChecked" (last To))
                        )
                    )
                )
                (if (not ("KingMovedOrCheckedBefore" (from)))
                    (or {
                        ("SlideCapture" ~ (between (exact 2)))
                        ("LeapCapture" "KnightWalk")
                        (if (is In (from) ("KingSites"))
                            (or
                                (if (and {
                                        (is Empty (ahead (from) steps:2 W))
                                        ("IsPieceAt" "Rook" Mover (ahead (from) W))
                                        (not ("RookMovedBefore" (ahead (from) W)))
                                    })
                                    (move
                                        (from)
                                        (to (ahead (from) steps:2 W))
                                    )
                                )
                                (if (and {
                                        (is Empty (ahead (from) steps:2 E))
                                        ("IsPieceAt" "Rook" Mover (ahead (from) E))
                                        (not ("RookMovedBefore" (ahead (from) E)))
                                    })
                                    (move
                                        (from)
                                        (to (ahead (from) steps:2 E))
                                    )
                                )
                            )
                        )
                        }
                        (then ("RememberKingMovedOrChecked" (last To)))
                    )
                )
            )
        )
        
        ("ChessRook" "Rook" ~
            (then
                (if (and 
                        (not ("RookMovedBefore" (last To)))
                        (not (is In (last To) ("SitesNextToKing")))
                    )
                    ("RememberRookMoved" (last To))
                )
            )
        )
        ("ChessBishop" "Bishop_noCross")
        ("ChessKnight" "Knight")
        (piece "Pawn"
            (if (is In (from) (sites Mover "Promotion"))
                ("SlideCapture" 
                    (directions {BR BL}) 
                    (between (exact 3))
                    ~
                    (then (promote (last To) (piece "Queen") Mover))
                )
                (or 
                    "StepForwardToEmpty" 
                    ("StepToEnemy" (directions {FR FL}))
                    (then ("PromoteIfReach" (intersection (sites Corners) (sites Mover "Promotion")) "Queen"))
                )		
            )
        ) 
        ("ChessQueen" "Queen")
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8") 
        })
        
        (play 
            (do
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
                (then
                    (if ("IsInCheck" "King_noCross" Next)
                        (if (not ("KingMovedOrCheckedBefore" (where "King_noCross" Next)))
                            ("RememberKingMovedOrChecked" (where "King_noCross" Next))
                        )
                    )
                )
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (= (count Pieces Next) 1) (result Mover Loss)) 
        })
    )
)

Construct a Ludii game based on the following description
Bao Ki Arabu is a mancala-style game board played on the island of Zanzibar, and is one of several kinds of Bao played there. It is similar to another game also called Bao Ki Arabu, which is said to be the version which originally came from Arabia.4x8 board. Three counters in each hole. Players pick up counters from any of their holes and sow them in either direction. If the last counter falls into an occupied hole, they pick the counters in this hole up and continue sowing. Sowing ends when the last counter falls into an empty hole. If the empty hole is in the inner row, the player captures any of the counters in the opponent's two holes opposite it. Play ends when all of one player's seeds have been captured. 
(game "Bao Ki Arabu (Zanzibar 1)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "24,E,S1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 3 to:(sites Board)))
        
        (play 
            (or
                ("Sow" (is Pending) "TrackCW" (and (moveAgain) (set Pending)))
                ("Sow" (not (is Pending)) "TrackCCW" (moveAgain))
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Describe the mechanics of the following Ludii game
(game "Awangdu"
    (players 2) 
    (equipment { 
        (board (rectangle 5 12) 
            { 
            (track "Track1" "0,E,N1,W,N1,E,N1,W,N1,E" P1 directed:True)
            (track "Track2" "59,W,S1,E,S1,W,S1,E,S1,W" P2 directed:True)
            }
            use:Vertex
        )
        ("StickDice" 6)
        (piece "Disc" Each
            (if (not ("IsFriendAt" ("NextSiteOnTrack" (mapEntry (var)))))
                (move 
                    (from) 
                    (to 
                        ("NextSiteOnTrack" (mapEntry (var)))
                        ("RemovePiece")
                    )
                )
            )
        ) 
        (map {(pair 0 <High:value>) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 1) (pair 6 <High:value>)})
    }) 
    
    (rules 
        (start { 	
            (place "Disc1" (sites Bottom))
            (place "Disc2" (sites Top))
        })	
        
        (play
            ("RollMove"
                (if 
                    (or 
                        ("CanMove") 
                        ("AllowToBegin")
                    )
                    (do (set Var (count Pips))
                        next:(forEach 
                            Piece 
                            (then (if (not ("CanMove")) (set Value Mover 1)))
                        )
                    )
                )
            )
        )
        
        (end ("HavingLessPiecesLoss" Next 2))
    )
)
Awangdu is a capturing game played in coastal West Africa in the mid-twentieth century. It is typically played with four players, two moving the pieces and two rolling the cowries.5x12 board, played on the intersections of lines. Twelve pieces per player, arranged along the side of twelve closest to the player. Pieces move along a boustrophedon track, one player starting from left to right in their starting row and the other from right to left in their starting row. Moves are determined by the throw of six cowries: one mouth up = 1, two mouth up = 2, three mouths up = 3, four mouths up = 4, five mouths up = 1 (0 and 6 mouths up are not specified, but are between 10 and 20 and the move can be split to make captures). A player must roll 1 or (0 or 6) to begin. When a piece moves to a spot occupied by an opponent's piece, it is captured. The goal of the game is to reduce the other player to one or two pieces. 0 or 6 mouths correspond to 10.

Construct a Ludii game based on the following description
Gamacha is a two-row mancala-style board game played by the Hadiya people of Ethiopia. This version of the game was considered to be the older version of several types played.2x12 board. The board begins with the following pattern of counters in the holes, beginning from the bottom left row and proceeding in an anti-clockwise direction: 0-0-4-0-4-0-4-0-4-0-4-0-4-0-4-0-4-0-4-0-4-0-4-0. One player starts with an additional four counters in their left hand hole. The player with fewer counters on their first move places the counters from their seventh hole into the opponent's opposite hole. Sowing occurs in an anti-clockwise direction, and may only happen when the final counter lands either in an empty hole in the player's own row or in any hole in the opponent's row. When the final counter lands in an empty hole in the player's own row, the contents of the opposite hole in the opponent's row are captured. When the final counter lands in an occupied hole in the opponent's row, these counters are picked up and sowing continues. The final counter of this sowing is allowed to fall into an occupied hole in the player's own row, and these are picked up and sowing continues. Sowing ends when the final counter lands in an empty hole. The game ends when one player has no counters on their side of the board, and the opponent wins. 
(game "Gamacha" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top)) 
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 4 
                to:(sites {"C1" "E1" "G1" "I1" "K1" "L2" "J2" "H2" "F2" "D2" "B2"}) 
            ) 
        )
        
        phases:{
        (phase "Opening"
            (play 
                (move 
                    (from 6)
                    (to 18)
                    count:4
                )
            )
            (nextPhase "Sowing")
        )
        (phase "Sowing"
            (play 
                (move Select
                    (from 
                        (if ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover) 
                        ) 
                        if:(if ("SameTurn") 
                            True
                            (and
                                (> (count at:(from)) 0)
                                (if (is In ("NextHoleFrom" (from) (count at:(from))) (sites Next))
                                    True
                                    (is Empty ("NextHoleFrom" (from) (count at:(from))))
                                )
                            )
                        )
                    )
                    (then 
                        (sow
                            apply:(if (and (is In (to) (sites Mover)) (<= (count at:(to)) 1))
                                (if (!= 0 (count at:("OppositePit" (to))))
                                    (fromTo
                                        (from ("OppositePit" (to)))
                                        (to (handSite Mover))
                                        count:(count at:("OppositePit" (to)))
                                    )
                                )
                                (if (> (count at:(to)) 1)
                                    (moveAgain)
                                )
                            )
                        )
                        
                    )
                )
            )
        )
        }
        
        (end (forEach Player
                if:("NoPiecesInPlayerSide" Player)
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Kotra is a race game related to other European Tables games that was played in Iceland. References to the game appear in early texts, suggesting that the game came to Iceland at an early date.2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player, which begin on the rightmost point, with respect to the player, on the opposite side of the board from which they sit. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A throw of doubles forces the player to play the throw twice. More than two pieces of the same player may not occupy a point on the starting side of the board. The player cannot move past the penultimate point on the opposite side of the board until five pieces have been moved from the starting point. A single opponent's piece may be removed from the board when a player's piece lands on it, and the opponent's piece must reenter the board. Pieces cannot move to a point occupied by two opponent's piece. A piece cannot reenter then board on a point occupied by another piece, whether belonging to the player or the opponent. When all of a player's pieces have reached the final quadrant of the board, the player may begin to remove them from the table. The player who bears off their pieces scores two points.  
(game "Kotra"
    (players 2)
    (equipment {
        ("TableBoard" ("TableTracksSameDirectionOppositeCorners" End))
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die
                replayDouble:True 
                if:("DieNotUsed")
                (if ("IsEndTrack" ("NextSiteFrom" (from) (pips)))
                    (if ("AllPiecesInFinalQuadrant")
                        (move Remove (from))
                    )
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:(and {
                                ("NoEnemyOrOnlyOne" (to))
                                (if (not (is In (to) (sites Mover "StartingSide")))
                                    True
                                    (> 2 (size Stack at:(to)))
                                )
                                (if (not (is In (to) (sites Mover "AfterPenultimate")))
                                    True
                                    (>= 10 (count Pieces in:(sites {(handSite Mover) (mapEntry "Entry" Mover)})))
                                )
                            })
                            ("HittingCapture" (handSite Next))
                        )
                    )
                )
                (then ("ReplayNotAllDiceUsed"))
            )		
        )
        (hand Each)
        (regions "FinalQuadrant" P1 (sites {18..23}))
        (regions "FinalQuadrant" P2 (sites {0..5}))
        (regions "StartingSide" P1 (sites {0..11}))
        (regions "StartingSide" P2 (sites {12..23}))
        (regions "AfterPenultimate" P1 (sites {23}))
        (regions "AfterPenultimate" P2 (sites {0}))
        (map "Entry" {(pair P1 11) (pair P2 12)})
    })
    (rules 
        (start {
            (place Stack "Disc1" 11 count:15)
            (place Stack "Disc2" 12 count:15)
        })
        (play 
            ("RollEachNewTurnMove"
                (or
                    ("EnterPieces")
                    (forEach Piece top:True)
                )
                (then
                    (if (no Pieces Mover) (set Score Mover 2))
                )
            )		
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Sneakthrough is a Chess variant that was invented for Ludii. It is BreakThrough, but the opponent's pieces are hidden.When a capture is made, the capturing piece is revealed to the opponent. If an orthogonal move is attempted to a spot with a hidden piece of the opponent, the move is not completed and the enemy piece is revealed. The goal is to reach the opposite side of the board like in Breakthrough. 
(game "Sneakthrough" (players 2)
    (equipment { 
        (board (square 8)) 
        (piece "Pawn" P1 N "Moves")
        (piece "Pawn" P2 S "Moves")
        (regions P2 (sites Top))
        (regions P1 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (expand (sites Bottom)))
            (place "Pawn2" (expand (sites Top)))
            (set Hidden (difference (sites Board) (sites Occupied by:P1)) to:P1)
            (set Hidden (difference (sites Board) (sites Occupied by:P2)) to:P2)
        })
        
        (play (forEach Piece))
        
        (end 
            (if 
                "RegionReached" 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
This version of Chaturanga is described in the Hariharacaturanga,  a late medieval Sanskrit manuscript attributed to Godavaramisra, a minister in the court of Prataparudra Deva, Gajapati emperor of Odisha.14x14 board. 32 pieces per player. Pieces move as follows: King (x1): Moves any distance orthogonally or diagonally; Crown Prince (x1): moves up to six spaces orthogonally or diagonally; Minister (x1): moves up to six spaces orthogonally or diagonally;  Military leader (x1): moves up to six spaces orthogonally or diagonally; Elephant (x2): moves forward orthogonally up to five spaces with the possibility of then moving one space backward diagonally; Cart (x2): moves any distance orthogonally; Horse (x4): moves one space orthogonally and then one space diagonally, leaping over any intervening pieces; Machinist (x4): moves forward orthogonally up to four spaces, forward diagonally one space, or backward orthogonally one space; Archer (x4): moves forward orthogonally up to three spaces, forward diagonally one space, or backward orthogonally one space; Spearmen (x4): moves forward orthogonally up to two spaces, forward diagonally one space, or backward orthogonally one space; Swordsmen (x4): forward one space orthogonally or diagonally or backward one space orthogonally. Players place their pieces on their half of the board in any arrangement they wish. When a piece moves to a space occupied by an opponent's piece, the opponent's piece is captured. If the King can be captured by the opponent on their next turn, it is in check and must not be in check at the end of the player's turn. If this is not possible, the player loses.  
(game "Chaturanga (14x14)"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 14)) 
        ("ChessQueen" "King")
        (piece "Prince" Each 
            ("SlideCapture" ~
                (between
                    (max 6)
                    if:(is Empty (between))
                )
            )		
        )
        (piece "Bishop" Each 
            ("SlideCapture" ~
                (between
                    (max 6)
                    if:(is Empty (between))
                )
            )	
        ) 
        (piece "Queen" Each 
            ("SlideCapture" ~
                (between
                    (max 6)
                    if:(is Empty (between))
                )
            )
        ) 
        (piece "Elephant" Each
            (or {
                ("SlideCapture"
                    Forward
                    (between
                        (max 5)
                        if:(is Empty (between))
                    )
                )
                ("StepToNotFriend" (directions {BR BL}))
                (forEach Direction 
                    Forward 
                    (between (range 1 5))
                    (to 
                        if:(is Empty (to)) 
                        (apply 
                            (and {
                                (move (from)
                                    (to 
                                        (sites To
                                            (step 
                                                (from (to))
                                                (if (is Mover P1) (directions {SW SE}) (directions {NW NE}))
                                                (to 
                                                    if:(not ("IsFriendAt" (to)))
                                                    (apply 
                                                        (if ("IsEnemyAt" (to))
                                                            (remove (to))
                                                        )
                                                    ) 
                                                ) 
                                            )
                                        )
                                    )
                                )
                            })
                        )
                    )
                )	
                
            })
        ) 
        ("ChessRook" "Rook") 
        ("ChessKnight" "Horse")
        (piece "Wrench" Each 
            (or 
                ("SlideCapture"
                    Forward
                    (between
                        (max 4)
                        if:(is Empty (between))
                    )
                )
                ("StepToNotFriend" (directions {FR FL Backward}))
            )		
        ) 
        (piece "Archer" Each
            (or 
                ("SlideCapture"
                    Forward
                    (between
                        (max 3)
                        if:(is Empty (between))
                    )
                )
                ("StepToNotFriend" (directions {FR FL Backward}))
            )			
        )
        (piece "Spear" Each
            (or 
                ("SlideCapture"
                    Forward
                    (between
                        (max 2)
                        if:(is Empty (between))
                    )
                )
                ("StepToNotFriend" (directions {FR FL Backward}))
            )		
        )
        (piece "Sword" Each ("StepToNotFriend" (directions {Forward FR FL Backward})))
        (hand Each size:11)
        (regions P1 (expand (sites Bottom) steps:6))
        (regions P2 (expand (sites Top) steps:6))
    })
    (rules 
        (start {
            (place "King1" (handSite P1)) (place "King2" (handSite P2)) 
            (place "Prince1" (handSite P1 1)) (place "Prince2" (handSite P2 1)) 
            (place "Bishop1" (handSite P1 2)) (place "Bishop2" (handSite P2 2)) 
            (place "Queen1" (handSite P1 3)) (place "Queen2" (handSite P2 3)) 
            (place "Elephant1" (handSite P1 4)) (place "Elephant2" (handSite P2 4)) 
            (place "Rook1" (handSite P1 5) count:2) (place "Rook2" (handSite P2 5) count:2) 
            (place "Horse1" (handSite P1 6) count:4) (place "Horse2" (handSite P2 6) count:4) 
            (place "Wrench1" (handSite P1 7) count:4) (place "Wrench2" (handSite P2 7) count:4) 
            (place "Archer1" (handSite P1 8) count:4) (place "Archer2" (handSite P2 8) count:4) 
            (place "Spear1" (handSite P1 9) count:4) (place "Spear1" (handSite P2 9) count:4) 
            (place "Sword1" (handSite P1 10) count:4) (place "Sword2" (handSite P2 10) count:4) 
        })
        phases:{
        (phase "Placement"
            (play 
                (move (from (sites Hand Mover) if:(is Occupied (from))) (to (intersection (sites Empty) (sites Mover))))
            )
            (nextPhase Mover (all Sites (sites Hand Mover) if:(is Empty (site))) "Play")
        )
        
        (phase "Play"
            (play 
                (do (forEach Piece)
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        }  
        (end ("Checkmate" "King"))
    )
)

Describe the mechanics of the following Ludii game
(game "One-Eyed Go" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each)
    })
    
    (rules 
        
            
        
        (play 
            (or
                (do
                    (move Add
                        (to (sites Empty))
                        
                    )
                    ifAfterwards:("HasFreedom" Orthogonal)
                    (then "CaptureSurroundedPiece")
                )
                (move Pass)
            )
        )
        
        (end
            (if (all Passed)
                (byScore {
                    (score P1 (+ (score P1) (size Territory P1))) 
                    (score P2 (+ (score P2) (size Territory P2)))
                })
            )
        )
    )
)
One-Eyed Go is a variant of Go.One-Eyed Go follows the same rules as go (e.g. Japanese Rules) with the exception that it is never allowed to place a stone such that your own group has no liberties, even when they would capture other stones. This renders the ko rule superfluous. The game is played on a 9x9 board

Construct a Ludii game based on the following description
Um el Tuweisat (\2x3 board. Three counters in each hole. Players sow from any one of their holes. Sowing can occur in the following directions: From the leftmost hole, clockwise; from the rightmost hole, anti-clockwise; from the center hole, the player may choose either direction. If the final counter falls into a hole in the opponent's row containing one counter, making it now contain two, these are taken. If the holes before them also contain two, in an unbroken sequence, they may all be captured. Single counters cannot be sown. When neither player can move, the single counters in each player's rows are taken by the player belonging to those rows. The player with the most counters wins. 
(game "Um el Tuweisat" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 3 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "2,W,N,E" loop:True)
            }
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightHole" {(pair P1 2) (pair P2 3)})
        (map "CenterHole" {(pair P1 1) (pair P2 4)})
        (map "LeftHole" {(pair P1 0) (pair P2 5)})
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 3 to:(sites Track)))
        
        (play 
            (or {
                ("Sow" (mapEntry "RightHole" (mover)) "TrackCCW")
                ("Sow" (mapEntry "LeftHole" (mover)) "TrackCW")
                ("Sow" (mapEntry "CenterHole" (mover)) "TrackCCW")
                ("Sow" (mapEntry "CenterHole" (mover)) "TrackCW")
            })
        )
        
        (end ("MancalaByScoreWhen" (and (no Moves P1) (no Moves P2))))
    )
)

Construct a Ludii game based on the following description
Tauru is an alignment game played by the Bariba people in what is now Benin. It is closely related to the game Dara, but instead of the player to capture the most pieces, the player to make the last possible capture wins. It is played by adult men, but at the time it was recorded was increasingly played by young men who were Wasangari, or in line to rule.5x6 board. Each player has twelve pieces. Players alternate placing their pieces until they are all placed on the board. The goal is to make a line of three, which allows the player to capture one of the opponent's pieces. Once the pieces are all on the board, they may be moved one space orthogonally. In the case that a move creates two lines of three, only one capture is made. The player who makes the last possible capture wins.
         
(game "Tauru"
    (players 2)
    (equipment {
        (board (rectangle 5 6))
        (hand Each)
        (piece "Marker" Each
            ("StepToEmpty" Orthogonal (then ("ReplayIfLine3")))
        )
    })
    (rules
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPiece")
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty))
                        (then ("ReplayIfLine3")) 
                    ) 
                )
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        (phase "Movement"
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPiece")
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("HavingLessPiecesLoss" Next 2))
    )	
)

Construct a Ludii game based on the following description
Schachzabel, a form of Chess, was played in early modern Germany with these rules.8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. The King may leap one, two, or three squares on its first move if it has not yet been checked and does not hop over an opponent's piece. The King cannot make this leap over an opponent's piece. A capture cannot be made with this special first move. 1 x Queen: One square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. 2 x Rook: Any number of spaces orthogonally. 2 x Bishop: Two squares diagonally, jumping over the first. Cannot capture another Bishop. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. The Rook's, King's and Queen's Pawns may move two spaces on its first move. The King's and Queen's Pawns are restricted in having this ability only if no piece on the board has been captured. Promoted to Queen when reaching the eighth rank, and may make the Queen's leap on its first move after being promoted, but cannot capture with this move. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins.
         
(game "Schachzabel"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        (piece "King" Each
            (or
                ("StepToNotFriend") 
                (if (= 1 (state at:(from)))
                    (move Hop 
                        (between 
                            (range 1 3)
                            if:(not ("IsEnemyAt" (between)))
                        ) 
                        (to if:(is Empty (to)))
                    )
                )
                ("RememberPieceHasMoved")
            )
        )
        ("ChessRook" "Rook")
        (piece "Bishop" Each
            (move Hop 
                Diagonal 
                (between if:True) 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    (apply 
                        (if ("IsEnemyAt" (to))
                            (remove (to))
                        )
                    ) 
                )
            )		
        )
        ("ChessKnight" "Knight")
        (piece "Queen" Each
            (or
                ("StepToNotFriend" Diagonal "RememberPieceHasMoved")	
                (if (= 1 (state at:(from)))
                    (move Hop 
                        Diagonal
                        (between if:True)
                        (to if:(is Empty (to)))
                    )
                )
                ("RememberPieceHasMoved")
            )
        )
        ("ChessPawn" "Pawn"
            (if (and {
                    (is In (from) (sites Start (piece (what at:(from)))))
                    (= 1 (state at:(from)))
                    (= 32 (count Sites in:(sites Occupied by:All)))
                })
                ("DoubleStepForwardToEmpty")
            )
            (then
                (if (is In (last To) (sites Mover "Promotion")) 
                    (and
                        (promote (last To) (piece (id "Queen" Mover)))
                        (set State at:(last To) 1)
                    )
                )
            )
        )
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites {"A2" "D2" "E2" "H2"}) state:1) (place "Pawn2" (sites {"A7" "D7" "E7" "H7"}) state:1)
            (place "Pawn1" (sites {"B2" "C2" "F2" "G2"})) (place "Pawn2" (sites {"B7" "C7" "F7" "G7"}))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (do (forEach Piece) 
                ifAfterwards:(not ("IsInCheck" "King" Mover))
                (then
                    (if (and (= 1 (state at:(where "King" Next))) ("IsInCheck" "King" Next))
                        ("PieceHasMoved" (where "King" Next))
                    )
                )
            )
        )
        
        (end ("Checkmate" "King"))
    )
)

Construct a Ludii game based on the following description
Pleasant Draughts was a game played in France and England in the seventeenth century, particularly in rural communities. It lacked the forced capture of regular English Draughts.Played on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them if they are adjacent. Capturing is not mandatory. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. The goal is to capture all of the opponent's pieces.
         
(game "Pleasant Draughts" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 8))
    (rules 
        ("BlackCellsSetup" 3)
        
        (play 
            (if "SameTurn"
                (or
                    (if "IsUnpromoted"
                        ("HopCapture" (from (last To)) (directions {FR FL})
                            (then 
                                ("PromoteIfReach" (sites Next) "DoubleCounter"
                                    ("ReplayIfCanMove" ("HopCapture" (from (last To)) (directions {FR FL})))
                                ) 
                            ) 
                        )
                        ("HopDiagonalSequenceCaptureAgain")
                    )
                    (move Pass)
                )
                (or 
                    (forEach Piece "Counter" 
                        (or
                            ("HopCapture" (from) (directions {FR FL})
                                (then 
                                    ("PromoteIfReach" (sites Next) "DoubleCounter"
                                        ("ReplayIfCanMove" ("HopCapture" (from (last To)) (directions {FR FL}))) 
                                    ) 
                                ) 
                            ) 
                            ("StepToEmpty" (directions {FR FL})) 
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                    )
                    (forEach Piece "DoubleCounter" 
                        (or
                            ("StepDiagonalToEmpty")
                            ("HopDiagonalSequenceCapture") 
                        )
                    )
                )
            )
        ) 
        
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
A variant of Tic-Tac-Toe using stacks.Your goal in Gobblet Junior is to place three of your pieces in a horizontal, vertical or diagonal row. Your pieces can stack on top of each other, and they start the game nested, off the board. On a turn, you either play one exposed piece from your three off-the-board piles or move one piece on the board to any other spot on the board where it fits. A larger piece can cover any smaller piece.
            
        Your memory is tested as you try to remember which color one of your larger pieces is covering before you move it. As soon as a player has three like-colored pieces in a row, he wins. 
(game "Gobblet Gobblers"
    (players 2) 
    (equipment { 
        (board (square 3))
        (piece "Disc1" Each)
        (piece "Disc2" Each)
        (piece "Disc3" Each)
        (hand Each size:3)
    }) 
    (rules 
        (start {
            (place Stack "Disc11" (handSite P1) count:3)
            (place Stack "Disc12" (handSite P2) count:3)
            (place Stack "Disc21" (handSite P1 1) count:3)
            (place Stack "Disc22" (handSite P2 1) count:3)
            (place Stack "Disc31" (handSite P1 2) count:3)
            (place Stack "Disc32" (handSite P2 2) count:3)
        })
        (play
            (or
                ("MoveToEmptyOrOccupiedByLargerPiece" (sites Hand Mover) if:(is Occupied (from)))
                ("MoveToEmptyOrOccupiedByLargerPiece" (sites Occupied by:Mover top:True))
            )
        )
        
        (end 
            (forEach Player
                if:(is Line 3 Player top:True)
                (result Player Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Shi Liu Kan Tsiang Kün is a hunt game from nineteenth century China. Sixteen pieces play against one general. The game was played by children and day laborers on boards drawn on the street.Board with 5x5 lines, diagonals drawn in the four quadrants of the board, and a triangle at the top, connecting the apex with the three central points at the top edge, and a line perpendicularly bisecting the height of the triangle. One player plays as the general, placed in the central position. The other player plays with sixteen pieces, arranged on the perimeter points of the square. Pieces move one spot along the lines on the board. The general may capture pieces when it moves into a space that is surrounded on two opposite sides, along the lines on the board, thus capturing the pieces on either side of it. Conversely, the general can be captured by surrounding it on two opposite sides with pieces. Only the general may enter the triangle. The goal of the general is to capture all of the opponent's pieces, the goal of the person playing with sixteen pieces is to capture the general. If the general becomes trapped in the triangle, the opponent wins. 
(game "Shi Liu Kan Tsiang Kun" 
    (players 2) 
    (equipment { 
        (board
            (merge
                (scale 2 (square 5 diagonals:Alternating))
                (shift 2 8 (rotate 180 (wedge 3)))
            )
            use:Vertex
        )
        (piece "General" P1 
            ("StepToEmpty"
                ~
                (then 
                    ("InterveneCapture")
                )
            )
        )
        (piece "Marker" P2
            (move Step 
                (to if:(and (not (is In (to) (expand (sites Top)))) (is Empty (to))))
                (then 
                    ("CustodialCapture")
                )
            )
        ) 
    }) 
    (rules 
        (start { 
            (place "General1" (ahead (centrePoint) S))
            (place "Marker2" (difference (sites Outer) (expand (sites Top))))
        })
        
        (play (forEach Piece)) 
        
        (end {
            (if (no Pieces P2) (result P1 Win))
            (if (no Pieces P1) (result P2 Win))
            (if 
                (and { 
                    (is In (where "General" P1) (expand (sites Top))) 
                    (>= (count Pieces P2) 2)
                    (= (who at:(coord "D5")) P2)
                }) 
                (result P2 Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Tower of Hanoi was invented by Édouard Lucas in 1883. The game equipment consists of three rods in a row and a series of disks of different sizes which fit on the rods.A player moves one disk at a time to an empty rod or on a rod where it rests on a larker disk. The goal is to place all of the disks on one rod in decreasing size with the largest on the bottom and the smallest on top. 
(game "Tower of Hanoi" 
    (players 1) 
    (equipment { 
        (board (rectangle 1 3)) 
        <Version:pieces>
    }) 
    (rules
        (start {
            <Version:start>
        }) 
        (play ("MoveToEmptyOrOccupiedByLargerPiece" (sites Occupied by:Mover)))
        
        (end {
            (if 
                (is Target {<Version:order>} 2) 
                (result P1 Win) 
            )
            (if 
                (= (count Moves) <Version:limit>) 
                (result P1 Loss) 
            )
        })
    )
)

Construct a Ludii game based on the following description
Agon is a kind of race game played with pure strategy. Sometimes called Queen's Guard, the game features a queen and six guards for each of the two players. The object is to get one's queen to the centre of the board, surrounded by her guards. The most notable aspect of this game is that it is one of the earliest to be played on a hexagonal grid.1. Agon is played on a hexagonal board made of 91 hexagonal playing spaces. Each concentric layer for hexagons is so coloured that it is easy to see a playing space's distance from the centre of the board.
            
            2. The players each start with a queen and six guards. They are placed in a set configuration at the edge of the board, as shown again in the diagram.
            
            3. In his turn a player moves a piece one space in any direction, except for any direction that leads away from the centre.
            
            5. A piece may not land on or jump over another.
            
            6. A piece may not move adjacent to two enemy pieces such that it is directly between them.
            
            7. Only a queen may move to the central space.
            
            8. If a piece becomes sandwiched between two enemies, it is captured.
            
            9. If the queen is captured, then its owner must, on his next turn, remove the queen from her predicament and place her on any other space on the board.
            
            10. Otherwise if one of his guards is captured, the player must remove the guard from his predicament, but the guard must be placed on a space at the edge of the board.
            
            11. Only one captured piece may be so removed each turn; so a player may arrest his opponent's strategy for a number of turns if he makes multiple captures at once or in quick succession.
            
            12. A player has won the game when his queen rests on the central space, and her six guards are on the six spaces adjacent to her.
            
        13. A player has lost the game if his six guards are adjacent to the central space but his queen is not between them, as this configuration prevents either player from ever winning the game. 
(game "Agon" 
    (players 2) 
    (equipment { 
        (board (hex 6))
        (piece "Pawn" Each 
            (move Step 
                (to if:(and {
                        (is Empty (to))
                        ("CloserToCentre")
                        (!= (to) (centrePoint))
                    })
                )
                (then ("CapturePiece"))
            )
        ) 
        (piece "Queen" Each
            (move Step 
                (to if:(and 
                        (is Empty (to))
                        ("CloserToCentre")
                    )
                )
                (then ("CapturePiece"))
            )		
        ) 
    }) 
    (rules 
        (start {
            (place "Pawn1" (sites {89 60 20 3 6 51}))
            (place "Pawn2" (sites {87 84 39 1 30 70}))
            (place "Queen1" 85)
            (place "Queen2" 5)
        })
        (play 
            (priority {
                ("ReleaseCapturePiece" "Queen" Board)
                ("ReleaseCapturePiece" "Pawn" Outer)
                (do (forEach Piece)
                    ifAfterwards:(not (can Move
                            ("InterveneCapture" Orthogonal)
                    ))
                )
                
                }
            )
        )
        (end 
            (if ("AllPawnsInInnerRing")
                {
                (if 
                    ("IsPieceAt" "Queen" Mover (centrePoint))
                    (result Mover Win)
                )
                (if 
                    (not ("IsPieceAt" "Queen" Mover (centrePoint)))
                    (result Mover Loss)
                )
                }
            )
        )
    )
)

Construct a Ludii game based on the following description
Ntyéngé is a two-row mancala-style board game played by the Mbenge people in Gabon. It is sometimes played on a board, but more frequently is made in the ground and played with seeds or pebbles.2x8 board. Four counters per hole. Players alternate turns taking the counters from one of the holes in their row and sowing them in an anticlockwise direction. When the final counter falls into a hole containing one or three counters, causing it to contain two or four, these counters are captured. Play continues until all of the counters have been captured. The player who captured the most counters wins. 
(game "Ntyenge" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 8 store:None
            (track "Track" "0,E,N,W" loop:True)		
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top)) 
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (move Select
                (from (sites Mover) if:(> (count at:(from)) 0))
                (then
                    (sow
                        apply:(if (or (= 2 (count at:(to))) (= 4 (count at:(to))))
                            (fromTo
                                (from (to))
                                (to (handSite Mover))
                                count:(count at:(to))
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" ("NoPieceOnBoard")))
    )
)

Construct a Ludii game based on the following description
Baghchal is a game popular in Nepal, observed in the twentieth century. It was particularly popular among Buddhist monks. It is also played in India, particularly in places close to Nepal.Played on 5x5 grid including diagonals and pieces are played on the intersections of the lines. One player has four tigers, placed on the corners, and the other has up to 20 goats, placed on the board on a free space. Tigers and goats can move to an adjacent intersection along the lines on the board. Tigers may capture goats by hopping over them. The game ends when tigers have captured all of the goats or the goats block the tigers from being able to move. The objective of the player 2 is to capture all the tigers.
(game "Baghchal" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (hand P1)
        (piece "Goat" P1 "StepToEmpty") 
        (piece "Tiger" P2 (or "HopCapture" "StepToEmpty"))
    }) 
    (rules 
        (start { 
            (place "Tiger2" (sites Corners))
            (place "Goat1" (handSite P1) count:20)
        })
        phases:{ 
        (phase "Placement" P1 
            (play 
                (move 
                    (from (handSite P1)) 
                    (to (sites Empty))
                )
            ) 
            (nextPhase ("HandEmpty" P1))
        )
        ("PhaseMovePiece" "Movement")
        }
        (end ("NoMovesLossAndLessNumPiecesPlayerLoss" P1 <Num:tigers>))
    )
)

Construct a Ludii game based on the following description
Paumecary is a European Tables game from fourteenth century England. Play is confined to one quarter of a typical board. Customarily, when a player wins, the game continues, with the winner helping the loser bear off their remaining pieces, smacking the loser's hands for each piece borne off.Played on a board with 12 points per side, divided in half. Play occurs only in the top right quadrant of the board. Fifteen pieces per player. Two six-sided dice. A double throw grants the player another throw. Players enter their pieces according to the throws of the dice, and they must use the entire value of a die to place or to move a piece. When all of a player's pieces are on the board, they may bear off their pieces with throws equal to the number of remaining spaces, plus one. If a piece lands on a point with a single piece belonging to the opponent, the opponent's piece is removed from the board and must re-enter. The player who bears off all their pieces first wins. 
(game "Paumecary"
    (players 2)
    (equipment {
        ("TableBoard"
            {
            (track "Track1" {24..18 End} P1 directed:True)
            (track "Track2" {25 23..18 End} P2 directed:True)
            }
        )
        (dice d:6 num:2)
        (piece "Disc" Each
            (or
                (forEach Die 
                    replayDouble:True 
                    if:("DieNotUsed")
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NoEnemyOrOnlyOne" (to))
                            ("HittingCapture" (handSite Next))
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
                (if (is Empty (handSite Mover))
                    (forEach Die 
                        replayDouble:True 
                        if:(and
                            ("DieNotUsed")
                            ("IsEndTrack" ("NextSiteFrom" (from) (pips)))
                        )
                        (move Remove (from))
                        (then ("ReplayNotAllDiceUsed"))
                    )
                )
            )		
        )
        (hand Each)
    })
    (rules 
        (start {
            (place Stack "Disc1" (handSite P1) count:15)
            (place Stack "Disc2" (handSite P2) count:15)
        })
        (play 
            ("RollEachNewTurnMove"
                (or (forEach Piece) (forEach Piece container:(mover)))
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
En Gehé is a two-row mancala-style game played by the Loitha and Misonga Masai in northern Tanzania. It is reported to be exclusively played by men, usually in two teams of eight people. It is played on a board with rows of holes dug into the ground.2x40-50 board. Each team controls one row. Play begins with each hole containing four counters (usually seeds or pebbles). A player picks up the counters in a hole in his team's row and sows them in a counterclockwise fashion, one in each consecutive hole. If the last counter is deposited into a hole containing counter, those counters are picked up and the player continues sowing. The turn continues in this fashion until the last counter falls into an empty hole. If this empty hole is on the player's side, the counters in the opposite hole in the other team's row are captured. The counter also causing the capture is taken. Play continues until one team cannot move, and the remaining counters are captured by the other team. The team with the most seeds wins. Each row has 40 holes.
(game "En Gehe" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        ) 
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (if ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover) 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        apply:(if (> (count at:(to)) 1)
                            (moveAgain)
                            (if (and 
                                    (is In (to) (sites Mover)) 
                                    (> (count at:("OppositePit" (to))) 0)
                                )
                                (and
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (handSite Mover)) 
                                        count:(count at:("OppositePit" (to)))
                                    ) 
                                    (fromTo 
                                        (from (to)) 
                                        (to (handSite Mover)) 
                                        count:(count at:(to))
                                    )
                                )
                            )
                        )
                        
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Deka is a two-row mancala-style board game played by the Yombe people in the Democratic Republic of Congo.Two rows of six holes encircling a larger hole in the center. Two counters in each hole, except the center hole. Players move by removing the counters from one of the holes in their row and sowing them in an anti-clockwise direction. If the final counter of the sowing falls into an occupied hole, these counters are picked up and sowing continues. When the final counter falls into an empty hole, the turn ends. If the final counter falls into a hole already containing two others, the player takes these counters and covers the hole. The three counters are sown beginning with the following hole. When sowing, if a player reaches a covered hole in their row, they skip it and continue sowing with the next available hole. If the player reaches a covered hole in the opponent's row, the counter that would fall into it is instead deposited into the central hole. If this is the final counter, the turn ends. It is possible to sow a single counter. The player who can no longer sow from their row loses. 
(game "Deka"
    (players 2)
    (equipment {
        (board 
            (merge {
                (rectangle 1 5)
                (rectangle 3 1)
                (shift 0 2 (rectangle 1 5))
                (shift 4 0 (rectangle 3 1))
                (shift 2 1 (square 1))
            })
            (track "Track" "0,E,N,W,S1" loop:True)
            use:Vertex
        )
        (regions P1 (sites {0..4 11})) 
        (regions P2 (sites {5..10})) 
        (piece "Seed" Shared)
    })
    (rules
        (start (set Count 2 to:(difference (sites Board) 12)))
        
        (play 
            (or {
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay") })
                            (sites Mover)
                        )
                        if:(is Occupied (from))
                    )
                    (then
                        (sow
                            apply:(if (not (and (is In (to) (sites Next)) (= (next) (state at:(to)))))
                                (if (= 3 (count at:(to)))
                                    (and {
                                        (fromTo
                                            (from (to))
                                            (to ("NextHoleFrom" (to) 1))
                                            count:3
                                        )
                                        (sow
                                            ("NextHoleFrom" (to) 1)
                                            count:3
                                            skipIf:(and (is In (to) (sites Mover)) (= 1 (state at:(to))))
                                        )
                                        (set State at:(to) 1)
                                    })
                                    (if (< 1 (count at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                            skipIf:(and (is In (to) (sites Mover)) (= (mover) (state at:(to))))
                        )
                    )
                )
                }
                (then
                    (forEach Site ("EnemySites")
                        (if (= 1 (state at:(site)))
                            (and
                                (fromTo
                                    (from (site))
                                    (to (centrePoint))
                                    count:(count at:(site))
                                )
                                (set State at:(site) 1)
                            )
                        )
                    )
                )
            )
        )
        
        (end ("ForEachPlayerNoMovesLoss"))
    )
)

Construct a Ludii game based on the following description
Nei-Pat-Kono is a game played in Korea at least since the end of the nineteenth century, and likely earlier. It is a game of leaping captures similar to others common around the world.4x4 board, eight pieces each player. Pieces move orthogonally by either jumping a player's own piece to capture an opponent's piece or by moving one space into an empty hole. Captures are not compulsory. The goal is to reduce the opponents pieces to 1 or blocking them so they can no longer move. The game is played on a 4x4 board. The game starts with half the board owned by each player.
(game "Nei-Pat-Kono"
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each 
            (or 
                ("StepOrthogonalToEmpty")
                (move Hop
                    Orthogonal 
                    (between if:("IsFriendAt" (between)))
                    (to if:("IsEnemyAt" (to))) 
                ) 
            ) 
        )
    }) 
    (rules 
        (start { <Start> })
        (play (forEach Piece))
        (end 
            (if 
                (or 
                    (no Moves Next) 
                    (<= (count Pieces Next) 1)
                ) 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Shatranj al-Mustatila is a version of Shatranj played on a 4x16 board. A die is used to determine which piece a player moves. The Persian Shatranj expert al-Adli states that this game was often made on textiles, with the game Nard on the other side.4x16 board. The pieces move as follows, with the number per player: Shah (king)x1: moves one space orthogonally or diagonally. Fers (counselor)x1: one square diagonally; Rukh (rook)x2: any number of spaces orthogonally; Pil (elephant)x2: two squares diagonally, jumping over the first, cannot capture another Pil; Asb (horse)x2: moves orthogonally one space and then diagonally one space, jumping over any intervening pieces; Sarbaz (soldier)x8: moves one space forward orthogonally or one space forward diagonally to capture. No en passant, promoted to Fers when reaching the sixteenth rank. Pieces are placed with the Shah and Fers in the center of the row closest to the player (Shah to the right), a Pil on either side of them, the Asb on the two center squares in the second row, flanked by the Rukh, and the Sarbaz on the fifth and sixth rows. Movement of the pieces is determined by one six-sided die, with the following throws: 6=Shah, 5=Fers, 4=Pil, 3=Asb, 2=Rukh, 1=Sarbaz. No castling. Stalemate results in win for player causing it. When the Shah is in check, the opponent must roll a 6 for it to escape. The player who checkmates the Shah wins. 
         
(game "Shatranj al-Mustatila"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (rectangle 16 4))
        ("ChessKing" "King_noCross")
        (piece "Queen" Each ("StepToNotFriend" Diagonal))
        (piece "Elephant" Each
            (move Hop Diagonal 
                (between if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        (and ("IsEnemyAt" (to)) (not ("IsPieceAt" "Elephant" Next (to))))
                    ) 
                    (apply (remove (to)))
                ) 
            )		
        )
        ("ChessKnight" "Knight")
        ("ChessRook" "Rook")
        ("ChessPawn" "Pawn" ~ (then ("PromoteIfReach" (sites Mover "Promotion") "Queen")))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
        (dice d:6 from:1 num:1)
    })
    (rules 
        (start {
            (place "Pawn1" (union (sites Row 4) (sites Row 5))) 
            (place "Pawn2" (union (sites Row 10) (sites Row 11)))
            (place "Elephant1" (sites {"A1" "D1"})) (place "Knight1" (sites {"B2" "C2"})) 
            (place "Rook1" (sites {"A2" "D2"})) 
            (place "King_noCross1" coord:"B1") (place "Queen1" coord:"C1")
            (place "Elephant2" (sites {"A16" "D16"})) (place "Knight2" (sites {"B15" "C15"})) 
            (place "Rook2" (sites {"A15" "D15"}))
            (place "King_noCross2" coord:"C16") (place "Queen2" coord:"B16")
        })
        (play 
            (do
                (do (roll)
                    next:(if ("IsInCheck" "King_noCross" Next (forEach Piece))
                        (move Pass (then (trigger "NextCanNotEscape" (next))))
                        ("PlayAPiece")
                    )
                )
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover (forEach Piece Next)))
            )
        )
        (end {
            ("Checkmate" "King_noCross")
            (if (is Triggered "CanNotEscape" Next) (result Mover Win))
            (if (not (can Move (forEach Piece Next)))
                (result Mover Win)
            ) 
        })
    )
)

Construct a Ludii game based on the following description
Gauntlet is a game of unequal forces that challenges players to run a gauntlet of blockers.Starting with the runner player, players alternate moving one of their checker tokens. Each token moves in one orthogonal direction only.
            
            Runner tokens move vertically from the first rank, either by moving into an adjacent empty space or by jumping over an adjacent opponent token into an empty space and capturing the jumped token.
            
            Blocker tokens move horizontally in a similar manner - the left tokens always move toward the right and the right tokens always move towards the left.
            
            In the standard/introductory game, played on an 8x8 board, captures are mandatory and multiple capture are possible with maximum capture sequences having priority. In tournament games, played on a 10 x 10 board, captures are optional.
            
            Blocker tokens may not jump over or capture other blocker tokens.
            
            The game ends when a runner token reaches the last rank or the runner player cannot move.
            
        Two games should be played, with players swapping roles. At the end of each game, the runner player scores the rank/row of each of his or her remaining tokens on the board. The player with the highest score after two games wins the match. 8 x 8 board Forced captures
(game "Gauntlet"
    (players {(player N) (player W)})
    (equipment {
        (board (square <Board:size>))
        (piece "Counter" Each)
        (piece "DoubleCounter" Each)
        
        (regions "RunnerGoal" P1 (difference (sites Top) (sites Corners)))
        (regions "RunnerGoalRed" Neutral 
            (intersection
                (difference (sites Top) (sites Corners)) 
                (sites Phase 0)
            )
        )
        (regions "RunnerGoalPink" Neutral
            (intersection
                (difference (sites Top) (sites Corners)) (sites Phase 1)
            )
        )
        }
    ) 
    
    (rules 
        (start { 
            (place "Counter1" (difference (sites Bottom) (sites Corners)))
            (place "DoubleCounter2" (difference (sites Left) (sites Corners)))
            (place "Counter2" (difference (sites Right) (sites Corners)))
        })
        
        (play
            (<Each:AIstyle> {
                (max Moves
                    (or
                        (forEach Piece "Counter"
                            ("HopCounter" (from) Forward
                                (then
                                    (if (can Move ("HopCounter" (last To) Forward))
                                        (moveAgain)
                                    )
                                )
                            ) 
                        )
                        (forEach Piece "DoubleCounter"
                            ("HopCounter" (from) Backward
                                (then
                                    (if (can Move ("HopCounter" (last To) Backward))
                                        (moveAgain)
                                    )
                                )
                            ) 
                        )
                    )
                )
                (or 
                    (forEach Piece "Counter" 
                        (move Step 
                            (directions Forward)
                            (to if:(is Empty (to)))
                        )
                    )
                    (forEach Piece "DoubleCounter"
                        (move Step 
                            (directions Backward)
                            (to if:(is Empty (to)))
                        )
                    )
                )
            })
        )
        
        (end {
            (if (no Moves Next) (result Next Loss))
            (if (is In (last To) (sites Mover)) (result Mover Win))
        })
    )
)

Construct a Ludii game based on the following description
Hawalis is a mancala-style game played in Oman that closely mirrors Bao Ki Arabu in Zanzibar. It has been observed being played outside in Muscat, and the players were Arab-speaking Omani men. The board has four rows of seven holes, and is often played as holes dug out in the sand.Play begins with two seeds in each hole. Each player owns the two rows closest to them. Play proceeds by taking the seeds from one hole and sowing them one by one in consecutive holes in an anti-clockwise direction. If the last seed falls in a hole in the inner row, and the opponent's hole opposite it is not empty, then the opponent's seeds in that hole are captured. Players can only play from holes with single counters when there is no other option, and they may not sow into another hole that already contains a counter. Play continues until one player no longer has any seeds. 
(game "Hawalis" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "14,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        (play 
            (priority
                ("Sow" (> (count at:(from)) 1))
                ("Sow" (= (count at:(from)) 1))
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Frangieh (\The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Play begins by each player rolling one die; the player who rolls the highest plays first, and then rolls again to begin play. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final six points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
             
(game "Frangieh" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" ("BackgammonTracksWithBar" End))
        (dice num:2)
        (regions P1 { 20..25 }) 
        (regions P2 { 7..12 }) 
        (map {(pair 1 6) (pair 2 19)}) 
        (piece "Disc" Each ("MoveAPieceIf" "DieNotUsedAndNoEscapeAndNotOffTheTrack" (from))) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) 
            (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5)
            (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) 
            (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (if "AllPieceInHome"
                    (forEach Die 
                        replayDouble:True 
                        if:("DieNotUsed")
                        (forEach Site 
                            (sites Occupied by:Mover)
                            (if ("NotEmptyAndNotOffTheBoard") 
                                (if ("CanEscape")
                                    ("RemoveAPiece")
                                    ("MoveAPiece" (site))
                                )
                            )
                            noMoveYet:(firstMoveOnTrack "Track" Mover
                                (if "HaveAPieceAndCanEscape"
                                    "RemoveAPiece"
                                )
                            )
                            (then ("ReplayNotAllDiceUsed"))
                        )
                    )
                    (if "BarEmpty"
                        (forEach Piece top:True)
                        ("MoveAPieceIf" ("DieNotUsed") ("Bar"))
                        (then 
                            (if (not (all DiceUsed))
                                (if (can Move 
                                        (if "BarEmpty"
                                            (forEach Piece top:True)
                                            ("MoveAPieceIf" ("DieNotUsed") ("Bar"))
                                        )
                                    )
                                    (moveAgain)
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Li'b el-Merafib is a race game played by the Kababish people of Sudan. The pieces represent the players' mothers, traveling from their home village to a well to get water, and they have to race home to avoid being eaten by the hyena, which eliminates players it overtakes.The board is a square spiral of any number of spaces. Each player begins with one piece. Three casting sticks, each with a round and a flat side, are used as dice. The throws are as follows: One flat side up = 1; two flat sides up = 2; three flat sides up = 4, zero flat sides up = 6. The pieces begin on the outer end of the track, and must throw a 1 to begin play. Once a player has left the starting spot, they move according to the throws, except on throws of 1, which are tabulated for use later. Players continue to throw until they throw 2. Players must land on the last space of the track, I.e. at the center of the spiral, by an exact throw. The player must then roll 1 five times before leaving this space and proceeding back to the starting point. Accumulated rolls of 1 may be used for this. The first player to reach the starting space by an exact throw releases the hyena. The hyena proceeds along the track in the same manner, but moving twice the value of each throw. When the hyena reaches the end of the track, it must throw or pay 1 ten times. The hyena captures any piece it overtakes on the return to the starting space, eliminating that player from the game. The game has 2 players.
(game "Li'b el-Merafib"
    (players <Player:num>)
    (equipment {
        (board 
            (merge {
                (shift 4 4 (rectangle 2 1))
                (shift 4 4 (rectangle 1 4))
                (shift 7 4 (rectangle 4 1))
                (shift 2 7 (rectangle 1 6))
                (shift 2 2 (rectangle 6 1))
                (shift 2 2 (rectangle 1 8))
                (shift 9 2 (rectangle 8 1))
                (shift 0 9 (rectangle 1 10))
                (rectangle 10 1)
                (rectangle 1 12)
                (shift 11 0 (rectangle 12 1))
                (shift 0 11 (rectangle 1 12))
            })
            {
            (track "Track" "73,E,S,W,N,E,S,W,N,E,S,W,N" directed:True)
            (track "ReverseTrack" "0,E,N,W,S,E,N,W,S,E,N,W" directed:True)
            }
        )
        ("StickDice" 3)
        (piece "Stick" Each
            (if (= (from) ("CentralSite"))
                (if ("AllowToMoveOutFromCentral")
                    (move
                        (from (from) level:(level))
                        (to ("FirstSiteBackward"))
                    )
                    (if ("ThrowOf1")
                        (move Select
                            (from (from) level:(level))
                            (then (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))))		
                        )
                        (if (is In 1 ("TabulatedValues"))
                            (move Select
                                (from (from) level:(level))
                                (then (and
                                        (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo))))
                                        ("Untabulate" 1)
                                    )
                                )		
                            )
                        )
                    )
                )
                (if ("AllowToUseTabulatedToGoCentral")
                    (move
                        (from (from) level:(level))
                        (to ("CentralSite"))
                        (then ("Untabulate" 1))
                    )
                    (if (= (from) ("InitSite"))
                        (move
                            (from (from) level:(level)
                                if:("ThrowOf1")
                            )
                            (to 
                                ("SiteToMoveOnTrack" from:(from) "Track" ("ThrowValue"))
                            )
                        )
                        (if (= 0 (state at:(from) level:(level)))
                            (if (not ("ThrowOf1"))
                                (move
                                    (from (from) level:(level))
                                    (to 
                                        ("SiteToMoveOnTrack" from:(from) "Track" ("ThrowValue"))
                                    )
                                )
                                (move Pass
                                    (then ("Tabulate" ("ThrowValue")))
                                )
                            )
                            (or 
                                (move
                                    (from (from) level:(level))
                                    (to 
                                        ("SiteToMoveOnTrack" from:(from) "ReverseTrack" ("ThrowValue"))
                                    )
                                    (then
                                        (if	(= (last To) ("InitSite"))
                                            (if ("IsOffBoard" (where "Hyena" Neutral))
                                                (add (piece (id "Hyena" Neutral)) (to (last To)))
                                            )
                                        )
                                    )
                                )
                                (if ("ThrowOf1")
                                    (move Pass
                                        (then ("Tabulate" ("ThrowValue")))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        (piece "Hyena" Neutral maxState:10)
        (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 4)})
    })
    (rules 
        (start {
            <Player:start>
        })
        (play 
            ("RollMove"
                (if (and (= ("InitSite") (where "Stick" Mover)) (!= 0 (state at:(where "Stick" Mover) level:(where Level "Stick" Mover at:(where "Stick" Mover)))))
                    ("MoveHyena")
                    (forEach Piece)
                )
                (then
                    (if (not ("ThrowOf2"))
                        (moveAgain)
                    )
                )
            )
        )
        (end {
            (forEach Player
                if:("NoStick" Player) 
                (result Player Loss)
            )
            (forEach Player
                if:("WinningCommonCondition")
                (result Player Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Main Chator is a replacement capture game played in Malaysia and Indonesia. This version was played in the Selangor region of Malaysia. Played on an 8x8 board with pieces with specialized moves. The pieces are as follows, and placed on the outer rank in the following order, starting from the left corner and moving in, with the placement mirrored on the right side (the Mantri is placed to the right of the Rajah): Tor (2): can move any number of spaces orthogonally; Kudah (2): moves in any direction, one space orthogonally with one space forward diagonally, jumping over any intervening pieces; Gajah (2): can move any number of spaces diagonally; Rajah (1): can move one space orthogonally or diagonally; Mantri (1): can move any number of spaces orthogonally or diagonally; Bidah (8), placed in front of the other pieces: can move one space forward, or one space diagonally to capture. A Bidah may move two squares on its first move. Bidahs may capture en passant only when it is blocked from moving forward by another of the opponent's Bidahs; the blocked Bidah has the option in this scenario of capturing with an en passant move, with the option of capturing either of the two Bidahs in question.
            The Rajah, for its first move may move like a Kudah as long as it has never been checked. 
            
            Players capture pieces by moving onto a space occupied by an opponent's piece. 
            
            Castling occurs by moving the Rajah to the left or the right two squares, regardless of any intervening pieces; the Tor is not moved as part of this move. 
            
            Promotion of Bidahs occur when they reach the opposite edge of the board, but only immediately if they reach the Tor's square. If it captures on the square next to the Tor's square, from the square in front of the Tor's square, it must move backward diagonally to the square in front of the Tor's square on a subsequent turn and continue before promotion. A Bidah reaching the Kudah's square must move backward diagonally once, to the right or left, before being promoted; a Bidah reaching the Gajah's square must move backward diagonally right or left two spaces, and a Bidah reaching the Raja or Mantri's square must move backward diagonally three squares before being promoted. Bidah's can be promoted to whatever piece the player wishes. 
            
            If the Rajah can be captured on the opponent's next turn, it is in check. The Rajah must not be in check at the end of the player's turn. If this is impossible, it is checkmate and the opponent wins. 
            
            If a player is reduced to only their Rajah, it can make the move of any piece. 
         
(game "Main Chator (Selangor)"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        (piece "Pawn" Each 
            (if (= 0 (state at:(from)))
                (or {
                    (if (is In (from) (sites Start (piece (what at:(from)))))
                        ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
                    )
                    "StepForwardToEmpty" 
                    ("StepToEnemy" (directions {FR FL}))
                    "EnPassant"
                    (move Step 
                        (directions {FR FL}) 
                        (to 
                            if:(and
                                ("InLocationEnPassant")
                                (= (id "Pawn" Next) (what at:(ahead (from) Forward)))
                            )
                        ) 
                        (then 
                            (remove 
                                (ahead (last From) (if (is Mover P1) N S))
                            )
                        )
                    )
                    }
                    (then
                        (if (is In (last To) (sites Mover "Promotion")) 
                            (if (is In (last To) (sites Corners))
                                (moveAgain)
                                (if (is In (last To) (intersection (sites Mover "Promotion") (expand (sites Corners))))
                                    (set State at:(last To) 1)
                                    (if (is In (last To) (intersection (sites Mover "Promotion") (expand (sites Corners) steps:2)))
                                        (set State at:(last To) 2)
                                        (set State at:(last To) 3)
                                    )
                                )
                            )
                        )
                    )
                )
                ("StepToEmpty" 
                    (directions {BR BL}) 
                    (then
                        (and
                            (if (= 1 (state at:(last To)))
                                (moveAgain)
                            )
                            (set State at:(last To) (- (state at:(last To)) 1))
                        )
                    )
                )
            )
        )
        ("ChessRook" "Rook")
        (piece "King_noCross" Each 
            (if (= (count Pieces Mover) 1)
                (or
                    ("LeapCapture" "KnightWalk")
                    ("SlideCapture")
                )
                (or {
                    ("StepToNotFriend")
                    (if (and ("HasNeverMoved" (from)) (!= (value Player Mover) (mover)))
                        ("LeapToEmpty" "KnightWalk"
                            (then (set Value Mover (mover)))
                        )
                    )
                    (if ("HasNeverMoved" (from))
                        (move Hop 
                            (directions {E W})
                            (between if:True)
                            (to if:(is Empty (to)))
                        )
                    )
                    }
                    "RememberPieceHasMoved"
                )
            )
        )
        ("ChessBishop" "Elephant")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Ferz_noCross")
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "King_noCross1" coord:"D1" state:1) (place "Ferz_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "King_noCross2" coord:"E8" state:1) (place "Ferz_noCross2" coord:"D8") 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Knight" "Elephant" "Rook" "Ferz_noCross"}) Mover)
                (do 
                    (forEach Piece) 
                    ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
                    (then
                        (if (!= (next) (value Player Next))
                            (if ("IsInCheck" "King_noCross" Next)
                                (set Value Next (next))
                            )
                        )
                    )		
                )
            )
        )
        
        (end {
            ("Checkmate" "King_noCross") 
            ("MisereBlockWin")
            (if (= (count Pieces Next) 1) (result Mover Win)) 
        })
    )
)

Construct a Ludii game based on the following description
'Double Run Stone' (originally 'A Family of Four') is a two player pattern-forming game that can be played on a variety of grids.     The main goal is to create a double run (like in Cribbage) as an isolated group of pieces. For this, you score the value of the included pair.         Forcing the opponent to stalemate you is intended to be a common secondary goal and win condition.        Play is chaotic due to destination restrictions and required removals that ensure no piece is next to all three values (irrespective of piece ownerships.)        This game is surprising as pattern forming games go, in that it may be played with the same rules on a variety of boards grids or networks. It is tactical and delightfully opaque, and thus best suited to small size boards and informal contests.        The new version eliminates cycles by using a limited piece supply and by limiting the number of serial movements to the number of a player's pieces currently in play.             The various restrictions combine to create many distinct modes of winning in addition to the pattern forming. They are best served by small tight boards with few enough pieces to make these alternative wins actually occur:    - Depleting a category of pieces and/or depleting all pieces to prevent one's own placement.     - Reducing piece count on the board to minimize the forced movement count needed to win.     - Forcing the opponent to fill the board, or eliminate all playable destinations.     - Forcing the opponent to remove pieces in a way that creates a group for yourself.     These tactics are mostly at odds with setting up your own double-run. For example, completely running out of one type of piece prevents one from forming a double run at all.         The game is intended to be played in sets and different wins produce different scores so that this is interesting.  Each player's stock of pieces is weighted to make higher scores less likely than lower scores. Triangle-Square Omni-Grid Order 3 board
(game "Double-Run Stone"
    (players 2)
    (equipment {
        (board "BoardUsed" use:Vertex)
        (hand Each size:15)
        (piece "1Dot" Each)
        (piece "2Dot" Each)
        (piece "3Dot" Each)
    })
    (rules
        ("SetupHands")
        (play
            (if 
                (= 0 (count Sites in:(sites State 1)))
                (priority {
                    (or {
                        ("AddPiece" "1Dot")
                        ("AddPiece" "2Dot")
                        ("AddPiece" "3Dot")
                    })
                    ("StepPiece")
                    (do (forEach Site (sites State 0) (set State at:(site) 1))
                        next:("Stalemate")
                    )
                    (move Pass
                        (then
                            (forEach Site (sites State 0) (set State at:(site) 1)) 
                        )
                    )
                    }
                    (then 
                        ("ScoreWinCondition")
                    )
                )
                ("Stalemate")
            )
        )
        (end 
            (if 
                (!= 0 (count Sites in:(sites State 1)))
                
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Chiana wa Bwalo is a four-row mancala-style board game played by the Nyanja people of East Africa. It is generally played by children.4 row board, of any number of holes. Four counters in each player's outer row. Sowing occurs from the player's rearmost hole and in an anti-clockwise direction. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. The player who captures all of the opponent's counters wins. Each player has 6 holes per row.
(game "Chiana wa Bwalo"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Board:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(union (sites Top) (sites Bottom))))
        
        (play 
            (move Select
                (from 
                    (sites Mover "Home") 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (and 
                                (= (count at:(to)) 1)
                                (> (count at:("OppositePit" (to))) 0) 
                            )
                            (fromTo 
                                (from ("OppositePit" (to))) 
                                (to (handSite Mover)) 
                                count:(count at:("OppositePit" (to)))
                            ) 
                        )
                    )
                )
            )		
        )
        
        (end ("MancalaByScoreWhen" (no Moves Next)))
    )
)

Construct a Ludii game based on the following description
Surakarta is purported to be from Java in Indonesia, but this claim may have been a marketing ploy by Ravensberger when the game was first published in Germany in 1971.Played on a 6x6 board with corner loops. Each player has 12 pieces. Play is made on the intersections of the lines. pieces are captured by moving via the outer loops and occupying a space held by another player. The goal is to capture all of the opponent's pieces. If no further captures are possible, the player with the most remaining pieces wins. The pieces can step to an empty site. The pieces can slide to capture. The mover win if the next player does not have any piece. The game is played on the Awithlaknan Mosona board.
(game "Surakarta" 
    (players <Option:players>) 
    (equipment { 
        (surakartaBoard <Option:board>) 
        
        (piece "Marker" Each 
            (or {
                (move Step
                    All
                    <Step:to>
                )
                ("SlideToCapture")						
            })
        )
    }) 
    (rules 
        (start {
            (place "Marker1" <Option:start1>)
            (place "Marker2" <Option:start2>)
            <Option:start3>
        })
        (play
            (if (is Proposed "End") 
                (or (move Vote "End") (move Vote "No" (then (set Counter)))) 
                (or 
                    (if (>= (counter) "NoCaptureProposal") 
                        (move Propose "End" (then (vote "End")))
                    )
                    (forEach Piece)
                )
            )
        ) 
        <End:rules>
    )
)

Construct a Ludii game based on the following description
Watershed is a square board placement game based on Branching Coral, with the principle of placing pieces, such that, after placement, every site on the boards still has a connection via empty sites to an empty site at the perimeter.                                      Scoring for the standard Plateau version is based on the size of the largest group plus a bonus factor for the number of opponent's pieces captured.  This works to reward capture and thus encourages breaking up opponent's groups, while remaining straight forward in the need to enlarge your largest group, it allows creating come-back groups, or staging combacks by capturing material.                           Ties are broken in favor of the underdog by considering only the largest group size as a negative score without including the capture bonus. Opponent-paired groups of the same size are excluded in this comparison. If all groups are paired in size with the opponent, last to play wins.                   Play is only on odd sized boards to avoid mirror strategy, since last to play also wins.                  A Floodplain variant reverses the board connections, group connections, bonus attribution and tie-breaker rules.Goal: Score the most points: 
            -- One point for each stone in one's largest group.
            -- Bonus points are also awarded for certain captured stones.
            
            The board starts empty.
            Players take alternating turns placing one of their stones onto an empty site.
            Directly after placement, every site of the board must remain connected to an empty perimeter site via a continuous path of empty sites, and the stone that was placed must be next to any 2 empty sites. 
            
            Capture 
            After placement, simultaneously remove all the stones adjacent to the placed stone that are no longer next to 2 empty sites.
            
            There is no passing. The game ends when no more placements can be made.  
            
            Ties are broken in favor of the underdog by compairing cascading largest groups (excluding tied pairs) Tie breaker scores are negative, so largest group LOSES.
            
            Plateau version (mauve background):
            Connection to the edge is by omni-directional steps. Stone groups are orthogonal only. 
            Players score one point for every stone in their largest group, plus a bonus point for each captured opponent's stone.
            
            The player with the higher score wins. 
            
            Floodplain version (green background):
            Connection to the edge is by orthogonal steps. Stone groups are omni-directional adjacent. 
            Players score one point for every stone in their largest group, plus a bonus point for each of their stones that the opponent removed from the board.
            
        The player with the higher score wins. Order 5 board Watershed Plateau: Omni-Square Grid - Orthogonal group scoring, Bonus for opponent's capured, Largest group loses a tie.
(game "Watershed"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Ball" Each)
        (piece "Disc" Each)
        (hand Each size:1)
    })
    (rules
        (start (set Score Each 0))
        (play
            (do
                (move 
                    Add
                    (to 
                        (sites Empty) 
                        if:(< 1 
                            (count Sites 
                                in:(intersection
                                    (sites Around (to) "ConnectionDirection")
                                    (sites Empty)
                                )
                            )
                        )
                    )
                )
                ifAfterwards:("AllHave1Connection2Edge" 
                    (intersection 
                        (sites Around (last To) "ConnectionDirection")
                        (sites Empty)
                    )
                ) 
                (then
                    (do
                        ("CapturingAtScoreWhat4Who" 
                            (intersection 
                                (sites Occupied by:All) 
                                (sites Around (last To) "ConnectionDirection") 
                            )
                            Next 
                            <Variant:bonus2> 
                        )
                        next:("Scoring")
                    )
                )
            )
        )
        (end 
            (if 
                (no Moves Next)
                {
                (if 
                    (= (score Mover) (score Next))
                    (result Mover Win)
                )
                (if 
                    (!= (score Mover) (score Next))
                    (byScore)
                )
                }
            )
        )
    )
)

Construct a Ludii game based on the following description
Greatest Loss is a theoretical game designed to demonstrate Monte Carlo resistance. There is one suboptimal (losing) move per turn against a competent opponent.Players take turns removing a piece of their colour (the mover must remove a piece each turn). The player who removes their highest numbered piece loses the game. 
(game "Greatest Loss" 
    (players 2) 
    (equipment { 
        (board (square 4)) 
        (piece "Disc" Each) 
    }) 
    (rules 
        (start {
            (place "Disc1" {"A1"} state:1) 
            (place "Disc1" {"B1"} state:2) 
            (place "Disc1" {"C1"} state:3) 
            (place "Disc1" {"D1"} state:4) 
            (place "Disc1" {"A2"} state:5) 
            (place "Disc1" {"B2"} state:6) 
            (place "Disc1" {"C2"} state:7) 
            (place "Disc1" {"D2"} state:8) 
            
            (place "Disc2" {"A4"} state:1) 
            (place "Disc2" {"B4"} state:2) 
            (place "Disc2" {"C4"} state:3) 
            (place "Disc2" {"D4"} state:4) 
            (place "Disc2" {"A3"} state:5) 
            (place "Disc2" {"B3"} state:6) 
            (place "Disc2" {"C3"} state:7) 
            (place "Disc2" {"D3"} state:8) 
        })
        
        (play 
            (move Select 
                (from 
                    (sites Occupied by:Mover)
                )
                (then
                    (remove (last To))	
                )		
            )
        ) 
        
        (end 
            (if 
                (= 0 
                    (count Sites 
                        in:(forEach 
                            (sites Occupied by:Mover) 
                            if:(= 8 (state at:(site)))
                        )
                    )
                )
                (result Mover Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Main Dam is a game with leaping captures played in Malaya in the early twentieth century.8x8 board. Twelve pieces per player. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them in a forward direction if they are adjacent. Capturing must happen if it is possible. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards, and can capture by jumping over any number of pieces, any distance. The goal is to capture all of the opponent's pieces. 
(game "Main Dam" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 8))
    (rules 
        ("BlackCellsSetup" 3)
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    ("HopCapture" (from (last To)) (directions {FR FL}) 
                        (then 
                            ("PromoteIfReach" (sites Next) "DoubleCounter"
                                ("ReplayIfCanMove" ("HopCapture" (from (last To)) (directions {FR FL}) )) 
                            ) 
                        ) 
                    )
                    ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows))
                )
                (priority {
                    (or 
                        (forEach Piece "Counter" 
                            ("HopCapture" (from) (directions {FR FL}) 
                                (then 
                                    ("PromoteIfReach" (sites Next) "DoubleCounter"
                                        ("ReplayIfCanMove" ("HopCapture" (from (last To)) (directions {FR FL}) ))
                                    ) 
                                ) 
                            ) 
                        )
                        (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture" before:(count Rows) after:(count Rows)))
                    )
                    
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal))
                    )
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Sam K'i is an alignment game played in China since at least the nineteenth century. It differs from some other games of this type during the placement phase, when a player can place another piece on top of a piece they capture from the opponent. Three concentric squares, with lines connecting the corners and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on the board. When a player places three pieces in a row along the lines of the board, the player places another of their pieces on top of one of the opponent's pieces; the opponent's piece is considered \ 
(game "Sam K'i"
    (players 2)
    
    (equipment { 
        (board (concentric Square rings:3 joinCorners:True) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3" if:("IsSingletonStack" (to)))))
        ) 
    }) 
    (rules 
        (start {
            (place Stack "Marker1" (handSite P1) count:12)
            (place Stack "Marker2" (handSite P2) count:12)
        })
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "PlaceOnTop"
                    (if ("HandOccupied" Mover)
                        (move 
                            (from (handSite Mover)) 
                            (to (sites Empty)) 
                            (then ("ReplayIfLine3" if:("IsSingletonStack" (to)))) 
                        ) 
                    )
                    (then 
                        (if (and (not (is Next Mover)) (and ("HandEmpty" P1) ("HandEmpty" P2)))
                            (and ("RemoveDeadPieces" P1) ("RemoveDeadPieces" P2))
                        )
                    )
                )
            ) 
            (nextPhase (and (not (is Next Mover)) (and ("HandEmpty" P1) ("HandEmpty" P2))) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (if (> (count Pieces Mover) 3)
                        (forEach Piece)
                        (move 
                            (from (sites Occupied by:Mover))
                            (to (sites Empty))
                        )
                    )
                )
            )
            (end ("BlockWin"))
        )
        }
    )
)

Construct a Ludii game based on the following description
Pasit is a race game played in Myanmar. In the nineteenth century, it was popular among children and people living in rural areas, and was said to not be popular among people living in cities.Four 3x8 rectangles, arranged in a cross-shaped board. the fourth square, counting from the outer corners, in the outer rows of each arm are marked. Four pieces per player. Six cowrie shells are used as dice. The value of the throws is as follows: one mouth up = 10; two mouths up = 2, three mouths up = 3; four mouths up = 5; five mouths up = 25; six mouths up = 12; all mouths down = 6. On the first turn, players get three throws, and enter a piece for every throw of 10 or 25. On the top left square in their arm. Players move their pieces around the board in an anti-clockwise direction. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is removed from the board and must enter again. Pieces resting on marked squares are safe from being removed from the board. When a piece completes a circuit of the board. It moves toward the central row in the player's arm, and progresses up the central row into the large square in the center of the board. The player who moves all of their pieces into the center first wine. 
(game "Pasit" 
    (players 4) 
    (equipment { 
        ("PachisiBoard"
            {
            (track "Track1" "8,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N8" P1 directed:True)
            (track "Track2" "42,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E8" P2 directed:True)
            (track "Track3" "53,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S8" P3 directed:True)
            (track "Track4" "11,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W8" P4 directed:True)
            }
        )
        (hand Each) 
        ("StickDice" 6)
        (piece "Pawn" Each
            (if ("IsOffBoard" ("SiteToMoveOnTrack" from:(from) ("ThrowValue")))
                (move 
                    (from (from) level:(level))
                    (to (centrePoint))
                )
                (move 
                    (from (from) level:(level))
                    (to
                        ("SiteToMoveOnTrack" from:(from) ("ThrowValue"))
                        if:True
                        (apply
                            (if (and (not (is In (to) (sites "SafeSites"))) ("IsEnemyAt" (to)))
                                (forEach Level (to) FromTop
                                    (fromTo
                                        (from (to) level:(level))
                                        (to (handSite (who at:(to) level:(level))))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        (map "Throw" {(pair 0 6) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 5) (pair 5 25) (pair 6 12)})
        (map "Entry" {(pair P1 8) (pair P2 42) (pair P3 53) (pair P4 11)})
        (regions "SafeSites" (sites {63 65 15 47 84 86 38 3}))
    }) 
    (rules 
        (start {
            (place Stack "Pawn1" (handSite P1) count:4)
            (place Stack "Pawn2" (handSite P2) count:4)
            (place Stack "Pawn3" (handSite P3) count:4)
            (place Stack "Pawn4" (handSite P4) count:4)
        })
        
        phases:{
        (phase "Opening" 
            (play 
                ("RollMove"
                    (if ("IsSpecialThrow")
                        (move
                            (from (handSite Mover))
                            (to (mapEntry "Entry" Mover))
                        )
                        (move Pass)
                        (then
                            (and
                                (if (!= 1 (value Player Mover)) (moveAgain))
                                (set Value Mover (+ 1 (value Player Mover)))
                            )
                        )
                    )
                )
            )	
            (nextPhase Mover (= 2 (value Player Mover)) "Moving")
        )
        (phase "Moving" 
            (play 
                ("RollMove"
                    (or
                        (if (and (is Occupied (handSite Mover)) ("IsSpecialThrow"))
                            (move
                                (from (handSite Mover))
                                (to (mapEntry "Entry" Mover))
                            )
                        )
                        (forEach Piece)
                    )
                )
            )		
        )
        }
        
        (end (if ("AllPiecesOnCentre" Mover) (result Mover Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Petol"
    (players <Players:num>)
    (equipment {
        (board
            (remove
                (merge {
                    (shift 0 7 (scale 2 1 (rectangle 3 2)))
                    (scale 2 1 (rectangle 8 2))
                    (shift 0 9 (scale 2 1 (rectangle 8 2)))
                    (shift 4.5 1 (scale 2 1 (rectangle 6 2)))
                    (shift -4.5 10 (scale 2 1 (rectangle 6 2)))
                    (shift 4.5 6
                        (graph
                            vertices:{ { 0 0 } { 0 1 } { 2 3 } {2 0 } } 
                            edges:{ {0 1} {1 2} {2 3} {3 0}} 
                        )
                    )
                    (shift 2 7
                        (graph
                            vertices:{ { 0 0 } { 0 2 } { 4.5 2 } {2.5 0 } } 
                            edges:{ {0 1} {1 2} {2 3} {3 0}} 
                        )
                    )
                    (shift 0 7
                        (graph
                            vertices:{ { 0 0 } { 0 2 } { -2.5 2 } {-4.5 0 } } 
                            edges:{ {0 1} {1 2} {2 3} {3 0}} 
                        )
                    )
                    (shift -2.5 10
                        (graph
                            vertices:{ { 0 0 } { 0 -1 } { -2 -3 } {-2 0 } } 
                            edges:{ {0 1} {1 2} {2 3} {3 0}} 
                        )
                    )
                })
                edges:{{2 3}}
            )
            <Players:tracks>
            use:Vertex
        )
        (dice d:2 facesByDie:{{0 1} {0 1} {0 15} {0 20}} num:4)
        (piece "Marker" Each
            (if ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) 1))
                (if (or { 
                        (= 1 ("ThrowValue"))
                        (= 10 ("ThrowValue"))
                        (= 15 ("ThrowValue"))
                        (= 20 ("ThrowValue"))
                    })
                    (move Remove (from) level:(level))
                )
                (if ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) 2))
                    (or
                        (if (or { 
                                (= 2 ("ThrowValue"))
                                (= 3 ("ThrowValue"))
                                (= 5 ("ThrowValue"))
                            })
                            (move Remove (from) level:(level))
                        )
                        (if (is In ("ThrowValue") (sites {1 10 15 20}))
                            (move 
                                (from (from) level:(level))	
                                (to ("SiteToMoveOnTrack" from:(from) 1))
                            )
                        )
                    )
                    (if (is In (from) (sites Mover "EndTrack"))
                        (move 
                            (from (from) level:(level))
                            (to
                                ("SiteToMoveOnTrack" from:(from) ("ThrowValueEndTrack"))
                                if:True
                            )
                        )
                        (move 
                            (from (from) level:(level))
                            (to
                                ("SiteToMoveOnTrack" from:(from) ("ThrowValue"))
                                if:(not (and (is In (to) (sites "SafeSites")) ("IsEnemyAt" (to))))
                                ("HittingStackCapture" (handSite (who at:(to) level:(level))))
                            )
                        )
                    )
                )
            )
        )
        (hand Each)
        (map "Throw" {(pair 0 10) (pair 37 5) (pair 1 1) (pair 15 15) (pair 20 20) (pair 2 2) (pair 16 2) (pair 21 2) (pair 35 2) (pair 17 3) (pair 22 3) (pair 36 3)})
        <Players:entries>
        (regions "SafeSites" (sites {2 3}))
        <Players:endTracks>
    })
    (rules 
        <Players:startRules>
        (play 
            ("RollMove"
                (or { 
                    (if (and (is Occupied (handSite Mover)) (<= 10 ("ThrowValue")))
                        (move 
                            (from (handSite Mover))
                            (to (mapEntry "Entry" Mover))
                            (then 
                                (and
                                    (moveAgain)
                                    (set Value Mover 0)
                                )
                            )
                        )
                    )
                    (forEach Piece
                        (then
                            (if (and (< Undefined (value Player Mover)) (> 3 (value Player Mover)))
                                (if (> 2 (value Player Mover))
                                    (and
                                        (moveAgain)
                                        (set Value Mover (+ 1 (value Player Mover)))
                                    )
                                    (set Value Mover (+ 1 (value Player Mover)))
                                )
                            )
                        )
                    )
                    (if (no Pieces Mover)
                        <Players:playingTeamPieces>
                    )
                })
            )
        )
        (end ("EscapeTeamWin"))
    )
)
Petol is a race game played in the northern part of the state of Puebla in Mexico. It is thought to be a surviving form of the Aztec game Patolli.Cross-shaped board, with two opposite arms bent at a right angle. Line cross each arm, creating 55 intersections where the pieces are placed. Two teams of one, two, or three people play, with each player controlling one piece. Four longitudinally split reed are used as dice, two are unmarked on the concave side which count as 1, and the other two are marked, and count as 15 and 20. The throws are as follows: All convex faces up = 10; all concave sides up = 5; one concave side up = the value of that side; two concave sides up = 2, three concave sides up =3, A player must throw 10 or more to enter the board. Once a piece is entered, the player throws three times consecutively. Each player owns one of the bent arms of the board, and the piece move anti-clockwise from the right hand end of the arm, to the exit at the left hand end of the arm, but not entering the opponent's arm. When a player lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. Pieces on the central spot (spot 25) are safe from being sent back. When a piece enters the player's arm again as they approach the goal, throws of 10, 15, and 20 count as 1. On the penultimate space, a throw of 2, 3, or 5 allows a piece to exit, but on the final space a throw of 1, 10, 15, or 20 is required. If playing on teams, a player who has reached the goal continues to throw and use those throws to move their teammates' pieces. The first team to remove all their pieces from the board wins.  The game is played with 2 players.

Construct a Ludii game based on the following description
This game is played on any square board (say 8x8).TURN - On each turn, each player drops a neutral stone on an empty cell provided that it does not share the same row, column or diagonal with all the stones already on board.
            
        GOAL - Wins the last player to move 
(game "First Attack" 
    (players 2) 
    (equipment { 
        (board (square 8))
        (piece "Ball" Shared) 
    }) 
    (rules 
        (play 
            (move Add
                (piece "Ball")
                (to (sites Empty)
                    if:(all Sites (sites Direction from:(to) Adjacent) if:(is Empty (site)))		
                )
                
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Diagonal Draughts is a type of Draughts game played at least as early as the nineteenth century. In it, the pieces are arranged such that the long diagonal of the board is unoccupied, rather than the central two rows of squares. 10x10 board, 20 pieces per player, arranged on the dark squares, leaving the diagonal from bottom left to top right empty, with each player's pieces on opposite sides of it. Pieces move diagonally one or can jump an opponent's adjacent player to capture it. Pieces can move forward or backwards. When a piece reaches the opposite edge of the board from its starting position, it becomes a king and can may move and jump over any number of spaces diagonally. Captures are compulsory and the maximum number of jumps must be made. Winning is achieved by capturing all the opponent's pieces or by blocking them from moving.
         
(game "Diagonal Draughts" 
    (players 2) 
    ("DraughtsEquipment" (square 10)) 
    (rules 
        (start { 
            (place "Counter1" (difference (expand (intersection (sites Right) (sites Bottom)) steps:8 Orthogonal) (sites Phase 1) ))
            (place "Counter2" (difference (expand (intersection (sites Left) (sites Top)) steps:8 Orthogonal) (sites Phase 1)))
        })
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves
                        ("HopInternationalDraughtsStyle" (from (last To))
                            (then 
                                ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To))) 
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                    )
                    (max Moves ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn))
                )
                (priority {
                    (max Moves
                        (or 
                            (forEach Piece "Counter"
                                ("HopInternationalDraughtsStyle" (from)
                                    (then 
                                        ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To))) 
                                            ("PromoteIfReach" (sites Next) "DoubleCounter")
                                        ) 
                                    ) 
                                ) 
                            )
                            (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture" before:(count Rows) after:(count Rows) at:EndOfTurn))
                        )
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" Diagonal)
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal))
                    )
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Jänes Soppi (\3x3 intersecting lines, with triangles extending on opposite ends of the large square and the central line extending to the apices. One player plays as the notched stick, called the hare, and the other as three sharp sticks, known as the hounds. Players alternate turns placing a piece on the board. When a player has placed all of their pieces on the board, they move one of their pieces to an empty adjacent spot along the lines. When the hounds block the hare from being able to move, the hounds win. The game has an ending condition only for P1.
(game "Janes Soppi" 
    (players 2) 
    (equipment { 
        (board 
            (merge {
                (rectangle 3 3) 
                (shift 1.5 0.5 (rotate -90 (wedge 2))) 
                (shift -1.5 0.5 (rotate 90 (wedge 2))) 
            })
            use:Vertex
        )
        (hand Each)
        (piece "Hound" P1 "StepToEmpty")
        (piece "Hare" P2 "StepToEmpty")
    }) 
    
    (rules 
        (start {
            (place "Hound1" (handSite P1) count:3)
            (place "Hare2" (handSite P2))
        })
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                ) 
            )
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        <End:rule>
    )
)

Construct a Ludii game based on the following description
Fanorona Telo is a simple game of alignment played by children of the Merina people of Madagascar.3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Each player has three pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they win. Once all pieces are placed, players take turns moving pieces one spot to an adjacent point along the lines trying to make three in a row.
         
(game "Fanorona Telo"
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 3 3)
        (hand Each)
        (piece "Marker" Each "StepToEmpty")
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
Janggi is played in Korea and is very similar to other games derived from Indian Chaturanga throughout East Asia. It is very popular in Korea, and international tournaments are becoming more popular.The board has nine vertical lines and ten horizontal rows, and the pieces are placed on the intersections of these lines. Centreed along the back lines of each side is a three by three square with diagonals known as the palace. Pieces have special movement values: Janggun (general): May move one spot along the lines within the palace but cannot leave it. Sa (guards): Same movement as the Janggun. Ma (horses): Move one spot forward orthogonally and then one forward diagonally. Sang (elephants): Move one spot orthogonally forward then two spots diagonally forward. A Ma and Sang can be switched in the initial setup. Cha (chariots): Move like a rook in Chess, but also diagonally within the palace. Po (cannons): Jump over exactly one piece, over any distance horizontally or vertically, but cannot jump over or capture another cannon. Byeong/Jol (soldiers): Move and capture one point forward or sideways. Play continues until Woetong (checkmate) of the Janggun. 
(game "Janggi" 
    (players 2) 
    (equipment { 
        (board (rectangle 10 9) use:Vertex)
        
        
        (piece "Han" P1 "StepMoveOnThePlace") 
        (piece "Cho" P2 "StepMoveOnThePlace") 
        
        
        (piece "Sa" Each "StepMoveOnThePlace") 
        
        
        (piece "Sang" Each 
            (forEach Direction 
                Orthogonal 
                (to if:(is Empty (to)) 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL} of:All)
                            (between (exact 2) if:(is Empty (between)))
                            (if (not ("IsFriendAt" (to)))
                                (move 
                                    (from)
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (remove (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ) 
        )
        
        
        (piece "Ma" Each 
            (forEach Direction 
                Orthogonal 
                (to 
                    if:(is Empty (to)) 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL} of:All) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (remove (to))
                                        )
                                    )
                                )
                            )
                        ) 
                    )
                )
            ) 
        )
        
        
        (piece "Cha" Each (or {
                ("SlideCapture" Orthogonal) 
                
                
                (if 
                    (is In (from) "ThePalaces") 
                    (move Slide
                        Diagonal 
                        (between 
                            (max 2) 
                            if:(and 
                                (is Empty (between)) 
                                (is In (between) "ThePalaces")
                            )
                        )
                        (to 
                            if:("IsEnemyAt" (to)) 
                            (apply (remove (to))) 
                        )
                    )
                )
            })
        )
        
        
        (piece "Po" Each 
            (or {
                (move Hop
                    Orthogonal 
                    (between 
                        before:(count Rows) 
                        after:(count Rows) 
                        if:"NotEmptyAndNotAnotherPo"
                    ) 
                    (to 
                        if:(is Empty (to)) 
                        (apply 
                            if:"NotAFriendAndNotNextPo" 
                            (remove (to))
                        )
                    ) 
                )
                (move Hop
                    Orthogonal
                    (between 
                        before:(count Rows) 
                        after:(count Rows) 
                        if:"NotEmptyAndNotAnotherPo"
                    ) 
                    (to if:(is Empty (to)))
                )
                
                (if 
                    (is In (from) "ThePalaces")
                    (move Hop
                        Diagonal 
                        (between if:"NotEmptyAndNotAnotherPo") 
                        (to 
                            if:(and 
                                "NotAFriendAndNotNextPo" 
                                (is In (to) "ThePalaces")
                            ) 
                            (apply (remove (to)))
                        ) 
                    )
                )
            })
        )
        
        
        (piece "Byeong" P1 N "PawnMove")
        (piece "Jol" P2 S "PawnMove") 
        
        (regions "PalaceP1" P1 { 3..5 12..14 21..23 })
        (regions "PalaceOrthoP1" P1 { 4 12 14 22 })
        (regions "PalaceP2" P2 { 66..68 75..77 84..86 })
        (regions "PalaceOrthoP2" P2 { 67 75 77 85 })
    }) 
    
    (rules 
        (start { 
            (place "Han1" coord:"E2") (place "Sa1" {"D1" "F1"}) (place "Sang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Cha1" {"A1" "I1"}) (place "Po1" {"B3" "H3"}) (place "Byeong1" {"A4" "C4" "E4" "G4" "I4"})
            (place "Cho2" coord:"E9") (place "Sa2" {"D10" "F10"}) (place "Sang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Cha2" {"A10" "I10"}) (place "Po2" {"B8" "H8"}) (place "Jol2" {"A7" "C7" "E7" "G7" "I7"})
        })
        
        (play (do (forEach Piece) ifAfterwards:"GeneralNotCheck" 
                (then 
                    (if 
                        "GeneralSameColumnWithNoPieceBetween"
                        "InitCounter"
                        "ResetCounter"
                    )
                )
            )
        )
        
        (end {
            (if (and 
                    ("GeneralEnemyCheck")
                    ("EnemyCannotMove")
                ) 
                (result Mover Win)
            )
            (if (and 
                    ("GeneralSameColumnWithNoPieceBetween")
                    ("SinceOnTurn") 
                )
                (result Mover Draw)
            )
        })
    )
)

Construct a Ludii game based on the following description
Kubuguza is a four-row mancala-style board game played by the Abatutsi people of Rwanda. It is unique in only allowing captured when the opponent's inner and outer rows contain counters.4x8 board. Four pieces in each of the holes in the inner two rows. Sowing occurs in an anti-clockwise direction. Single counters cannot be sown. When the final counter of a sowing falls into an occupied hole, these counters are picked up and the sowing continues. If this hole is in the player's inner row, the counters in the opponent's opposite holes in both rows are captured. Both the inner and outer opposite holes must contain counters for a capture to occur. Play continues with the captured counters, and the player sows these beginning with the next hole after the last one on the player's side from which they picked up holes. Captures cannot be made on the first move. Clockwise sowing can begin from the following holes only if it will allow a capture to occur: the rightmost and leftmost holes of the outer row, the second from the right and second from the left holes in the inner row. Direction can be changed in the middle of a turn if the final counter lands in one of these holes and a clockwise move will result in a capture. When no capture is available, the player must resume in an anti-clockwise direction. When the final counter falls into an empty hole, the turn ends.  
(game "Kubuguza" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "23,W,N1,E" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))          
        (regions "Home" P2 (sites Track "TrackCCW2"))          
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom)))  
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top)))   
        (regions "HolesCW" P1 (sites {15 8 1 6}))
        (regions "HolesCW" P2 (sites {16 23 25 30}))
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 3 to:(union (sites P1 "Inner") (sites P2 "Inner")))
        )
        
        (play 
            (or
                (move Select
                    (from 
                        (if ("SameTurn") 
                            (sites {(var "Replay")})
                            (sites Mover "Home") 
                        ) 
                        if:(> (count at:(from)) 1)
                    )
                    (then
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (and
                                    (if (and {
                                            (> (count Turns) 2)
                                            (is In (to) (sites Mover "Inner"))
                                            (is Occupied ("OppositeOuterPit" (to)))
                                            (is Occupied ("OppositePit" (to)))
                                        })	
                                        (and {
                                            (fromTo
                                                (from ("OppositeOuterPit" (to)))
                                                (to (last From))
                                                count:(count at:("OppositeOuterPit" (to)))
                                            )
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (last From))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (set Var "Replay" (last From))
                                        })
                                        (set Var "Replay" (to))
                                    )
                                    (moveAgain)
                                )
                            )
                        )
                    )
                )
                (move Select
                    (from 
                        (if ("SameTurn") 
                            (sites {(var "Replay")})
                            (sites Mover "HolesCW") 
                        ) 
                        if:(and {
                            (> (count at:(from)) 1)
                            (is In (from) (sites Mover "HolesCW"))
                            (if (is In ("NextHoleFrom" (from) "TrackCW" (count at:(from))) (sites Mover "Inner"))
                                (and
                                    (is Occupied ("OppositeOuterPit" ("NextHoleFrom" (from) "TrackCW" (count at:(from)))))
                                    (is Occupied ("OppositePit" ("NextHoleFrom" (from) "TrackCW" (count at:(from)))))
                                )
                                False
                            )
                        })
                    )
                    (then
                        (sow
                            "TrackCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (and
                                    (if (and {
                                            (> (count Turns) 2)
                                            (is In (to) (sites Mover "Inner"))
                                            (is Occupied ("OppositeOuterPit" (to)))
                                            (is Occupied ("OppositePit" (to)))
                                        })	
                                        (and {
                                            (fromTo
                                                (from ("OppositeOuterPit" (to)))
                                                (to (last From))
                                                count:(count at:("OppositeOuterPit" (to)))
                                            )
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (last From))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (set Var "Replay" (last From))
                                        })
                                        (set Var "Replay" (to))
                                    )
                                    (moveAgain)
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end ("ForEachPlayerNoMovesLoss"))
    )
)

Construct a Ludii game based on the following description
Patol is a race game played by Pueblo peoples of New Mexico. Typically played by boys, any number of people can play, and it is a race game with three sticks used as dice.Forty stones are arranged in a circle, with a larger gap between every tenth and eleventh stone. The gaps between the stones are the playing spaces. One piece per player. Any number of players. Three sticks used as dice, marked on one side and blank on the other. Throws are as follows: One marked side up = 3, two marked sides up = 2, three marked sides up = 10; all blank sides up = 5. Players enter their pieces from one of the wider gaps in the board, and chooses to move either clockwise or anti-clockwise. When  a player's piece lands on a space occupied by the opponent, the opponent's piece is sent back to the space in which they entered. The first player to complete the circuit wins. The game has 2 players. Captures are possible.
(game "Patol"
    (players <Player:num>)
    (equipment {
        ("FortyStonesWithFourGapsBoard"
            {
            (track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True)
            (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)
            }
        )
        (regions "Gates" (sites {36..39}))
        (piece "Marker" Each
            (if ("IsOffBoard" (value Player Mover))
                (or 
                    ("MoveOn" ("SiteToMoveOnTrackCW") ("RememberSelectedTrack" ("SelectCW")))
                    ("MoveOn" ("SiteToMoveOnTrackCCW") ("RememberSelectedTrack" ("SelectCCW")))
                )
                ("MoveOn" "SiteToMoveOnSelectedTrack")
            )
        )
        ("StickDice" 3)
        (map "ThrowDiceValue" {(pair 0 5) (pair 1 3) (pair 2 2) (pair 3 10)})
        (hand Each)
    })
    (rules 
        (start (place "Marker" "Hand"))
        phases:{
        (phase "Placement" 
            (play 
                (move
                    (from (handSite Mover))
                    (to (sites "Gates"))
                    (then (set Value at:(last To) (last To)))
                )
            )
            (nextPhase Mover "Playing")
        )
        (phase "Playing"
            (play 
                ("RollMove"
                    (forEach Piece)
                )
            )	
            (end 
                (if 
                    ("MadeACompleteCircuit")
                    (result Mover Win)
                )
            )
        )
        }
    )
)

Construct a Ludii game based on the following description
Gala is a game used to refer to at least two games played in the Makassar Peninsula of Sulawesi, Indonesia. This is the Buginese version, which is played on a larger board and the ability to capture in corners.7x7 board, with an X in each corner space, the middle space along each side, and the central space. Black plays with thirteen pieces, white plays with ten. Black places the first piece on the central square, then players alternate turns placing a piece on their own half of the board. When all of the pieces are placed, players alternate turns moving pieces one space orthogonally. A piece is captured when it is surrounded on two opposite sides by opponent's pieces, or if it is in the corner and there are two opponent's pieces blocking it from moving. Capturing cannot happen in the placement phase. Black wins if it can block white from being able to move. White wins if it is impossible for black to block them. 
(game "Gala (Buginese)"
    (players 2)
    (equipment {
        (board (square 7))
        (piece "Marker" Each
            ("StepToEmpty" Orthogonal
                (then 
                    (and
                        ("CustodialCapture" Orthogonal (max 1))
                        (surround 
                            (from (last To)) 
                            Orthogonal 
                            (between 
                                if:(and 
                                    ("IsEnemyAt" (between)) 
                                    (is In (between) (sites Corners))
                                )
                                (apply (remove (between)))
                            ) 
                            (to 
                                if:("IsFriendAt" (to))
                            )
                        )
                    )
                )
            )
        )
        (hand Each)
        (regions "HalfBoard" P1 (expand (sites Bottom) steps:3))
        (regions "HalfBoard" P2 (expand (sites Top) steps:3))
    })
    (rules 
        (start {
            (place "Marker1" (handSite P1) count:13)
            (place "Marker2" (handSite P2) count:10)
        })
        phases:{
        (phase "CentrePlacing" P1 
            (play 
                (move 
                    (from (handSite P1)) 
                    (to (centrePoint))
                )
            )
            (nextPhase "Placement")
        )
        (phase "Placement" P2
            (play 
                (if ("HandOccupied" Mover)
                    (move 
                        (from (handSite Mover)) 
                        (to (intersection (sites Empty) (sites Mover)))
                    )
                    (move Pass)
                )
            )
            (nextPhase (and ("HandEmpty" P1) ("HandEmpty" P2)) "Movement")
        )
        ("PhaseMovePiece" "Movement"
            (end { 
                (if (no Moves P2) (result P1 Win))
                (if (< (count Pieces P1) 2) (result P2 Win))
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Mangala is a word which refers to many two-row mancala-style board games throughout Western Asia and North Africa. This game was played by the Bedouin of the Arabian Peninsula in the early twentieth century.2x6 board. Seventy counters. One player distributes the counters unevenly in the central four holes (central two holes of each row). The opponent then has the option to flip the board around if they are not satisfied with the distribution. Opponent begins play. The first move must be from the fourth hole in the row. Sowing occurs in a clockwise direction. Capturing cannot happen on the first move. If the last counter is dropped into a hole, creating an odd number of counters in it, play ends. If the number is now even and the hole in the other player's row also has an even number, the contents of both holes are captured. If the final hole is now even but the other player's row does not have an even number of counters, the counters are picked up and a new sowing begins. If the final hole has more than ten counters it cannot be captured and sowing must continue from this hole whether the number is even or odd. Play ends when a player has no more counters on their side of the board. The player who has captured the greatest number of counters wins. 
(game "Mangala (Bedouin)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "5,W,N,E" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (hand Shared)
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top)) 
        (map "FourthHole" {(pair P1 3) (pair P2 8)})
    })
    
    (rules 
        
        (start (place "Seed" (handSite Shared) count:17))
        
        phases:{
        (phase "OpeningP1"
            (play 
                (move
                    (from (handSite Shared))
                    (to (sites Centre))
                    (then (if (is Occupied (handSite Shared)) (moveAgain)))
                )
            )
            (nextPhase (is Empty (handSite Shared)) "OpeningP2")
        )
        
        (phase "OpeningP2"
            (play 
                (or
                    (move Pass)
                    (if (is Mover P2) 
                        (move Pass 
                            (then
                                (and {
                                    (remove (sites Centre))
                                    (add (piece (id "Seed" Shared)) (to 9) count:(count at:2))
                                    (add (piece (id "Seed" Shared)) (to 2) count:(count at:9))
                                    (add (piece (id "Seed" Shared)) (to 8) count:(count at:3))
                                    (add (piece (id "Seed" Shared)) (to 3) count:(count at:8))
                                })
                            )
                        )
                    )
                )
            )
            
            (nextPhase (all Passed) "SowingRestricted")
        )
        
        (phase "SowingRestricted"
            (play
                (move Select
                    (from (mapEntry Mover) if:(is Occupied (from)))
                    (then (sow))
                )
            )
            (nextPhase Mover "Sowing")
        )
        
        (phase "Sowing"
            (play
                (move Select
                    (from
                        (if ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover) 
                        ) 
                        if:(> (count at:(from)) 0)		
                    )
                    (then
                        (sow
                            apply:(if (< 10 (count at:(to)))
                                (moveAgain)
                                (if (is Even (count at:(to)))
                                    (if (is Even (count at:("OppositePit" (to))))
                                        (and
                                            (fromTo
                                                (from (to))
                                                (to (handSite Mover))
                                                count:(count at:(to))
                                            )
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                        )
                                        (moveAgain)
                                    )
                                )
                            )		
                        )
                    )
                )
            )
            
            (end ("MancalaByScoreWhen" ("OneRowIsEmpty")))
        )
        }
    )
)

Construct a Ludii game based on the following description
This version of Shatranj was recorded in Algiers in the early twentieth century, and combines several movement and winning rules known in other variations of the game.8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. May move like an Asb if it is not in check and has never been in check. Place to a player's square right of center. 1 x Fers (counselor): Any distance orthogonally or diagonally; 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Any distance diagonally. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. Promoted to Fers when reaching the eighth rank. No en passant. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. The game ends in a draw only when a player's final piece, being a Sarbaz, is lost, that player's Shah captures the opponent's only remaining piece, a Sarbaz. 
(game "Shatranj (Algeria)" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn" ~ (then ("PromoteIfReach" (sites Mover "Promotion") "Ferz_noCross")))
        ("ChessRook" "Rook")
        (piece "King_noCross" Each 
            (or
                ("StepToNotFriend")
                (if (!= (value Player Mover) (mover))
                    ("LeapToEmpty" "KnightWalk"
                        (then (set Value Mover (mover)))
                    )
                )
            )	
        )
        ("ChessBishop" "Elephant")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Ferz_noCross")
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8") 
        })
        
        (play 
            (do 
                (forEach Piece) 
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
                (then
                    (if (!= (next) (value Player Next))
                        (if ("IsInCheck" "King_noCross" Next)
                            (set Value Next (next))
                        )
                    )
                )
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (= (count Pieces Next) 1) (result Mover Win)) 
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
Elea is a simple unification game of pure placement invented by Michael Amundsen in May 2022. There cannot be a tie in Elea.Players take turns placing a stone of their own color on any empty cell of a hexagonal grid of hexagons (a hexhex board). 
            The game is over when the board is full, and the player with the lower score wins. 
            Your score is 1 point per odd-sized group and 2 points even-sized group.
            
        In this implementation, you get -1 per odd-sized group and -2 per even-sized group, so the winner will be the player with the higher score. The score is currently updated after each move, and groups of even size are marked with a red outline. A size 3 board is currently selected
(game "Elea"
    (players 2)
    (equipment {
        (board (hex <Size>))
        (piece "Disc" Each)
    })
    (rules
        (meta (swap))
        (play
            (move Add
                (to (sites Empty))
                (then <Score>)
            )
        )
        (end 
            (if (is Full) 
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Bày Khòm is a two-row mancala-style board game from Cambodia. It was observed in the mid-twentieth century, but it is possible that Khmer texts from the middle ages mention it as \2x4 board with two stores on either end, the store on a player's right belonging to them. Four counters per hole, five in each store. Players sow in the direction of their choosing from one of the holes in their row, not from the stores, on each turn, sowing also into the stores. If the next hole has counters, these are picked up and sowing continues with these counters. When this next hole is empty, the counters in the next hole after that are captured and the turn ends. If there are a series of alternating empty holes and holes with counters, the counters in these holes are captured until two empty or full holes are reached. When the point of the game is reached that play cannot continue, the players claim the counters in their holes, and a new game begins. The players refill their holes, beginning with their store, which receives five counters, and four in each other. Holes are only filled with exactly four counters, any extra are set aside. If a player cannot fill any of their holes with counters, these holes are eliminated from play. Play continues in this way until one player captures all of the counters or the other player cannot fill any holes. 
(game "Bay Khom" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 4
            {
            (track "TrackCW" "0,5,E,9,4,W" loop:True)
            (track "TrackCCW" "0,1,E,9,8,W" loop:True)
            }
        )
        (piece "Seed" Shared) 
        (map {(pair P1 LastSite) (pair P2 FirstSite)}) 
        (regions P1 (sites Bottom))     
        (regions P2 (sites Top))      
        (hand Each)
    }) 
    (rules 
        
        (start { 
            (set Count 4 to:(union (sites P1) (sites P2))) 
            (set Count 5 at:(mapEntry 1)) 
            (set Count 5 at:(mapEntry 2))
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Sowing"
            (play 
                (or
                    (if (or (<= (var "Direction") 0) (= (var "Direction") 1))
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    ("LastHoleSowed") 
                                    ("OwnedHoles")
                                )
                                if:(is Occupied (from))
                            )
                            (then
                                (sow
                                    "TrackCW"
                                    apply:("CaptureMove" "TrackCW" (set Var "Direction" 1))
                                )
                            )
                        )
                    )
                    (if (or (<= (var "Direction") 0) (= (var "Direction") 2))
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    ("LastHoleSowed") 
                                    ("OwnedHoles")
                                )
                                if:(is Occupied (from))
                            )
                            (then
                                (sow
                                    "TrackCCW"
                                    apply:("CaptureMove" "TrackCCW" (set Var "Direction" 2))
                                )
                            )
                        )
                    )
                    (then
                        (if ("AllRowsEmpty")
                            (and { 
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (if (is Occupied (mapEntry P1))
                                    (fromTo
                                        (from (mapEntry P1))
                                        (to (handSite P1))
                                        count:(count at:(mapEntry P1))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (if (is Occupied (mapEntry P2))
                                    (fromTo
                                        (from (mapEntry P2))
                                        (to (handSite P2))
                                        count:(count at:(mapEntry P2))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 9 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 9 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (is Empty (mapEntry Mover))
                    (move
                        (from (handSite Mover))
                        (to (mapEntry Mover))
                        count:5
                    )
                    (if (<= 4 (count Cell at:(handSite Mover)))
                        (move 
                            (from (handSite Mover))	
                            (to (sites Mover) if:(is Empty (to)))
                            count:4
                            (then
                                ("RemmemberOwnedHoles" (last To))	
                            )
                        )
                    )
                )	
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Sig wa Duqqan is a race game played on the island of Djerba, Tunisia. This game is a representation of the Hajj, where fathers attempt to reach the Ka'aba without being captured and buried by the Ghoula.4x4 board, with an extension of four squares extending from the left of the bottom row. Two or more players, each with one piece. A piece of charcoal plays the part of the Ghoula. Four sticks, with one green side and one white side, used as dice. The throws are as follows: One white side up = 1, this throw is known as \ The game has 2 players.
(game "Sig wa Duqqan (Houmt al-Arbah)"
    (players <Player:num>)
    (equipment {
        (board 
            (merge {
                (shift -4 0 (rectangle 1 4))
                (square 4)
                (shift -4 3 (square 1))
            })
            {
            (track "Track" "16,E,S1,W,S1,E,S1,W2" directed:True)
            (track "ExtensionTrack" "4,W" directed:True)
            (track "GhoulaTrack" "20,16,E,S1,W,S1,E,S1,W2" directed:True)
            (track "ReverseGhoulaTrack" "6,E,N1,W,N1,E,N1,W" directed:True)
            }
        )
        (piece "Ghoula" Neutral)
        (piece "Stick" Each
            (if (= (from) ("EndTrack"))
                (if (= (state at:(from) level:(level)) 8)
                    (move 
                        (from (from) level:(level))
                        (to ("BeginningExtensionTrack"))
                    )
                    (if ("Sig")
                        (move Select
                            (from (from) level:(level))
                            (then 
                                (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo))))
                            )
                        )
                    )
                )
                (if (is In (from) (sites Track "Track"))
                    (move
                        (from (from) level:(level)
                            if:(if ("ActivatedPiece" (from) (level))
                                True
                                ("Sig")
                            )
                        )
                        (to
                            ("SiteToMoveOnTrack" "Track" ("ThrowValue"))
                            if:True
                        )
                        (then
                            (if (not ("ActivatedPiece" (last To) (topLevel at:(last To))))
                                ("ActivePiece" (last To) (topLevel at:(last To)))
                            )
                        )
                    )
                    (if (is In (from) (sites Track "ExtensionTrack"))
                        (or {
                            (if (and (!= (from) ("Kaaba")) ("Sig"))
                                (move
                                    (from (from) level:(level))
                                    (to ("SiteToMoveOnTrack" "ExtensionTrack" 1))
                                )
                            )
                            (if (= (from) ("Kaaba"))
                                (move Pass
                                    (then
                                        (and
                                            (if (= 0 ("ThrowValue"))
                                                (set Var 2)
                                                (set Var ("ThrowValue"))
                                            )
                                            (moveAgain)
                                        )
                                    )
                                )
                                (if (= 3 ("ThrowValue"))
                                    (move Pass
                                        (then
                                            (and
                                                (set Var 3)
                                                (moveAgain)
                                            )
                                        )
                                    )
                                )
                            )
                        })
                    )
                )
            )
            maxState:8
        )
        ("StickDice" 4)
        (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)})
    })
    (rules 
        (start { 
            (place Stack "Ghoula0" ("ExternalSite"))
            <Player:start>
        })
        (play 
            (do (if (<= (var) 0) (roll)) 
                next:(if (> (var) 0)
                    ("MoveGhoula")
                    (if (!= 0 ("ThrowValue")) (forEach Piece))
                )
                (then
                    (if ("IsSpecialThrow")
                        (moveAgain)
                    )
                )
            )
        )
        (end {
            (forEach Player
                if:(no Pieces Player) 
                (result Player Loss)
            )
            (forEach Player
                if:("GhoulaPhaseDone")
                (result Player Win)
            )
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Tabu Y" 
    (players 2) 
    (equipment { 
        (board (hex Triangle <Board>)) 
        (piece "Disc")
    }) 
    (rules 
        (play
            (move Add 
                (to (sites Empty) 
                    if:(not (is In (to) (sites Around (last To))))
                ) 
            )
        )
        (end 
            (if (is Connected 3 Sides) 
                (result Mover <Result>) 
            ) 
        )
    )
)
Place pieces to connect all three board sides.Players take turns placing one piece of their colour on empty cells; the piece they place may not be adjacent to the last piece placed by their opponent. A player wins by connecting all three board sides with a connected group of their pieces. Played on a size 3 board. The first player to connect all three sides wins.

Construct a Ludii game based on the following description
Dèleb is a game with captures played in Somalia. It is played with teams, and often is played on a large board. One defining feature of it is the requirement of making a series of throws in order to start playing. It is similar to games such as Tab known in North Africa and Southwest Asia. Board of intersecting lines: four horizontal and up to 100 vertical. Twenty is typical. Played on two teams with even-numbered players. One piece per vertical line, lined up on the outer rows. Four sticks, white on one side and black on the other, used as dice. The value of the throw is the number of white sides that land face up, when only black are face up, the value is 6. Each player must progress through the following three stages of throws to begin playing. In the first stage, they throw four sticks. A throw of 2 or 3 ends the turn, a throw of 4 or 6 gives another throw. A throw of 1 allows the player to progress to the next stage and to add 1 to their score. In the second stage, the player throws three sticks. If the player throws two or three black, they add 1 to their score and keep throwing, three white up allows the player to add 4 to their score and keep playing; one black face up allows the player to pass to the third stage. In the third stage, the player throws two sticks. If two black are thrown, all of the previously tabulated score is lost, the turn ends and the player must start again from the first stage in their next turn. If the player throws two white, the player scores 4 and reverts back to the second phase. When the player scores one white and one black, the player enters the game and plays the pieces according to their accumulated score. Each piece must be unlocked with a throw of 1 before being  moved normally. From this point, players throw all four sticks. Throws of 2 or 3 end the turn, players continue to throw until they receive one of these values. Each throw must be assigned to move a piece and a single throw cannot be subdivided, though separate throws can be assigned to different pieces. Players may choose not to play a throw if they wish. Throws of 1 must be used to unlock a piece if there are any which are locked. Pieces move from left to right in their home row, right to left in the second row, left to right in the third row, right to left in their opponent's home row, returning to the third row and progressing from left to right, then to the second row progressing from right to left, and then back into the home row, proceeding from left to right, and so in a loop. Pieces may not pass the pieces of the opposing team. When a piece lands on the same space occupied by an opponent's piece, the opponent's piece is removed from the board. The team that captures all the pieces of the opposing team wins. The board has 10 columns.
(game "Deleb"
    (players 4)
    (equipment {
        (board
            (rectangle 4 <Board:size>)
            <Board:tracks>
            use:Vertex
        )
        ("StickDice" 4)
        (piece "Marker" P1 ("Move"))
        (piece "Marker" P2 ("Move"))
        (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)})
    })
    (rules 
        (start {
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
            (place "Marker1" (sites Bottom))
            (place "Marker2" (sites Top))
        })
        phases:{
        
        (phase "StageOne" 
            (play 
                ("RollMove"
                    (move Pass)
                    (then
                        (if (or 
                                (= ("ThrowValue") 6)
                                (= ("ThrowValue") 4)
                            )
                            (moveAgain)
                            (if (= ("ThrowValue") 1)
                                ("Remember" 1)
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (= ("ThrowValue") 1) "StageTwo")
        )
        
        (phase "StageTwo" 
            (play 
                ("RollMove"
                    (move Pass)
                    (then
                        (if (or 
                                (= 0 ("ThrowThreeDice"))
                                (= 1 ("ThrowThreeDice"))
                            )
                            (and
                                (moveAgain)
                                ("Remember" 1)
                            )
                            (if (= 3 ("ThrowThreeDice"))
                                (and
                                    (moveAgain)
                                    ("Remember" 4)
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (= ("ThrowThreeDice") 2) "StageThree")
        )
        
        (phase "StageThree" 
            (play 
                ("RollMove"
                    (move Pass)
                    (then
                        (if 
                            (= 0 ("ThrowTwoDice"))
                            ("ForgetAll")
                            (if (= 1 ("ThrowTwoDice"))
                                (moveAgain)
                                (and
                                    (moveAgain)
                                    ("Remember" 4)
                                )
                            )
                        )
                    )
                )
            )
            {
            (nextPhase Mover (= 0 ("ThrowTwoDice")) "StageOne")
            (nextPhase Mover (= 2 ("ThrowTwoDice")) "StageTwo")
            (nextPhase Mover (= 1 ("ThrowTwoDice")) "PlayingScore")
            }
        )
        
        (phase "PlayingScore" 
            (play 
                (if (can Move ("PlayRulesPlayingScore"))
                    ("PlayRulesPlayingScore")
                    (move Pass (then ("ForgetAll")))
                    (then 
                        (if (!= 0 (size Array ("RememberedValues"))) 
                            (moveAgain)
                        )
                    )
                )
            )	
            (nextPhase Mover (= 0 (size Array ("RememberedValues"))) "Playing")	
        )
        
        (phase "Playing" 
            (play 
                ("RollMove" (or 
                        (if (or (is Mover P1) (is Mover P3)) 
                            (forEach Piece P1) 
                            (forEach Piece P2)
                        )
                        (move Pass)
                    )
                    (then
                        (if (and (!= 2 ("ThrowValue")) (!= 3 ("ThrowValue")))
                            (moveAgain)
                        )
                    )
                )
            )		
        )
        
        }
        (end ("CaptureAllTeam"))
    )
)

Construct a Ludii game based on the following description
Annuvin is played on a hexagonal board (4 hexagons on a side) with 6 pieces per player arranged in opposite corners.MOVE - A stone can move up to N spaces in any combination of directions (it may even move over intervening stones), where N varies depending on the number of stones he has remaining:
            - Six pieces: one space per turn
            - Five pieces: two spaces per turn
            - Four pieces: three spaces per turn
            - Three pieces: four spaces per turn
            - Two pieces: five spaces per turn
            - One piece: six spaces per turn.
            
            CAPTURE - A stone captures an opposing piece by moving onto it. If a stone makes a capture before it has used all of the spaces available to it that move, it may continue to make additional captures until it has moved its limit.
            
        GOAL - Wins the player who captures all of his opponent's stones, or, if he reduces his opponent to a single stone without losing any of his own. 
(game "Annuvin"
    (players 2)
    (equipment {
        (board (rotate 30 (hex 4)))
        (piece "Ball" Each ("PieceMovement"))
        (hand Each)
    })
    (rules
        (start {
            (place "Ball1" (difference (union {(sites Side NW) (sites Side NE) (expand (sites Side N))}) (union (sites Left) (sites Right))))
            (place "Ball2" (difference (union {(sites Side SW) (sites Side SE) (expand (sites Side S))}) (union (sites Left) (sites Right))))
        })
        (play
            (if ("SameTurn")
                ("PieceMovement" (from (last To)))
                (forEach Piece)
            )
        )
        (end 
            (if 
                (or 
                    (and (= 1 (count Pieces Next)) (= 6 (count Pieces Mover))) 
                    (no Pieces Next)
                )
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Musinaykahwhanmetowaywin is a hunt game played by the Chippewa and Cree people. Players play as an Oke-mow (\Played on cross-shaped board, made of five squares, each divided into four squares and with the diagonals of the larger squares drawn. One player plays with one larger piece, the Oke-mow, placed on the central point, and the other player with thirteen pieces situated on every point of one arm of the cross and along the line immediately perpendicular to that arm. Pieces move along the lines to an adjacent empty spot. The Oke-mow may jump over an adjacent piece to capture it. Multiple captures are allowed. The Oke-mow wins if it can capture all the opponent's pieces, the other player wins by blocking the Oke-mow from moving.
         
(game "Musinaykahwhanmetowaywin" 
    (players 2) 
    (equipment { 
        ("CrossBoard" 3 7 use:Vertex diagonals:Alternating)
        (piece "Marker" P1 (or ("HopSequenceCapture") ("StepToEmpty")))
        (piece "Disc" P2 ("StepToEmpty")) 
    }) 
    (rules 
        (start { 
            (place "Disc2" (union (expand (sites Bottom)) (sites Row 2)))
            (place "Marker1" (centrePoint))
        })
        
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("NoMovesP1NoPiecesP2"))
    )
)

Construct a Ludii game based on the following description
Sabou'iyya is a smaller version of Kharbga played in northern Tunisia. It is generally played in the sand, with pebbles, date pits, shells, or camel droppings as pieces. Typically, it is played in rounds, and the winner plays first in subsequent rounds. It is widely thought to be simpler than the larger Khamousiyya, and it is believed that the first player should win.5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on the board. The first piece of each player must be placed on a spot adjacent to the central spot. The central spot cannot be filled. When both players have placed their pieces, they move their pieces orthogonally to an empty adjacent space. When an opponent's piece is surrounded on two opposite sides by pieces belonging to the player, the opponent's piece is captured. The player who made the capture may move the same piece they moved to make a capture another time if another capture is possible by doing so.
            
            The player who captures all of their opponent's pieces, or which blocks the opponent from being able to move, wins.
            
            In a case where the second player has created a blockade of their pieces containing one or more of only their own pieces which can move infinitely without possibility of being taken, the second player player may declare H'ajeb in order to regain the possibility of winning. The second player declares H'ajeb on their turn, and then the first player gains the ability to move any distance orthogonally or diagonally. The first player may also make multiple captures not just with the same piece, but with more than one. The second player may rescind the H'ajeb declaration at any time and the captures must stop. If the second player allows the first player to continue until the first player cannot capture, the second player captures any two of the first player's pieces, and the first player captures one of the second player's pieces that is able to move infinitely.
         
(game "Sabou'iyya"
    (players 2)
    (equipment {
        (board (square 5))
        (piece "Marker" Each 
            ("StepToEmpty" Orthogonal
                (then ("CustodialCapture"
                        Orthogonal
                        (max 1)
                        (then
                            (if ("CanCaptureAgain")	
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        (hand Each)
    })
    (rules
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover))
                    (to 
                        (if (= 0 (count Pieces Mover in:(sites Board)))
                            (forEach
                                (sites Around (centrePoint) Orthogonal)
                                if:(is Empty (site))
                            )
                            (difference (sites Board) (centrePoint)) 
                        )
                        if:(is Empty (to))
                    )
                    (then
                        (if ("NewTurn") (moveAgain))
                    )
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Capture")
        )
        (phase "Capture"
            (play 
                (if ("SameTurn")
                    (or
                        (move Step
                            (from (last To))
                            Orthogonal 
                            (to if:("IsConfigurationToCustodialAgain"))	
                            (then
                                ("CustodialCapture"
                                    Orthogonal
                                    (max 1)
                                    (then
                                        (if ("CanCaptureAgain")	
                                            (moveAgain)
                                        )
                                    )
                                )
                            )
                        )
                        (move Pass)
                    )
                    (forEach Piece) 
                )
            )	
        )
        }
        (end ("BlockWin"))
    )	
)

Construct a Ludii game based on the following description
Yeung Luk Sz' Kon Tseung Kwan is a hunt game that was played in Nanjing in the seventeenth century. It was described by Shen Fuzong, a Chinese man who taught the English scholar Thomas Hyde about Chinese culture. It was played by young men, and was considered a game to teach war strategy.5x9 intersecting lines; with a triangle formed by lines drawn from the second and fourth line of one of the short sides of the rectangle, with the base and a line bisecting the base of the triangle. One player plays as the General, placed on the central space of the rectangle, and the other player plays as 26 Rebels, places on the intersections of the second, third, and fourth of the long lines. Pieces move one space orthogonally. The General may capture one of the Rebels by hopping over it to an empty space. The General wins by capturing all the Rebels. The Rebels win by blocking the General from moving. P1 wins in blocking P2 to move. P2 wins in capturing by hopping all the pieces of P1.
(game "Yeung Luk Sz' Kon Tseung Kwan" 
    (players 2) 
    (equipment { 
        (board
            (merge
                (rectangle 9 5)
                (shift 1 8 (scale 0.5 (wedge 3)))
            )
            use:Vertex
        )
        <Variant:pieceMoves>
    }) 
    (rules 
        (start { 
            (place "Marker1" (union {(sites Column 1) (difference (sites Column 3) (union (sites Centre) (expand (sites Top)))) (sites Column 5)}))
            (place "Marker2" (centrePoint))
        })
        
        (play (forEach Piece)) 
        
        <Variant:endRules>
    )
)

Describe the mechanics of the following Ludii game
(game "Paintscape"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Disc" Each)
        (piece "Square" Shared maxState:5)
    })
    (rules
        (start {
            (place Random (sites Empty) {"Disc1" "Disc2"} count:2)
            (place Random (sites Empty) {"Square"} count:12 state:1)
            (place Random (sites Empty) {"Square"} count:12 state:2)
            (place Random (sites Empty) {"Square"} count:12 state:3)
            (place Random (sites Empty) {"Square"} count:12 state:4)
            (place Random (sites Empty) {"Square"} count:12 state:5)
        })
        phases:{
        <Balance>
        (phase "Play"
            (play
                (move Add
                    (to 
                        (sites Around 
                            (sites Occupied by:Mover)
                            Orthogonal
                        )
                        if:(not
                            (or
                                (= (mover) (who at:(to)))
                                (= (next) (who at:(to)))
                            )
                        )
                    )
                    stack:True
                    (then
                        (if 
                            (and
                                (= 3 (who at:(last To) level:0))
                                (= 6
                                    (count Sites
                                        in:(forEach
                                            (sites Occupied by:Mover)
                                            if:(= 
                                                (state at:(last To) level:0)
                                                (state at:(site) level:0)
                                            )
                                        )
                                    )
                                )
                            )
                            (and
                                (remove
                                    (forEach
                                        (sites Board)
                                        if:(= 
                                            (state at:(last To) level:0)
                                            (state at:(site) level:0)
                                        )
                                    )
                                    count:2
                                )
                                (addScore Mover 1)
                            )
                        )
                    )
                )
            )
        )
        }
        (end
            (if
                (or
                    (= 3 (score P1))
                    (= 3 (score P2))
                )
                (byScore)
            )
        )
    )
)
Paintscape is a colorful territory game played on a Chess board with colored tiles and black and white stones. It was invented by Michael Amundsen fall 2022.Paintscape is a game for two players – Black and White – played on the squares (cells/faces) of a square grid with 8 squares per side (e.g. a Chess board). 
            You also need a large supply of black and white stones and 5 distinguishable (e.g. by color) shared sets of 12 tiles. That is, each of the 5 sets contain 12 tiles, for 60 tiles in total.
            
            Setup:
            Before play begins, all 60 tiles and 2 white and 2 black stones are distributed randomly on the 64 squares of the board.
            A short balancing phase then ensues:
            
            One player swaps the position of any number of stones with a tile. That is, for 0, 1, 2, 3, or 4 of the stones, swap its position with any tile.
            When all stones have been swapped, or the swapping player passes, indicating that they do not wish to swap any more stones, the other player choses to play first as Black or second as White in the proper playing phase.
            (To show the button for swapping in Ludii, you might have to click the three dots next to the pass button.)
            
            The balancing phase can be skipped by new players, or you can agree on a fixed setup for the 4 initial stones.
            
            Play:
            In this phase (the proper playing phase), players take turns, starting with Black, placing stones of their own color.
            On your turn, place a stone of your color on a square adjacent to one of your stones already on the board.
            You may not place a stone on a square occupied by a stone. I.e. the square you place at must be empty or only occupied by a tile.
            Stones placed on tiles normally just stack on top of them, however:
            If a placement makes you have a stone on half of the tiles of a certain color, remove all tiles of that color along with the stones stacked on top of them (regardless of whether they're friendly or enemy).
            
            The goal:
        You win if you remove 3 of the 5 colors. The balance protocol is currently in force.

Construct a Ludii game based on the following description
Domineering is a mathematical game, typically played on a sheet of paper with a grid, and with dominoes. Players take turns placing dominoes until one can no longer play.Two players have a collection of dominoes which they place on the grid in turn, covering up squares. One player places tiles vertically, while the other places them horizontally. The first player who cannot move loses. The board has 1 row. The board has 2 columns. The Last player to play wins.
(game "Domineering" 
    (players 2) 
    (equipment { 
        (board (rectangle <Rows:num> <Columns:num>)) 
        (tile "Horz" P1 {R F} numSides:4)
        (tile "Vert" P2 {F} numSides:4)
    }) 
    (rules 
        (play 
            (move Add 
                (piece (mover) state:0) 
                (to (sites Empty))
            )
        )
        (end ("NoMoves" <End:result>))
    )
)

Describe the mechanics of the following Ludii game
(game "Dala"
    (players 2) 
    
    (equipment { 
        (board (square 6))
        (hand Each)
        (piece "Stick" Each 
            (if (is Line 4 Orthogonal through:(from) exact:True)
                ("StepToEmpty" Orthogonal
                    (then
                        (and {
                            ("CheckLine3LastFrom" N)
                            ("CheckLine3LastFrom" S)
                            ("CheckLine3LastFrom" E)
                            ("CheckLine3LastFrom" W)
                        })
                    )
                )
                ("StepToEmpty" Orthogonal "IfLine3MoveAgain")
            )
        )
    }) 
    (rules 
        (start (place "Stick" "Hand" count:12))
        
        phases:{
        (phase "PlacementCenter"
            (play ("AddPieceTo" "FreeCentreSites"))
            (nextPhase "IfCentreFull" "Placement")
        )	
        
        (phase "Placement"
            (play 
                (if (!= 0 (score Mover))
                    "RemoveEnemyPiece"
                    ("AddPieceTo" (to (sites Empty)) "IfLine3MoveAgain")
                )
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        (phase "Movement"
            (play   
                (if (!= 0 (score Mover))
                    "RemoveEnemyPiece"
                    (forEach Piece) 
                )
            )
            
            (end ("HavingLessPiecesLoss" Next 2))
        )
        }
    )
)
Dala is a game of alignment played by older children among the Baggara peoples in Sudan. These rules come from the Homr people, but Riziegat people were observed playing a similar game. Davies implies they played with the same rules.6x6 board. Each player has twelve sticks. One player's sticks are without bark to distinguish them. Players placing their sticks in empty spaces, filling the central four first. Once all of the sticks have been placed, the players may move their sticks orthogonally one space. If a player can bring three of their sticks in a row, they may then remove one of the opponent's sticks during either phase of the game. During the movement phase, if a player has a row of four pieces and moves one away, leaving a row of three spaces, this also allows the player to capture an opponent's piece. The player who can no longer play loses. 

Describe the mechanics of the following Ludii game
(game "Pachesi" 
    (players 4) 
    (equipment { 
        ("PachisiBoard" 
            {
            (track "Track1" "96,9,S,W,N,7,W,N,E,51,N,E,S,43,E,S,W,10,S,W1,N7,End" P1 directed:True)
            (track "Track2" "96,26,W,N,E,51,N,E,S,43,E,S,W,10,S,W,N,7,W,N1,W7,End" P2 directed:True)
            (track "Track3" "96,52,N,E,S,43,E,S,W,10,S,W,N,7,W,N,E,51,N,E1,S7,End" P3 directed:True)
            (track "Track4" "96,27,E,S,W,10,S,W,N,7,W,N,E,51,N,E,S,43,E,S1,W7,End" P4 directed:True)
            }
        )
        ("StickDice" 7)
        (piece "Pawn" Each
            (if ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) ("ThrowValue")))
                (move Remove (from) level:(level))
                (if (and ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) 1)) ("IsSpecialThrow"))
                    (move Remove (from) level:(level))
                    (move 
                        (from (from) level:(level))
                        (to
                            ("SiteToMoveOnTrack" from:(from) ("ThrowValue"))
                            if:(not (and (is In (to) (sites "SafeSites")) ("IsEnemyAt" (to))))
                            ("HittingStackCapture" (centrePoint))
                        )
                    )
                )
            )
        )
        (hand Each)
        (regions "SafeSites" (sites {55 63 65 34 15 47 94 84 86 19 38 3}))
        (map "Throw" {(pair 0 7) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 30) (pair 7 12)})
    }) 
    (rules 
        (start {
            (place Stack "Pawn1" (handSite P1) count:4)
            (place Stack "Pawn2" (handSite P2) count:4)
            (place Stack "Pawn3" (handSite P3) count:4)
            (place Stack "Pawn4" (handSite P4) count:4)
        })
        
        (play 
            ("RollMove"
                (or
                    (if (and (is Occupied (handSite Mover)) ("IsSpecialThrow"))
                        (move
                            (from (handSite Mover))
                            (to (centrePoint))
                        )
                    )
                    (forEach Piece)
                )
            )
        )
        
        (end ("EscapeWin"))
    )
)
Pachesi is a race game played on a cross-shaped board, of which there are several versions in South Asia. This version is played near Chitrakoot Dham in central India.Four 3x8 rectangles, arranged in a cross. The couting from the bottom of each arm, the spaces marked are the fourth square in the outer rows and the first in the central row. Four pieces per player. Seven cowrie shells, used as dice. The throws are as follows: one mouth up = 10; two mouths up = 2; three mouth up = 3; four mouths up = 4; five mouths up. = 25; six mouths up = 30, seven mouths up = 12, zero mouths up = 7. Pieces begin in the large central space of the board, and then proceed down the central row of their arm, then clockwise around the board, back to the central row, and then to the central space again. Pieces may enter the board on throws of 10, 25, or 30. When a player's piece lands on a space that is occupied by an opponent's piece, the opponent's piece is sent back to start. Pieces are safe from being sent to start when they rest on a marked space. To move off the board, a player must make an exact throw to arrive in the central square. When resting on the final square before the central one, a throw of 10, 25, or 30 is required. The first player to place all of their pieces in the central square wins.  

Construct a Ludii game based on the following description
Fondji is a two-row mancala-style board game that was played in Dahomey in the early twentieth century. It is similar to other two-row mancala games from the region, like Oware.2x6 board, with a storage hole on either end. The game starts with four counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a counterclockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. Players capture counters when the final counter is sown in the player's own row and the hole containing it has two or three counters (counting the counter just dropped into it). If the hole before it also has two or three counters, these are also captured and so on until reaching a hole without two or three counters or one not belonging to the player. If an opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row.
         
(game "Fondji" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))		 
        (play 
            (if (is Proposed "End")
                (or (move Vote "End") (move Vote "No"))
                (or
                    (if (is Cycle) (move Propose "End")) 
                    (do 
                        (move Select 
                            (from 
                                (sites Mover) 
                                if:(< 0 (count at:(from)))
                            )
                            (then 
                                (sow 
                                    if:(and 
                                        (is In (to) (sites Next)) 
                                        (or 
                                            (= (count at:(to)) 2) 
                                            (= (count at:(to)) 3)
                                        )
                                    ) 
                                    apply:(fromTo 
                                        (from (to)) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:(to))
                                    )
                                    includeSelf:False
                                    backtracking:True
                                )
                            )
                        )
                        ifAfterwards:(< 0 (count in:(sites Next)))
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (or (no Moves Mover) (is Decided "End"))))
    )
)

Construct a Ludii game based on the following description
Shakhmaty is a Chess game played in Russia that developed in parallel to Chess in Westerm Europe.Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space orthogonally forward, or two steps orthogonally forward on their first move, capture one space diagonally forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. Castling, En Passant, and Pawn promotion allowed. Play begins by each player moving two of their pieces in the same turn, provided that neither enter the opponent's half of the board. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins.
         
(game "Shakhmaty" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        (piece "Pawn" Each 
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
                )
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                "EnPassant"
                }
                (then
                    (if (is In (last To) (sites Mover "Promotion")) 
                        (moveAgain)
                    )
                )
            )
        )
        
        (piece "Rook" Each 
            (move
                Slide 
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPiece"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "King" Each 
            (move
                Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "Bishop" Each 
            (move
                Slide 
                Diagonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "Knight" Each 
            (move
                Leap 
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece"
                ) 
            )
        )
        (piece "Queen" Each 
            (move
                Slide 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPiece"
                ) 
            ) 
        )
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
        (regions "Half" P1 (expand (sites Bottom) steps:3))
        (regions "Half" P2 (expand (sites Top) steps:3))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        phases:{
        (phase "Opening" 
            (play 
                (do 
                    (forEach Piece)
                    ifAfterwards:(and (is In (last To) (sites Mover "Half")) (not ("IsInCheck" "King" Mover)))
                    (then (if ("NewTurn") (moveAgain)))
                )
            )
            (nextPhase Mover ("SameTurn") "Playing")
        )
        (phase "Playing"
            (play 
                (if "SameTurn"
                    (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                    (do 
                        (or 
                            (forEach Piece)
                            (if (and 
                                    ("HasNeverMoved" "King")
                                    (not ("IsInCheck" "King" Mover)) 
                                )
                                (or
                                    (if (and 
                                            ("HasNeverMoved" "RookLeft")
                                            (can Move ("CastleRook" "RookLeft" E 3 (is Empty (to))))
                                        )
                                        "BigCastling"
                                    )
                                    (if (and 
                                            ("HasNeverMoved" "RookRight")
                                            (can Move ("CastleRook" "RookRight" W 2 (is Empty (to))))
                                        )
                                        "SmallCastling"
                                    )
                                )
                            )
                        )
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
            )
        )
        }
        
        (end 
            (if (and 
                    ("IsInCheck" "King" Next)
                    ("NextCanNotMove")
                ) 
                (result Mover Win)
            ) 
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Astralesce and Constellation"
    (players 2)
    (equipment {
        (board (hex Hexagon <Board:side>) use:Cell)
        (piece "Disc" Each)
    })
    (rules
        (start {<Board:white> <Board:black>})
        (play
            <Game:structure>
        )
        (end 
            <Game:winCondition>
        )
    )
)
'Astralesce' and 'Constellate' are games based loosely on Kanare Kato's 'Advanced Squish'.        The mechanism found in 'advanced Squish' of: 'move toward in-line-targets that are part of larger groups', is extended in these games to a future look-ahead restriction, i.e.:    'move along a line from a starting location to a location that is in line with a larger group than the moving piece had been in line with before.'        This is inherently difficult perceptually, and it remains to be seen if the game can be played without the assistance of an app.        However the game is both interesting and exciting, and appears to have various levels of strategy.               The goal is unification, and causing a stalemate before achieving the goal is considered a loss.        'Astralesce' has sliding moves and captures that can remove multiple pieces. Thus stalemate is impossible, as the opponent cannot block movement. This is the preferred game.        'Constellation' also has sliding moves, but only allows capture at the move's desination. This means opponent's pieces can block some potential destinations. Astralesce: Capturing every opponent's piece along the way, slide a piece to a location in-line with larger groups than the piece had been in-line with before moving. (A group is considered in-line if it contains the first friendly piece along any of the 6 radial grid directions.) Win when unified; if tied, the mover wins. Order 4 board

Construct a Ludii game based on the following description
Cages is a drawless checkers variant that always ends in one player eliminating the other. Mark Steere designed Cage in 2010.Cage is a checkers variant for two players played on a square 10x10 board. In this implementation you also have the option of playing on smaller boards. In the initial position, 50 checkers of one color and 50 checkers of a different color fill up the board in a checkered pattern. The goal of the game is to capture all your opponent's checkers.
            
            On your turn, if you can, you must choose one of two different kinds of moves to perform:
            • a single step, or
            • a sequence of jumps.
            Note: A single jump is considered a jump sequence of length 1.
            
            Universal restriction:
            All moves are subject to the following restriction:
            • At no time may a checker be orthogonally adjacent to a checker of the same color.
            
            Stepping:
            Stepping is moving one of your checkers to an orthogonally or diagonally adjacent empty square, and this kind of move is subject to the following two additional restrictions:
            • A step my never bring the number of orthogonal enemy neighbors of the moved checker down to 0.
            • The only condition under which a step may fail to bring the moved checker closer to the center of the line you are moving along is if it brings its number of orthogonal enemy neighbors up from 0.
            
            (Some elaboration on this last restriction: In general, a step must decrease the moved checker's straight line distance to the board's central intersection. That's the same as bringing it closer to the center of the orthogonal or diagonal line you are moving along. (Note: The center of a diagonal line is an intersection if it is an even number of squares long, and a square otherwise. The center of an orthogonal line is an edge if it is an even number of squares long, and a square otherwise.) Here is a different way of putting it: Whatever diagonal or orthogonal line you are stepping along, the largest distance to an edge square on this line before the step must be bigger than the largest distance to an edge square on the same line after the step. The only exception to this rule, as explained in the last restriction, is if your checker has no orthogonal neighbors and can step into such a relationship – then you may step in any direction.)
            
            Jumping sequences:
            If a checker of your color is orthogonally adjacent to an enemy checker, and immediately on the opposite side of that enemy checker is either an empty square or the outside of the board, your checker may initiate a sequence of jumps. You do this by jumping your checker over to the opposite side of the enemy checker and immediately removing the jumped piece. If your checker lands outside the board, it too is removed from the board. Note: If your last checker is removed when you capture your opponent's last checker, you still win.
            
        If the jumping checker lands in a position where it can jump again, your turn does not end, and the checker must make yet a jump. If there are several ways to continue the sequence, you may choose freely between these. The sequence of jumps only ends when the checker lands on a square where it can make no further jump. A 10x10 board is currently selected
(game "Cage"
    (players 2)
    (equipment {
        (board (square <Board>))
        (piece "Disc" Each)
    })
    (rules
        (start {
            (place "Disc1" 
                (difference
                    (sites Phase 0)
                    (sites Outer)
                )
            )
            (place "Disc2"
                (difference
                    (sites Phase 1)
                    (sites Outer)
                )
            )
        })
        (play
            (forEach Piece
                (if
                    (!= 1 (var))
                    (or
                        ("Hop" ~)
                        ("Step")
                    )
                    ("Hop" if:(= (from) (last To)))
                )
            )
        )
        (end 
            (if 
                (or
                    (= 0
                        (count Sites in:(sites Occupied by:P1))
                    )
                    (= 0
                        (count Sites in:(sites Occupied by:P2))
                    )
                ) 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Do Guti is a blockade game from what is now Pakistan. Graffiti on early monuments suggest this game could be medieval in date.A square, with diagonals, but one side of the square has been removed. Two pieces per player. Players alternate turns placing a piece on an empty spot on the board. When the pieces are placed, players alternate turns moving one of their pieces to an empty adjacent spot along the lines. The player who blocks the other from being able to move wins. 
(game "Do Guti" 
    (players 2) 
    (equipment { 
        (board 
            (add
                (remove
                    ("AlquerqueGraph" 3 3)
                    vertices:{1 3 5 7}
                )
                edges:{{3 0} {0 1} {1 4}}
            )
            use:Vertex
        )
        (hand Each)
        (piece "Disc" Each "StepToEmpty")
    }) 
    
    (rules 
        (start (place "Disc" "Hand" count:2))
        phases:{
        (phase "Placement" 
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        ) 
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("NoMoves" Loss)) 
    )
)

Construct a Ludii game based on the following description
Garanguet is a European Tables game played in France using three dice. It was played since at least the nineteenth century.The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has fifteen pieces, which all begin on the first point of their track. Three dice are used. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When a player rolls triples, the throw is played three times. If a player throws a pair among the three dice, they play the dice as normal if the third die has a greater value than the value which appears twice. If the value of the third die is lower, the player plays the doubles twice and the single value once. When a piece lands on a point with a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the quadrant of the board from which it began. When a piece reaches the end of the track, it may bear off the board with a throw greater than the number of points remaining in the track. The player who bears off all their pieces first wins.  
(game "Garanguet" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" ("BackgammonTracksWithBar"))
        (dice num:3)
        (piece "Disc" Each) 
        (map {(pair 1 6) (pair 2 19)}) 
        (regions "Home" P1 { 7..12 }) 
        (regions "Home" P2 { 20..25 }) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 12 count:15)
            (place Stack "Disc2" 25 count:15)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (if (all DiceEqual)
                    ("Move" ("NextSiteFromDistTripleDice" (site)) (then ("UpdateCounterTriplePlay")))
                    (if ("TwoDiceEqualLastLower")
                        (or
                            (if ("CanStillPlayDouble")
                                ("Move" ("NextSiteFromDistDouble" (site)) (then ("UpdateCounterDoublePlay")))
                            )
                            (if ("CanStillLowerDie")
                                ("Move" ("NextSiteFromDistLower" (site)) 
                                    (then 
                                        (if 
                                            (< (count MovesThisTurn) 4) 
                                            (moveAgain) 
                                            (set Value Mover 0) 
                                        )
                                    )		
                                )
                            )
                        )
                        (forEach Die
                            if:("DieNotUsed")
                            ("Move" ("NextSiteFrom" (site)) (then ("ReplayNotAllDiceUsed")))
                        )
                    )
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Yucebao is a two-row mancala-style board game played by the Bai people of Yunnan, China. It is typically played by men and boys, and involves the use of special stones which effect captures in addition to the usual mancala-style capturing rules.2x5 board, with two stores. Five counters in each hole, with a large stone normally in each store, but which may be placed in any of the player's holes to start. The player owns the store to their right. Sowing proceeds in either direction, the first player chooses which and all sowing for the rest of the game proceeds in that direction. Sowing includes the stores. Players may sow from any hole on the board. If the last counter falls into a hole with counters, the counters in the next hole are picked up and sowing continues, and if this hole is empty, the counters in the hole following the empty hole are captured. If there is an unbroken sequence of alternating empty and occupied holes, the counters in the occupied holes are captured until there are two empty or two occupied holes. When the larger stone is sown into a hole with counters, those counters are taken by the player to whom the hole belongs. When a player has no further counters, they may, if they wish, place one captured counter in each of their holes to continue playing, or may choose to end the round, and the opponent captures the remaining counters on the board. Another round begins: Both players fill as many of their holes as they can with five counters. The player with more counters may continue filling holes, if possible, in a clockwise direction from the end of their row. Any remaining counters are lent to the player with fewer counters to fill their holes. Play continues until one player can no longer fill any holes.
         
(game "Yucebao"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 5 largeStack:True
            {
            (track "TrackCCW" "0,1,E,11,10,W" loop:True)
            (track "TrackCW" "11,5,W,0,6,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (piece "Ball" P1)
        (piece "Ball" P2)
        (hand Each size:2)
        (regions P1 (sites Bottom))  
        (regions P2 (sites Top))   
        (map {(pair P1 LastSite) (pair P2 FirstSite)}) 
        (map "LeftMost" {(pair P1 1) (pair P2 10)}) 
        (regions "EndHoles" (sites {"A1" "G1"}))
    }) 
    (rules 
        (start {
            (place Stack "Seed" (union (sites Bottom) (sites Top)) count:5)
            (place Stack "Ball1" (mapEntry P1))
            (place Stack "Ball2" (mapEntry P2))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (if (!= (var "Direction") 2)
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    (sites Mover) 
                                )
                                if:(!= 0 (size Stack at:(from)))
                            )
                            (then
                                (and {
                                    (forEach Value min:1 max:(size Stack at:(last From))
                                        (if (= (id "Seed" Shared) (what at:(last From) level:(- (size Stack at:(last From)) (value))))
                                            (fromTo
                                                (from (last From) level:(- (size Stack at:(last From)) (value)))
                                                (to ("NextHole" (last From) "TrackCCW" (value)))
                                                stack:True
                                            )
                                            (and
                                                (if (and (is Occupied ("NextHole" (last From) "TrackCCW" (value))) (!= ("NextHole" (last From) "TrackCCW" (value)) (last From)))
                                                    (if (= (who at:(last From) level:(- (size Stack at:(last From)) (value))) P1)
                                                        (forEach Level ("NextHole" (last From) "TrackCCW" (value)) FromTop
                                                            (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCCW" (value)) level:(level)))
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCCW" (value)) level:(level))
                                                                    (to (handSite P1))
                                                                )
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCCW" (value)) level:(level))
                                                                    (to (handSite P1 1))
                                                                )
                                                            )
                                                        )
                                                        (forEach Level ("NextHole" (last From) "TrackCCW" (value)) FromTop
                                                            (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCCW" (value)) level:(level)))
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCCW" (value)) level:(level))
                                                                    (to (handSite P2))
                                                                )
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCCW" (value)) level:(level))
                                                                    (to (handSite P2 1))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (fromTo
                                                    (from (last From) level:(- (size Stack at:(last From)) (value)))
                                                    (to ("NextHole" (last From) "TrackCCW" (value)))
                                                    stack:True
                                                )
                                            )
                                        )
                                    )
                                    (if (< (var "Direction") 1) (set Var "Direction" 1))
                                    (if (< (size Stack at:(last From)) 8)
                                        (if (!= 0 (size Stack at:("NextHole" (last From) "TrackCCW" (+ 1 (size Stack at:(last From))))))
                                            (and 
                                                (moveAgain)
                                                (set Var "Replay" ("NextHole" (last From) "TrackCCW" (+ 1 (size Stack at:(last From)))))
                                            )
                                            (if (is Occupied ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))))
                                                (forEach Level ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) FromTop
                                                    (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level)))
                                                        (fromTo
                                                            (from ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                            (to (handSite Mover))
                                                        )
                                                        (fromTo
                                                            (from ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                            (to (handSite Mover 1))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                })
                            )
                        )
                    )
                    (if (!= (var "Direction") 1)
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    (sites Mover) 
                                ) 
                                if:(!= 0 (size Stack at:(from)))
                            )
                            (then
                                (and {
                                    (forEach Value min:1 max:(size Stack at:(last From))
                                        (if (= (id "Seed" Shared) (what at:(last From) level:(- (size Stack at:(last From)) (value))))
                                            (fromTo
                                                (from (last From) level:(- (size Stack at:(last From)) (value)))
                                                (to ("NextHole" (last From) "TrackCW" (value)))
                                                stack:True
                                            )
                                            (and
                                                (if (and (is Occupied ("NextHole" (last From) "TrackCW" (value))) (!= ("NextHole" (last From) "TrackCW" (value)) (last From)))
                                                    (if (= (who at:(last From) level:(- (size Stack at:(last From)) (value))) P1)
                                                        (forEach Level ("NextHole" (last From) "TrackCW" (value)) FromTop
                                                            (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCW" (value)) level:(level)))
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCW" (value)) level:(level))
                                                                    (to (handSite P1))
                                                                )
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCW" (value)) level:(level))
                                                                    (to (handSite P1 1))
                                                                )
                                                            )
                                                        )
                                                        (forEach Level ("NextHole" (last From) "TrackCW" (value)) FromTop
                                                            (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCW" (value)) level:(level)))
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCW" (value)) level:(level))
                                                                    (to (handSite P2))
                                                                )
                                                                (fromTo
                                                                    (from ("NextHole" (last From) "TrackCW" (value)) level:(level))
                                                                    (to (handSite P2 1))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (fromTo
                                                    (from (last From) level:(- (size Stack at:(last From)) (value)))
                                                    (to ("NextHole" (last From) "TrackCW" (value)))
                                                    stack:True
                                                )
                                            )
                                        )
                                    )
                                    (if (< (var "Direction") 1) (set Var "Direction" 2))
                                    (if (< (size Stack at:(last From)) 8)
                                        (if (!= 0 (size Stack at: ("NextHole" (last From) "TrackCW" (+ 1 (size Stack at:(last From))))))
                                            (and 
                                                (moveAgain)
                                                (set Var "Replay" ("NextHole" (last From) "TrackCW" (+ 1 (size Stack at:(last From)))))
                                            )
                                            (if (is Occupied ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))))
                                                (forEach Level ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) FromTop
                                                    (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level)))
                                                        (fromTo
                                                            (from ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                            (to (handSite Mover))
                                                        )
                                                        (fromTo
                                                            (from ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                            (to (handSite Mover 1))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                })
                            )
                        )
                    )
                    }
                    (then
                        (if ("NoPieceOnOwnedHoles" P1)
                            (forEach Site
                                (sites Board)
                                (if (is Occupied (site))
                                    (forEach Level (site) FromTop
                                        (if (= (id "Seed" Shared) (what at:(site) level:(level)))
                                            (fromTo
                                                (from (site) level:(level))
                                                (to (handSite P1))
                                                stack:True
                                            )
                                            (fromTo
                                                (from (site) level:(level))
                                                (to (handSite P1 1))
                                                stack:True
                                            )
                                        )
                                    )
                                )
                            )
                            (if ("NoPieceOnOwnedHoles" P2)
                                (forEach Site
                                    (sites Board)
                                    (if (is Occupied (site))
                                        (forEach Level (site) FromTop
                                            (if (= (id "Seed" Shared) (what at:(site) level:(level)))
                                                (fromTo
                                                    (from (site) level:(level))
                                                    (to (handSite P2))
                                                    stack:True
                                                )
                                                (fromTo
                                                    (from (site) level:(level))
                                                    (to (handSite P2 1))
                                                    stack:True
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 5 (size Stack Cell at:(handSite P1)))
                        (result P2 Win)
                    )
                    (if (> 5 (size Stack Cell at:(handSite P2)))
                        (result P1 Win)
                    )
                    }
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play 
                (or
                    (if (<= 5 (size Stack Cell at:(handSite Mover)))
                        (move Select
                            (from Cell (handSite Mover))
                            (to ("LeftMostEmpty"))
                            (then
                                (forEach Value min:1 max:5
                                    (fromTo
                                        (from Cell (last From) level:(- (size Stack Cell at:(last From)) (value)))
                                        (to (last To))
                                        stack:True
                                    )
                                )
                            )
                        )
                    )
                    (if (!= 0 (size Stack Cell at:(handSite Mover 1)))
                        (move Select
                            (from Cell (handSite Mover 1))
                            (to (sites Mover))
                            (then
                                (fromTo
                                    (from Cell (last From) level:(topLevel Cell at:(last From)))
                                    (to (last To))
                                    stack:True
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Magic Hexagon" 
    
    (players 1) 
    
    (equipment { 
        (board (hex 3) (values Cell (range 1 19))) 
        (regions { 
            (sites {0 1 2})
            (sites {3 4 5 6})
            (sites {7 8 9 10 11})
            (sites {12 13 14 15})
            (sites {16 17 18})
            (sites {2 6 11})
            (sites {1 5 10 15})
            (sites {0 4 9 14 18})
            (sites {3 8 13 17})
            (sites {7 12 16})
            (sites {0 3 7})
            (sites {1 4 8 12})
            (sites {2 5 9 13 16})
            (sites {6 10 14 17})
            (sites {11 15 18})
        })
        (regions HintRegions) 
    })
    
    (rules 
        (play 
            (satisfy {
                (all Different (sites Board))
                (is Sum 38)
            })
        )
        
        (end (if (is Solved) (result P1 Win)))
    )
)
Magic Hexagon is a logic puzzle game. A hexagonal grid (usually 3 per side) starts with numbers placed in some of the spaces.The player must insert numbers so that the sums of lines in all three directions equal the same number. Numbers cannot be repeated. 

Construct a Ludii game based on the following description
Skirmish, a Chess variant by Alex Landau, has the same rules as Chess, but without checkmate and with a 100 turn limit.The rules are the same as in Chess, without checkmate. The game is won either after 100 turns or when one player can no longer move, by the player with the most pieces. 
(game "Skirmish (GDL)" 
    ("TwoPlayersNorthSouth")
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then ("ReplayInMovingOn" (sites Mover "Promotion")))
        )
        
        ("ChessRook" "Rook" ~ ("RememberPieceHasMoved"))
        ("ChessKing" "King" ~ ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Queen")
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (or 
                    (forEach Piece)
                    ("Castling")
                )
            )
        )
        
        (end
            (if (or (no Moves Next) (= (count Moves) 100))
                (byScore {
                    (score P1 (count Pieces P1)) 
                    (score P2 (count Pieces P2))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Vai Lung Thlān is a two-row mancala-style board game played by the Mizo people of India, Bangladesh, and Myanmar.2x6 board. Five counters in each hole. Sowing occurs from any hole in the player's row in a clockwise direction. If the final counter lands into an empty hole, it is captured. If there is an unbroken line of holes behind it also having single counters, these are also captured. The player who captures the most counters wins. 
(game "Vai Lung Thlan" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "5,W,N,E" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    
    (rules 
        (start (set Count 5 to:(sites Track)))		 
        (play 
            (move Select
                (from 
                    (sites Mover) 
                    if:(< 0 (count at:(from)))
                )
                (then 
                    (sow 
                        if:(= (count at:(to)) 1)
                        apply:(fromTo 
                            (from (to)) 
                            (to (handSite Mover)) 
                            count:(count at:(to))
                        )
                        backtracking:True
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Nzengué is an alignment game played by children in the Republic of Congo, on a board drawn on the ground and using pieces of stone as the playing pieces.A square is drawn, with diagonals. Three pieces per player. Players alternate turns placing a piece on the board. The corners or the square, the central point, and the midpoint of each side of the square are playing sites. When a player forms a line with their three pieces, they win. 
(game "Nzengue (Small)"
    (players 2)
    (equipment {
        (board
            (add
                (remove
                    (remove
                        (square 3 diagonals:Solid) 
                        vertices:{8 9 3 4}
                    )
                    edges:{{7 4} {4 1} {3 4} {4 5}}
                )
                edges:{{6 4} {4 8} {4 2} {4 0}}
            )
            use:Vertex
        ) 
        (piece "Marker" Each)
        (hand Each)
    })
    (rules 
        (start (place "Marker" "Hand" count:3))
        (play (move (from (handSite Mover)) (to (sites Empty))))
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
Manu is a hunt game played in Hawaii in the nineteenth century. Played on cross-shaped board, made of five squares, each divided into four squares and with the diagonals of the larger squares drawn. One player plays with thirteen pieces situated on every point of one arm of the cross and along the line immediately perpendicular to that arm. The other plays as the Punipeki, which is placed on any empty spot on the first turn. Pieces move along the lines to an adjacent empty spot. The Punipeki may jump over an adjacent piece to capture it. The Punipeki wins if it can capture all the opponent's pieces, the other player wins by blocking the Punipeki from moving. 
(game "Manu" 
    (players 2) 
    (equipment { 
        ("CrossBoard" 3 7 use:Vertex diagonals:Alternating)
        (hand P1)
        (piece "Stick" P1 (or ("HopCapture") "StepToEmpty"))
        (piece "Marker" P2 "StepToEmpty") 
    }) 
    (rules 
        (start { 
            (place "Marker2" (union (expand (sites Bottom)) (sites Row 2)))
            (place "Stick1" (handSite P1))
        })
        
        phases:{ 
        (phase "Placement" P1 
            (play 
                (move 
                    (from (handSite P1)) 
                    (to (sites Empty))
                )
            ) 
            (nextPhase ("HandEmpty" P1) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("NoMovesLossAndNoPiecesPlayerLoss" P2))
    )
)

Construct a Ludii game based on the following description
Tshuba is a four-row mancala-style board game played by the Tsonga people of southeast Africa. It may be played on boards with four to 22 holes per row, and is similar to other games in the region.4x4, 8, 10, 16, or 22 board. Two counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, the contents are picked up and sowing continues. When the final counter lands in an empty hole in the player's inner row, the contents of the opponent's hole in the inner row opposite it are captured, and if there are counters also in the corresponding outer row hole, these are also captured. The player may also capture from another hole from the opponent's side of the board of their choosing. The turn ends. If the final counter lands in an empty hole in the player's outer row, the turn ends. Play continues until one player captures all of the opponent's counters, thus winning. Each player has 4 holes on each row.
(game "Tshuba" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Board:CCW2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        (play 
            (if (= 1 (var "ExtraCapture"))
                (move Remove
                    (difference (sites Next "Home") (sites Empty))
                    count:(count at:(to))
                    (then (set Var "ExtraCapture" 0))
                )
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover) 
                        ) 
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                                (if (is In (to) (sites Mover "Inner"))
                                    (and {
                                        (if (> (count at:("OppositePit" (to))) 0) 
                                            (remove ("OppositePit" (to)) count:(count at:("OppositePit" (to)))) 
                                        )
                                        (if (> (count at:("OppositeOuterPit" (to))) 0) 
                                            (remove ("OppositeOuterPit" (to)) count:(count at:("OppositeOuterPit" (to)))) 
                                        )
                                        (set Var "ExtraCapture" 1)
                                        (moveAgain)
                                    })
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end
            (if (all Sites (sites Next "Home") if:(= 0 (count at:(site))))
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Dice Shogi is a recently invented Shogi variant. It is essentially Mini Shogi played with dice determining the players' moves.The rules are the same of Mini Shogi except the value of the die rolled at each turn is the index of the column of a piece must go.
            When you have pieces on your hand, you can drop a piece you like on the column with the index equal to the value of the die. 
        If there are no legal moves with the value of the die, or if the value of the die is equal to 6, you can move any piece according to the rules of Mini Shogi. 
(game "Dice Shogi" 
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        (board (square 5))
        
        
        (piece "Osho" Each ("StepMove"))
        
        
        (piece "Fuhyo" Each ("StepMove" Forward "ForcePromote"))
        
        
        (piece "Ginsho" Each ("StepMove" (directions {Forward BL BR FL FR}) "CanPromote"))
        
        
        (piece "Hisha" Each ("SlideMove" Orthogonal "CanPromote"))
        
        
        (piece "Kakugyo" Each ("SlideMove" Diagonal "CanPromote"))
        
        
        ("ShogiGold" "Kinsho" "CapturePiece")
        
        
        ("ShogiGold" "Tokin" "CapturePiece")
        
        
        ("ShogiGold" "Narigin" "CapturePiece")
        
        
        (piece "Ryuo" Each (or ("SlideMove" Orthogonal) ("StepMove" Diagonal)))
        
        
        (piece "Ryuma" Each (or ("SlideMove" Diagonal) ("StepMove" Orthogonal)))
        
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
        (map "Where" { 
            (pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) 
            (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) 
            (pair (id "Hisha" P1) (handSite P2 2)) (pair (id "Hisha" P2) (handSite P1 2)) 
            (pair (id "Kakugyo" P1) (handSite P2 3)) (pair (id "Kakugyo" P2) (handSite P1 3)) 
            (pair (id "Kinsho" P1) (handSite P2 4)) (pair (id "Kinsho" P2) (handSite P1 4)) 
            (pair (id "Tokin" P1) (handSite P2)) (pair (id "Tokin" P2) (handSite P1)) 
            (pair (id "Narigin" P1) (handSite P2 1)) (pair (id "Narigin" P2) (handSite P1 1)) 
            (pair (id "Ryuo" P1) (handSite P2 2)) (pair (id "Ryuo" P2) (handSite P1 2)) 
            (pair (id "Ryuma" P1) (handSite P2 3)) (pair (id "Ryuma" P2) (handSite P1 3)) 
        })
        (map "Captured" { 
            (pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) 
            (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) 
            (pair (id "Hisha" P1) (id "Hisha" P2)) (pair (id "Hisha" P2) (id "Hisha" P1)) 
            (pair (id "Kakugyo" P1) (id "Kakugyo" P2)) (pair (id "Kakugyo" P2) (id "Kakugyo" P1)) 
            (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) 
            (pair (id "Tokin" P1) (id "Fuhyo" P2)) (pair (id "Tokin" P2) (id "Fuhyo" P1)) 
            (pair (id "Narigin" P1) (id "Ginsho" P2)) (pair (id "Narigin" P2) (id "Ginsho" P1)) 
            (pair (id "Ryuo" P1) (id "Hisha" P2)) (pair (id "Ryuo" P2) (id "Hisha" P1)) 
            (pair (id "Ryuma" P1) (id "Kakugyo" P2)) (pair (id "Ryuma" P2) (id "Kakugyo" P1)) 
        })
        (map "Promoted" { 
            (pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) 
            (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) 
            (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) 
            (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2)) 
        })
        
        (hand Each size:5)
        (dice num:1)
    })
    
    (rules 
        (start { 
            (place "Osho1" coord:"A1") (place "Kinsho1" coord:"B1") (place "Ginsho1" coord:"C1") (place "Kakugyo1" coord:"D1") (place "Hisha1" coord:"E1") (place "Fuhyo1" coord:"A2")
            (place "Osho2" coord:"E5") (place "Kinsho2" coord:"D5") (place "Ginsho2" coord:"C5") (place "Kakugyo2" coord:"B5") (place "Hisha2" coord:"A5") (place "Fuhyo2" coord:"E4")
        })
        
        (play
            (if ("SameTurn")
                (or
                    ("Promote")
                    (move Pass)
                )
                ("RollMove"
                    (do
                        (if (!= 6 (count Pips))
                            (or {
                                (if (can Move 
                                        (do 
                                            (or ("PlaceAPiece" Mover Next) (forEach Piece))
                                            ifAfterwards:(and 
                                                (not ("IsInCheck" "Osho" Mover (forEach Piece Next))) 
                                                ("CorrectColumn")
                                            )
                                        )
                                    )
                                    (do 
                                        (or ("PlaceAPiece" Mover Next) (forEach Piece))
                                        ifAfterwards:("CorrectColumn")
                                    )
                                    (or ("PlaceAPiece" Mover Next) (forEach Piece))
                                )
                            })
                            (or ("PlaceAPiece" Mover Next) (forEach Piece))
                        )
                        ifAfterwards:(not ("IsInCheck" "Osho" Mover (forEach Piece Next)))
                    )
                )
            )
        )
        
        (end {
            (if (and ("IsInCheck" "Osho" Next (or ("PlaceAPiece" Mover Next) (forEach Piece))) ("NextCannotMove")) (result Mover Win)) 
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
Shuanglu is a race game known from East Asia that is similar to European Backgammon. References to it in Chinese sources date to the first millennium CE.The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, number the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and other the number on the other die, or by moving one piece the total number of both die. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
         
(game "Shuanglu"
    (players 2)
    (equipment {
        ("TableBoard" ("TableTracksOppositeWithHands2" End))
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die
                if:("DieNotUsed")
                (if ("IsEndTrack" ("NextSiteFrom" (from) (pips)))
                    (if ("AllPiecesInFinalQuadrant")
                        (move Remove (from))
                    )
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NoEnemyOrOnlyOne" (to))
                            ("HittingCapture" (handSite Next))
                        )
                    )
                )
                (then ("ReplayNotAllDiceUsed"))
            )
        )
        (hand Each)
        (regions "FinalQuadrant" P1 (sites {18..23}))
        (regions "FinalQuadrant" P2 (sites {6..11}))
    })
    (rules 
        (start {
            (place Stack "Disc1" 6 count:5) (place Stack "Disc1" 4 count:3) 
            (place Stack "Disc1" 12 count:5) (place Stack "Disc1" 23 count:2)
            (place Stack "Disc2" 18 count:5) (place Stack "Disc2" 16 count:3) 
            (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 11 count:2)
        })
        (play 
            ("RollEachNewTurnMove"
                (priority {
                    ("EnterPieces")
                    (if (is Empty (handSite Mover)) (max Distance (forEach Piece top:True)))
                })
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Pallankuli is a two-row mancala-style board game played primarily by women in South India. Men do play the game, but typically gambled when playing.2x7 board. Six counters in each hole. Play begins from any one of a player's holes, even if there is just one. Sowing occurs in an anti-clockwise direction. If they end in a hole with counters, these are picked up and sowing continues. If sowing ends in an empty hole, the contents of the next hole are captured and the turn ends. When sowing, if the contents of a hole are brought to four, they are immediately captured by the player in whose row the counters are located. Play ends when a player has no counters in their holes, remaining player takes all the remaining counters. In the next round, the player with the smaller number of counters captured from the previous round fills as many of their holes as they can, starting from the left and filling each hole with six counters. Leftover counters are placed in the player's store. The opponent then does the same. Any holes remaining empty are out of play for this round, otherwise play continues as before. The right to begin alternates from round to round. Further rounds are played until one player has fewer than six counters. 
(game "Pallankuli" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 7 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "LeftMost" {(pair P1 0) (pair P2 13)})
        (hand Each)
    }) 
    (rules 
        (start { 
            (set Count 6 to:(sites Track)) 
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select 
                        (from 
                            (if ("SameTurn") 
                                (sites {(var "Replay")})
                                (sites Mover) 
                            ) 
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then
                            (do
                                (set Var "NumSowed" (count at:(last To)))
                                next:(sow
                                    apply:(if 
                                        (and 
                                            (!= 4 (count at:(to))) 
                                            (< 1 (count at:(to)))
                                        ) 
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                        (if (= 1 (count at:(to)))
                                            (if (is Occupied ("NextHoleFrom" (to) 1))
                                                (fromTo
                                                    (from ("NextHoleFrom" (to) 1))
                                                    (to (handSite Mover))
                                                    count:(count at:("NextHoleFrom" (to) 1))
                                                )
                                            )
                                        )
                                    )
                                    skipIf:(not (is In (to) ("PlayableSites")))
                                )
                                (then
                                    (and
                                        (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed")))
                                            (if (= 4 (count at:(site)))
                                                (fromTo
                                                    (from (site))
                                                    (to (if (is In (to) (sites P1)) (handSite P1) (handSite P2)))
                                                    count:4
                                                )
                                            )
                                        )
                                        (set Var "NumSowed" 0)
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OneRowIsEmpty")
                            (and { 
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "Playable" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 6 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 6 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
            
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 6 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty") if:(is In (to) (sites Mover)))
                        count:6
                        (then
                            (remember Value "Playable" (last To))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Tsatsarandi is a capturing game that was played by the Kanuri people of Nigeria. Very few people still played it in the early twentieth century, and it was said to have been played during the time of the Kanem-Bornu Empire.8x8 board. Pieces have specific moves, as follows: Mai (x1): moves one space in any direction; Chiroma (x1): Moves one space diagonally; Bintu (x2): moves exactly two spaces diagonally, jumping over the first square; Fer (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Kaigamma (x2): moves orthogonally any distance; Gollo: (x8) move one space forward orthogonally, or one space diagonally forward to capture. Pieces capture the opponent's pieces by moving onto the spot they occupy. No en passant; no castling. When the Mai can be captured at the beginning of the opponent's next turn, it is in check and must be removed from this state on the player's turn. If this is not possible, it is checkmate and the player who threatened the Mai wins.  
(game "Tsatsarandi"
    (players 2)
    (equipment {
        (board (square 8))
        ("ChessPawn" "Pawn")
        ("ChessRook" "Rook")
        ("ChessKing" "King_noCross")
        (piece "Bishop_noCross"
            (move Hop 
                Diagonal 
                (between if:True) 
                (to 
                    if:(or 
                        (is Empty (to)) 
                        ("IsEnemyAt" (to))
                    ) 
                    (apply (remove (to))) 
                )
            )		
        )
        ("ChessKnight" "Knight")
        (piece "Ferz_noCross" ("StepToNotFriend" Diagonal))
    })
    (rules 
        (start {
            (place "King_noCross1" coord:"E1") (place "King_noCross2" coord:"E8")
            (place "Ferz_noCross1" coord:"D1") (place "Ferz_noCross2" coord:"D8")
            (place "Bishop_noCross1" {"C1" "F1"}) (place "Bishop_noCross2" {"C8" "F8"})
            (place "Knight1" {"B1" "G1"}) (place "Knight2" {"B8" "G8"})
            (place "Rook1" {"A1" "H1"}) (place "Rook2" {"A8" "H8"})
            (place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6))
        })
        (play 
            (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
        )
        
        (end ("Checkmate" "King_noCross"))
    )
)

Construct a Ludii game based on the following description
Lam Pusri is a game with leaping captures that was played in the Teesta River valley of India during the early twentieth century.5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. Eighteen pieces per player, each side arranged on one side of the board, with the central point empty and the player's pieces on the points to the right of it. Players alternate turns moving one of their pieces to an empty point. A piece may jump an opponent's piece to capture it. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
         
(game "Lam Pusri" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithBottomAndTopTriangles") 
        (piece "Marker" Each 
            (or 
                ("HopSequenceCapture")
                ("StepToEmpty")
            )
        )
    }) 
    (rules 
        (start {
            (place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3) (expand (sites {"E5"}) W)}))
            (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8) (expand (sites {"A5"}) E)}))
        })
        
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
The Short Assize was a form of Chess played in medieval France and England. It is thought to have been a way of speeding up the game by starting the pieces in an advanced position.8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. 1 x Queen: One square diagonally. 2 x Rook: Any number of spaces orthogonally. 2 x Fil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Queen when reaching the eighth rank. The pieces begin in the following position: Fils on the third and sixth spaces of the first row, King on the fifth space of the first row, Rooks on the third and sixth spaces of the second row, Knights on the fourth and fifth spaces of the second row, Pawns on the third row, the Queen sharing a space with the Pawn in the fifth space. Kings are on the same column. The only time two pieces can be on the same space is in this initial arrangement. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. Capturing all of an opponent's pieces except the King also results in a win.
         
(game "Short Assize"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        (piece "King" Each
            (move
                Step 
                (from (from) level:(level))
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece" 
                )
            )
        )
        (piece "Rook" Each
            (move
                Slide 
                (from (from) level:(level))
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPiece"
                ) 
            )		
        )
        (piece "Bishop" Each
            (move
                Hop 
                (from (from) level:(level))
                Diagonal 
                (between if:True) 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece" 
                )
            )		
        )
        (piece "Knight" Each
            (move
                Leap 
                (from (from) level:(level))
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece"
                ) 
            )			
        )
        (piece "Queen" Each
            (move
                Step 
                (from (from) level:(level))
                Diagonal
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece" 
                )
            )		
        )
        (piece "Pawn" Each
            (or 
                (move Step 
                    (from (from) level:(level)) 
                    Forward 
                    (to if:(is Empty (to)))
                )
                "CaptureForwardDiagonal"
                (then
                    (if (is In (last To) (sites Mover "Promotion")) 
                        (promote (last To) (piece (id "Queen" Mover)))
                    )
                )
            )		
        )
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start {
            (place "Bishop1" (sites {"C1" "F1"})) (place "Rook1" (sites {"C2" "F2"}))
            (place "Knight1" (sites {"D2" "E2"}))
            (place "King1" coord:"E1") (place Stack "Pawn1" (sites Row 2)) 
            (place Stack "Queen1" (sites {"D3"}))
            
            (place "Bishop2" (sites {"C8" "F8"})) (place "Rook2" (sites {"C7" "F7"}))
            (place "Knight2" (sites {"D7" "E7"}))
            (place "King2" coord:"E8") (place Stack "Pawn2" (sites Row 5)) 
            (place Stack "Queen2" (sites {"D6"}))
        })
        (play (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King" Mover))))
        (end {
            (if (and 
                    ("IsInCheck" "King" Next)
                    ("NextCanNotMove")
                ) 
                (result Mover Win)
            ) 
            ("BlockWin")
            (if (= (count Pieces Next) 1) (result Mover Win)) 
        })
    )
)

Construct a Ludii game based on the following description
Tic-Tac-Die is played as per Tic-Tac-Toe except that players roll a D9 dice each turn to dictate where they move (dice pips show cell index to move to).Play occurs on a 3x3 grid. One player places an X, the other places an O and players take turns placing their marks in the grid, attempting to get three in a row. The die is showing the cell index to place a piece. Players reroll until they roll an empty cell.
(game "Tic-Tac-Die" 
    (players 2) 
    (equipment { 
        (board (square 3)) 
        (piece "Disc" P1) 
        (piece "Cross" P2) 
        (dice d:9 from:0 num:1)
    }) 
    (rules 
        (play 
            ("RollMove" 
                (if (is Empty (count Pips))
                    (move Add ("PlayerPiece") (to (count Pips)))
                    <Play:choice>
                )
            )
        )
        (end {
            ("Line3Win")
            (if (is Full) (result Mover Draw))
        })
    )
)

Construct a Ludii game based on the following description
Ikibuguzo is a four-row mancala-style board game from the Great Lakes Region of Africa. It  is closely related to other games in the region, but with different opening positions and the possibility of winning by making a specific capture.4x8 board. Two counters in each hole. Opening play: Players simultaneously arrange their counters in the following patter, beginning from the bottom left and proceeding anti-clockwise: 0, 6, 0, 0, 0, 0, 0, 17, 0, 3, 0, 3, 0, 3, 0, 0. Players then move alternately. The first three turns are made by sowing from the holes with three holes, proceeding in order from the one furthest to the left, sowing two in the next hole and one in the following. They then sow from the next hole to the right with three counters on the next turn in the same way. Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over. For capturing: Holes are in 'opposition' when one player has the front row hole occupied and the opponent has both of the holes opposite it occupied. If the last hole in a sowing is in opposition, the player takes the counters in both of the opponent's holes and places them in the empty hole from which the player lifted the counters. The player then sows the captured counters from this hole. Further captures in the sowing can occur in the same way. However, each player has two hole from which clockwise plays can be made: the leftmost hole in the outer row and the second from the left in the inner row. Clockwise moves can only be made from these holes if they immediately lead to a capture. When the captured counters are sown, starting from the same hole, they can also be sown clockwise if they lead to a capture. If they cannot lead to a capture, they are sown anti-clockwise. Another alternative the player has is that, if the player plays clockwise from one of these holes and therefore makes a capture, the captured counters may be placed in the hole and left there, and the player may play instead from the other hole from which clockwise captures are allowed in a clockwise direction, if it leads to a capture. The player may continue playing from this hole as above until the possibilities to move are exhausted, and then may move from any hole in an anti-clockwise direction. Multiple captures can only be made in a clockwise direction from these holes if it is made on the first sowing of the turn. Otherwise, only one clockwise capture can be made and sowing must proceed in an anti-clockwise direction. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses. A player may also win by capturing the counters from both of the opponent's end holes in the inner row in a single turn. 
(game "Ikibuguzo (Opening 1)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "24,E,S1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (map "FirstMove" {(pair P1 10) (pair P2 21)})
        (map "SecondMove" {(pair P1 12) (pair P2 19)})
        (map "ThirdMove" {(pair P1 14) (pair P2 17)})
        (map "LeftMostOuter" {(pair P1 0) (pair P2 31)})
        (map "SecondLeftInner" {(pair P1 9) (pair P2 22)})
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start { 
            (set Count 6 to:(sites {"G4" "B1"}))
            (set Count 17 to:(sites {"H1" "A4"}))
            (set Count 3 to:(sites {"G2" "E2" "C2" "B3" "D3" "F3"}))
        })
        
        phases:{
        (phase "FirstMove"
            (play
                (move 
                    (from (mapEntry "FirstMove" Mover))
                    (to ("NextHole" (from) "TrackCCW" 1))
                    count:2
                    (then
                        (fromTo
                            (from (mapEntry "FirstMove" Mover))
                            (to ("NextHole" (from) "TrackCCW" 2))
                            count:1
                        )
                    )
                )
            )
            (nextPhase Mover "SecondMove")
        )
        (phase "SecondMove"
            (play
                (move 
                    (from (mapEntry "SecondMove" Mover))
                    (to ("NextHole" (from) "TrackCCW" 1))
                    count:2
                    (then
                        (fromTo
                            (from (mapEntry "SecondMove" Mover))
                            (to ("NextHole" (from) "TrackCCW" 2))
                            count:1
                        )
                    )
                )
            )
            (nextPhase Mover "ThirdMove")
        )
        (phase "ThirdMove"
            (play
                (move 
                    (from (mapEntry "ThirdMove" Mover))
                    (to ("NextHole" (from) "TrackCCW" 1))
                    count:2
                    (then
                        (fromTo
                            (from (mapEntry "ThirdMove" Mover))
                            (to ("NextHole" (from) "TrackCCW" 2))
                            count:1
                        )
                    )
                )
            )
            (nextPhase Mover "MainPhase")
        )
        
        (phase "MainPhase"
            (play
                (or
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)}) 
                            )
                            if:(and {
                                if:(if ("SameTurn")
                                    (< 0 (count at:(from)))
                                    (< 1 (count at:(from)))
                                )
                                (is In (from) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)}))
                                (is In ("NextHole" (from) "TrackCW" (count at:(from))) (sites Mover "Inner"))
                                (is Occupied ("OppositePit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                                (is Occupied ("OppositeOuterPit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                            })
                        )
                        (then 
                            (sow
                                "TrackCW"
                                owner:(mover)
                                apply:
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and {
                                                (is Occupied ("OppositePit" (to)))
                                                (is Occupied ("OppositeOuterPit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            })
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                                (set Var "Replay" (from))
                                            })
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover) 
                            )
                            if:(if ("SameTurn")
                                (< 0 (count at:(from)))
                                (< 1 (count at:(from)))
                            )
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                owner:(mover)
                                apply:
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and {
                                                (is Occupied ("OppositePit" (to)))
                                                (is Occupied ("OppositeOuterPit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            })
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                                (set Var "Replay" (from))
                                            })
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end ("BlockWin"))
        )
        }
    )
)

Construct a Ludii game based on the following description
Unlur is a game between two people taking turns placing tiles on a hexagonal board. Each player has a different objective to achieve victory. It is classified as an abstract, connecting and unequal forces board game.This game was the winner of the second Annual Game Design Competition in 2002, whose theme that year was the design of games of unequal forces (organized by Abstract Games magazine, About Board Games, and the Strategy Gaming Society). The name came from a symmetric ancestor game called 'Lur'. When the game was supported on Ludoteka, the Edge rule was added because placing on the edge is usually bad for Black. More information about the origins of the game can be found in Spanish on the designer's blog:<a href=\This game is played on a hexagonal board made up of hexagonal squares, usually 6 squares per side, although other sizes are possible. Initially the board is empty and black pieces are placed in turns until one player passes. The player who passed becomes Black. The other player becomes White and takes the next turn. Play continues, with each player in turn placing pieces of their colour on unoccupied squares on the board. White wins if they manage to connect two opposite sides of the board. Black wins if they manage to connect three non-adjacent sides of the board. To avoid ties, if a player meets the opponent's goal with their pieces, they lose the game. The game is played on a board with 6 hexes per side. You may place stones on the edge in the opening phase.
(game "Unlur" 
    (players 2) 
    (equipment { 
        (board (hex <Board:size>)) 
        (piece "Disc" Each) 
    }) 
    (rules 
        phases:{
        (phase "Opening"
            (play
                (or
                    (move Add
                        (piece (id "Disc" P2))
                        (to <Edge:target_zone>)
                    )
                    (move Pass
                        (then
                            (if (is Mover P1)
                                (swap Players P1 P2
                                    (then
                                        (note "Player 1 is now Black. Player 2 is now White." to:All)
                                    )
                                )
                                (note "Player 1 remains White. Player 2 remains Black." to:All)
                                (then
                                    (do
                                        (set NextPlayer (player 1))
                                        next:(set Var 1) 
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase ("IsPlayingPhase") "Playing")
        )
        (phase "Playing"
            (play (move Add (to (sites Empty))))
        )
        }
        (end {
            (if (and {("IsPlayingPhase") (= (id P1) (mover)) ("BlackVC") (not ("WhiteVC"))}) (result P1 Loss)) 
            (if (and {("IsPlayingPhase") (= (id P2) (mover)) ("WhiteVC") (not ("BlackVC"))}) (result P2 Loss)) 
            (if (and {("IsPlayingPhase") (= (id P1) (mover)) ("WhiteVC")}) (result P1 Win)) 
            (if (and {("IsPlayingPhase") (= (id P2) (mover)) ("BlackVC")}) (result P2 Win)) 
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Greater Even Loss" 
    (players 2) 
    (equipment { 
        (board (square 4)) 
        (piece "Disc" Each) 
    }) 
    (rules 
        (start {
            (place "Disc1" {"A1"} state:1) 
            (place "Disc1" {"B1"} state:2) 
            (place "Disc1" {"C1"} state:3) 
            (place "Disc1" {"D1"} state:4) 
            (place "Disc1" {"A2"} state:5) 
            (place "Disc1" {"B2"} state:6) 
            (place "Disc1" {"C2"} state:7) 
            (place "Disc1" {"D2"} state:8) 
            (place "Disc2" {"A3"} state:5) 
            (place "Disc2" {"B3"} state:6) 
            (place "Disc2" {"C3"} state:7) 
            (place "Disc2" {"D3"} state:8) 
            (place "Disc2" {"A4"} state:1) 
            (place "Disc2" {"B4"} state:2) 
            (place "Disc2" {"C4"} state:3) 
            (place "Disc2" {"D4"} state:4) 
        })
        
        (play 
            (move Select 
                (from 
                    (forEach 
                        (sites Occupied by:Mover)
                        if:(> (state at:(site)) ("LastStateRemove"))
                    )
                )
                (then
                    (and 
                        ("StoreStateRemoved")
                        (remove (last To))	
                    )
                )		
            )
        ) 
        
        (end 
            (if 
                (is Even "LastStateRemove")
                (result Mover Loss)
            )
        )
    )
)
Greater Even Loss is a theoretical game designed to demonstrate Monte Carlo resistance. Each turn there is one strategically optimal move against a competent opponent and many losing moves.Players take turns removing a piece of their colour whose number is higher than the last piece they removed (free choice of first piece). The mover loses if they remove an even numbered piece. 

Construct a Ludii game based on the following description
Ovalhu is a two-row mancala-style board game played in the Maldives.2x8 board, with a store on either end. Each player owns the store to their right. Eight counters in each hole. Players alternate turns sowing in an anti-clockwise direction from one of the holes on their side of the board. Sowing always includes the player's store (but not the opponent's store), and sowing cannot begin from the store. When the final counter lands in an occupied hole, the contents of that hole are picked up and sowing continues. If the last counter lands in the player's store, they may choose any of the holes on their side of the board and continue sowing from it. When the final counter lands in an empty hole, the counters in the opposite hole are captured. Play continues until all of the counters are captured. A new round begins. Players fill the holes on their side of the board with their captured counters. If a player cannot fill a hole with the required number of counters, the hole is closed and is out of play for that round. Play continues as before. Play continues in successive rounds until one player closes all of their opponent's holes and wins.  
(game "Ovalhu" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "Track1" "1,E,17,16,W" loop:True P1)
            (track "Track2" "1,E,N,W,0" loop:True P2)
            }
        )
        (piece "Seed" Shared)
        (map {(pair P1 LastSite) (pair P2 FirstSite)}) 
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start {
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
            (set Count 8 to:(union (sites Bottom) (sites Top))) 
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from 
                            (if (and (is Pending) ("SameTurn"))
                                (sites {(var "Replay")})
                                (sites Mover) 
                            )
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then
                            (sow
                                "Track"
                                owner:(mover)
                                apply:(if (or (is In (to) ("Stores")) (< 1 (count at:(to))))
                                    (and
                                        (moveAgain)
                                        (if (not (is In (to) ("Stores")))
                                            (and
                                                (set Pending)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                    (if (is Occupied ("OppositePitTwoRows" (to)))
                                        (fromTo
                                            (from ("OppositePitTwoRows" (to)))
                                            (to (mapEntry Mover))
                                            count:(count at:("OppositePitTwoRows" (to)))
                                        )
                                    )
                                )
                                skipIf:(and (not (is In (to) ("Stores"))) (not (is In (to) ("PlayableSites"))))
                            )
                        )
                    )
                    }
                    (then
                        (if ("NoPieceOnBoard")
                            (forget Value "Playable" All)
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 8 (count at:(mapEntry P1))) (result P2 Win))
                    (if (> 8 (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                    (if (<= 8 (count at:(mapEntry Mover)))
                        (move
                            (from (mapEntry Mover))
                            (to (sites Mover) if:(is Empty (to)))
                            count:8
                            (then (remember Value "Playable" (last To)))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Dam is a capturing game played in Singapore during the nineteenth century. It is played on the same board as a local hunt game, Rimau-Riimau.5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. Each player has sixteen pieces, which begin on the points of one triangle and the two rows of points in front of it, thus leaving the central row of points empty. Players alternate turns moving a piece to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to an empty space immediately on the opposite side of the piece, along the lines of the board. The first player to capture all of the opponent's pieces wins. 
(game "Dam (Singapore)" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (piece "Marker" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    (rules 
        (start { 
            (place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3)}))
            (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8)}))
        })
        
        (play (forEach Piece))
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
L game was invented by Edward do Bono in 1967. It is a blocking game played by moving pieces which take up several spaces on a board.Played on a board of 4x4 squares. Each player controls a 3x2 L-shaped piece, and there are two 1x1 pieces which either player can manipulate. On a turn, a player moves the L piece to a new available position, and then has the option to move one of the 1x1 pieces. When a player cannot move their L piece, they lose. 
(game "L Game" 
    (players 2) 
    (equipment { 
        (board (square 4)) 
        (piece "Dot" Neutral) 
        (tile "L" Each "LWalk") 
    }) 
    (rules 
        (start { 
            (place "Dot0" {"A4" "D1"})
            (place "L1" coord:"C1" state:0)
            (place "L2" coord:"B4" state:2)
        })
        (play
            (if ("SameTurn")
                (or
                    (move Pass)
                    (move 
                        (from (sites Occupied by:Neutral)) 
                        (to (sites Empty))
                    )
                )
                (move
                    (from (sites Occupied by:Mover)) 
                    (to (union (sites Empty) (sites Occupied by:Mover))) 
                    (then (moveAgain))
                )
            )
        )
        
        (end 
            (if 
                "CanNotMoveALPiece" 
                (result Mover Win) 
            ) 
        ) 
    ) 
)

Construct a Ludii game based on the following description
Chungcajon is a two-row mancala-style board game played in the Philippines.2x7 board, with two stores. Seven counters in each hole. Players sow from any hole on their side of the board, in a clockwise direction, and sow into the store on their left, but not the one on the right. When the final counter of a sowing lands in an occupied hole that is not the store, the player picks up these counters and continues sowing. When then final counter lands in an empty hole, the turn ends. When the final counter lands in the store, the turn ends. Play continues until all of the counters are in the stores, and the player with the most counters in their store wins. 
(game "Chungcajon" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 7
            {
            (track "Track1" "7,W,WNW,ENE,E" loop:True P1)
            (track "Track2" "8,E,ESE,WSW,W" loop:True P2)
            }
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 7 to:(union (sites P1) (sites P2))))		 
        (play 
            (move Select 
                (from 
                    (if 
                        ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover) 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow 
                        "Track"
                        owner:(mover)
                        if:(and 
                            (> (count at:(to)) 1)
                            ("NotMoverStore")
                        ) 
                        apply:(moveAgain)
                    )
                )
            )
        )
        (end ("MancalaByScoreWhen" (all Sites (union (sites P1) (sites P2)) if:(= 0 (count at:(site))))))
    )
)

Describe the mechanics of the following Ludii game
(game "Sig (El Oued Capture)"
    (players 2)
    (equipment {
        (board
            (rectangle 3 6)
            {
            (track "Track1" "0,E,N1,W,N1,E,S1,W" loop:True P1)
            (track "Track2" "17,W,S1,E,S1,W,N1,E" P2 directed:True)
            }
        )
        (piece "Marker" Each)
        (hand Each)
        ("StickDice" 6)
        (map "ExtraThrow" {(pair 0 3) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 1)})
    })
    (rules
        (start { 
            (place "Marker1" (sites Bottom))
            (place "Marker2" (sites Top))
        })
        (play 
            ("RollMove"
                (priority 
                    (forEach Piece ("MoveToActivate"))
                    (forEach Piece ("Move"))
                )
                (then
                    (if (!= 0 ("ExtraThrowValue"))
                        (and
                            (if (= 3 ("ExtraThrowValue"))
                                (if (<= (var) 0)
                                    (set Var 2)
                                )
                            )
                            (if (!= (mover) (prev))
                                (and 
                                    (moveAgain)
                                    (if (!= 1 ("ThrowValue")) (set Var "SpecialSig" 1))
                                )
                            )
                        )
                        (if (> (var) 0)
                            (and {
                                (set Var (- (var) 1))
                                (moveAgain)
                            })
                            (set Var "SpecialSig" 0)
                        )
                    )
                )
            )
        )
        (end ("CaptureAll" Next))
    )	
)
Sig is a word used for many different games throughout Saharan Africa. This game, a capturing game played in El Oued, Algeria, was played by children.3x6 board. Six pieces per player, which begin one in each space in the row closest to the player. Six sticks, used as dice. One side is polished, and the other is rough. The value of a throw is equal to the number of polished sides which land face up. A throw of sig (five polished or five rough sides up) must be made to move a piece that has not yet been moved; a throw of sig moves it 1 and grants the player another throw. If six polished sides up are thrown, the player gets another throw. If this throw is a sig, the player's throw = 7 and the player may either free the first piece and move it seven spaces or free all six pieces, moving them each one, and moving the first piece the remaining one space. Also, if the player throws six rough sides on their first turn, they get three extra throws. If any of these three throws is a sig, the value of the throw = 13, and the player may free the first piece and move it thirteen spaces, or free all of the player's pieces, moving them each one space, and then moving the first piece the remainder of the spaces. Pieces move from left to right in the player's home row, right to left in the central row, left to right in the opponent's home row, right to left in the central row, and then left to right in the player's home row. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. The player who captures all of their opponent's pieces wins. 

Construct a Ludii game based on the following description
Chains of Thought is a 2 player combinatorial game.          Finite play is ensured by the limited available area for stone placement, and by the need, when removing stones from the board, to create a chain larger than the chain(s) from which stones were taken.        The game ends when a player cannot move, but the goal is to have the largest chain at the end of play. The goal cascades for tied chains.        Chains of similar size are capable of approaching and attacking each other, when supported by potential mergers from behind. The need for support causes such approaches to be cool.         Blocking is generally done by chains of disparate size, as they mutually repel the isolated stones needed for the larger chain to attack the smaller. This is what leads to the territorial race by placing outliers into yet open areas for expansion.        The result is a tactical cool clouding of stones, followed by an obstructive race to extend the largest viable group.         Players must also be careful obstruct their own possibility of (re)connecting chains that have been formed separately, or been cut in an attack.            The leading player may seek to stalemate himself if the opponent has potential for future expansion. Order 6, Square Omni-Grid Cascading scoring of largest chain. Placement: If placed adjacent to a chain, the sum of the stones in the adjacent chains for each player must be equal when the placed piece is included in the sums. Movement: Move a piece to reduce the number of chains by merger Remove any opponent's stone that is directly adjacent to a larger friendly chain.
(game "Chains of Thought"
    (players 2)
    (equipment {
        (board <BoardShape:gridType> use:Vertex)
        (piece "Disc" Each)
    })
    (rules
        (play
            (or
                (move Add
                    (to (sites Empty)
                        if:(<Variant:placement>)
                    )
                    <GameOption:capture>
                )
                (do
                    (and {
                        (set Var "GroupCount" (count Groups "GridDirection" if:(is Mover (who at:(to)))))
                        <Movement:precheck> 
                    })
                    next:(forEach Piece 
                        (move Step "GridDirection"
                            (to 
                                if:(is In (to)
                                    <Movement:limits> 
                                )
                            )
                        )
                    )
                    ifAfterwards:(and {
                        
                        (< (count Groups "GridDirection" if:(is Mover (who at:(to)))) (var "GroupCount"))
                        
                        
                        (>=
                            (size Group at:(last To) "GridDirection" if:(is Mover (who at:(to)))) 
                            (max
                                (results
                                    from:(sites Around (last To) "GridDirection" if:(is Next (who at:(to)))) 
                                    to:(from)
                                    (size Group at:(to) "GridDirection" if:(is Next (who at:(to))))
                                )
                            )
                        )
                    }) 
                    <GameOption:capture>
                )
                <GameGoal:scoring>
            )
        )
        (end 
            (if (no Moves Next) <GameGoal:goal>)
        )
    )
)

Construct a Ludii game based on the following description
Bamboo is a game by Mark Steere based on a novel but simple placement restriction.Each turn a player places a stone of their color on an empty hex. The placement is subject to the following restriction: After your placement you may not have a group containing more stones than the number of groups you have on the board. The first player unable to place a stone loses the game. A size 4 board is currently selected The standard goal is selected, which means that the first player unable to place loses.
(game "Bamboo"
    (players 2)
    (equipment {
        (board (hex <Board>))
        (piece "Disc" Each)
        (piece "Disc" Neutral)
    })
    (rules
        (play
            (do
                (move Add (to (sites Empty)))
                ifAfterwards:(<=
                    (max
                        (results
                            from:(sites Occupied by:Mover)
                            to:1 
                            (* 1 (size Group at:(from)))
                        )
                    )
                    (count Groups if:(= (who at:(to)) (mover)))
                )
            )
        )
        (end ("NoMoves" <Result>))
    )
)

Construct a Ludii game based on the following description
Pushing Me XO, a strategic game for brain training while playing to find the ways to connect and creates the line with cubes to win the game in horizontally, vertically or diagonal.At the first round of the game, players can only pick a blank face cube.
            
            Next round players can play the same cube at the previously.
            
            A player cannot return a cube that he/she has played to place on where he/she took it from.
            
        A player who creates the line of opponent’s symbol is the person who loses the game, even if he/she has created a line of his/her own symbol at the same time. 
(game "Pushing Me XO" 
    (players 2) 
    (equipment { 
        (board (square 5)) 
        (piece "Disc" P1) 
        (piece "Cross" P2) 
        (piece "Square" Neutral)
        (hand Each)
    }) 
    
    (rules 
        (start (place "Square0" (sites Board)))
        (play
            (if "SameTurn"
                (or {
                    ("Push" ("From" Left "LastRow") E)
                    ("Push" ("From" Right "LastRow") W)
                    ("Push" ("From" Bottom "LastColumn") N)
                    ("Push" ("From" Top "LastColumn") S)
                })
                "TakeAPieceInOuterSites"
            )
        )
        (end {
            (if (is Line 5 throughAny:(sites LastTo) what:(next)) (result Next Win))
            (if (is Line 5 throughAny:(sites LastTo) what:(mover)) (result Mover Win))
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Msuwa wa Kunja" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(union (sites Top) (sites Bottom))) 
        )
        
        (play 
            (if (and 
                    ("SameTurn") 
                    (< 0 (var))
                )
                (move Remove 
                    (forEach
                        (sites Next "Home")
                        if:(< 0 (count at:(site)))
                    )
                    (then 
                        (and
                            (if (> (var) 1)
                                (moveAgain)
                            )
                            (set Var (- (var) 1))
                        )
                        
                    )
                )
                (if ("HaveHolesWithMoreThanOneCounter") 
                    (move Select
                        (from 
                            (if ("SameTurn") 
                                "LastHoleSowed" 
                                (sites Mover "Home") 
                            ) 
                            if:(< 1 (count at:(from)))
                        )
                        (then 
                            (sow
                                "Track"
                                owner:(mover)
                                apply:(if (< 1 (count at:(to)))
                                    (moveAgain)
                                    (if (is In (to) (sites Mover "Inner"))
                                        (if (< 0 (count at:("OppositePit" (to))))
                                            (and
                                                (remove ("OppositePit" (to)))
                                                (if (< 0 (count at:("OppositeOuterPit" (to))))
                                                    (and {
                                                        (remove ("OppositeOuterPit" (to)))
                                                        (set Var 2)
                                                        (moveAgain)
                                                    })
                                                )
                                            )
                                        )
                                    )
                                ) 
                            )
                        )
                    )
                    (move Select
                        (from 
                            (sites Mover "Home") 
                            if:(and
                                (= 1 (count at:(from)))
                                (= 0 (count at:("NextHoleFrom" (from))))
                            )
                        )
                        (then 
                            (sow
                                "Track"
                                owner:(mover)
                                apply:
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (< 0 (count at:("OppositePit" (to))))
                                        (and
                                            (remove ("OppositePit" (to)))
                                            (if (< 0 (count at:("OppositeOuterPit" (to))))
                                                (and {
                                                    (remove ("OppositeOuterPit" (to)))
                                                    (set Var 2)
                                                    (moveAgain)
                                                })
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)
Msuwa wa Kunja is a four-row mancala-style board game played by the Nyanja people of East Africa. 4x10-20 holes, with even numbers. Two counters in each hole in the outer row. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from two other holes on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game.
         Each row has 10 holes.

Construct a Ludii game based on the following description
Shobu is a beautifully crafted abstract strategy game for two players.Your turn is in two parts. First, a player may move one of their stones up to two spaces in any direction, including diagonally, in what is called a passive (or set up) move. Second, they take a more aggressive move, which must be the same direction and number of spaces as the first move. It is this second move that allows you to push stones across the board - or off the board's edge. A passive move can be done only if it can be followed by an aggressive move. Remove all four of your opponent's stones from just one of the four boards to win. 
(game "Shobu" 
    (players 2)
    (equipment {
        (board 
            (merge {
                (square 4)
                (shift 5 0 (square 4))
                (shift 0 5 (square 4))
                (shift 5 5 (square 4))
            })
        )
        (piece "Ball" Each)
        (regions "BottomDark" (expand origin:(coord "A1") steps:3))
        (regions "TopDark" (expand origin:(coord "A5") steps:3))
        (regions "BottomLight" (expand origin:(coord "E1") steps:3))
        (regions "TopLight" (expand origin:(coord "E5") steps:3))
        (regions "Home" P1 (union (sites "BottomDark") (sites "BottomLight")))
        (regions "Home" P2 (union (sites "TopLight") (sites "TopDark")))
        (regions "Light" (expand (sites Right) steps:3))
        (regions "Dark" (expand (sites Left) steps:3))
    })
    (rules
        (start {
            (place "Ball1" (union (sites Bottom) (sites Row 4)))
            (place "Ball2" (union (sites Top) (sites Row 3)))
        })
        
        phases:{
        (phase "Passive"
            (play 
                (do
                    (forEach Piece 
                        (if (is In (from) (sites Mover "Home"))
                            (move Slide 
                                (between 
                                    (max 2)
                                    if:(is Empty (between))
                                )
                            )
                        )
                        (then (moveAgain))
                    )
                    ifAfterwards:(can Move ("AgressiveMoves"))
                )
            )
            (nextPhase Mover "Agressive")
        )
        (phase "Agressive"
            (play ("AgressiveMoves"))
            (nextPhase Mover "Passive")
        )
        }
        (end 
            (if (or { 
                    ("NextNoPieceInRegion" (sites "BottomDark"))
                    ("NextNoPieceInRegion" (sites "TopDark"))
                    ("NextNoPieceInRegion" (sites "BottomLight"))
                    ("NextNoPieceInRegion" (sites "TopLight"))
                }) 
                (result Mover Win) 
            )
        )
    )
)

Construct a Ludii game based on the following description
Chongka' is a two-row mancala-style board game played by the Chamorro people in the Marianas Islands in the early twentieth century. It is similar to other mancala-style games played on the islands of the western Pacific and Indian Oceans.2x7 board with two stores. Seven counters in each hole. Players move from one of the holes in their row, sowing in a clockwise direction, and including the player's store, which is to the left, but not the opponent's store. If the final counter of a sowing lands in an occupied hole (not a store), sowing continues. If it lands into an empty hole, the turn is over. If the empty hole is in the player's own row, the contents of the hole opposite in the opponent's row are captured and placed in the store. The person who captures the most counters wins. 
(game "Chongka'" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "Track1" "7,W,WNW,ENE,E" loop:True P1)
            (track "Track2" "7,W,N,E,ESE" loop:True P2)
            }
        )
        (piece "Seed" Shared) 
        (regions P1 (sites Bottom))     
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        
        (start (set Count 7 to:(union (sites P1) (sites P2))))
        
        (play 
            (move Select 
                (from 
                    (if 
                        ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover) 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (and { 
                                (> (count at:(to)) 1)
                                (is In (to) (union (sites P1) (sites P2)))
                            })
                            (moveAgain)
                            (if (and 
                                    (is In (to) (sites Mover)) 
                                    (> (count at:("OppositePit" (to))) 0)
                                )
                                (fromTo 
                                    (from ("OppositePit" (to))) 
                                    (to (mapEntry Mover)) 
                                    count:(count at:("OppositePit" (to)))
                                ) 
                            )
                        )
                    )
                )
            )		
        )
        
        (end ("MancalaByScoreWhen" (and (no Moves Mover) (no Moves Next))))
    )
)

Construct a Ludii game based on the following description
Choro is a four-row mancala-style board game played by the Lango people of northern Uganda. It was documented in the early twentieth century.4x8 board. Two counters in each hole. Opening play: Two players play simultaneously, lifting and sowing counters from their outer rows. The game must begin from one of the rightmost two holes. Rules for sowing and capturing are the same as in the main phase of the game. The opening ends when both players reach an empty hole, and the first player to do so begins play in the main phase. Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over. For capturing: Holes are in 'opposition' when one player has the inner row hole occupied and the opponent has at least the opposite hole in the inner row occupied; if the outer row hole is also occupied it is also in opposition. However, if the opponent's inner row hole is empty and the outer row is occupied, it is not in opposition. If the last hole in a sowing falls into a hole that is is in opposition, the player takes the counters in the opponent's holes in opposition and places them in the outer row hole next to the hole from which the capture occurred. The player then sows the captured counters from this hole. If the capture is only of one counter, the contents of the appropriate outer row hole on the player's side are sown along with the one captured counter. Further captures in the sowing can occur in the same way. If a player can make a capture on the first sowing they must. Otherwise, they can choose any hole on their side to sow. However, each player has four holes from which clockwise plays can be made: the leftmost two holes in both the inner and outer rows. Clockwise moves can only be made from these holes if they immediately lead to a capture. When the captured counters are sown, they may, starting from the same hole, also be sown clockwise as long as they lead to a capture. If they cannot lead to a capture, they are sown anti-clockwise in the normal way from the outer row hole opposite the hole from which the capture was made. A player is not required to capture in a clockwise direction. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses. 
(game "Choro (Lango)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "24,E,S1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))          
        (regions "Outer" P2 (sites Top))           
        (regions "FourLeftMost" P1 (intersection (expand (sites Left)) (expand (sites Bottom)))) 
        (regions "FourLeftMost" P2 (intersection (expand (sites Right)) (expand (sites Top)))) 
        (regions "TwoRightMostOuter" P1 (intersection (expand (sites Right)) (sites Bottom))) 
        (regions "TwoRightMostOuter" P2 (intersection (expand (sites Left)) (sites Top)))  
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        phases:{
        (phase "OuterPhase"
            (play
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (if (= 1 (value Player Mover))
                                (sites Mover "Outer") 
                                (sites Mover "TwoRightMostOuter") 
                            )
                        )
                        if:(if ("SameTurn")
                            (< 0 (count at:(from)))
                            (and
                                (if (= 0 (count Sites in:("HolesWithPossibleCapture" (sites Mover "Outer"))))
                                    True
                                    (is In (from) ("HolesWithPossibleCapture" (sites Mover "Outer")))
                                )
                                (< 1 (count at:(from)))
                            )
                        )
                    )
                    (then 
                        (sow
                            count:(if ("SameTurn") (var "Count") (count at:(last From)))
                            "TrackCCW"
                            owner:(mover)
                            apply:(and
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and 
                                                (is Occupied ("OppositePit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            )
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to ("CorrespondingOuterPit" (to)))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (if (is Occupied ("OppositeOuterPit" (to)))
                                                    (fromTo
                                                        (from ("OppositeOuterPit" (to)))
                                                        (to ("CorrespondingOuterPit" (to)))
                                                        count:(count at:("OppositeOuterPit" (to)))
                                                    )
                                                )
                                                (set Var "Replay" ("CorrespondingOuterPit" (to)))
                                                (if (= 1 (count at:("CorrespondingOuterPit" (to))))
                                                    (set Var "Count" (+ { 1 (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))) }))
                                                    (set Var "Count" (+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to)))))
                                                )
                                            })
                                            (and
                                                (set Var "Replay" (to))
                                                (set Var "Count" (count at:(to)))
                                            )
                                        )
                                    )
                                )
                                (if (!= 1 (value Player Mover)) (set Value Mover 1))
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (= 1 (count at:(last To afterConsequence:True))) "MainPhase")
        )
        
        (phase "MainPhase"
            (play
                (or
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover "FourLeftMost") 
                            )
                            if:(and {
                                if:(if ("SameTurn")
                                    (< 0 (count at:(from)))
                                    (< 1 (count at:(from)))
                                )
                                (is In (from) (sites Mover "FourLeftMost"))
                                (is In ("NextHole" (from) "TrackCW" (count at:(from))) (sites Mover "Inner"))
                                (is Occupied ("OppositePit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                            })
                        )
                        (then 
                            (sow
                                count:(if ("SameTurn") (var "Count") (count at:(last From)))
                                "TrackCW"
                                owner:(mover)
                                apply:
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and 
                                                (is Occupied ("OppositePit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            )
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to ("CorrespondingOuterPit" (to)))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (if (is Occupied ("OppositeOuterPit" (to)))
                                                    (fromTo
                                                        (from ("OppositeOuterPit" (to)))
                                                        (to ("CorrespondingOuterPit" (to)))
                                                        count:(count at:("OppositeOuterPit" (to)))
                                                    )
                                                )
                                                (set Var "Replay" ("CorrespondingOuterPit" (to)))  
                                                (if (= 1 (count at:("CorrespondingOuterPit" (to))))
                                                    (set Var "Count" (+ { 1 (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))) }))
                                                    (set Var "Count" (+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to)))))
                                                )
                                            })
                                            (and
                                                (set Var "Replay" (to))
                                                (set Var "Count" (count at:(to)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover) 
                            )
                            if:(if ("SameTurn")
                                (< 0 (count at:(from)))
                                (and
                                    (if (= 0 (count Sites in:("HolesWithPossibleCapture" (sites Mover))))
                                        True
                                        (is In (from) ("HolesWithPossibleCapture" (sites Mover)))
                                    )
                                    (< 1 (count at:(from)))
                                )
                            )
                        )
                        (then 
                            (sow
                                count:(if ("SameTurn") (var "Count") (count at:(last From)))
                                "TrackCCW"
                                owner:(mover)
                                apply:
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and {
                                                (is Occupied ("OppositePit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            })
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to ("CorrespondingOuterPit" (to)))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (if (is Occupied ("OppositeOuterPit" (to)))
                                                    (fromTo
                                                        (from ("OppositeOuterPit" (to)))
                                                        (to ("CorrespondingOuterPit" (to)))
                                                        count:(count at:("OppositeOuterPit" (to)))
                                                    )
                                                )
                                                (set Var "Replay" ("CorrespondingOuterPit" (to)))
                                                (if (= 1 (count at:("CorrespondingOuterPit" (to))))
                                                    (set Var "Count" (+ { 1 (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))) }))
                                                    (set Var "Count" (+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to)))))
                                                )
                                            })
                                            (and
                                                (set Var "Replay" (to))
                                                (set Var "Count" (count at:(to)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Acedrex de los Cuatros Tiempos is a four-player game dervied from Chess. It was described in Alofonso X of Castile's Libro de los Juegos. The four players are conceptualized as playing the four seasons, eating away at the other seasons.Played on an 8x8 checkered board, with large diagonals drawn on the inner square 4x4 spaces. Four players, seated, from top left, anti-clockwise: red, black, white, green. Each player has four pawns, a knight, a fil, a rook, and a king. The kings begin in the corner space, with the knight to the adjacent square in the row with the king, the rook in the square in the column adjacent to the king, and the fil in the remaining 2x2 square in the corner. The pawns are placed on the orthogonally adjacent squares to this formation. Pieces move as follows: King: One square in any direction. Knight: As a knight in Chess. Rook: Orthogonally any number of spaces. Fil: moves diagonally two spaces, jumping over any piece in the intervening square. Pawns: move forward along the direction of their nearest edge, but capture diagonally forward. Upon reaching the opposite edge of the board, pawns are immediately promoted to \ 
(game "Acedrex de los Cuatros Tiempos" 
    (players 4) 
    (equipment { 
        (board (square 8))
        (piece "King" Each
            (move
                Step 
                (to 
                    if:("EmptyorNext") 
                    ("CapturePiece")
                ) 
            )
        )
        (piece "Pawn" P1 W ("PawnMove" Left))
        (piece "Pawn3d" P1 N ("PawnMove" Top))
        
        (piece "Pawn" P2 W ("PawnMove" Left))
        (piece "Pawn3d" P2 S ("PawnMove" Bottom))
        
        (piece "Pawn" P3 E ("PawnMove" Right))
        (piece "Pawn3d" P3 S ("PawnMove" Bottom))
        
        (piece "Pawn" P4 E ("PawnMove" Right))
        (piece "Pawn3d" P4 N ("PawnMove" Top))
        
        (piece "Knight" Each
            (move Leap 
                "KnightWalk" 
                (to 
                    if:("EmptyorNext") 
                    ("CapturePiece")
                ) 
            )
        )
        (piece "Rook" Each
            (move Slide 
                Orthogonal 
                (to 
                    if:(= ("RightPlayer") (who at:(to))) 
                    ("CapturePiece")
                ) 
            )
        )
        (piece "Bishop" Each
            (move Hop 
                Diagonal 
                (between if:True) 
                (to 
                    if:("EmptyorNext") 
                    ("CapturePiece")
                ) 
            )		
        )
        (piece "Queen" Each
            (move Step 
                Diagonal
                (to 
                    if:("EmptyorNext") 
                    ("CapturePiece")
                ) 
            )	
        )
        }
    )
    (rules
        (start {
            (place "King1" coord:"H1") (place "Knight1" coord:"G1") (place "Rook1" coord:"H2") 
            (place "Bishop1" coord:"G2") (place "Pawn1" {"F1" "F2"}) (place "Pawn3d1" {"G3" "H3"})
            
            (place "King2" coord:"H8") (place "Knight2" coord:"G8") (place "Rook2" coord:"H7") 
            (place "Bishop2" coord:"G7") (place "Pawn2" {"F8" "F7"}) (place "Pawn3d2" {"H6" "G6"})
            
            (place "King3" coord:"A8") (place "Knight3" coord:"B8") (place "Rook3" coord:"A7") 
            (place "Bishop3" coord:"B7") (place "Pawn3" {"C7" "C8"}) (place "Pawn3d3" {"A6" "B6"})
            
            (place "King4" coord:"A1") (place "Knight4" coord:"B1") (place "Rook4" coord:"A2") 
            (place "Bishop4" coord:"B2") (place "Pawn4" {"C1" "C2"}) (place "Pawn3d4" {"A3" "B3"})
        })
        phases:{
        (phase "Betting" 
            (play (move Bet Mover (range 0 100)))
            (nextPhase Mover)
        )
        (phase "Playing" 
            (play
                (do
                    (forEach Piece)
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                    (then 
                        (if ("IsInCheck" "King" Next)
                            (if 
                                ("NextCanNotMove")
                                (forEach Site (sites Occupied by:Next)
                                    (and
                                        (remove (to))
                                        (and 
                                            (note player:Next "Pays into the pot" to:Next) 
                                            (set Pot (+ (pot) (amount Next)))
                                        )
                                    )
                                )
                                (and 
                                    (note player:Next "Pays into the pot" to:Next) 
                                    (set Pot (+ (pot) (amount Next)))
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        (end
            (if (no Pieces Next)
                (result Next Loss)
            ) 
        )
    )
)

Construct a Ludii game based on the following description
Pancha Keliya is a race game game similar to others played in South Asia which have similar tracks, and seem to date from at least the medieval period. The board is a single track: nine squares along the bottom row. From the central space, a track of 25 spaces, which makes turns every five spaces. It begins vertically, then to the right, then vertical, then diagonallyup and to the left, then diagonallydown and to the left. The squares just before the track turns are marked with an \ 
(game "Pancha Keliya" 
    (players 2)
    (equipment {
        (board 
            (rotate 90
                (merge {
                    (shift 2.79 10.44 (rotate 135 (rectangle 5 1)))
                    (shift 6.32 11.15 (rotate 45 (rectangle 5 1)))
                    (shift 9 11
                        (graph
                            vertices:{ { 0 0 } { -0.75 0.55 } { -0.04 1.24 }{ 1 0 } } 
                            edges:{ {0 1} {1 2} {2 3} {3 0}} 
                        )
                    )
                    (shift 9 5 (rectangle 6 1))
                    (shift 5 5 (rectangle 1 5))
                    (rectangle 1 9)
                    (shift 4 0 (rectangle 6 1))
                })
            )
            {
            (track "Track1" "23,N4,W,N,W,11,7,SW,SE,End" P1 directed:True)
            (track "Track2" "31,S4,W,N,W,11,7,SW,SE,End" P2 directed:True)
            }
        )
        (piece "Marker" Each
            (if ("IsEndTrack" "SiteToMoveOnTrack")
                "RemoveAPiece"
                (if ("IsNotOffBoard" "SiteToMoveOnTrack") 	 			
                    (if (or
                            (is Empty "SiteToMoveOnTrack")
                            (and 
                                (not ("IsFriendAt" "SiteToMoveOnTrack")) 
                                (not (is In "SiteToMoveOnTrack" (sites "Protect")))
                            )
                        )
                        (move 
                            (from)
                            (to 
                                "SiteToMoveOnTrack" 
                                ("HittingCapture" (mapEntry "Entry" Next))
                            )
                        )
                    )
                )
            )
        )
        ("StickDice" 6)
        (hand Each)
        (regions "Protect" (sites {27 19 12 10 1}))
        (regions "SpecialDiceValues" (sites {1 5 6})) 
        (map "Entry" {(pair P1 23) (pair P2 31)})
    })
    (rules
        (start (place "Marker" "Hand" count:3))
        (play 
            ("RollMove"
                (if 
                    (and (is In (count Pips) (sites "SpecialDiceValues")) ("HandOccupied" Mover))
                    (or
                        (move 
                            (from (handSite Mover)) 
                            (to 
                                (mapEntry "Entry" Mover) 
                                if:(not ("IsEnemyAt" (to)))
                            )
                        )
                        (forEach Piece)
                        (then (moveAgain))
                    )
                    (forEach Piece)
                )
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Seega is a game played in North Africa, and is particularly well-known in Egypt and Sudan. It has been documented since the nineteenth century, but is likely to be older. The boards are typically scooped out of the sand or etched into stone surfaces.5x5 board. Players begin by placing their pieces in prescribed spaces, and then alternating two-by-two in places as they see fit, except for the central space. Once all the spaces except the central one are filled, the first player moves a piece one space orthogonally to the empty space. Pieces are captured by surrounding them on either side by a player's own pieces. The player to capture all of the opponent's pieces wins. The game is played on a 5x5 board.
(game "Seega" 
    (players 2) 
    (equipment { 
        (board (square <Board:size>)) 
        (hand Each) 
        
        (piece "Marker" Each 
            ("StepToEmpty" Orthogonal
                (then
                    ("CustodialCapture"
                        Orthogonal
                        (max 1)
                    )
                )
            )
        )
    }) 
    
    (rules 
        (start (place "Marker" "Hand" count:<Board:numPieces>))
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (difference (sites Empty) (centrePoint))) 
                    (then 
                        (if 
                            ("NewTurn") 
                            (moveAgain)
                        )
                    )
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Yoin is a drawless game for two players: Black and White. It is played on the spaces (cells) of an initially empty hexagonal grid of hexagons (board).Yoin was invented by Luis Bolaños Mures in 2021.Definitions
            A group is a stone along with all other stones one could reach from it through a series of steps between adjacent stones of its color.
            
            The size of a group is the number of stones in it.
            
            Play
            Black plays first, then turns alternate. On your turn, place a stone of your color on an empty cell. When the board is full, the winner is determined as follows:
            
            (1) Let n equal 0.
            (2) The player with fewer groups bigger than n stones wins.
            (3) If no winner is found, increase n by 1 and go back to (2).
            
        The pie rule is used in order to make the game fair. This means White will have the option, on their first turn only, to swap sides with their opponent instead of making a regular move. A size 3 board is currently selected The score is currently updated after each move.
(game "Yoin"
    (players 2)
    (equipment {
        (board (hex <Size>))
        (piece "Disc" Each)
    })
    (rules
        (meta (swap))
        (play
            (move Add
                (to (sites Empty))
                (then <Score>)
            )
        )
        (end 
            (if (is Full) 
                {(if
                    (< 
                        (score P1)
                        (score P2)
                    )
                    (result P1 Win)
                )
                (if
                    (> 
                        (score P1)
                        (score P2)
                    )
                    (result P2 Win)
                )}
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Gavalata" 
    (players <Player:num>) 
    (equipment { 
        (board 
            (square 5)
            {
            (track "Track1" "2,W,N,E,S,W1,N3,W2,S2,E1,N1" P1 directed:True)
            (track "Track2" "22,E,S,W,N,E1,S3,E2,N2,W1,S1" P2 directed:True)
            <Player:trackP3>
            <Player:trackP4>
            }
        )
        ("StickDice" <Num:dice>)
        (piece "Paddle" Each
            (if ("IsNotOffBoard" "SiteToMoveOnTrack")
                (move 
                    (from (from) level:(level))
                    (to 
                        "SiteToMoveOnTrack" 
                        ("HittingCapture" ("StartingPoint" (who at:(to))))
                    )
                )
                (then 
                    (if (= "Goal" (last To))
                        (remove (last To))
                    )
                )
            )		
        )
        (map {(pair 1 "C1") (pair 2 "C5") (pair 3 "E3") (pair 4 "A3")})
    }) 
    (rules 
        (start {
            (place Stack "Paddle1" ("StartingPoint" 1) count:"NumInitPiece")
            (place Stack "Paddle2" ("StartingPoint" 2) count:"NumInitPiece")
            <Player:startP3>
            <Player:startP4>
        })
        
        (play 
            ("RollMove"
                (if (!= 0 ("ThrowValue")) (forEach Piece) (move Pass))
            )
        )
        
        (end ("EscapeWin"))
    )
)
Gavalata is a race game played on a square board that was played in southern India in the nineteenth century.5x5 square. Nine squares are marked: the four central squares of each side, the central square of the board, and the squares which are diagonally between them. Two or four players; each player begins on one of the marked outer squares, beginning on opposite sides if two are playing. Players use one or two cowries as pieces. Four or five cowries are used as dice, with the value of the throw equalling the number of mouths which land face up. Players proceed in a clockwise direction around the board, until they reach the space before the one in which they began, moving to the marked square to the right of the direction of play, and proceeding around the inner square of spaces in an anti-clockwise direction, until arriving at the central space. When a player's piece lands on a space occupied by the opposing player, the opponent's piece is sent back to the starting point. The first player to bring all their pieces to the central square wins. The game involves 2 players. The game involves 1 piece per player. The game involves 4 dice.

Construct a Ludii game based on the following description
This hunt game played in the Orissa region of India is played with one tiger trying to eat twelve goats, while the goats try to block the tiger from moving.5x5 lines, intersecting to form a square. Diagonals are drawn in the four quadrants of the board. One triangle, its apex intersecting the main board at the midpoint of one side. The base of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. One player plays as the tiger, placed on the central point of the triangle, and the other plays as twelve goats, which begin on the first two rows of points opposite the triangle and on the outer two points in the third row. The tiger moves first. Pieces move to an empty adjacent spot along the lines on the board. The tiger alone may capture a goat by hopping over it to an empty spot immediately opposite a goat. The tiger wins by capturing all the goats; the goats win by blocking the tiger from being able to move. 
(game "Orissa Tiger Game (One Tiger)" 
    (players 2)
    (equipment { 
        (board 
            (rotate 180 ("AlquerqueGraphWithBottomTriangle"))
            use:Vertex
        ) 
        (piece "Tiger" P1 (or ("StepToEmpty") ("HopCapture")))
        (piece "Goat" P2 ("StepToEmpty"))
    }) 
    
    (rules 
        (start { 
            (place "Tiger1" (sites {"C6"}))
            (place "Goat2" (union (expand (sites Bottom)) (sites {"A3" "E3"})))
        })
        
        (play (forEach Piece)) 
        
        (end ("NoMovesP1NoPiecesP2"))
    )
)

Construct a Ludii game based on the following description
International Draughts, which is also commonly known as Polish Draughts, has become one of the most widely-played forms of Draughts in the world, and is played in international competitions. It seems to have originated in the eighteenth century in Paris, and spread throughout Europe from there and to the rest of the world through European colonisation.10x10 board, 20 pieces per player. Pieces move diagonally one or can jump an opponent's adjacent player to capture it. Pieces can move forward or backwards. When a piece reaches the opposite edge of the board from its starting position, it becomes a king and can may move and jump over any number of spaces diagonally. Captures are compulsory and the maximum number of jumps must be made. Winning is achieved by capturing all the opponent's pieces or by blocking them from moving. 
(game "International Draughts" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 10))
    
    (rules 
        ("BlackCellsSetup" 4)
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves
                        ("HopInternationalDraughtsStyle" (from (last To))
                            (then 
                                ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To)))
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                    )
                    (max Moves ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn))
                )
                (priority {
                    (max Moves
                        (or 
                            (forEach Piece "Counter"
                                ("HopInternationalDraughtsStyle" (from)
                                    (then 
                                        ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To))) 
                                            ("PromoteIfReach" (sites Next) "DoubleCounter")
                                        ) 
                                    ) 
                                ) 
                            )
                            (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture" before:(count Rows) after:(count Rows) at:EndOfTurn))
                        )
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal))
                    )
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Mathematical game used as an introductory game in the book Winning Ways for your Mathematical Plays.This game is played on an empty 1row x n coloumn board with m stones on each side. At each turn, each player must do one of the following actions. Move a stone forward (i.e., left to one player, right to the other) or jump over one enemy stone, landing on the immediate empty cell. The player who makes the last move wins the game. The game is played on a 1x5 board.
(game "Toads and Frogs"
    (players 2)
    (equipment {
        (board (rectangle 1 <BoardSize:BoardSize>))
        (piece "Toad" P1 E "MoveOfThePiece")
        (piece "Frog" P2 W "MoveOfThePiece")
    })
    (rules
        (start {
            (place "Toad1" (expand (sites Left) steps:(- <BoardSize:pieces> 1)))
            (place "Frog2" (expand (sites Right) steps:(- <BoardSize:pieces> 1)))
        })
        (play (forEach Piece))
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Chaturanga is a replacement capturing game that is the ancestor of Chess and which has been played in India for centuries. This version was documented in the nineteenth century, on a 12x12 board.12x12 board. Pieces move as follows: Raja (King, x1): moves one space in any direction; Mantri (Minister, placed to the left of the Raja, x1): moves any distance orthogonally or diagonally; Ushtra (Camel, x2): moves diagonally any distance; Chariot (x2), moves orthogonally any distance; Flagcar (x2), moves diagonally any distance; Vaha (Horse, x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (Elephant, x2): moves orthogonally any distance. Padati (Pawn, x12): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja). 
(game "Chaturanga (12x12)"
    ("TwoPlayersNorthSouth")
    (equipment { 
        (board (square 12))
        ("ChessPawn" "Pawn" ~
            (then
                (if (is In (last To) (sites Mover "Promotion")) 
                    (and
                        (promote (last To) (piece "Ferz_noCross") Mover)	
                        (fromTo (from (last To)) (to (last From)))
                    )
                )
            )
        )
        ("ChessRook" "Rook")
        ("ChessBishop" "Camel")
        ("ChessKing" "King_noCross")
        ("ChessBishop" "Bishop_noCross") 
        ("ChessRook" "Elephant")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Ferz_noCross")
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 10))
            (place "Elephant1" {"A1" "L1"}) 
            (place "Knight1" {"B1" "K1"}) 
            (place "Bishop_noCross1" {"C1" "J1"}) 
            (place "Rook1" {"D1" "I1"}) 
            (place "Camel1" {"E1" "H1"}) 
            (place "Ferz_noCross1" coord:"F1") 
            (place "King_noCross1" coord:"G1") 
            
            (place "Elephant2" {"A12" "L12"}) 
            (place "Knight2" {"B12" "K12"}) 
            (place "Bishop_noCross2" {"C12" "J12"}) 
            (place "Rook2" {"D12" "I12"}) 
            (place "Camel2" {"E12" "H12"})
            (place "Ferz_noCross2" coord:"G12") 
            (place "King_noCross2" coord:"F12") 
        })
        (play
            (if (no Moves Mover)
                (move Remove
                    (difference (sites Occupied by:Next) (where "King_noCross" Next))
                )
                (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (and {
                    (no Pieces Next "Ferz_noCross")
                    (no Pieces Next "Knight")
                    (no Pieces Next "Bishop_noCross")
                    (no Pieces Next "Elephant")
                    (no Pieces Next "Rook")
                    (no Pieces Next "Camel")
                })
                (result Mover Win) 
            ) 
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Kensington" 
    (players 2) 
    (equipment { 
        (board (rotate 90 (tiling T3464 2)) use:Vertex)
        (hand Each)
        (piece "Marker" Each "StepToEmpty") 
        (regions "HexA" P1 (sites Cell "E4")) 
        (regions "HexB" P1 (sites Cell "I4")) 
        (regions "HexA" P2 (sites Cell "E12")) 
        (regions "HexB" P2 (sites Cell "I12")) 
        (regions "HexNeutral1" (sites Cell "C8")) 
        (regions "HexNeutral2" (sites Cell "G8")) 
        (regions "HexNeutral3" (sites Cell "K8")) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:15))
        
        (play
            (if "SameTurn"
                "MoveAnEnemyPiece"
                (if ("HandEmpty" Mover)
                    (forEach Piece)
                    "PlaceAPiece"
                    (then 
                        (forEach Site 
                            "AllCellOfLastVertex"
                            (if "CellFilled"
                                (if "HexFilled"
                                    (if 
                                        (or {
                                            (= "AllVerticesOfCell" (sites Mover "HexA")) 
                                            (= "AllVerticesOfCell" (sites Mover "HexB"))
                                            (= "AllVerticesOfCell" (sites "HexNeutral1"))
                                            (= "AllVerticesOfCell" (sites "HexNeutral2"))
                                            (= "AllVerticesOfCell" (sites "HexNeutral3"))
                                        }) 
                                        "NextPlayerLose"
                                    )
                                    (and 
                                        (if "SquareFilled"
                                            "TwoPieceToMove" 
                                        )
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ) 
        (end (if "NextPlayerHasLost" (result Mover Win))) 
    )
)
Kensington is an abstract strategy board game devised by Brian Taylor and Peter Forbes in 1979, named after London's Kensington Gardens, which contains the mosaic upon which the gameboard is patterned. It is played on a geometrical board based on the rhombitrihexagonal tiling pattern.The two players, Red and Blue, alternately place tokens on the intersections of the board until each has placed fifteen. Thereafter they alternate turns sliding a single token along a line to an adjacent vertex.
            
            A player who occupies the three vertices of any triangle has formed a mill and may relocate one enemy token. Occupying the four vertices of a square (forming a double mill) allows the player to relocate two enemy tokens. No more than two tokens may be relocated in a single turn, even if a player completes a mill and double mill with the same move.
            
        The winner is the first player to occupy all six vertices of either any neutral hexagon or one of his/her own color. A win can be achieved during either the placement or movement phases of the game. 

Construct a Ludii game based on the following description
Katséla is an alignment game played by the Chokwe people of Angola.Three intersecting lines, with diagonals drawn in the square. Two players. Three pieces per player, one playing as red and the other as white. The red player plays first and places their piece in the central spot. Players alternate turns placing one of their pieces on an empty space on the board. When all of the pieces are placed, players alternate turns moving one of their pieces to an empty adjacent spot on the board along the lines. The first player to place three of their pieces in a row wins. 
(game "Katsela"
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 3 3)
        (hand Each)
        (piece "Marker" Each ("StepToEmpty"))
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        phases:{
        (phase "Opening" 
            (play (move (from (handSite Mover)) (to (centrePoint))))
            (nextPhase "Placing") 
        )
        (phase "Placing" 
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" Mover) "Moving")
        )
        (phase "Moving" (play (forEach Piece)))
        }
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
Tsun K'i is a race game played in seventeenth century China. It is described in De Ludibus Orientalibus, which is the only source mentioning this game.2x8 board, with rectangular spaces. Sixteen pieces per player, eight each placed on the two rectangles to each player's left. Each player moves their pieces in an anti-clockwise direction. Two six-sided dice. When a player rolls two 1s, they lose a piece. When a player rolls doubles of another number, the player may move two pieces the full total of the roll, or one piece only moves half the total roll. When consecutive numbers are rolled, the player may move one piece the total of the two dice and the second piece the value of the lower die, or may move one piece the total of the die and another piece the total of the dice minus 1. When the roll is two non-consecutive numbers, the player moves the values of the individual dice. The first player to move their pieces around the board and back to the starting position wins.  
(game "Tsun K'i" 
    (players 2)
    (equipment {
        (board 
            (scale 10 2 (rectangle 8 2))
            {
            (track "Track1" "1,N,W,S,N,E1,S" P1 directed:True)
            (track "Track2" "14,S,E,N,S,W1,N" P2 directed:True)
            }
        )
        (piece "Stick" Each)
        (dice d:6 num:2)
        (regions "Exit" P1 (sites {"B1" "B2"}))
        (regions "Exit" P2 (sites {"A7" "A8"}))
    })
    (rules
        (start {
            (place Stack "Stick1" (sites {"B1" "B2"}) count:8)
            (place Stack "Stick2" (sites {"A7" "A8"}) count:8)
        })
        (play 
            (do
                (if ("NotReplayMove") (roll))
                next:(if (can Move ("Move")) ("Move") (move Pass (then (set Var 0))))
                (then
                    (if (and (is In (last To) (sites Mover "Exit")) (not (is In (last From) (sites Mover "Exit"))))
                        (remove (last To) level:(last LevelTo))
                    )
                )
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Zola is an drawless annihilation game by Mark Steere.On your turn you have to options:
            • Noncapturing move: Step kingwise away from the center of the line you are stepping along.
            • Capturing move: Capture queenwise any enemy not farther away from the center of the line you are moving along.
            
        Only if you have no moves may you pass. The game is over when only one player has pieces left. That player is the winner. A 6x6 board is currently selected
(game "Zola"
    (players 2)
    (equipment {
        (board (square <Board>))
        (piece "Disc" Each)
    })
    (rules
        (start {
            (place "Disc1" (sites Phase 0))
            (place "Disc2" (sites Phase 1))
        })
        (play
            (forEach Piece
                (or {
                    ("Capture" N S)
                    ("Capture" NE SW)
                    ("Capture" E W)
                    ("Capture" SE NW)
                    ("Step")
                })
            )
        )
        (end 
            (if 
                (or
                    (no Pieces P1)
                    (no Pieces P2)
                ) 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Mak Ruk is a capturing game played in Thailand. It is similar to other games derived from Chaturanga, with different moves for some pieces and the pawns starting on the third rank of the board, rather than the second.8x8 board. Each player begins with sixteen pieces with special moves: Khoon (x1): moves orthogonally in any direction; Met (x1): placed to the right of the Khoon, moves one square orthogonally or diagonally forward, or one square diagonally backward, may move two squares orthogonally forward on the first move; Khon (x2): moves one square forward orthogonally or diagonally, may move backward diagonally but not to capture; Maa (x2): moves as a Chess knight; Rooa (x2): moves orthogonally any distance; Bea (x8): move forward one space, but capture diagonally. When they reach the opposite edge of the board, they are promoted to Met. They begin on the third row of the board with respect to each player. When the Khoon is threatened, it is in check and the player's next move must be to remove the check. If the player cannot, it is checkmate and the player loses. If there are no legal moves, the game is a draw. If one player has only a king left, the opponent must checkmate it within a set number of turns, based on the highest ranking piece left on the board, minus the total number of pieces on the board. The values are: two Rooa: eight; one Rooa, sixteen, two Khon, 22; one Khon, 44; two Maa, 33; one Maa, 66; Met and two Bea, 88; one each of Met, Rooa, Maa, Khon, sixteen. With only a Met, the game is a draw. 
(game "Mak Ruk" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        ("ChessPawn" "Pawn" ~ (then ("PromoteIfReach" (sites Mover "Promotion") "Ferz_noCross")))
        ("ChessRook" "Rook")
        (piece "King_noCross" Each ("StepToNotFriend" Orthogonal))
        (piece "Bishop_noCross" Each 
            (or
                ("StepToNotFriend" (directions {FL FR Forward}))
                ("StepToEmpty" (directions {BL BR}))
            )
        )
        ("ChessKnight" "Knight")
        (piece "Ferz_noCross" Each 
            (or
                (if (= (state at:(from)) 1)
                    (move (from) (to (ahead (ahead (from) N) N) if:(is Empty (to))))
                    (then (set State at:(last To) 0))
                )
                ("StepToNotFriend" (directions {BL BR FL FR Forward}))
            )
        )
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 2))
            (place "Pawn2" (sites Row 5))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"E1" state:1) (place "King_noCross1" coord:"D1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8" state:1) (place "King_noCross2" coord:"E8") 
        })
        
        (play 
            (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
        )
        
        (end {
            ("Checkmate" "King_noCross")
            ("DrawIfNoMoves" Next)
            (if (and {(= (count Pieces Next) 1) (= (count Pieces Mover) 2) ("IsNotOffBoard" (where "Ferz_noCross" Mover))})
                (result Mover Draw)
            )
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Sijat El Taba" 
    (players 2)
    (equipment {
        (board (rectangle <Row:num> 10)
            { 
            <Row:track>
            }
        )
        (piece "Marker" Each
            (if (= (state at:(from)) 1) 
                (or
                    (if ("IsNotOffBoard" ("NextSiteOnTrack" ("ThrowValue")))
                        (if (or
                                (is In ("NextSiteOnTrack" ("ThrowValue")) (sites Empty))
                                ("IsEnemyAt" ("NextSiteOnTrack" ("ThrowValue")))
                            )
                            (move 
                                (from)
                                (to 
                                    ("NextSiteOnTrack" ("ThrowValue")) 
                                    "CaptureEnemyPiece"
                                )
                            )
                        )
                    )
                    (if ("IsNotOffBoard" ("NextSiteOnTrack" (+ (value Player Mover) ("ThrowValue"))))
                        (if ("IsEnemyAt" ("NextSiteOnTrack" (+ (value Player Mover) ("ThrowValue"))))
                            (move 
                                (from)
                                (to 
                                    ("NextSiteOnTrack" (+ (value Player Mover) ("ThrowValue"))) 
                                    "CaptureEnemyPiece"
                                )
                                (then ("ReinitTabule"))
                            )
                        )
                    )
                )
            )
        )
        ("StickDice" 3)
        (map {(pair 1 1) (pair 2 2) (pair 3 4) (pair 0 6)})
    })
    (rules
        (start {
            (place "Marker1" ("StartSites" Bottom))
            (place "Marker2" ("StartSites" Top))
        })
        (play 
            ("RollMove" 
                (if 
                    (= (mapEntry (count Pips)) 1)
                    (or
                        (move Pass 
                            (then 
                                (and 
                                    ("TabuleThrowOne")
                                    (moveAgain)
                                )
                            )
                        )
                        ("ActiveInactivedPiece")
                    )
                    (if (= (mapEntry (count Pips)) 2)
                        (forEach Piece)
                        (forEach Piece (then (moveAgain)))
                    )
                )
            )
        )
        (end (if ("CapturesAreImpossible") (byScore)))
    )
)
Sijat El Taba is a race game with captures played by the Kababish people of Sudan in the early twentieth century.4 or 6x10 board. Six pieces per player, with one piece placed on each of the three spaces on either end of the long row closest to the player. Three casting sticks, each with a round and a flat side, are used as dice. The throws are as follows: One flat side up = 1; two flat sides up = 2; three flat sides up = 4, zero flat sides up = 6. A player must throw a 1 to move each piece for the first time. Players move according to the throws, except on throws of 1, which are tabulated for use later. Players continue to throw until they throw 2. Pieces move along a boustrophedon path, beginning from left to right in the row closest to them. Pieces are captured when an player's piece lands on a spot occupied by an opponent's piece. Players may used tabulated throws to supplement a throw in order to make a capture. The player who captured the most pieces wins. 4 rows.

Describe the mechanics of the following Ludii game
(game "Greater Loss" 
    (players 2) 
    (equipment { 
        (board (square 4)) 
        (piece "Disc" Each) 
    }) 
    (rules 
        (start {
            (place "Disc1" {"A1"} state:1) 
            (place "Disc1" {"B1"} state:2) 
            (place "Disc1" {"C1"} state:3) 
            (place "Disc1" {"D1"} state:4) 
            (place "Disc1" {"A2"} state:5) 
            (place "Disc1" {"B2"} state:6) 
            (place "Disc1" {"C2"} state:7) 
            (place "Disc1" {"D2"} state:8) 
            (place "Disc2" {"A3"} state:5) 
            (place "Disc2" {"B3"} state:6) 
            (place "Disc2" {"C3"} state:7) 
            (place "Disc2" {"D3"} state:8) 
            (place "Disc2" {"A4"} state:1) 
            (place "Disc2" {"B4"} state:2) 
            (place "Disc2" {"C4"} state:3) 
            (place "Disc2" {"D4"} state:4) 
        })
        
        (play 
            (move Select 
                (from 
                    (forEach 
                        (sites Occupied by:Mover)
                        if:(> (state at:(site)) ("LastStateRemove"))
                    )
                )
                (then
                    (and
                        ("StoreStateRemoved")
                        (remove (last To))	
                    )
                )		
            )
        ) 
        
        (end 
            (if 
                (= 0 
                    (count Sites 
                        in:(forEach 
                            (sites Occupied by:Mover) 
                            if:(= 8 (state at:(site)))
                        )
                    )
                )
                (result Mover Loss)
            )
        )
    )
)
Greater Loss is a theoretical game designed to demonstrate Monte Carlo resistance. There is one optimal (non-losing) move per turn against a competent opponent and always a losing move.Players take turns removing a piece of their colour whose number is higher than the last piece they removed (free choice of first piece). The player who removes their highest numbered piece loses. 

Construct a Ludii game based on the following description
El-Mthaltha is a small game with custodial captures played in Tunisia.3x3 intersecting lines, with diagonals in the square. Three pieces per player, which begin on opposite sides of the square. Players alternate turns moving one of their pieces along the lines of the board. When a player surrounds one of the opponent's pieces with two of their pieces, the opponent's piece is captured. The player who captures all of the opponent's pieces wins. 
(game "El-Mthaltha" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 3 3)
        (piece "Marker" Each ("StepToEmpty" ~ (then ("CustodialCapture" Orthogonal (max 1)))))
    }) 
    (rules 
        (start {
            (place "Marker1" (sites Bottom))
            (place "Marker2" (sites Top))
        })
        (play (forEach Piece))
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Tables Rabbatuées is a European Tables-style game played in France. Players must remove their pieces from the board, and then return them to the starting position.2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Play occurs only in two quadrants of the board, opposite one another, a player's pieces only leaving their quadrant to bear off. Two pieces are stacked each on the first three points, and three are stacked in the second three points. Players use throws to unstack pieces on their points, unstacking one piece per die which corresponds to that point. Doubles allow the player to unstack or bear off a number of pieces equal to the total number of the throw. When all of the pieces are unstacked, that player may begin bearing their pieces off. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Once a player has borne off all of their pieces, they must re-enter them onto the points and replicate the starting position. The first player to bear off all their pieces and then place them in the starting position again wins.
         
(game "Tables Rabbatuees"
    (players 2)
    (equipment {
        ("TableBoard"
            {
            (track "Track1" {0..5} P1 directed:True)
            (track "Track2" {12..17} P2 directed:True)
            }
        )
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" "SiteToMoveOnTrack")
                    ("BearOff" (from))
                    (move 
                        (from) 
                        (to 
                            "SiteToMoveOnTrack" 
                        )
                    )
                )
            )		
        )
        (hand Each)
        (map "StartTrack" {(pair P1 0) (pair P2 12)})
    })
    (rules 
        (start {
            (place Stack "Disc1" (sites {0..2}) count:2)
            (place Stack "Disc1" (sites {3..5}) count:3)
            (place Stack "Disc2" (sites {12..14}) count:2)
            (place Stack "Disc2" (sites {15..17}) count:3)
        })
        phases:{
        (phase "UnStacking" 
            (play 
                ("RollEachNewTurnMove"
                    (if (or (< 0 (var "Double")) (all DiceEqual)) 
                        (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips)))
                            next:(forEach Site (sites Occupied by:Mover)
                                (if ("PieceFullStacked" (site))
                                    (move Select
                                        (from (site))
                                        (then (if (= 3 (size Stack at:(last To))) ("UnstackHalf") ("UnstackFull")))
                                    )
                                    (if ("PieceHalfStacked" (site))
                                        (move Select
                                            (from (site))
                                            (then ("UnstackFull"))
                                        )
                                    )
                                )
                                (then
                                    (and
                                        (if (< 1 (var "Double")) (moveAgain))
                                        (set Var "Double" (- (var "Double") 1))
                                    )
                                )
                            )
                        )
                        (forEach Die 
                            if:("DieNotUsed")
                            (or
                                (if ("PieceFullStacked" "SiteToSelect")
                                    (move Select (from ("SiteToSelect"))
                                        (then 
                                            (and 
                                                (if (= 3 (size Stack at:(last To))) ("UnstackHalf") ("UnstackFull"))
                                                ("ReplayNotAllDiceUsed")
                                            )
                                        )
                                    )
                                )
                                (if ("PieceHalfStacked" "SiteToSelect")
                                    (move Select (from ("SiteToSelect"))
                                        (then 
                                            (and 
                                                ("UnstackFull")
                                                ("ReplayNotAllDiceUsed")
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover 
                (all Sites (sites Occupied by:Mover) if:(not ("PieceStacked" (site)))) 
                "BearingOff"
            )
        )
        (phase "BearingOff" 
            (play 
                ("RollEachNewTurnMove"
                    (if (or (< 0 (var "Double")) (all DiceEqual)) 
                        (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips)))
                            next:(forEach Site (sites Occupied by:Mover)
                                ("BearOff" (site))
                                (then
                                    (and
                                        (if (< 1 (var "Double")) (moveAgain))
                                        (set Var "Double" (- (var "Double") 1))
                                    )
                                )
                            )
                        )
                        (forEach Piece top:True)
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
            (nextPhase Mover 
                (no Pieces Mover in:(sites Board))
                "Placing"
            )
        )
        (phase "Placing" 
            (play 
                ("RollEachNewTurnMove"
                    (if (is Occupied (handSite Mover))
                        (forEach Die 
                            if:("DieNotUsed")
                            (if (if (< (pips) 4) (< (size Stack at:"SiteToSelect") 2) (< (size Stack at:"SiteToSelect") 3))
                                (move
                                    (from (handSite Mover))
                                    (to ("SiteToSelect"))
                                )
                            )
                            (then
                                (and
                                    ("ReplayNotAllDiceUsed")
                                    (if (!= 0 (state at:(last To)))
                                        (set State at:(last To) 0)
                                    )
                                )
                            )		
                        )
                    )
                )
            )
            (end (if (is Empty (handSite Mover)) (result Mover Win)))
        )
        }
    )
)

Construct a Ludii game based on the following description
Tic-Tac-Toe on a nxnxn gridPlay occurs on a 4x4x4 grid. One player places an X, the other places an O and players take turns placing their marks in the grid, attempting to get four in a row of their color. For the lines between levels, the diagonals are not taken in account. The game is played on a 3x3x3 board.
(game "3D Tic-Tac-Toe"
    (players 2)
    (equipment {
        (board (rectangle (+ (^ <Board:size> 2) (- <Board:size> 1)) <Board:size>))
        (piece "Disc" P1)
        (piece "Cross" P2)
        (piece "Dot" Neutral)
    })
    (rules
        (start (place "Dot0" <Board:dot0>)) 
        (play (move Add (to (sites Empty))))
        (end {
            (if (is Line <Board:size>) (result Mover Win))
            (if "Line3D" (result Mover Win))
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Doov" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 8)) 
    (rules 
        ("BlackCellsSetup" 2)
        
        (play 
            (or 
                (or 
                    (forEach Piece "Counter" 
                        ("HopCapture" (from)  (directions {FR FL}) 
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        ) 
                    )
                    (forEach Piece "DoubleCounter" ("HopDiagonalCapture"))
                )
                
                (or 
                    (forEach Piece "Counter" 
                        ("StepToEmpty" (directions {FR FL}))
                        (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                    )
                    (forEach Piece "DoubleCounter" "StepDiagonalToEmpty")
                )
            )
        ) 
        
        (end ("BlockWin"))
    )
)
Dööv is a capturing game played in Mongolia. Each player plays as a pack of dogs (one pack spotted, the other black), who jump over opposing dogs to capture them.8x8 board. Eight pieces per player, which begin on alternating squares in the first two rows on opposing sides of the board. Players alternate turns moving one of their pieces to an adjacent space. Pieces move diagonally forward only. A piece may capture one of the opponent's adjacent pieces by hopping over it to an empty adjacent space immediately on the opposite side of the opponent's piece. Multiple captures are not allowed. When a piece arrives at the opposite edge of the board from where it began, it is promoted and may move diagonally forward or backward. The player who captures all of the opponent's pieces wins. 

Construct a Ludii game based on the following description
Archimedes can be played with a standard checkers set. The board is an 8x8 grid,and each player has 12 \MOVING
            Each player moves one ship each turn. A ship moves any number of empty squares in a straight line, either vertically, horizontally, or diagonally (that is, like a chess queen). However, a ship may never end its turn in its home port.
            
            DESTROYING SHIPS
            Two opposing ships \ 
(game "Archimedes"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Ball" Each (move Slide (between if:(and (is Empty (between)) (!= (between) (mapEntry "Port" Mover))))))
        (map "Port" {(pair P1 "H8") (pair P2 "A1")})
        (hand Each)
    })
    (rules
        (start {
            (place "Ball1" (difference (expand origin:(mapEntry "Port" P1) steps:4 Orthogonal) (sites {"D8" "H4" "H8"})))
            (place "Ball2" (difference (expand origin:(mapEntry "Port" P2) steps:4 Orthogonal) (sites {"A5" "A1" "E1"})))
        })
        (play
            (if ("SameTurn")
                (move Slide (from (mapEntry "Port" Mover)))
                (or
                    (forEach Piece
                        (then
                            (forEach Site
                                (sites Occupied by:Next)
                                (if 
                                    ("AttackByAtLeast3")
                                    (fromTo
                                        (from (site))
                                        (to (handSite Next))
                                    )
                                )
                            )
                        )
                    )
                    (if
                        (and {
                            (is Occupied (handSite Mover))
                            (is Empty (mapEntry "Port" Mover))
                            ("CanMoveANewShip")
                        })
                        (move (from (handSite Mover)) (to (mapEntry "Port" Mover)) (then (moveAgain)))
                    )
                )
            )
        )
        (end 
            (if 
                (and
                    ("IsFriendAt" (if (is Mover P1) (mapEntry "Port" P2) (mapEntry "Port" P1)))
                    ("CapturingPortNotAttacked")
                )
                (result Mover Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Contagion" 
    (players 2) 
    (equipment {
        (board <Board>)
    }) 
    
    (rules 
        (start (set Score P2 (* (count Rows) (count Columns))))
        
        phases:{
        (phase "InitContagion" P1 
            (play 
                (move Add
                    (to
                        Cell 
                        (sites Empty Cell)
                    )
                    (then 
                        (and 
                            (if (< (count MovesThisTurn) (- "NumContagionByTurn" 1)) (moveAgain)) 
                            (addScore {P1 P2} {1 -1}) 
                        ) 
                    )
                )
            )
            (nextPhase (not (is Next Mover)) "ContagionGrowth")
        )
        
        (phase "ContagionGrowth" P1 
            (play (move Add 
                    (to 
                        Cell 
                        (sites Empty Cell) 
                        if:("NoEdgeBetweenCells")
                    ) 
                    (then 
                        (and 
                            (if (< (count MovesThisTurn) (- "NumContagionByTurn" 1)) (moveAgain)) 
                            (addScore {P1 P2} {1 -1})
                        )
                    )
                )
            )
        )
        
        (phase "Containment" P2
            (play
                (move Add
                    (to
                        Edge 
                        (sites Empty Edge)
                    )
                    (then 
                        (if 
                            (< (count MovesThisTurn) (- "NumContainmentByTurn" 1)) 
                            (moveAgain)
                        )
                    )
                )
            )
        )
        }
        (end {
            (if (> (score P1) (/ (* (count Rows) (count Columns)) 2)) (result P1 Win))
            (if (no Moves P1) (result P2 Win))
        })
    )
)
Contagion was invented by game designer David King.The face player places three faces each turn. The edge player places four edges each turn. The face player goes first and can specify any locations on the board on their first turn. On all subsequent turns the face player can only place a face next to another face (orthogonally), that does not pass through an edge. The edge player can place their four lines anywhere. The game is finished when the face player cannot add a piece or if they cover more than half the board. The game is played on a 2x2 board

Construct a Ludii game based on the following description
Panchi is a race game played in India in Mysore in the late eighteenth and nineteenth century.A track of eleven squares, with marks in the two outer and central squares. Ten further squares extending from the central square, with markings in the fifth and final squares. Including this fifth square, a square track with eleven squares per side, with a marked square in each corner and middle square of each side. Five pieces per player. Seven cowries used as dice. The number of mouths up equals the value of the throw; when no mouths are up the player loses their turn. Players begin from opposite ends of the bottom track, and proceed up the vertical track, around the square, and then up the remainder of the vertical track. A player must throw a 1, 5, or 7 to enter the board. Throws of 1, 5, or 7 grant the player another throw. If a piece lands on a space occupied by a piece belonging to the opponent, the opponent's piece is removed from the board and must enter again. Pieces resting on a marked square are safe from being sent back. The player who moves all five of their pieces beyond the final space in the vertical row with an exact throw wins.
         
(game "Panchi" 
    (players 2)
    (equipment {
        (board 
            (merge {
                (rectangle 1 11)
                (shift 0 5 (rotate 90 (rectangle 1 11)))
                (shift 0 5 (rectangle 1 11))
                (shift -5 10 (rotate 90 (rectangle 1 11)))
                (shift 5 10 (rotate 90 (rectangle 1 11)))
                (shift 0 15 (rectangle 1 11))
            })
            {
            (track "Track1" "0,E5,N5,W,N,E,S,W5,N,End" P1 directed:True)
            (track "Track2" "10,W5,N5,E,N,W,S,E5,N,End" P2 directed:True)
            }
        )
        (piece "Pawn" Each
            (if ("IsEndTrack" "SiteToMoveOnTrack")
                "RemoveAPiece"
                (if ("IsNotOffBoard" "SiteToMoveOnTrack") 	 			
                    (if (if (not ("IsEnemyAt" "SiteToMoveOnTrack"))
                            True
                            (not (is In "SiteToMoveOnTrack" (sites "Protect")))
                        )
                        (move 
                            (from (from) level:(level))
                            (to 
                                "SiteToMoveOnTrack" 
                                "CaptureEnemyPiece"
                            )
                        )
                    )
                )
            )
        )
        ("StickDice" 7)
        (hand Each)
        (regions "Protect" (sites {0 10 5 16 21 23 30 36 46 56 51 42}))
        (map {(pair P1 0) (pair P2 10)})
    })
    (rules
        (start {
            (place Stack "Pawn1" (handSite P1) count:5)
            (place Stack "Pawn2" (handSite P2) count:5)
        })
        (play 
            ("RollMove"
                (if (can Move ("Move"))
                    ("Move")
                    (move Pass 
                        (then (if ("SpecialThrow") (moveAgain)))
                    )
                )
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Senet is one of the oldest board games known in the world, documented from about 3000 BCE until the first millennium BCE in Egypt. It was also played In Cyprus for most of that time, and played at different times in the Levant. Though a full ruleset has never been found, hints from texts and tomb paintings in Egypt give us clues about the manner in which it was likely played. The game was also heavily imbued with religious significance, as the board itself represented the journey through the afterlife.Played on a 3x10 grid. No spaces are marked. The track is a boustrophedon track. One D4. The throw is equal to the sum of the dice. The rules of Kendall.
(game "Senet"
    (players 2) 
    (equipment { 
        (board (rectangle 3 10) 
            { 
            <Track>
            }
        )
        <Dice>
        <Throw>
        (regions "Symbols" (sites {"F2" "F1" "G1" "H1" "I1"}))
        (regions "Ankh Waset" (sites {"F2"}))
        (regions "Neferu" (sites {"F1"}))
        (regions "Water" (sites {"G1"}))
        (regions "Baw" (sites {"H1"}))
        (regions "Two Men" (sites {"I1"}))
        (regions "Horus" (sites {"J1"}))
        (regions "TopRow" (sites Top))
        (regions "MiddleRow" (difference (expand (sites Top)) (sites Top)))
        (regions "BottomRow" (sites Bottom))
        (piece "SenetPiece" Each ("PieceMovement")) 
        (hand Each)
    }) 
    <Ruleset:rules>
)

Construct a Ludii game based on the following description
Shono is a two-row mancala-style board game played by the Fang people of Gabon, Equatorial Guinea, and Cameroon.2x6 board with two stores. Five counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in a hole in the opponent's row containing one or two counters, thus making it contain two or three counters, they are captured. Any other holes in the opponent's row which also contain two or three counters, in an unbroken sequence preceding the hole where the first capture was made, are captured. When a player sows around the board, the hole from which the coutners were taken is left empty. Play ends when one player cannot play from their row, and players capture any remaining counters in their holes. The player with the most counters wins. The seeds have a normal size.
(game "Shono"
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 5 to:(sites Track)))
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(< 0 (count at:(from)))
                )
                (then 
                    (sow 
                        if:(and 
                            (is In (to) (sites Next)) 
                            (or 
                                (= (count at:(to)) 2) 
                                (= (count at:(to)) 3)
                            )
                        ) 
                        apply:(fromTo 
                            (from (to)) 
                            (to (mapEntry (mover))) 
                            count:(count at:(to))
                        )
                        includeSelf:False
                        backtracking:True
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )	
)

Construct a Ludii game based on the following description
Trax is a two player abstract strategy game of loops and lines. It can be played on any flat surface (no board). The square tiles have straights on one side and curves on the other.The rules of TRAX are simple: 
            - Place tiles adjacent to those already in play such that the colours of the tracks match. 
            - The objective is to get a loop or line of your colour while attempting to stop your opponent in their colour. 
            - A line is a continuous path of track that connects opposite and outermost edges of the tiles in play, over at least 8 rows of tiles, across or down.
            - What gives Trax its strategic depth is the forced play rule which allows (or even requires) multiple tiles to be played in a turn.
         
(game "Trax" 
    (players 2) 
    (equipment { 
        (boardless Square) 
        (hand Shared size:2)
        (tile "TileX" 
            numSides:4
            { 
            (path from:0 to:2 colour:1)
            (path from:1 to:3 colour:2)
            }
        ) 
        (tile "TileCurved" 
            numSides:4
            { 
            (path from:0 to:1 colour:1)
            (path from:2 to:3 colour:2)
            }
        )
    }) 
    (rules 
        
        (meta (automove))
        
        (start {
            (place "TileX" (handSite Shared)) 
            (place "TileCurved" (handSite Shared 1)) 
        })
        
        phases:{
        (phase "Opening"
            (play ("PlaceATileTo" (centrePoint)))
            (nextPhase "Connection")
        )
        
        (phase "Connection"
            (play  
                (do
                    ("PlaceATileTo" "AnotherConnectedTile")
                    ifAfterwards:(is SidesMatch)
                )
            )
            (end {
                (if (or (is Loop (mover) path:True) (<= "PathLength" (pathExtent (mover)))) (result Mover Win))
                (if (or (is Loop (next) path:True) (<= "PathLength" (pathExtent (next)))) (result Next Win))
                (if (>= (count Sites in:(sites Occupied by:All)) (* (count Players) "NumTiles")) (result Mover Draw))
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Tapata is a two-row mancala-style board game played by the Konso people of Ethiopia. It is typically played in spaces reserved for large assemblies by adult men and, less frequently, by boys and adolescents.2x12 board. Beginning from the leftmost hole closest to a player and proceeding in an anti-clockwise direction, the opening arrangement of counters is an alternating pattern of one empty hole, followed by two holes with three counters each. The first move for each player must be from an occupied hole in the right half of their row. Players sow in an anti-clockwise direction, but if the final counter is about to fall in a hole in the player's own row, it is instead placed in the first hole in the opponent's row. After this, players may sow from any hole in their row, provided that the final counter does not fall into an occupied hole in their row. When the final counter of a sowing lands in an occupied hole in the opponent's row, the counters there are picked up and sowing continues. When this happens, the player is allowed to drop the final counter into an occupied hole in their row, which would then be picked up and sowing would continue as before. When the final counter falls into an empty hole in the player's row, any counters in the opponent's hole opposite are captured. When the final counter falls into an empty hole in the opponent's row, the turn ends. The player who captures all of the opponent's counters wins. Players typically play to achieve five consecutive wins.  
(game "Tapata"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "TrackCCW" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Bottom))              
        (regions "Home" P2 (sites Top))              
        (regions "Right Half" P1 (intersection (sites Bottom) (expand (sites Right) steps:5))) 
        (regions "Right Half" P2 (intersection (sites Top) (expand (sites Left) steps:5)))  
        (map {(pair P1 0) (pair P2 23)})              
    }) 
    (rules 
        (start (set Count 3 to:(sites {1 2 4 5 7 8 10 11 22 21 19 18 16 15 13 12})))
        
        phases:{
        
        (phase "FirstMove" 
            (play 
                (move Select 
                    (from (difference (sites Mover "Right Half") (sites Empty)))
                    (then 
                        (sow
                            apply:(if (is In (to) (sites Mover "Home"))
                                (fromTo 
                                    (from (to))
                                    (to (mapEntry Next))
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover "Play")
        )
        
        (phase "Play" 
            (play
                (move Select 
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover "Home") 
                        ) 
                        if:(and
                            (> (count at:(from)) 0)
                            (or ("SameTurn")
                                (and ("NewTurn")
                                    (not 
                                        (and 
                                            (is In ("NextHoleFrom" (from) (count at:(from))) (sites Mover "Home")) 
                                            (!= 0 (count at:("NextHoleFrom" (from) (count at:(from)))))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (then 
                        (sow
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                                (if (and (!= 0 (count at:("OppositePit" (to)))) (is In (to) (sites Mover "Home")))
                                    (remove ("OppositePit" (to)))
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Abak is an abstract strategy game for 2 to 6 players and was invented in 2015 by the historian and chemist Prof. Dr. Luc Chanteloup.The aim of Abak is to be the first player to connect one of the orange squares in the centre of the board to any one orange squares in the corners by forming a continuous row of counters of one colour. 
            
            In the first phase, each player places one counter on one of the orange squares in the centre of the board. 
            
            They continue to take turns to place their counters on a free adjacent square (squares are adjacent if they touch on the sides or diagonally by the points).
            
            The counter may be placed beside counters of any colour. Once placed, a counter may not be moved. 
            
            During the game, if a counter is surrounded by more than 4 occupied squares, that counter is removed. 
            
        Moreover, if then a counter becomes isolated, it is also removed from the board. The game is played on a 9x9 board. Two players.
(game "Abak" 
    (players <Players>)
    (equipment {
        (board (square <Board:size>))
        (piece "Disc" Each)
        <Board:regions>
    })
    (rules 
        
        phases:
        {
        (phase "Placement"
            (play (move Add (to (intersection (sites "CentreRing") (sites Empty)))))
            (nextPhase (= (count Pieces All) <Players>) "Movement")
        )
        
        (phase "Movement"
            (play 
                (move Add 
                    (to (difference (sites Playable) (sites Centre)))
                    (then 
                        (forEach Site (sites Occupied by:All) 
                            (if (<= 4 ("Nbors" (to)))
                                (remove (to)) 
                            )
                            (then 
                                (forEach Site (sites Occupied by:All) 
                                    (if (= 0 ("Nbors" (to)))
                                        (remove (to)) 
                                    )
                                )
                            )
                        )
                    )
                ) 
            )
        )
        }
        
        (end (if (is Connected {(sites "CentreRing") (sites "OuterGoals")}) (result Mover Win))) 
    )
)

Construct a Ludii game based on the following description
Piç is a multiplayer mancala-style board game played in eastern Turkey, particularly near the city of Erzurum. Instead of being played on a board, the counters are placed in heaps, and players capture heaps from which they capture all counters which enter that heap.Played by two to five players. Each player has three heaps of counters, with twelve counters per heap. Sowing occurs in an anti-clockwise direction. When a player creates a heap containing three counters in an opponent's heap, a circle is drawn around the heap and the player captures the counters in it and every counter sown into it for the rest of the game. When there are no heaps left, the player with the most counters wins. Each hole contains initially 9 seeds. The game is played with 2 players.
(game "Pic" 
    (players "NumPlayers") 
    
    (equipment { 
        (board 
            (concentric {(* 3 "NumPlayers")}) 
            (track "Track" <Player:track> loop:True)
            use:Vertex
        )
        (piece "Seed" Shared)
        (hand Each)
        <Player:regions>
    }) 
    (rules 
        (start (set Count <Start:numSeeds> to:(sites Track)))
        
        (play 
            (or {	
                (move Select
                    (from
                        (sites Mover)
                        if:(is Occupied (from))
                    )
                    (then
                        (sow
                            apply:(if (and 
                                    (not (is In (to) (sites Mover)))
                                    (= 3 (count at:(to)))
                                )
                                (and
                                    (fromTo
                                        (from (to))
                                        (to (handSite Mover))
                                        count:3
                                    )
                                    (set State at:(to) (mover))
                                )
                            )
                        )
                    )
                )
                }
                (then
                    (forEach Site (sites Board)
                        (if (and (is Occupied (site)) (!= 0 (state at:(site))))
                            (and
                                (fromTo
                                    (from (site))
                                    (to (handSite (state at:(site))))
                                    count:(count at:(site))
                                )
                                (set State at:(site) (state at:(site)))
                            )
                        )
                    )
                )
            )
        )
        
        (end
            (if ("NoPieceOnBoard")
                (byScore {
                    <Player:scores>
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Maharajah Chess is a Chess variant known since the nineteenth century.The black player has a normal set of chess pieces. The white player has a single piece which can move either as a queen or as a knight. Black's goal is to checkmate the white piece, White's goal is to checkmate the black king. There is no pawn promotion. 
(game "Maharajah Chess" 
    (players 2) 
    (equipment { 
        (board (square 8)) 
        
        (piece "Pawn" P2 S
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty")
                )
                "StepForwardToEmpty" 
                ("StepToEnemy" (directions {FR FL}))
                }
                (then (set Counter))
            )
        )
        
        (piece "Rook" P2 ("SlideCapture" Orthogonal ~ (then (set Counter)) "RememberPieceHasMoved"))
        (piece "King" P2 
            (move Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndResetCounter"
                ) 
                "RememberPieceHasMoved"
            )
        )
        (piece "Bishop" P2 
            (move Slide 
                Diagonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "Knight" P2 ("LeapCapture" "KnightWalk" (then (set Counter))))
        (piece "Queen" P2 
            (move Slide 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            ) 
        )
        
        (piece "Amazon" P1 
            (or
                ("LeapCapture" "KnightWalk" (then (set Counter)))
                ("SlideCapture" ~ ~ (then (set Counter)))
            )
        )
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
    }) 
    (rules 
        (start { 
            (place "Pawn2" (sites Row 6))
            (place "Amazon1" coord:"E1")
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (do 
                (or 	
                    (forEach Piece)
                    (if (and {
                            (is Mover P2)
                            "KingInTheInitialPlace" 
                            ("HasNeverMoved" "King")
                            (not ("IsInCheck" "King" Mover)) 
                        })
                        (or
                            (if (and 
                                    ("HasNeverMoved" "RookLeft")
                                    (can Move ("DoCastle" "RookLeft" E 3 (is Empty (to))))
                                )
                                "BigCastling"
                            )
                            (if (and 
                                    ("HasNeverMoved" "RookRight")
                                    (can Move ("DoCastle" "RookRight" W 2 (is Empty (to))))
                                )
                                "SmallCastling"
                            )
                        )
                    )
                )
                ifAfterwards:(if (is Mover P1)
                    (not ("IsInCheck" "Amazon" Mover))
                    (not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            (if 
                (if (is Mover P1)
                    (and 
                        ("IsInCheck" "King" Next)
                        ("NextCanNotMoveToProtect" "King")
                    ) 
                    (and 
                        ("IsInCheck" "Amazon" Next)
                        ("NextCanNotMoveToProtect" "Amazon")
                    ) 
                )
                (result Mover Win)
            ) 
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Mig Mang is a territory game played in Tibet on a 17x17 board.17x17 intersecting lines. 151 pieces per player. Each player begins with six larger pieces on the board, on the third line from the perimeter on all four sides, one piece on every fourth intersection, alternating between black and white. These pieces are never moved from the  board. There is a star marking at each of these points. Players alternate turns placing one of their pieces on an empty intersection of the board. When a player encloses an area with their pieces, it becomes their territory, and any pieces of the opponent inside it are captured. The opponent cannot place one of their pieces inside a territory won on the previous turn. White plays first. When players can no longer play, the number of  counters and each territory are counted to determine the winner. 
(game "Mig Mang" 
    (players 2) 
    (equipment { 
        (board (square 17) use:Vertex) 
        (piece "Ball" Each)
    })
    
    (rules 
        (start {
            (place "Ball1" (sites {"C7" "K15" "C15" "G3" "O11" "O3"}) state:1)
            (place "Ball2" (sites {"C3" "K3" "C11" "G15" "O15" "O7"}) state:1)
        })
        (play 
            (move Add
                (to (sites Empty) if:(= (state at:(to)) 0))
                (then 
                    (and
                        ("RemovePreviousTerritoryTaken")
                        ("CaptureSurroundedPiece")
                    )
                )
            )
        )
        (end
            (if (and (no Moves P1) (no Moves P2))
                (byScore {
                    (score P1 (+ (count Pieces P1) (size Territory P1))) 
                    (score P2 (+ (count Pieces P2) (size Territory P2)))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
EinStein Würfelt Nicht! (Einstein does not play dice) is a board game, designed by Ingo Althöfer, a professor of applied mathematics in Jena, Germany. It was the official game of an exhibition about Einstein in Germany during the Einstein Year (2005).The name of the game in German has a double meaning. It is a play on Einstein's famous quote \The game is played on a square board with a 5×5 grid. Each player has six cubes, numbered one to six. During setup, each player can arrange the cubes as he or she sees fit within the triangular area of their own color.
            
            The players take turns rolling a six-sided die and then moving the matching cube. If the matching cube is no longer on the board, the player moves a remaining cube whose number is next-higher or next-lower to the rolled number. The player starting in the top-left may move that cube one square to the right, down, or on the diagonal down and to the right; the player starting in the bottom-right may move that cube one square to the left, up, or on the diagonal up and to the left. Any cube which already lies in the target square is removed from the board.
            
        The objective of the game is for a player to either get one of their cubes to the far corner square in the grid (where their opponent started) or to remove all of their opponent's cubes from the board. The version of the game played on 5x5 board.
(game "EinStein Wurfelt Nicht" 
    (players {(player SE) (player NW)}) 
    (equipment { 
        (board (square <Board:size>)) 
        (piece "Square" Each) 
        (hand Each size:<Board:numPieces>)
        (dice num:<Board:numDice>)
        (regions "Home" P1 (expand (intersection (sites Top) (sites Left)) steps:<Board:sizeHome> Orthogonal))
        (regions "Home" P2 (expand (intersection (sites Bottom) (sites Right)) steps:<Board:sizeHome> Orthogonal))
        (regions "Goal" P1 (intersection (sites Bottom) (sites Right)))
        (regions "Goal" P2 (intersection (sites Top) (sites Left)))
    }) 
    (rules 
        (start {
            <Board:start>
        })
        phases:{
        (phase "Placement" 	  
            (play 
                (move 
                    (from ("CubeInHand")) 
                    (to ("EmptySitesInHome"))
                )
            )
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        (phase "Movement" 	  
            (play 
                ("RollMove"
                    (if ("PieceIsOnTheBoard")
                        ("MoveAPieceOf" ("SameValue"))
                        (or
                            ("MoveAPieceOf" ("ValueNextHigher"))
                            ("MoveAPieceOf" ("ValueNextLower"))
                        )
                    )
                )
            )
        )
        }
        
        (end 
            (if 
                (or 
                    (no Pieces Next) 
                    ("GoalReached")
                ) 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
The word Siryu is used for several games in the Tabelbala Oasis of Algeria that are played by women and girls. In this game, players take the roles of a mother, father, and an angel traveling to Mecca. 5x5 grid, with six spaces extending from the central row; the final three of this extension rendered as rectangles rather than squares (Cairo, Medina, and Mecca, in that order). The central square of the grid is marked with a circle (the Minaret). Any number of players. Three pieces per player, a father, a mother, and an angel. Six sticks, black on one side and white on the other, used as dice. The throws are as follows: Five of any color plus one of the other color (known as \ The game has 2 players.
(game "Siryu (Race)" 
    (players <Player:num>) 
    (equipment { 
        (board 
            (merge {
                (rectangle 5 2)
                (shift 2 -3 (scale 1.2 1 (rectangle 8 1)))
                (shift 3.2 0 (rectangle 5 2))
                (shift 1.6 -6 (scale 2 1 (rectangle 3 1)))
            })
            {
            (track "FirstTrack" "13,S,E1,N,E1,S1" directed:True)
            (track "SecondTrack" "6,S1,E1,N,E1,S" directed:True)
            }
        )
        ("StickDice" 6)
        (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 6)})
        (map "ExtraThrow" {(pair 0 1) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 3)})
        (piece "Father" Each ("Move" ("ThrowValue")))
        (piece "Angel" Each ("Move" (* 2 ("ThrowValue")) ("GoToStep3Angel")))
        (piece "Mother" Each ("Move" ("ThrowValue")))
    }) 
    (rules 
        <Player:start>
        
        (play 
            ("RollMove"
                (forEach Piece)
                (then
                    (if (!= 0 ("ExtraThrowValue"))
                        (and
                            (if (= 3 ("ExtraThrowValue"))
                                (if (<= (var) 0)
                                    (set Var 2)
                                    (set Var (+ 2 (var)))
                                )
                            )
                            (moveAgain)
                        )
                        (if (> (var) 0)
                            (and
                                (set Var (- (var) 1))
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        
        (end (if ("AllPiecesInMecca") (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Omega was invented by Néstor Romeral Andrés in 2010. It is described as a cross between Hex and Go.Players take turns placing a piece of each color in an empty site. Play ends at the start of the first players turn, if all the players would not be able to complete their turn. Example: for 2 players less than 4 empty sites.
            
        Scores are awarded based on the sizes of the groups of each color on the board, which are multiplied. The player with the highest score wins. The game is played on a 4x4 board The version of the game played with 2 players.
(game "Omega" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board (hex <Board>))
        (piece "Marker" Each) 
    }) 
    (rules 
        (play 
            (move Add 
                (piece (+ 1 (% (count Moves) (count Players)))) 
                (to (sites Empty)) 
                (then 
                    (if 
                        (!= (count MovesThisTurn) (- (count Players) 1)) 
                        (moveAgain)
                    )
                )
            )
        ) 
        
        (end
            (if (and {
                    (not (is Mover P1)) 
                    (is Next P1) 
                    (> 
                        (pow (count Players) 2) 
                        (count Sites in:(sites Empty))
                    )
                })
                (byScore <Version:endScore>)
            )
        )
    )
)

Construct a Ludii game based on the following description
Tablo is a game that was played among the Sámi people of Sweden.  The board was usually scratched into a  wooden board with a  knife, and sticks were used as pieces, one player keeping the bark on the sticks and the other stripping them. It was usually played by children, but was played by people of all ages.7x7 lines, forming a grid. 21 pieces per player. The pieces begin on the three rows  closest to the player.  Pieces move forward orthogonally or sideways, never backwards. A piece may capture an adjacent opponent's piece by hopping over it to an empty adjacent spot immediately on the opposite side of it along the lines of the board. Multiple captures are allowed. Captures can only be made in the forward orthogonal or sideways directions also. The player who captures all of their opponent's pieces or who blocks them from being able to move wins. 
(game "Tablo" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board 
            (square 7)
            use:Vertex
        )
        (piece "Marker" Each
            (or {
                ("StepToEmpty" (directions {Forward Rightward Leftward}))
                ("HopCapture" ~ (directions {Forward Rightward Leftward}) 
                    (then 
                        ("ReplayIfCanMove" 
                            ("HopCapture" 
                                (from (last To)) 
                                (directions {Forward Rightward Leftward})
                            )
                        ) 
                    )
                )
            })
        ) 
    }) 
    (rules 
        (start {
            (place "Marker1" (expand (sites Bottom) steps:2))
            (place "Marker2" (expand (sites Top) steps:2))
        })
        (play 
            (if ("SameTurn")
                (and
                    ("HopCapture"
                        (from (last To)) 
                        (directions {Forward Rightward Leftward})
                        (then 
                            ("ReplayIfCanMove"
                                (("HopCapture" 
                                        (from (last To)) 
                                        (directions {Forward Rightward Leftward})
                                    )
                                ) 
                            )
                        )
                    )	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
The game of Dwarfs, also called, \One player has three dwarfs and the other has one giant.
            Firstly, the giant is placed on one of the top sites. After this first move of the giant, it is the dwarfs' move.
            Each piece can move between the different sites only if they are connected by an edge. The dwarfs can move only forwards or sideways, the giant can move in all the directions.
            
            The goal of the dwarfs is to block the giant on the top site. The giant has to break through the line of dwarfs to get 2 points and win. In case of a repetition of moves, the giant is winning with one point.
            
         
(game "Game of Dwarfs"
    (players {(player S) (player N)})
    
    (equipment {
        (board 
            (add
                (remove
                    (rotate 90 ("ThreeMensMorrisGraphWithLeftAndRightTriangles"))
                    vertices:{3 7 1}
                )
                edges:{{0 1} {4 5} {2 7} {0 4}}
            )
            use:Vertex
        )
        
        (piece "Foot" P1 
            (move Step Adjacent 
                (to 
                    if:(and
                        (if (= 1 (count Turns)) (!= (centrePoint) (to)) True)
                        (is Empty (to))
                    )
                )
            )
        )
        
        (piece "Gnome" P2 ("StepToEmpty" (directions {Forwards Rightward Leftward})))
        
        (hand P1)
        (regions "Home" P2 (intersection (sites Outer) (expand (sites Bottom))))
        (regions "Home" P1 (sites Top))
    })
    (rules
        
        (start {
            (place "Gnome2" (intersection (sites Outer) (expand (sites Bottom))))
            (place "Foot1" (handSite P1))
        })
        
        phases:{
        (phase "Opening" P1
            (play
                (move 
                    (from (handSite Mover))
                    (to (expand (sites Top)))
                )
            )
            (nextPhase P1 "MainP1")
        )
        (phase "MainP1" P1 
            (play 
                (forEach Piece
                    (then 
                        (if (is In (where "Foot" P1) (sites P2))
                            (set Score P1 2)
                            (if (is Cycle)
                                (set Score P1 1)
                            )
                        )
                    )
                )
            )
        )
        (phase "MainP2" P2 
            (play (forEach Piece
                    (then (if (no Moves Next)
                            (set Score P2 1)
                            (if (is Cycle)
                                (set Score P1 1)
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end (forEach Player if:(!= 0 (score Player)) (result Player Win))) 
    )
)

Construct a Ludii game based on the following description
Polypods was created as an exploration of a new capture concept in which a group lives as long as it has more terminal ends than core pieces. Group capture naturally became determinened in two stages: removing terminals, which then in turn cause the group to exceed its core limit.     This works best on the hex grid.     Since terminals are added in play, they can also be removed without destroying the group.    All groups fall in the range of with 0 to 3 free terminals. Additions can either help stabilize the group, or destabilize it.     Efficiency in scoring encourages growing groups to near the critical size. As does attacking another player's terminals, and being attacked.        Critical size groups are most vulnerable to being killed by terminal attacks instead of merely suffering a terminal loss.    This is not difficult to use as a tactic, and if the result were to clear too much of the board the game would be too unstable an cycle. Removing only the core, ensures that the resultant groups will be singletons and pairs which are all legal formations, and keep the board from clearing too much.         However, tit-for-tat captures still can cause major resets. Therefore the capture rule specifies that the ownership of the terminals of the captured groups also changes to the capturing player.         This final solution allows tactical instability, but strategic stability.        On small boards ties may be more frequent than some players would like. Thus a tie-breaker based on empty territory control has also been added. This value is is intuitive, and not frequently correlated to the core score, so it functions well in this role.        Group count is not used for scoring, because the terminals provide a benefit in allowing for stability and future growth, and thus function best as investments rather than outcomes.Polypods is a game about groups of connected stones called Polypods.
            
            Understanding the mythical life of a polypod should help you to easily remember the rules.
            
            Polypods are creatures that have poisonous body segments that tie together its numerous feet. To survive, at least half of a polypod must be its feet, and this determines how they may grow and the shapes they may take. 
            
            The feet die and fall off upon contact with the poisonous body segments of other polypods,  however, since the feet themselves are not poisonous, there is no harm in their contact with other polypod's feet. Fortunately a polypod's foot is able to smell the area around it, and thus a polypod avoids extending its feet to touch the bodies of competing polypods.
            
            Hungry polypods do, however, find ways to bring their body against a foot of another polypod, causing that foot (or feet) to self-amputate.     If the attacking polypod is lucky, the loss of a foot will cause its neighbor to die. 
            
            The attacking polypod then ingests the body of its dead neighbor and spawns new polypods in the dead neighbor's feet.
            
            Definitions:
            -- A POLYPOD is a group of interconnected stones. The group includes every stone of the same color that is connected to it.
            (A single stone, or monopod, is also considered as a polypod in these rules.)
            
            Each stone in a polypod has one of two roles: Body or foot.   
            -- FOOT STONES (FEET) are stones that connect to at most two other friendly stones:- and if connected to two stones, those two must already be adjacent to each other. 
            -- BODY STONES are those that serve to link all the polypod feet together. 
            
            As the polypods grow or shrink, the roles of their individual stones change accordingly.
            (In this application the body stones are marked with squares for convenience in reading the board.)
            
            A polypod is ALIVE if it has at least as many feet as body stones.
            
            -- Foot stones in contact with a body stone of the opposite color SELF-AMPUTATE (ie get immediately removed from the board)
            -- when a Polypod DIES, its body stones are removed, and its feet change ownership.
            
            Rules:
            The game uses discs played on the intersections of a triangular grid of the desired size and shape. 
            The board starts empty and Dark starts. Turns Alternate.
            
            The moving player, either passes, or does the following sequence of actions, if possible:
            1. The mover places a piece on an empty space.
            -- The placement must not cause the immediate self-amputation of the placed stone.
            -- It may add to or merge friendy polypods, UNLESS this would cause those polypod(s) to die.
            2. The mover removes all self-amputating feet.
            3. The mover resolves all polypod deaths.
            
            The game ends when the players pass consecutively.
            
            The winner is determined by tallying the value of each player's polypods.
            The value of a polypod is the number of body stones that it contains.
            If tied, score all the empty spaces adjacent to the players' own polypods.
        If this count is also equal, the game is considered a draw. Order 5 Square Grid
(game "Polypods"
    (players 2)
    (equipment {
        (board <BoardShape:gridType> use:Vertex)
        (piece "Disc" Each maxState:1 maxValue:4)
    })
    (rules
        (play
            (or
                (move Pass)
                (do
                    (do
                        (move Add "ToAllowedSites" 
                            (then
                                (and
                                    (set Value at:(last To) (layer of:(last To)))
                                    ("UpdateTerminals" (sites Group at:(last To)))
                                )
                            )
                        )
                        ifAfterwards:("IsAliveAt" (sites Group at:(last To)))
                        (then ("Captures"))
                    )
                    ifAfterwards:(not (is Triggered "IllegalCapture" Mover))
                )
                (then 
                    ("Score")
                )
            )
        )
        (end 
            (if
                (all Passed) {
                (if
                    (> (score Mover) (score Next))
                    (result Mover Win)
                )
                (if
                    (and
                        (= (score Mover) (score Next))
                        (>= ("FringeScoreOf" Mover) ("FringeScoreOf" Next))
                    )
                    (result Mover Win)
                )
                (if
                    (and
                        (= (score Mover) (score Next))
                        (= ("FringeScoreOf" Mover) ("FringeScoreOf" Next))
                    )
                    (result Mover Draw)
                )
                }
                (result Next Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
An abstract board game played on the vertices, edges and cells of the board.Players take turns moving a piece of their colour as follows:
            
            1. A piece on a vertex can move either:
            
            1a. To an adjacent empty vertex. The edge it travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed).
            
            1b. To an empty cell that vertex is part of.
            
            2. A piece on an edge can move either:
            
            2a. To a connected empty edge. The vertex it travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed).
            
            2b. To an empty cell that edge is part of.
            
            3. A piece in a cell can move either:
            
            3a. To a neighbouring empty cell which may be connected by an edge or a vertex. The connecting edge or vertex that the piece travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed).
            
            3b. To step over one of its empty edges into an adjacent cell containing an enemy piece (which is captured), then step out over a different empty edge to another empty cell.
            
            3c. To an empty vertex or edge belonging to that cell.
            
            Aim: A player wins if their opponent is reduced to a single piece. An empty edge has no piece on its midpoint. An empty cell has no piece on its centroid.
            
            Three Player Version:
        In the three player version, any player reduced to a single piece is removed from the game (along with their piece). Last remaining player wins. The game is played with 2 players.
(game "Triple Tangle" 
    (players <Players:num>) 
    (equipment { 
        (board (tiling T3464 1) use:Vertex)
        (piece "Disc" Each)
    }) 
    
    (rules 
        <Players:start>
        
        (play 
            (if ("SameTurn")
                ("MoveLastCellToEmptyCellOverEmptyEdge")
                (or {
                    (forEach Piece on:Vertex 
                        (or
                            ("MoveVertexToVertex")
                            ("MoveVertexToCell")
                        )
                    )
                    
                    (forEach Piece on:Edge 
                        (or
                            ("MoveEdgetoEdge")
                            ("MoveEdgetoCell")
                        )
                    )
                    
                    (forEach Piece on:Cell 
                        (or {
                            ("MoveCellToEmptyCellOverEdge")
                            ("MoveCellToEnemyCellOverEmptyEdge")
                            ("MoveCellToEmptyCellOverVertex")
                            ("MoveCellToEdge")
                            ("MoveCellToVertex")
                        })
                    )
                })
                <Players:removeLastPiece>
            )
        )
        
        <Players:end>
    )
)

Construct a Ludii game based on the following description
In Fenix, two armies fight against each other. The battle of the two kings, their generals and soldiers is a matter of life and death — but Fenix is different from other strategy games: Here, the battle is not automatically lost when one of the kings has been defeated. Why? The phoenix-bird is immortal; if he loses his life, he rises again from the ashes. The cycle starts all over. The king is dead? Long live the king!—description from the publisherEach player, on their first five turns, uses some of their own pieces to create one King and three Generals, in any preferred order. A General is made by placing any single piece on top of an orthogonally adjacent piece, and a King is made by placing any single piece on top of an orthogonally adjacent General. 
            
            - Soldiers move orthogonally one step to an adjacent square.
            - Generals move any distance in a straight line orthogonally, like a Chess Rook.
            - The King moves one step to any adjacent square, like a Chess King
            
            Capture is compulsory if possible.
            
            - A Soldier or King captures by jumping over an enemy piece occupying a square to which it can legally move and landing on the square immediately beyond it in the same direction, provided that the landing square is vacant.
            - A General captures in the same way, but may move any number of vacant squares before the captured piece, and  may land on any successive vacant square in line of travel beyond the captured piece.
            
            If the capturing piece can then make another capture, it must, and it must continue doing so until all possible consecutive captures have been made. An enemy piece can only be jumped once in a single turn. If it is reached a second time it forms a block and ends the turn. At the end of a capturing turn all captured pieces must be removed from the board before the next player moves.
            
            If more than one capture is possible you must choose that which captures the greatest number of pieces, counting a King as three, a General as two, and a Soldier as one. If two possible capturing moves offer an equal number of pieces, you may freely choose between them.
            
            If one or more of your Generals is captured in one turn, you may create just one General (not more) from two orthogonally adjacent Soldiers anywhere on the board.
            
            If your King is captured you must, if possible, use your next turn to create another King by placing a Soldier on top of an adjacent General. 
            
        If you are unable to create another King, when your King is captured, you lose the game. The game is played on a 9x9 square board.
(game "Fenix"
    (players 2)
    (equipment {
        (board <Board:board>)
        (piece "Fenix" Each)
    })
    (rules
        (start {
            (place "Fenix1" (expand (intersection (sites Bottom) (sites Right)) steps:<Board:expandSize> Orthogonal) value:1)
            (place "Fenix2" (expand (intersection (sites Top) (sites Left)) steps:<Board:expandSize> Orthogonal) value:1)
        })
        
        phases:{
        (phase "Setup"
            (play 
                (move
                    (from (sites Occupied by:Mover) if:("IsSingletonStack" (from)))
                    (to 
                        (sites Around (from) Own Orthogonal) 
                        if:(and {
                            (!= (from) (to))
                            (< (size Stack at:(to)) 3)
                            (if ("NoKing")
                                True
                                (< (size Stack at:(to)) 2)
                            )
                            (if ("DoesNotHaveThreeGeneral")
                                True
                                (not ("IsSingletonStack" (to)))
                            )
                        })
                    )
                )
            )
            (nextPhase Mover (and (not ("NoKing")) (not ("DoesNotHaveThreeGeneral"))) "Play")
        )
        (phase "Play"
            (play 
                (if ("SameTurn")
                    (max Moves withValue:True
                        (if ("IsSoldier" (last To))
                            ("Hop" (last To) Orthogonal 
                                (then ("ReplayIfCanMove" ("Hop" (last To) Orthogonal)))
                            )
                            (if ("IsKing" (last To))
                                ("Hop" (last To) ~
                                    (then ("ReplayIfCanMove" ("Hop" (last To)))) 
                                )
                                (if ("IsGeneral" (last To))
                                    ("HopGeneral" (from (last To)) before:(count Columns) after:(count Columns) at:EndOfTurn)
                                )
                            )
                        )
                    )
                    (if ("NoKing")
                        (forEach Piece
                            (if ("IsSoldier" (from))
                                (move Step Orthogonal
                                    (to if:(and ("IsFriendAt" (to)) (= 2 (size Stack at:(to)))))
                                    stack:True
                                )
                            )
                        )
                        (priority {
                            (max Moves withValue:True
                                (forEach Piece
                                    (if ("IsSoldier" (from))
                                        ("Hop" (from) Orthogonal 
                                            (then ("ReplayIfCanMove" ("Hop" (last To) Orthogonal)))
                                        )
                                        (if ("IsKing" (from))
                                            ("Hop" (from) ~
                                                (then ("ReplayIfCanMove"  ("Hop" (last To))))
                                            )
                                            (if ("IsGeneral" (from))
                                                ("HopGeneral" (from) before:(count Columns) after:(count Columns) at:EndOfTurn)
                                            )
                                        )
                                    )		
                                )
                            )
                            (forEach Piece
                                (if ("IsSoldier" (from))
                                    (or
                                        (move Step Orthogonal (to if:(is Empty (to))) stack:True)
                                        (if ("DoesNotHaveThreeGeneral")
                                            (move Step Orthogonal
                                                (to if:(and ("IsFriendAt" (to)) ("IsSingletonStack" (to))))
                                                stack:True
                                            )
                                        )
                                    )
                                    (if ("IsGeneral" (from))
                                        (move Slide Orthogonal stack:True)
                                        (if ("IsKing" (from))
                                            ("StepToEmpty" ~ stack:True)
                                        )
                                    )
                                )		
                            )
                        })
                    )
                )
            )
            (end (if ("NoKing") (result Mover Loss)))
        )
        }
        
    )
)

Construct a Ludii game based on the following description
Knight's tour is a puzzle by which a Chess knight is moved on a board so that is is placed in every square on the board only once. It has been documented in India, where the movement of the horse piece in Chaturanga has the same movement as the Chess knight.Played with one knight on a Chess board. The goal is to move the knight onto every square of the board only once using its typical move as in Chess. 
(game "Knight's Tour" 
    (players 1) 
    (equipment { 
        (board (square 8)) 
        (piece "Knight" P1)
    }) 
    (rules 
        phases:{ 
        (phase "Placement" 
            (play (move Add (to (sites Empty)))) 
            (nextPhase "Movement")
        )
        (phase "Movement" 
            (play 
                (move Leap
                    (from (last To)) 
                    "KnightWalk" 
                    (to if:(is Empty (to)))
                    (then 
                        (add (to (last From)))
                    )
                ) 
            )
        )
        }
        
        (end {
            (if 
                (>= (count Moves) (count Sites "Board")) 
                (result P1 Win) 
            )
            (if 
                (no Moves P1) 
                (result P1 Loss) 
            ) 
        })
    )
)

Construct a Ludii game based on the following description
Beirut chess is a chess variant invented by Jim Winslow in 1992. The game is played using the standard chess pieces and board, with each side having secretly equipped one of their men with a \Beirut chess follows all the rules and conventions of standard chess, with one difference: Before the game begins, each player secretly attaches a red dot to the bottom of one of their pieces (but not the king). This piece is called a bomb carrier. On any turn, instead of moving, a player may say \ 
(game "Beirut Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        phases:{
        (phase "Bomb"
            (play 
                (forEach Site (sites Occupied by:Mover)
                    (if (!= (what at:(site)) (id "King" Mover))
                        (move Select 
                            (from (site))
                            (then
                                (and
                                    (set Value at:(last To) 1)
                                    (set Hidden Value at:(last To) to:Next)
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover "Play")
        )
        (phase "Play"
            (play 
                (if "SameTurn"
                    (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                    (or
                        (do 
                            (or 
                                (forEach Piece)
                                ("Castling")
                            )
                            ifAfterwards:(not ("IsInCheck" "King" Mover))
                        )
                        (move Select
                            (from (sites Occupied by:Mover) if:(= 1 (value Piece at:(from))))
                            (then
                                (forEach Site (sites Around (last To) includeSelf:True)
                                    (if (is Occupied (site)) 
                                        (remove (site))
                                    )
                                )		
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end {
            (if (or
                    (and 
                        ("IsInCheck" "King" Next)
                        ("NextCanNotMove")
                    )
                    ("IsOffBoard" (where "King" Next))
                )
                (result Mover Win)
            ) 
            (if ("IsOffBoard" (where "King" Mover)) (result Mover Loss))
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Toono (Yurt's Roof) is a capturing game played in Mongolia. The shape of the board is said to resemble the roof of a yurt. The pieces jump three places on the board and capture a piece they land on.Two concentric circles, with two perpendicular diameters intersecting both circles, and four other lines, positioned diagonally, connecting the circumferences of the two circles. Six pieces per player. which begin on opposite sides of the circle from the other player, three on each circle. Players alternate turns moving their pieces. Pieces move three spaces along the lines on the board, regardless of whether they are occupied, capturing any piece on the third. Pieces may change direction in a turn, as long as the lines are followed and there is no backtracking. The player who captures all of the opponent's pieces wins. 
(game "Toono"
    (players 2)
    (equipment {
        (board 
            (add
                (concentric {1 0 8 8})
                edges:{{0 2} {0 4} {0 6} {0 8}}
            )
            use:Vertex
        )
        (piece "Marker" Each
            (move 
                (from) 
                (to 
                    (sites Distance from:(from) (exact 3))
                    if:(not ("IsFriendAt" (to)))
                    (apply (if ("IsEnemyAt" (to)) (remove (to))))
                )
            )
        )
    })
    (rules
        (start {
            (place "Marker1" (difference (expand (sites Bottom) steps:2) (expand (sites Top) steps:2)))
            (place "Marker2" (difference (expand (sites Top) steps:2) (expand (sites Bottom) steps:2)))
        })
        (play (forEach Piece))
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Meusueb is a two-row mancala-style board game played by the Acehnese people on the island of Sumatra in Indonesia and particularly popular with women and children. It was documented in the early twentieth century, but it is probably older. It shares several features with similar mancala-style games in Pacific and Indian Ocean islands.2x6 board with two stores. Play begins with four counters in each hole. A move begins from any of a player's holes, sowing happens anti-clockwise. Move ends if the last counter falls into an empty hole. If it lands in a hole with counters, these are picked up and sowing continues, unless the sowing makes the last hole contain four counters, in which case these are captured and the sowing continues from the next hole. When both players have too few counters to play, each one makes one move with one of their counters and then adds all of the counters on their side of the board to the store. The player with the most counters in the store wins. 
(game "Meusueb" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (move
                Select 
                (from 
                    (if "SameTurn" 
                        (if (is Pending) "PlayFromNextHole" "LastHoleSowed") 
                        (sites Mover) 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        apply:(if (= (count at:(to)) 4)
                            (and
                                (fromTo 
                                    (from (to)) 
                                    (to (mapEntry (mover))) 
                                    count:(count at:(to))
                                ) 
                                (if (> (count at:(trackSite Move from:(to) steps:1)) 0)
                                    (and
                                        (moveAgain)
                                        (set Pending)
                                    )
                                )
                            )
                            (if (> (count at:(to)) 1)
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Pentomino tiling puzzles and games are popular in recreational mathematics.Two players have a collection of dominoes which they place on the grid in turn, covering up squares. One player places tiles vertically, while the other places them horizontally. The first player who cannot move loses. The game is played by 2 players The board has 1 row. The board has 2 columns. The Last player to play wins.
(game "Pentomino" 
    (players <Players:numPlayers>) 
    (equipment { 
        (board (rectangle <Rows:num> <Columns:num>)) 
        (tile "Z" Shared {F R F F L F})
        (tile "Y" Shared {F R F R R F R F F})
        (tile "X" Shared {F L F L L F F L L F R F})
        (tile "W" Shared {F L F R F L F})
        (tile "V" Shared {F F R F F})
        (tile "U" Shared {F L F F L F})
        (tile "T" Shared {F F R F R R F F})
        (tile "P" Shared {F F R F R F})
        (tile "N" Shared {F R F L F F})
        (tile "L" Shared {F R F F F})
        (tile "I" Shared {F F F F})
        (tile "F" Shared {F L F L L F L F R F})
        (hand Shared size:12)
        
    }) 
    (rules 
        (start {
            (place "F" (handSite Shared 0))
            (place "I" (handSite Shared 1))
            (place "L" (handSite Shared 2))
            (place "N" (handSite Shared 3))
            (place "P" (handSite Shared 4))
            (place "T" (handSite Shared 5))
            (place "U" (handSite Shared 6))
            (place "V" (handSite Shared 7))
            (place "W" (handSite Shared 8))
            (place "X" (handSite Shared 9))
            (place "Y" (handSite Shared 10))
            (place "Z" (handSite Shared 11))
        })
        (play (move (from (sites Hand Shared)) (to (sites Empty))))
        (end ("NoMoves" <End:result>))
    )
)

Construct a Ludii game based on the following description
Peralikatuma is a board game played in Sri Lanka and other places in South Asia, documented since the early twentieth century but likely to be older. The game is played on an Alquerque board, 5x5 intersecting lines, with triangular appendages on each of the four sides.Each player has 24 pieces, which are placed on the intersections of the lines and move along the lines to an adjacent intersection. Players may capture opponents' pieces by jumping them. Captures are not obligatory. Multiple captures can be made. A player wins by capturing all of the opponent's pieces. 
(game "Peralikatuma" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithFourTriangles")
        (piece "Marker" Each)
    }) 
    (rules 
        (start { 
            (place "Marker1" (union {(expand (sites Bottom) steps:2) (expand (sites Right) steps:3) (sites {"F3" "G3" "F4" "F6" "F7" "G7"}) }))
            (place "Marker2" (union {(expand (sites Top) steps:2) (expand (sites Left) steps:3) (sites {"C3" "D3" "D4" "D6" "D7" "C7"}) }))
        })
        
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")
                    (move Pass)
                )
                (forEach Piece "Marker" 
                    (or
                        ("HopSequenceCapture")
                        ("StepToEmpty")
                    )
                )
            )
        )
        
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
Puluc is a capturing game played by the Qeqchi people of Guatemala. Opponent's pieces arre captured and dragged back to the point where a player starts.Ten corn kernels are placed in a line; the spaces between the kernels are the playing spaces. Four kernels of corn are used as dice, blackened on one side. The throws are as follows: Two of the same side up = 2, three of the same side up = 3; four black sides up = 4; four unblackened sides up = 5. Five pieces per player. Players take turns moving pieces according to the throws of the corn, with two throws per turn. When a player reaches the opposite end of the board, they move to the start and continue moving in the same direction. If a piece lands on a space occupied by an opponent's piece, the player then moves in the reverse direction, carrying the opponent's piece with it in an attempt to move past the starting points and off the board. Upon moving off the board, the opponent's piece is captured. The player then enters their piece again on their next turn. However, if the opponent lands on a piece carrying one of their pieces away, they then start carrying both of those pieces back to their starting point, freeing the captured piece and capturing the other player's piece. The player who captures all of the opponent's pieces wins. 
(game "Puluc"
    (players 2)
    (equipment {
        (board 
            (rectangle 1 10) 
            {
            (track "Track1" {0..8} loop:True P1)
            (track "Track2" {8..0} loop:True P2)
            (track "CaptureTrack1" {8..0} P1 directed:True)
            (track "CaptureTrack2" {0..8} P2 directed:True)
            } 
            use:Edge
        )
        (piece "Marker" Each
            (or
                (if ("FreePiece" (state at:(from) level:(level)))
                    (move 
                        (from (from) level:(level))
                        (to 
                            ("NextSiteOnTrack" ("ThrowValue") from:(from) "Track")
                        )
                        (then 
                            (if ("AtLeastAnEnemyPieceThere" (last To))
                                ("CaptureMove")
                            )
                        )
                    )
                )
                (if ("CapturingPiece" (state at:(from) level:(level)))
                    (if ("IsNotOffBoard" ("NextSiteOnTrack" ("ThrowValue") from:(from) "CaptureTrack"))
                        (move 
                            (from (from) level:(level))
                            (to 
                                ("NextSiteOnTrack" ("ThrowValue") from:(from) "CaptureTrack")
                            )
                            (then 
                                (and
                                    ("CapturedPiecesFollowCapturingPiece")
                                    ("UnsetCapturingPieces")
                                )
                            )
                        )
                        (move Remove (from) level:(level)
                            (then
                                (and {
                                    ("UnsetCapturingPieces")
                                    ("RemoveCapturedPieces")	
                                    ("RebirthCapturingPiece")
                                })
                            )
                        )
                    )
                )
            )		
        )
        (regions "AllSites" (sites Board Vertex))
        (map "Throw" {(pair 0 5) (pair 1 3) (pair 2 2) (pair 3 3) (pair 4 4)})
        (map "Entry" { (pair 1 0) (pair 2 8)})
        ("StickDice" 4)
        (hand Each)
    })
    (rules
        (start {
            (place Stack "Marker1" (handSite P1) count:5)
            (place Stack "Marker2" (handSite P2) count:5)
        })
        (play 
            ("RollMove"
                (or {
                    (if (is Occupied (handSite Mover))
                        ("EnterAPiece")
                    )
                    (forEach Piece)
                })
                (then
                    (if ("NewTurn")
                        (moveAgain)
                    )
                )
            )
        )
        (end {
            ("CaptureAll" P2)
            ("CaptureAll" P1)
        })
    )
)

Construct a Ludii game based on the following description
Kolica Atárakua is a race game played by the Purépecha people of Michoacán, Mexico. The board is strikingly similar to boards found at Mesoamerican archaeological sites, suggesting that this game is very old.Two players. Four pieces per player, played with four stick dice. They are round on one side, flat on the other, and the round side of one has horizontal stripes, another has cross-hatching, the other two remaining blank. The throws are as follows: One flat side up = 1; two flat sides and at least one blank round side up = 2; two flat sides and both marked round sides up = 35; four flat sides up = 5; four round sides up = 10; three flat sides and one blank round side up = 3; three flat sides and cross-hatched round side up = 15; three flat sides and striped round side up = 20. The throw may only be applied to one piece. Pieces enter from the midpoint of the sides and proceed along the track in the middle, then back to the edge following that track and making a circuit of the board, returning back to the center when it has traveled along the entire perimeter. If a piece lands exactly on the points where the tracks cross in the center, the piece starts again from the beginning, but remains in the center of the board until it does so. The goal is for pieces to pass the points where the center tracks intersect after traveling all the way around the board with all four pieces. If a player lands on the same space as an opponent's piece, the opponent's piece must again start from the beginning.   
(game "Kolica Atarakua"
    (players 2)
    (equipment {
        (board 
            (add
                (merge {
                    (rectangle 1 10)
                    (shift 0 9 (rectangle 1 10))
                    (shift -1 -1 (square 2))
                    (shift 9 -1 (square 2))
                    (rectangle 10 1)
                    (shift 9 0 (rectangle 10 1))
                    (shift -1 9 (square 2))
                    (shift 9 9 (square 2))
                    (shift 5 0 (rectangle 6 1))
                    (shift 0 5 (rectangle 1 6))
                    (shift 4 4 (rectangle 1 6))
                    (shift 4 4 (rectangle 6 1))
                })
                vertices:{{1 1} {1 8} {8 1} {8 8} {4.5 4.5}}
            )
            {
            (track "Track1" "69,5,N,W,N,W,S,65,11,E,N,W,67,41,S,E,N,66,8,W,S,E,64,26,N4,E3,68,56" P1 directed:True)
            (track "Track2" "70,14,S,E,S,E,N,66,8,W,S,E,64,26,N,W,S,65,11,E,N,W,67,41,S4,W3,68,56" P2 directed:True)
            }
            use:Vertex
        )
        ("StickDice" 4)
        (piece "Marker" Each
            (if ("IsOffBoard" ("SiteToMoveOnTrack" from:(from) ("ThrowValue")))
                (move Remove (from) level:(level))
                (move 
                    (from (from) level:(level))
                    (to
                        ("SiteToMoveOnTrack" from:(from) ("ThrowValue"))
                        if:True
                        ("HittingStackCapture" (handSite (who at:(to) level:(level))))
                    )
                    (then
                        (if (is In (last To) (sites "RemoveSites"))
                            (fromTo
                                (from (last To))
                                (to (handSite (mover)))
                            )
                        )
                    )
                )
            )		
        )
        (hand Each)
        (regions "RemoveSites" (sites {51 56}))
    })
    (rules 
        (start {
            (place Stack "Marker1" (handSite P1) count:4)
            (place Stack "Marker2" (handSite P2) count:4)
        })
        (play 
            ("RollMove"
                (or
                    (forEach Piece)
                    (forEach Piece container:(mover))
                )
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
This game, the original name for which has not survived, is a capturing game related to European Tables games, but for seven players. Each player represents one of the five Gallilean planets, the sun, or the moon, and they capture one another's pieces until one is left.Seven players. Heptagonal board, with seven semi-circular socket as spaces on each side. Seven pieces per player, which begin on the leftmost spot on their side. Players are as follows: Saturn = black; Jupiter = green; Mars = red; the sun = yellow; Venus = purple; Mercury = multi-colored; the moon is white. Pieces move in an anti-clockwise direction around the board. Three seven-sided die. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When a piece lands on a space with a single piece belonging to an opponent, the opponent's piece is removed from the board. Play continues until one player remains, who becomes the winner. 
(game "Tablas Astronomias"
    (players 7)
    (equipment {
        (board 
            (concentric {49})
            {
            (track "Track" {48 46 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2 0 1 3 5 7 9 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47} loop:True)
            }
            use:Vertex
        )
        (dice d:7 num:3)
        (piece "Disc" Each)
    })
    (rules 
        (start {
            (place Stack "Disc1" 14 count:7) 
            (place Stack "Disc2" 0 count:7) 
            (place Stack "Disc3" 13 count:7) 
            (place Stack "Disc4" 27 count:7) 
            (place Stack "Disc5" 41 count:7) 
            (place Stack "Disc6" 42 count:7) 
            (place Stack "Disc7" 28 count:7) 
        })
        (play
            ("RollEachNewTurnMove" 
                (forEach Die
                    if:("DieNotUsed")
                    (forEach Site
                        (sites Occupied by:Mover)
                        (move 
                            (from (site))
                            (to ("NextSiteOnTrack" (pips) from:(site))
                                if:("NotEnemyOrOnlyOne")
                                (apply 
                                    if:("IsEnemyAt" (to)) 
                                    (remove (to))
                                )
                            )
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )
        
        (end (forEach NonMover if:(no Pieces Player) (result Player Loss)))
    )
)

Construct a Ludii game based on the following description
Tant Fant is an alignment game documented in Bengal during the later eighteenth and early twentieth century, but is likely to be much older.3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Players each have three pieces, initially placed on the sides closest to the player. Players move the pieces to an adjacent unoccupied intersection along the lines. The goal is to make three in a row which cannot be in the starting position. An alternate version requires the three in a row to be diagonal. 
(game "Tant Fant"
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 3)
        (piece "Marker" Each "StepToEmpty")
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    (rules 
        (start { 
            (place "Marker1" (sites P1)) 
            (place "Marker2" (sites P2)) 
        })
        (play (forEach Piece))
        
        (end 
            (if 
                (and 
                    "NotAllPieceInHome"
                    (is Line 3)
                ) 
                (result Mover Win)
            )
        ) 
    )
)

Describe the mechanics of the following Ludii game
(game "Ludus Lombardorum" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" 
            {
            (track "Track1" {6 0..5 18..12} P1 directed:True)
            (track "Track2" {19 12..18 5..0} P2 directed:True)
            } 
        ) 
        (dice num:3)
        (map {(pair 1 19) (pair 2 6)}) 
        (piece "Disc" Each) 
        (regions P1 { 0..5 }) 
        (regions P2 { 13..18 }) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 0 count:15)
            (place Stack "Disc2" 13 count:15)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (forEach Die
                    if:("DieNotUsed")
                    (forEach Site
                        (sites Occupied by:Mover)
                        (if ("CanEscape" ("NextSiteFrom" (site))) 
                            ("RemoveAPiece")
                            (move 
                                (from (site))
                                (to ("NextSiteFrom" (site))
                                    if:("NotEnemyOrOnlyOne")
                                    ("HittingCapture" ("Bar"))
                                )
                            )
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (result Mover Win)
            )
        )
    )
)
The Ludus Lombardorum is a European Tables game played in medieval England. It was described in a fourteenth century manuscript that also describes similar games.2x12 board, divided in half. Spaces on each side take the form of points. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, only on the left half of the board where the pieces begin, toward the point where the opponent's pieces begin, and bearing off the board from there. A player cannot have two of their pieces on the same spot in the starting quadrant. When a piece lands on the same space as an opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins.  

Construct a Ludii game based on the following description
American Pool Checkers is a game with leaping captured played primarily in Black communities in the United States.8x8 board. Twelve pieces per player. Pieces move forward diagonally to an empty space on the board. A piece may capture an opponent's adjacent piece by hopping over it to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. Captures can be made in a forward or backward direction. Captures are compulsory, but it is not required to choose a capture sequence that captures the most pieces. A piece which reaches the opposite edge of the board from where it started is promoted to a king. Kings move any number of spaces forward or backward. They also may capture a single piece if there is at least one empty space beyond it, and can change direction after a capture. Kings must also make all possible captures in a sequence. The player who captures all of the opponent's pieces wins. 
(game "American Pool Checkers"
    (players 2)
    ("DraughtsEquipment" (square 8))
    (rules 
        ("BlackCellsSetup" 3)
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    ("HopInternationalDraughtsStyle" (from (last To))
                        (then 
                            ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To)))
                                ("PromoteIfReach" (sites Next) "DoubleCounter")
                            ) 
                        ) 
                    )
                    (max Moves ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn))
                )
                (priority {
                    (or 
                        (forEach Piece "Counter"
                            ("HopInternationalDraughtsStyle" (from) 
                                (then 
                                    ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To)))
                                        ("PromoteIfReach" (sites Next) "DoubleCounter")
                                    ) 
                                ) 
                            ) 
                        )
                        (max Moves 
                            (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture" before:(count Rows) after:(count Rows) at:EndOfTurn))
                        )
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal))
                    )
                })
            )
        ) 
        (end ("BlockWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "Portes" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" ("BackgammonTracksWithBar" End)) 
        (dice num:2)
        (regions P1 { 20..25 }) 
        (regions P2 { 7..12 }) 
        (map {(pair 1 6) (pair 2 19)}) 
        (piece "Disc" Each ("MoveAPieceIf" "DieNotUsedAndNoEscapeAndNotOffTheTrack" (from))) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) 
            (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5)
            (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) 
            (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (if "AllPieceInHome"
                    (forEach Die 
                        replayDouble:True 
                        if:("DieNotUsed")
                        (forEach Site 
                            (sites Occupied by:Mover)
                            (if ("NotEmptyAndNotOffTheBoard") 
                                (if ("CanEscape")
                                    ("RemoveAPiece")
                                    ("MoveAPiece" (site))
                                )
                            )
                            noMoveYet:(firstMoveOnTrack "Track" Mover
                                (if "HaveAPieceAndCanEscape"
                                    "RemoveAPiece"
                                )
                            )
                            (then ("ReplayNotAllDiceUsed"))
                        )
                    )
                    (max Distance "Track" Mover
                        (if "BarEmpty"
                            (forEach Piece top:True)
                            ("MoveAPieceIf" ("DieNotUsed") ("Bar"))
                            (then 
                                (if (not (all DiceUsed))
                                    (if (can Move 
                                            (if "BarEmpty"
                                                (forEach Piece top:True)
                                                ("MoveAPieceIf" ("DieNotUsed") ("Bar"))
                                            )
                                        )
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (byScore { 
                    ("SetScoreOf" P1 P2)
                    ("SetScoreOf" P2 P1)
                })
            )
        )
    )
)
Portes is a game that is closely similar to Backgammon played in the eastern Mediterranean. It is frequently played as part of Tavli, where it is played in succession with Plakoto and Fevga.The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Play begins by each player rolling one die; the player who rolls the highest plays first, and then rolls again to begin play. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. The winner gains one point, or two points if the opponent has pieces in their starting quadrant.
             

Construct a Ludii game based on the following description
The Jeu de Renard is a hunt game from seventeenth century France. Players play as a fox or a group of hens. This version involves the use of two foxes instead of the customary one.8x8 Draughts board. One player plays with two foxes, the other with twelve or more hens, played on the white squares. The hens begin on the rows closest to the player; the foxes begin, one each on the left and right end of the row farthest from the hens. Hens move one space forward diagonally, the foxes move one space diagonally forward or backward. Foxes must alternate turns, i.e., when one fox moves, the other fox must move on the next turn. The foxes may capture a hen by hopping over it to an empty space diagonally on the other side of it. The hens win by blocking the foxes from being able to move; the foxes win by capturing all the hens.
         
(game "Jeu de Renard (Two Foxes)" 
    (players 2) 
    (equipment { 
        (board (square 8)) 
        (piece "Fox" P1
            (if (= (state at:(from)) 1)
                (or
                    "StepDiagonalToEmpty"
                    "HopDiagonalCapture"
                )
                (then 
                    (and
                        (forEach Site
                            (sites Occupied by:Mover)
                            (if (= (state at:(site)) 0) (set State at:(site) 1))
                        )
                        (set State at:(last To) 0)
                    )
                )
            )
        )
        (piece "Hen" P2 N ("StepToEmpty" (directions {FR FL})))
    }) 
    (rules 
        (start { 
            (place "Fox1" (intersection (sites Top) (union (sites Left) (difference (expand (sites Right)) (sites Right)))) state:1)
            (place "Hen2" (difference (expand (sites Bottom) steps:2) (sites Phase 0)))
        })
        
        phases:{
        (phase "Opening" P1
            (play 
                (forEach Piece 
                    (or
                        "StepDiagonalToEmpty"
                        "HopDiagonalCapture"
                        (then (set State at:(last To) 0))
                    )
                )
            )
            (nextPhase "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("NoMovesP1NoPiecesP2")) 
    )
)

Describe the mechanics of the following Ludii game
(game "Chukaray"
    (players 2)
    (equipment {
        (board
            (rectangle 1 25)
            {
            (track "Track1" {0..23} loop:True P1)
            (track "Track2" {23..0} loop:True P2)
            }
            use:Edge
        )
        ("StickDice" 4)
        (piece "Stick" Each
            (move 
                (from (from) level:(level))
                (to
                    ("NextSiteOnTrack" ("ThrowValue") from:(from))
                    if:True
                    (apply
                        (and
                            (if ("IsEnemyAt" (to))
                                (if ("IsOffBoard" ("NearestHomeWithStick" (who at:(to))))
                                    (remove (to))
                                    (fromTo
                                        (from (to))
                                        (to ("NearestHomeWithStick" (who at:(to))))
                                    )
                                )
                            )
                            (if (and {
                                    (is Occupied (to))
                                    ("IsPieceAt" "Stick" Neutral (to) level:0)
                                    (is In (to) (sites Next "Side"))
                                })
                                (remove (to) level:0)
                            )
                        )
                    )
                )
            )
        )
        (piece "Stick" Neutral)
        (map "Throw" {(pair 0 2) (pair 1 0) (pair 2 1) (pair 3 0) (pair 4 4)})
        (regions "Side" P1 (sites {0..11}))
        (regions "Side" P2 (sites {13..23}))
    })
    (rules 
        (start {
            (place Stack "Stick1" 0) 
            (place Stack "Stick2" 23)
            (place Stack "Stick0" (sites {1..11 13..22}))
        })
        (play 
            ("RollMove"
                (if ("NotThrow0") 
                    (forEach Piece)
                    (if (= ("Centre") (where "Stick" Mover))
                        (if ("IsNotOffBoard" ("NearestHomeWithStick" (mover)))
                            (move
                                (from (where "Stick" Mover))
                                (to ("NearestHomeWithStick" (mover)))
                            )
                            (if 
                                (and
                                    ("IsOffBoard" ("NearestHomeWithStick" (mover)))
                                    ("IsOffBoard" ("NearestHomeWithStick" (next)))
                                )
                                (move Pass (then (trigger "Draw" Mover)))
                            )
                        )
                    )
                )
                (then 
                    (if ("NotThrow0") 
                        (moveAgain)
                    )
                )
            )
        )
        (end {
            ("CaptureAll" Next)
            (if (is Triggered "Draw" Mover) (result Mover Draw))
        })
    )
)
Chukaray is a game known among several different indigenous populations in the Gran Chaco region of South America. It is a race game that requires a player to land on every space on the opponent's side of the board before attaining the goal. It is game of pure chance.Twenty-three spaces are arranged in a line: the outer space on each side and the central space are a circular holes, the intervening spaces are vertically-oriented trenches. A stick is laid in each trench, and a stick is stuck into the ground in each end hole, one belonging to each player. They move their sticks toward the opposite end of the track and then go back to their starting point, according to  the throw of four stick dice, with one flat and one convex side. The values of the throws are as follows: 4 convex sides up = 4, 3=0, 2=1, 1=0, 0=2. Players continue to throw and move until obtaining a result of 0. When the player passes the central hole, they remove the sticks from the trenches in which they land. If the player lands in the central hole, and throws a 0 on their next throw, they must then return to the space nearest to their home still containing a stick. If the player lands on the same place as the opponent, the opponent is sent back to the space nearest their home which still has a stick in it, thus eliminating this stick. The goal is to eliminate all of the sticks from the opponent's side of the board and then to land on the same space as the opponent's playing stick. If both players are in the end stage and trying to land on each other, and a player lands in the central space and then throws a 0, the game is a draw. 

Construct a Ludii game based on the following description
Tsoro Yemutatu is an alignment game played by boys, young men, and sometimes adults in Zimbabwe. This version is played on a triangular board, drawn on the ground and played with stones.Triangle, with a line from the apex bisecting the base, and a line bisecting this one and the opposite sides. Three pieces per player. Players alternate turns placing a piece on one of the empty points on the board. When all of the pieces have been placed, players alternate turns moving any one of their pieces to the empty point on the board. The first player to make a line of three wins.  
(game "Tsoro Yemutatu (Triangle)" 
    (players 2) 
    (equipment { 
        (board
            (scale 1 2 (wedge 3))
            use:Vertex
        )
        (hand Each) 
        (piece "Marker" Each (move (from) (to (sites Empty))))
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
Kara is a mancala-style game played by the Baggara people of Sudan. It is unique in that it can be played by any number of players; each player has three holes and one store hole, with the stores in the center and the other holes arranged in a rectangle around them.Play begins with seven counters in each hole. Players begin by picking up the counters in one of their holes and sowing them anti-clockwise. If the final counter lands in an opponent's hole or the rightmost hole belonging to the player sowing, having dropped counters in the opponent's holes making them contain two, four, or six counters, the contents of those holes are captured. The player who has the most counters at the end of the game wins. 
(game "Kara" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 3
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (map "RightHole" {(pair P1 3) (pair P2 4)})
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 7 to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        if:(and 
                            (is In (count at:(to)) (sites {2 4 6})) 
                            (is In (to) (union (sites Next) (sites {(mapEntry "RightHole" (mover))})))
                        )
                        apply:(fromTo 
                            (from (to)) 
                            (to (mapEntry (mover))) 
                            count:(count at:(to))
                        ) 
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Six-Penny Madell is an alignment game played in Wiltshire, England during the nineteenth century, and perhaps older. They were typically drawn on a floor or in the ground, and the pieces were whatever was readily available, such as stones or sticks.Three concentric triangles, with lines connecting their corners. Six pieces per player. Pieces can move or be placed where the lines intersect, or in the center of the sides of the triangles. Players alternate turns placing their pieces on an empty space on the board.When all the pieces have been placed, players alternate turns moving their pieces to an empty adjacent space along the lines. During either phase, when a player places three pieces in a row along one of the sides of one of the lines, they remove one of the pieces belonging to the other player. The player who removes all of the opponent's pieces wins. 
(game "Six-Penny Madell"
    (players 2) 
    (equipment {
        (board
            (concentric Triangle rings:3 joinMidpoints:False joinCorners:True)
            use:Vertex
        )
        (hand Each)
        (piece "Marker" Each
            ("StepToEmpty" ~ (then ("ReplayIfLine3" Orthogonal exact:True)))
        )
    }) 
    (rules 
        (start (place "Marker" "Hand" count:6))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPiece")
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True))
                    ) 
                )
            )
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPiece")
                    (forEach Piece)
                )
            )
        )
        }
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Lights Out is an electronic game released by Tiger Electronics in 1995.The game consists of a 5 by 5 grid of lights. When the game starts, some lights are switched on. Pressing any of the lights will toggle it and the four adjacent lights. The goal of the puzzle is to switch all the lights off, preferably in as few button presses as possible.
        Ludii allows 100 moves maximum before losing. 
(game "Lights Out" 
    (players 1) 
    (equipment { 
        (board (square 5)) 
        (piece "Light" Shared)
    }) 
    (rules
        (start (place Random {"Light"} count:(value Random (range 10 20))))
        (play
            (move Select 
                (from (sites Board))
                (then
                    (forEach Site (sites Around (last To) Orthogonal includeSelf:True)
                        (if (is Occupied (site))
                            (remove (site))
                            (add (piece "Light") (to (site)))
                        )
                    )
                )
            )
        )
        (end { 
            (if (all Sites (sites Board) if:(is Empty (site))) (result Mover Win))
            (if (= 98 (counter)) (result Mover Loss))
        })
    )
)

Construct a Ludii game based on the following description
Wouri is a two-row mancala-style board game observed in Mopti, Mali in the early twentieth century. 2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction, beginning from any hole in the player's row. When the final counter lands in a hole in the opponent's row containing three (four counting the last counter dropped into it), these are taken. In addition, the contents of any hole in the opponent's row which a player causes to contain four counters are captured. When the final counter lands in an empty hole, the turn ends. When the final counter lands in an occupied hole containing a number of counters other than three, the counters are picked up and sowing continues. If sowing reaches the original hole from which the sowing began, this hole is skipped over. A player must play so that the opponent has counters with which to play, if possible. 
(game "Wouri" 
    (players 2) 
    (equipment {
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))		 
        (play 
            (do 
                (move Select 
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover)
                        ) 
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (sow 
                            apply:(if (and 
                                    (is In (to) (sites Next)) 
                                    (= (count at:(to)) 4)
                                ) 
                                (fromTo 
                                    (from (to)) 
                                    (to (handSite Mover)) 
                                    count:(count at:(to))
                                    (then 
                                        (forEach Site
                                            (if (is Mover P1) (sites P2) (sites P1))
                                            (if (= (count at:(site)) 4)
                                                (fromTo 
                                                    (from (site)) 
                                                    (to (handSite Mover)) 
                                                    count:(count at:(site))
                                                )
                                            )
                                        )
                                    )
                                )
                                (if (< 1 (count at:(to))) 
                                    (moveAgain)
                                )
                            )
                            includeSelf:False
                        )
                    )
                )
                ifAfterwards:(< 0 (count in:(if (is Mover P1) (sites P2) (sites P1))))
            )
        )
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Tsoro is a name for sevela two-row mancala-style board games from Zimbabwe. In this version, multiple captures are allowed, as well as the option to end a sowing in certain holes.4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Two holes in each player's outer row are selected as misoro. Typically, the left two holes are chosen. At the beginning of the game, players choose whether to capture from one, two, or three extra holes. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. If this final hole is one of the misoro, the player may choose to end their turn instead of continuing to sow. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. The player also captures the counters from the agreed-upon number of holes on the opponent's side of the board. Counters in misoro cannot be captured with one of these additional captures. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. Players choose the misoro holes. 6 Holes per row. 1 extra capture.
(game "Misoro Tsoro (Additional Capture)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))         
        (regions "Outer" P2 (sites Top))          
        (piece "Seed" Shared)
    }) 
    (rules 
        
        <Start:rules>
        
        phases:{
        <Start:misoroPhase>
        (phase "Playing"
            (play 
                (if (< 0 ("NumCapture"))
                    (move Select
                        (from (forEach (sites Next) if:(and (= 0 (state at:(site))) (< 0 (count at:(site))))))
                        (then 
                            (and {
                                (if (< 1 ("NumCapture")) (moveAgain))
                                (set Var "ExtraCapture" (- ("NumCapture") 1))
                                (remove (last To))
                                (forEach Site (sites Board)
                                    (if (!= 0 (state at:(site))) (set State at:(site) (state at:(site))))
                                )
                            })
                        )
                    )
                    (or
                        (if (and (!= 0 (state at:(var))) ("SameTurn"))
                            (move Pass)
                        )
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    "LastHoleSowed" 
                                    (sites Mover "Home") 
                                ) 
                                if:(if "AHoleHasMoreThanOneCounter"
                                    (> (count at:(from)) 1)
                                    (and (= (count at:(from)) 1) (= 0 (count at:("NextHoleFrom" (from) Mover)))) 
                                )
                            )
                            (then 
                                (and
                                    (sow
                                        "Track"
                                        owner:(mover)
                                        apply:(if (= (count at:(to)) 1)
                                            (if (is In (to) (sites Mover "Inner"))
                                                (if (> (count at:("OppositePit" (to))) 0) 
                                                    (and {
                                                        (remove ("OppositePit" (to))) 
                                                        (if 
                                                            (> (count at:("OppositeOuterPit" (to))) 0) 
                                                            (remove ("OppositeOuterPit" (to))) 
                                                        )
                                                        (moveAgain)
                                                        ("HaveToMakeExtraCapture")
                                                    }) 
                                                ) 
                                            )
                                            (and 
                                                (moveAgain)
                                                (set Var (to))
                                            )
                                        )
                                    )
                                    (forEach Site (sites Board)
                                        (if (!= 0 (state at:(site))) (set State at:(site) (state at:(site))))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Jeu du Renard et de la Poule" 
    (players 2) 
    (equipment { 
        ("CrossBoard" 3 7 use:Vertex diagonals:Alternating)
        (hand P1)
        (piece "Fox" P1 (or ("HopSequenceCapture") "StepToEmpty"))
        (piece "Hen" P2 N "StepForwardsToEmpty") 
    }) 
    (rules 
        (start { 
            (place "Fox1" (handSite P1))
            (place "Hen2" (union (expand (sites Bottom)) (sites Row 2)))
        })
        
        phases:{ 
        (phase "Placement" P1 
            (play 
                (move 
                    (from (handSite P1)) 
                    (to (sites Empty))
                )
            ) 
            (nextPhase ("HandEmpty" P1) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("NoMovesLossAndNoPiecesPlayerLoss" P2))
    )
)
The Jeu du Renard et de la Poule is a hunt game documented in seventeenth century France. Played on cross-shaped board, made of five squares, each divided into four squares and with the diagonals of the larger squares drawn. One player plays as thirteen hens, which begin on the points on one of the arms of the cross and along the line immediately perpendicular to that arm. The other player plays as one fox, which can be placed on any empty point of the board. Players alternate turns moving to an empty adjacent spot  along the lines of the board. The hens, however, can only move in a forward direction. The fox may hop over an adjacent hen to an empty spot immediately on the opposite side of the hen along the lines of the board. The fox wins by capturing all the hens, the hens win by blocking the fox from being able to move. 

Construct a Ludii game based on the following description
Uthi is a two-row mancala-style board game played by the Embu people of Kenya.2x8 and two stores. Five counters per hole. On each player's first move, they sow three counters into the first hole and two into the second hole. After this, sowing proceeds as usual, with one counter in each hole. Sowing may occur in either direction. When the final counter lands in an occupied hole, the contents of this hole are picked up and sowing continues in the opposite direction. When the final counter falls in an empty hole in the player's own row, the contents of the opposite hole are captured. If the final counter falls into the first of a series of empty holes, the contents of all of the holes opposite the empty holes are captured. It is necessary to enter the opponent's row first and return before making a capture.If the final counter lands in an empty hole in the opponent's row, the turn ends. The winner is the player who has captured the most counters. 
(game "Uthi"
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "TrackCW" "8,W,N,E" loop:True)
            (track "TrackCCW" "1,E,N,W" loop:True)
            }
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 5 to:(sites Track)))
        
        phases:{
        (phase "Opening"
            (play
                (or
                    (move Select
                        (from (sites Mover))
                        (then
                            (and
                                (fromTo 
                                    (from (last To))
                                    (to ("NextHole" (last To) "TrackCW" 1))
                                    count:3
                                )
                                (fromTo 
                                    (from (last To))
                                    (to ("NextHole" (last To) "TrackCW" 2))
                                    count:2
                                )
                            )
                        )
                    )
                    (move Select
                        (from (sites Mover))
                        (then
                            (and
                                (fromTo 
                                    (from (last To))
                                    (to ("NextHole" (last To) "TrackCCW" 1))
                                    count:3
                                )
                                (fromTo 
                                    (from (last To))
                                    (to ("NextHole" (last To) "TrackCCW" 2))
                                    count:2
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover "Sowing")
        )
        
        (phase "Sowing"
            (play
                (or
                    (if (!= (value Player Mover) 1)
                        (move Select
                            (from 
                                (if 
                                    ("SameTurn") 
                                    "LastHoleSowed" 
                                    (sites Mover) 
                                ) 
                                if:(> (count at:(from)) 0)
                            )
                            (then 
                                (sow
                                    "TrackCW"
                                    apply:(if (> (count at:(to)) 1)
                                        (and {
                                            (moveAgain)
                                            (set Value Mover 1)
                                            (if (is In (to) (sites Next))
                                                (set Var "GoInOpponentRow" 1)
                                            )
                                        })
                                        (and {
                                            (set Value Mover 0)
                                            (set Var "GoInOpponentRow" 0)
                                            ("Capture" "TrackCW")
                                        })
                                    )
                                    
                                )
                            )
                        )
                    )
                    
                    (if (!= (value Player Mover) 2)
                        (move Select
                            (from 
                                (if 
                                    ("SameTurn") 
                                    "LastHoleSowed" 
                                    (sites Mover) 
                                ) 
                                if:(> (count at:(from)) 0)
                            )
                            (then 
                                (sow
                                    "TrackCCW"
                                    apply:(if (> (count at:(to)) 1)
                                        (and {
                                            (moveAgain)
                                            (set Value Mover 2)
                                            (if (is In (to) (sites Next))
                                                (set Var "GoInOpponentRow" 1)
                                            )
                                        })
                                        (and {
                                            (set Value Mover 0)
                                            (set Var "GoInOpponentRow" 0)
                                            ("Capture" "TrackCCW")
                                        })
                                    )
                                    
                                )
                            )
                        )
                    )
                )
            )
        )
        
        }
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )	
)

Construct a Ludii game based on the following description
Ram Tir is a game with leaping captures played in the Bihar region of India. 9x9 board played on the intersections, diagonals for the four quadrants of the board. Forty pieces per player, one playing as white, the other as red, arranged on opposite sides of the board, each player's pieces taking up the first through fourth ranks of spaces, plus their right half of the fifth rank. The central spot remains empty. Players alternate turns by moving a piece to an adjacent empty spot along the lines on the board. A player may capture an opponent's piece by hopping over one adjacent piece if there is an empty spot behind it along a line on the board. The player who captures all of the opponent's pieces wins. 
(game "Ram Tir" 
    (players 2) 
    (equipment { 
        (board
            (add 
                (square 9)
                edges:{ 
                {0 10} {10 20} {20 30} {30 40} {40 50} {50 60} {60 70} {70 80} 
                {8 16} {16 24} {24 32} {32 40} {40 48} {48 56} {56 64} {64 72} 
                {4 12} {12 20} {20 28} {28 36} {36 46} {46 56} {56 66} {66 76} 
                {76 68} {68 60} {60 52} {52 44} {44 34} {34 24} {24 14} {14 4} 
                }
            )
            use:Vertex
        )
        (piece "Marker" Each
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
        (hand P2)
    }) 
    (rules 
        (start {
            (place "Marker1" (difference (expand (sites Bottom) steps:4) (sites {36..40})))
            (place "Marker2" (difference (expand (sites Top) steps:4) (sites {40..44})))
        })
        (play (forEach Piece))
        
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Foji" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "5,W,N,E" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (if (is Proposed "End")
                (or (move Vote "End") (move Vote "No"))
                (or
                    (if (is Cycle) (move Propose "End")) 
                    (if ("SameTurn") 
                        (move Select
                            (from "LastHoleSowed")
                            (then
                                (sow
                                    apply:(if (< 1 (count at:(to)))
                                        (moveAgain)
                                        (if (is In (to) (sites Mover))
                                            (if (is Occupied ("OppositePit" (to)))
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (handSite Mover))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                            )
                                        )
                                    )	
                                    includeSelf:False
                                )
                            )
                        )
                        (do
                            (move Select
                                (from 
                                    (sites Mover) 
                                    if:(is Occupied (from))
                                )
                                (then
                                    (sow
                                        apply:(if (< 1 (count at:(to)))
                                            (moveAgain)
                                            (if (is In (to) (sites Mover))
                                                (if (is Occupied ("OppositePit" (to)))
                                                    (fromTo
                                                        (from ("OppositePit" (to)))
                                                        (to (handSite Mover))
                                                        count:(count at:("OppositePit" (to)))
                                                    )
                                                )
                                            )
                                        )	
                                        includeSelf:False
                                    )
                                )
                            )
                            ifAfterwards:(if (is Mover P1) (< 0 (count in:(sites P2))) (< 0 (count in:(sites P1))))
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (or (no Moves Mover) (is Decided "End"))))
    )
)
Foji is a two-row mancala-style board game oberved in Dahomey during the early twentieth century. It is similar to other two-row mancala games from West Africa.2x6 board. Four counters in each hole.  A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a clockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. When the final counter falls into an occupied hole, these are picked up and sowing continues. When the final counter of a sowing lands in an empty hole in the player's own row, the contents of the hole in the opponent's row opposite it are captured. If the opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row.
         

Describe the mechanics of the following Ludii game
(game "Goldilocks Stones"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Ball" P1)
        (piece "Ball" P2)
    })
    (rules
        (start (set Score Each 0))
        (play
            (or
                (move Pass)
                (move Add 
                    (piece (mover))
                    (to (sites Empty))
                    (then 
                        <Scoring:updateOption>
                ))
                <TurnType:turnOption>
        ))
        (end 
            (if 
                (all Passed)
                {
                (if 
                    (= (score Mover) (score Next))
                    (result Mover Loss)
                )
                (if 
                    (!= (score Mover) (score Next))
                    (byScore)
                )
                }
            )
        )
    )
)
Goldilocks Stones is a pure placement game in which a player scores one point for each stone that has just the right number of friendly neighbors; i.e. 3    A fairly straight-forward game that fills about 90 percent of the board. The tactics lie in blocking placements or taking advantage of future placement sites where the opponent would need to sacrifice points to block your placement.Goal: Score stones where exactly half of the available neighbor sites are occupied by friendly stones at the end of the game.
            The player with the highest score wins.
            
            Start with an empty board. Then on each turn the player adds one of his stones to the board, or passes.
            
            The game ends when both players pass consecutively, and then the score is calculated.
            
            In case of a tie, the last to place a stone loses.
            
            Variant Placement: Add 2 stones at a time after the first placement.
        Variant Goal: Score stones that have exactly 3 friendly neighbors at the end of the game. Goldilocks Stones have exactly 3 friendly neighbors Turns Alternate one stone per turn Hex N / N-1 Grid Order 3 board

Construct a Ludii game based on the following description
Ketch-Dolt is a Tables game played in Early Modern England. In it, players must enter their pieces to avoid being \2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The players enter their pieces on the board on the points corresponding to the throws of the dice. A player who rolls a number corresponding to a point on the opponent's side of the board that contains a piece should remove the piece from the opponent's point, which must be reentered. If the player fails to do so, they lose instantly. Otherwise, players continue to place their pieces until all are on the board, and they then bear the pieces off from the same quadrant of the board. The first player to bear off all their pieces wins. 
(game "Ketch-Dolt"
    (players 2)
    (equipment {
        ("BackgammonBoard" 
            {
            (track "Track1" {26 12..7} P1 directed:True)
            (track "Track2" {27 25..20} P2 directed:True)
            } 
        )
        (dice d:6 num:2)
        (piece "Disc" Each
            (or
                (if (is Empty (handSite Mover))
                    (forEach Die
                        if:("DieNotUsed")
                        (if ("IsOffBoard" ("NextSiteFrom" (from) "Track" (pips)))
                            (do
                                (if ("RemoveEnemyPiece") (trigger "ShouldCapture" Mover))
                                next:(move Remove (from))
                            )
                        )
                        (then ("ReplayNotAllDiceUsed"))
                    )
                )
                (forEach Die
                    if:("DieNotUsed")
                    (or
                        (if ("RemoveEnemyPiece")
                            (move 
                                (from (if (is Mover P1) ("EnemySite" P2 "Track2") ("EnemySite" P1 "Track1")))
                                (to (handSite Next))
                            )
                        )
                        (move 
                            (from (from))
                            (to 
                                ("NextSiteFrom" (from) "Track" (pips))
                                (apply (if ("RemoveEnemyPiece") (trigger "ShouldCapture" Mover)))
                            )
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )		
            )
        )
        (hand Each)
        (map "Start" {(pair P1 12) (pair P2 25)})
    })
    (rules 
        (start {
            (place Stack "Disc1" (handSite P1) count:15)
            (place Stack "Disc2" (handSite P2) count:15)
        })
        (play 
            ("RollEachNewTurnMove"
                (or (forEach Piece) (forEach Piece container:(mover)))
            )
        )
        (end {
            (if (is Triggered "ShouldCapture" P1) (result P1 Loss))
            (if (is Triggered "ShouldCapture" P2) (result P2 Loss))
            ("EscapeWin")
        })
    )
)

Construct a Ludii game based on the following description
Hexifact is a Hex grid based place-or-jump game with a goal of maximizing the product of one's largest 2 groups.                It is fairly opaque, and thus suited to small boards. Large boards will work, but the games will be long, and it will be unclear how the outcome was derived from the earlier positions.     The reason for the opacity is that connection of groups must be accomplished through jumping opponent's pieces, which themselves are frequently changing position.                To minimise this instability, no location on the board is allowed to have more than 3 adjacent friendly pieces.     Also passing is allowed to avoid forced moves that de-optimise the scores.                   Also, the standard version only allows a jump if the player made a placement on the previous turn.    This significantly reduced the game complexity compared to allowing each piece to move once before the next placement turn. Order 3-4, Hex Grid Jumping is only allowed if a player made a placement on the last turn
(game "Hexifact"
    (players 2)
    (equipment {
        (board <BoardShape:gridType> use:Vertex)
        (piece "Disc" Each)
    })
    (rules
        (play
            (or {
                (move Add
                    (piece (id "Disc" Mover))
                    (to (sites Empty)
                        if:(or
                            ("PlacementSites")
                            (= -1 (counter))
                    ))
                    (then
                        (forEach Site
                            (sites Occupied by:Mover)
                            (set State at:(site) 0)
                        )
                    )
                )
                (if
                    <Jumping:limits>
                    (do
                        (forEach Piece
                            (move Hop
                                (from if:(= 0 (state at:(from))))
                                "GridDirection"
                                (between (range 1 Infinity) if:(is In (between) (sites Occupied by:Next)))
                                (to if:(is In (to) (sites Empty)))
                                (then (set State at:(last To) 1))
                            )
                            Mover
                        )
                        ifAfterwards:(all Sites
                            (sites Occupied by:Mover) 
                            if:(> 4 (count Pieces Mover in:(sites Around (site) "GridDirection")))
                        )
                    )
                )
                (move Pass) 
                }
                (then ("ScoreMover"))
            )
        )
        (end 
            (if
                (all Passed)
                {
                (if
                    (>= (score Mover) (score Next))
                    (result Mover Win)
                )
                }
                (result Next Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Kotu Baendum" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "TrackCCW" "1,E,N,W" loop:True)
            (track "TrackCW" "7,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        (start { 
            (set Count 4 to:(sites Track)) 
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "StartingMove" P1
            (play
                (or
                    (move Select
                        (from
                            (intersection (sites Mover) (expand (sites Corners)))
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (and
                                (sow
                                    "TrackCCW"
                                    apply:(if (= 4 (count at:(to)))
                                        (and
                                            (if (is In (to) (expand (sites Corners)))
                                                (set Var "Blocked" (to))
                                                (if (!= 0 (count at:("NextHole" (to) "TrackCCW" 1)))
                                                    (and
                                                        (moveAgain)
                                                        (set Var "Replay" ("NextHole" (to) "TrackCCW" 1))
                                                    )
                                                )
                                            )
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:4
                                            )
                                        )
                                        (if (< 1 (count at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                    skipIf:(or (not (is In (to) ("PlayableSites"))) (and (= 3 (count at:(to))) (!= 1 (value)))) 
                                )
                                (set Var "Direction" 1)
                            )
                        )
                    )
                    (move Select
                        (from
                            (intersection (sites Mover) (expand (sites Corners)))
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (and
                                (sow
                                    "TrackCW"
                                    apply:(if (= 4 (count at:(to)))
                                        (and
                                            (if (is In (to) (expand (sites Corners)))
                                                (set Var "Blocked" (to))
                                                (if (!= 0 (count at:("NextHole" (to) "TrackCW" 1)))
                                                    (and
                                                        (moveAgain)
                                                        (set Var "Replay" ("NextHole" (to) "TrackCW" 1))
                                                    )
                                                )
                                            )
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:4
                                            )
                                        )
                                        (if (< 1 (count at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                    skipIf:(or (not (is In (to) ("PlayableSites"))) (and (= 3 (count at:(to))) (!= 1 (value)))) 
                                )
                                (set Var "Direction" 2)
                            )
                        )
                    )
                )
            )
            (nextPhase Mover "Sowing")
        )
        
        (phase "StartingMove" P2
            (play
                (if (= 1 (var "Direction"))
                    (move Select
                        (from
                            (intersection (sites Mover) (expand (sites Corners)))
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                apply:(if (= 4 (count at:(to)))
                                    (and
                                        (if (is In (to) (expand (sites Corners)))
                                            (set Var "Blocked" (to))
                                            (if (!= 0 (count at:("NextHole" (to) "TrackCCW" 1)))
                                                (and
                                                    (moveAgain)
                                                    (set Var "Replay" ("NextHole" (to) "TrackCCW" 1))
                                                )
                                            )
                                        )
                                        (fromTo
                                            (from (to))
                                            (to (mapEntry Mover))
                                            count:4
                                        )
                                    )
                                    (if (< 1 (count at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(or (not (is In (to) ("PlayableSites"))) (and (= 3 (count at:(to))) (!= 1 (value)))) 
                            )
                        )
                    )
                    (move Select
                        (from
                            (intersection (sites Mover) (expand (sites Corners)))
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (sow
                                "TrackCW"
                                apply:(if (= 4 (count at:(to)))
                                    (and
                                        (if (is In (to) (expand (sites Corners)))
                                            (set Var "Blocked" (to))
                                            (if (!= 0 (count at:("NextHole" (to) "TrackCW" 1)))
                                                (and
                                                    (moveAgain)
                                                    (set Var "Replay" ("NextHole" (to) "TrackCW" 1))
                                                )
                                            )
                                        )
                                        (fromTo
                                            (from (to))
                                            (to (mapEntry Mover))
                                            count:4
                                        )
                                    )
                                    (if (< 1 (count at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(or (not (is In (to) ("PlayableSites"))) (and (= 3 (count at:(to))) (!= 1 (value)))) 
                            )
                        )
                    )
                )
            )
            (nextPhase Mover "Sowing")
        )
        
        (phase "Sowing" 
            (play
                (if (= 1 (var "Direction"))
                    (move Select
                        (from
                            (if (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay")})
                                (sites Mover)
                            )
                            if:(and { 
                                (is Occupied (from)) 
                                (is In (from) ("PlayableSites")) 
                                (not (is In (from) ("BlockingHoles")))
                                (if (not ("OnlySingleCounters"))
                                    (< 1 (count at:(from)))
                                )
                            })
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                apply:(if (= 4 (count at:(to)))
                                    (and
                                        (if (is In (to) (expand (sites Corners)))
                                            (set Var "Blocked" (to))
                                            (if (!= 0 (count at:("NextHole" (to) "TrackCCW" 1)))
                                                (and
                                                    (moveAgain)
                                                    (set Var "Replay" ("NextHole" (to) "TrackCCW" 1))
                                                )
                                            )
                                        )
                                        (if (not (is In (to) ("BlockingHoles")))
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:4
                                            )
                                        )
                                    )
                                    (if (< 1 (count at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(or (not (is In (to) ("PlayableSites"))) (and (= 3 (count at:(to))) (!= 1 (value)))) 
                            )
                        )
                    )
                    (move Select
                        (from
                            (if (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay")})
                                (sites Mover)
                            )
                            if:(and { 
                                (is Occupied (from)) 
                                (is In (from) ("PlayableSites")) 
                                (not (is In (from) ("BlockingHoles")))
                                (if (not ("OnlySingleCounters"))
                                    (< 1 (count at:(from)))
                                )
                            })
                        )
                        (then 
                            (sow
                                "TrackCW"
                                apply:(if (= 4 (count at:(to)))
                                    (and
                                        (if (is In (to) (expand (sites Corners)))
                                            (set Var "Blocked" (to))
                                            (if (!= 0 (count at:("NextHole" (to) "TrackCW" 1)))
                                                (and
                                                    (moveAgain)
                                                    (set Var "Replay" ("NextHole" (to) "TrackCW" 1))
                                                )
                                            )
                                        )
                                        (if (not (is In (to) ("BlockingHoles")))
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:4
                                            )
                                        )
                                    )
                                    (if (< 1 (count at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(or (not (is In (to) ("PlayableSites"))) (and (= 3 (count at:(to))) (!= 1 (value)))) 
                            )
                        )
                    )
                    (then
                        (if (no Moves Next) 
                            (and {
                                (forEach Site (sites P1)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry P1))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site (sites P2)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forget Value "Playable" All)
                                (forget Value "Blocked" All)
                                (if (< ("PiecesOwnedBy" P1) ("PiecesOwnedBy" P2))
                                    (and
                                        (set NextPlayer (player 2))
                                        (set Var "Winner" 2)
                                    )
                                    (and
                                        (set NextPlayer (player 1))
                                        (set Var "Winner" 1)
                                    )
                                )
                            })
                        )
                    )
                )
            )
            
            (end (if (no Moves Next)
                    {
                    (if (> 2 (count at:(mapEntry P1))) (result P2 Win))
                    (if (> 2 (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase (no Moves Next) "BetweenRounds")
        )
        
        (phase "BetweenRounds" 
            (play
                (if (and ("NewTurn") (!= (mover) (var "Winner")))
                    (or
                        (move
                            (from (mapEntry Mover))
                            (to ("RightMostEmpty") if:(is Empty (to)))
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (if (> 4 (count at:(last To)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (mapEntry Next))
                                                count:(- 4 (count at:(last To)))
                                            )
                                            (remember Value "Blocked" (last To))
                                        )
                                    )
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                    (set Var "Direction" 2)
                                })
                            )
                        )
                        (move
                            (from (mapEntry Mover))
                            (to ("LeftMostEmpty") if:(is Empty (to)))
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (if (> 4 (count at:(last To)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (mapEntry Next))
                                                count:(- 4 (count at:(last To)))
                                            )
                                            (remember Value "Blocked" (last To))
                                        )
                                    )
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                    (set Var "Direction" 1)
                                })
                            )
                        )
                    )
                    (if (!= (mover) (var "Winner"))
                        (move
                            (from (mapEntry Mover))
                            (to 
                                (if (= (var "Direction") 1)
                                    ("NextHole" (last To) "TrackCCW" 1) 
                                    ("NextHole" (last To) "TrackCW" 1) 
                                )
                                if:(is Empty (to))
                            )
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                })
                            )
                        )
                        (move
                            (from (mapEntry Mover))
                            (to (sites Mover) if:(is Empty (to)))
                            count:4
                            (then (and
                                    (remember Value "Playable" (last To))
                                    (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing") 
        )
        }
    )
)
Kotu Baendum is a two-row mancala-style board game from Sri Lanka.2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. The first turn of each player must occur from one of the player's end holes. Players sow beginning from holes in their row. In the course of sowing, a player cannot sow into a hole containing three counters; if one is encountered, it is skipped and the counter is sowed into the next hole without three. If the final counter falls into a hole containing three counters, the contents of the hole are captured and the contents of the next hole are picked up and sowing continues. However, if the hole fitting these conditions is an end hole, it is treated as a puta or naga hole as described below. Otherwise, if the last counter falls into a hole with counters, these are picked up and sowing continues, or if it falls into an empty hole or one treated as a naga or puta hole, the turn ends. Throughout the game, single counters cannot be moved if a player has a hole with multiple counters, and a single counter in the front hole cannot be moved if there are other single counters in the player's row. The round ends when one player's holes are empty. 
            
            A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round. The player with empty holes begins play in the direction of the empty hole. Counters cannot be captured or sowed from puta or naga holes. Play continues as before.
            
            When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters.  
            
        Play continues until one player cannot sow at the beginning of a round. 

Construct a Ludii game based on the following description
Aj Sakakil, \Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, exiting at the opposing team's home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the opposing team's home field, the piece may be re-entered on that player's team's own home field. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured. The captured piece is placed on top of the piece that captured it, and the stack continues toward the opposing team's home space. If the player successfully carries the captured piece to the opposing team's home space, the piece is permanently captured and removed from play. If the opposing side lands on the same space as the stack, they are stacked with the opponent's piece, and the opponent begins carrying the stack to the their opposing team's side. Any pieces captured belonging to the team which brings them off the board are returned to their players. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces.
         The game has 6 players.
(game "Aj Sakakil"
    (players <Player:num>)
    (equipment {
        (board
            (rectangle 1 <Player:size>)
            <Player:tracks> 
            use:Edge
        )
        (regions "AllSites" (sites Board Vertex))
        (piece "Stick" Each
            (forEach Value (values Remembered "Throws")
                (or
                    (if ("FreePiece" (state at:(from) level:(level)))
                        (if ("IsOffBoard" ("NextSiteOnTrack" (value) from:(from)))
                            (move 
                                (from (from) level:(level))
                                (to 
                                    (handSite Mover)
                                    (apply (forget Value "Throws" (value)))		
                                )
                            )
                            (move 
                                (from (from) level:(level)
                                    if:(if (is In (from) (sites Hand Mover))
                                        ("NoPieceOnBoard")
                                        True
                                    )
                                )
                                (to 
                                    ("NextSiteOnTrack" (value) from:(from))
                                    (apply (forget Value "Throws" (value)))
                                )
                                (then 
                                    (if ("AtLeastAnEnemyPieceThere" (last To))
                                        ("CaptureMove")
                                    )
                                )
                            )
                        )
                    )
                    (if ("CapturingPiece" (state at:(from) level:(level)))
                        (if ("IsOffBoard" ("NextSiteOnTrack" (value) from:(from)))
                            (do (forget Value "Throws" (value))
                                next:(move Remove (from) level:(level)
                                    (then
                                        (and {
                                            ("UnsetCapturingPieces")
                                            ("RemoveCapturedPieces")	
                                            ("RebirthCapturingPiece")
                                        })
                                    )
                                )
                            )
                            (move 
                                (from (from) level:(level))
                                (to 
                                    ("NextSiteOnTrack" (value) from:(from))
                                    (apply (forget Value "Throws" (value)))
                                )
                                (then 
                                    (and
                                        ("CapturedPiecesFollowCapturingPiece")
                                        ("UnsetCapturingPieces")
                                    )
                                )
                            )
                        )
                    )
                )
            )		
        )
        ("StickDice" 4)
        (hand Each)
    })
    (rules 
        (start {
            <Player:team>
        })
        
        phases:{
        (phase "ThrowPhase" 
            (play 
                ("RollMove"
                    (move Pass
                        (then
                            (if (not (no Pieces Mover))
                                (and {
                                    (if (!= 0 ("ThrowValue"))
                                        (do
                                            (remember Value "Throws" ("ThrowValue"))
                                            ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece)))
                                        )
                                    )
                                    (moveAgain)
                                    (if ("SameTurn") (set Pending))
                                })
                            )
                        )
                    )
                )	
            )
            (nextPhase (is Pending) "MovePhase")
        )
        (phase "MovePhase" 
            (play 
                (or (forEach Piece) (forEach Piece container:(mover))
                    (then
                        (if (< 0 (size Array (values Remembered "Throws")))
                            (moveAgain)
                        )
                    )
                )
            )
            (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase")
        )
        }
        
        (end ("CaptureAllTeam"))
    )
)

Construct a Ludii game based on the following description
A version of Xiangqi played on a hexagonal board.All rules are the same as regular Xiangqi. 
(game "Xiang Hex" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (renumber Cell (rotate 90 (remove (hex Rectangle 9 11) cells:{0 1 11 21 63 74 85 84 94 93 83 73 31 20 9 10}))))
        
        
        (piece "Jiang" Each ("StepMoveOnThePalace" Orthogonal)) 
        
        
        (piece "Shi" Each ("StepMoveOnThePalace" Diagonal)) 
        
        
        (piece "Xiang" Each 
            (move Slide
                Diagonal 
                (between 
                    (exact 2) 
                    if:(and { 
                        (is In (between) (sites Mover "Home")) 
                        (is Empty (between)) 
                    })
                )
                (to 
                    if:("IsEnemyAt" (to)) 
                    (apply (remove (to)))
                ) 
            )
        ) 
        
        
        (piece "Ma" Each 
            (forEach Direction 
                Orthogonal 
                (to 
                    if:(is Empty (to)) 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL} of:All) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (remove (to))
                                        )
                                    )
                                )
                            )
                        ) 
                    )
                )
            ) 
        )
        
        
        (piece "Ju" Each ("SlideCapture" Orthogonal))
        
        
        (piece "Pao" Each 
            (or 
                (move Slide Orthogonal) 
                (move Hop
                    Orthogonal 
                    (between 
                        before:(count Rows) 
                        after:(count Rows) 
                        if:(is Occupied (between))
                    )
                    (to 
                        if:(is Empty (to)) 
                        (apply 
                            if:("IsEnemyAt" (to)) 
                            (remove (to))
                        )
                    ) 
                ) 
            )
        )
        
        
        (piece "Zu" Each
            ("StepToNotFriend"
                (if 
                    (is In (from) (sites Mover "Home")) 
                    Forward 
                    (union (directions {Forward FL FR}) (directions {W E}))
                ) 
            )
        )
        
        (regions "PalaceP1" P1 { 0 1 2 4 7 8 12 })
        (regions "PalaceP2" P2 { 66 70 71 74 76 77 78 })
        (regions "Home" P1 (forEach (sites Board) if:(< (site) 37)))
        (regions "Home" P2 (forEach (sites Board) if:(> (site) 41)))
    }) 
    
    (rules 
        (start { 
            (place "Jiang1" coord:"A1") (place "Shi1" {"A2" "B1"}) (place "Xiang1" {"A3" "C1"}) (place "Ma1" {"A4" "D1"}) (place "Ju1" {"A5" "E1"}) (place "Pao1" {"B5" "E2"}) (place "Zu1" {"B6" "C5" "D4" "E3" "F2"})
            (place "Jiang2" coord:"K11") (place "Shi2" {"J11" "K10"}) (place "Xiang2" {"I11" "K9"}) (place "Ma2" {"H11" "K8"}) (place "Ju2" {"G11" "K7"}) (place "Pao2" {"G10" "J7"}) (place "Zu2" {"F10" "G9" "H8" "I7" "J6"})
        })
        
        (play (do 
                (forEach Piece) 
                ifAfterwards:(and 
                    ("JiangSameColumnWithNoPieceBetween")
                    (not ("IsInCheck" "Jiang" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "Jiang")
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
Chase is a turn-based computer game in which players are tasked with escaping from robots programmed to pursue and kill them. The player attempts to destroy the robots by moving in such a way that the robots collide with each other or other obstacles.Chase is played on a two-dimensional rectangular grid. The objective of the game is to escape from a number of robots, which have been programmed to kill the player.
            
            The game is turn-based. The player character and the robots start at randomly selected locations. Every time the player character moves a square in any direction (horizontally, vertically, or diagonally), each robot moves one square closer to their new location, in whichever direction is the shortest path. If the player character collides with a robot, they die and the game ends.
            
            The player attempts to survive by causing the robots to kill themselves by colliding with other objects on the map. When two robots collide each other a pile of rubble is created.
            
            The player can also teleport into a randomly selected location. Teleportation counts as a move, and the robots will respond by moving towards the new location. Because the location is randomly selected, it is possible that the player teleports right into the path of a robot. A safe teleport is also possible for the player but can be used only a limited number of times.
            
            The game is won when all of the robots are destroyed. 
            
        In Ludii, the number of safe teleportations available is the score of the player. In clicking on the player a safe teleportation will be applied. To make a non safe teleportation, the button Pass has to be pressed. The board has 1 row. The board has 2 columns. The player has 2 safe teleportations. 2 robots.
(game "Chase" 
    (players 1) 
    (equipment { 
        (board (rectangle <Rows:num> <Columns:num>)) 
        (piece "Human" P1 
            ("StepToEmpty" ~
                (then
                    ("RobotThreat")
                )
            )
        )
        (piece "Robot" Shared)
        (piece "Rubble" Neutral)
    }) 
    (rules 
        (start {
            (place Random {"Human"})
            (place Random {"Robot"} count:("NumRobots"))
            (set Score P1 ("NumSafeTeleportation"))
        })
        (play
            (or {
                (forEach Piece)
                (move Pass (then ("Teleportation")))
                (if (< 0 (score P1))
                    (move Select
                        (from (where (id "Human")))
                        (then
                            (and
                                (set Score Mover (- (score P1) 1))
                                ("SafeTeleportation")
                            )
                        )
                    )
                )
                }
                (then
                    ("KillRobotsIfColliding")
                )
            )
        )
        (end {
            (if (no Pieces Mover) (result Mover Loss))
            (if (no Pieces "Robot") (result Mover Win))
        })
    )
)

Construct a Ludii game based on the following description
Katra Boaoaka is a four-row mancala-style board game played in Madagascar. It is typically played by women and older children.4x8 board. Two counters in each hole. Each player may sow in either direction on their first move, but must continue in the same direction for the remainder of the game. When the final counter of a sowing lands in an occupied hole, the counters in that hole are picked up and sowing continues. If the final hole of a sowing is in the inner row, regardless of whether it is occupied or empty, the player then captures the counters in both of the opponent's holes opposite it, and continues sowing with these counters as well as the ones in the final hole of sowing. Captures cannot be made when the final hole of a sowing was empty, and the opponent's opposite holes have only a single counter. When the final counter lands in an empty hole, the turn is over. The player who captures all the counters wins. 
(game "Katra Boaoaka" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "24,E,S1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        (play
            (or
                (if (!= (value Player Mover) 2)
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                (sites {(var "Replay")})
                                (sites Mover "Home") 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then
                            (and
                                (sow
                                    "TrackCCW"
                                    owner:(mover)
                                    apply:(and
                                        (if (< 1 (count at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                        (if (is In (to) (sites Mover "Inner"))
                                            (if (not 
                                                    (and { 
                                                        (= 1 (count at:(to)))
                                                        (= 1 (count at:("OppositePit" (to))))
                                                        (= 1 (count at:("OppositeOuterPit" (to))))
                                                    })
                                                )
                                                (if (or (is Occupied ("OppositePit" (to))) (is Occupied ("OppositeOuterPit" (to))))
                                                    (and {
                                                        (fromTo
                                                            (from ("OppositePit" (to)))
                                                            (to (to))
                                                            count:(count at:("OppositePit" (to)))
                                                        )	
                                                        (fromTo
                                                            (from ("OppositeOuterPit" (to)))
                                                            (to (to))
                                                            count:(count at:("OppositeOuterPit" (to)))
                                                        )
                                                        (if (= 1 (count at:(to)))
                                                            (and
                                                                (moveAgain)
                                                                (set Var "Replay" (to))
                                                            )
                                                        )
                                                    })
                                                )
                                            )
                                        )
                                    )
                                )
                                (if (!= (value Player Mover) 1)
                                    (set Value Mover 1)
                                )
                            )
                        )
                    )
                )
                
                (if (!= (value Player Mover) 1)
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                (sites {(var "Replay")})
                                (sites Mover "Home") 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then
                            (and
                                (sow
                                    "TrackCW"
                                    owner:(mover)
                                    apply:(and
                                        (if (< 1 (count at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                        (if (is In (to) (sites Mover "Inner"))
                                            (if (not 
                                                    (and { 
                                                        (= 1 (count at:(to)))
                                                        (= 1 (count at:("OppositePit" (to))))
                                                        (= 1 (count at:("OppositeOuterPit" (to))))
                                                    })
                                                )
                                                (if (or (is Occupied ("OppositePit" (to))) (is Occupied ("OppositeOuterPit" (to))))
                                                    (and {
                                                        (fromTo
                                                            (from ("OppositePit" (to)))
                                                            (to (to))
                                                            count:(count at:("OppositePit" (to)))
                                                        )	
                                                        (fromTo
                                                            (from ("OppositeOuterPit" (to)))
                                                            (to (to))
                                                            count:(count at:("OppositeOuterPit" (to)))
                                                        )
                                                        (if (= 1 (count at:(to)))
                                                            (and
                                                                (moveAgain)
                                                                (set Var "Replay" (to))
                                                            )
                                                        )
                                                    })
                                                )
                                            )
                                        )
                                    )
                                )
                                (if (!= (value Player Mover) 2)
                                    (set Value Mover 2)
                                )
                            )
                        )
                    )
                )
            )
        )
        (end "ForEachNonMoverNoMovesLoss")
    )
)

Construct a Ludii game based on the following description
Ratio is a board game that can be played with many rulesets.First, the giant takes place on one of the top sites. Centre site in the opening move for the giant is not allowed. In any subsequent moves, the giant is allowed to enter the centre.
                
                The Giant piece can step to an empty site, the dwarves can step only forward to the top of the board.
                
        The giant wins if it reaches the bottom sites and the dwarves win if they block the giant to move. The rules of the game I.
(game "Ratio"
    (players {(player S) (player N)})
    <Game:equipment>
    (rules
        <Game:start>
        <Game:play>
        <Game:end>
    )
)

Describe the mechanics of the following Ludii game
(game "Sudoku Mine" 
    (players 1) 
    (equipment { 
        (board (square <Challenge:size>) (values Cell (range 0 1)))
        (hints { <Challenge:hints> })
        (regions {Columns Rows})
        (piece "Bomb" P1)
    }) 
    (rules 
        (play 
            (satisfy {
                (forAll
                    Hint 
                    (is Count 
                        (sites Around (from)) 
                        of:1
                        (hint)
                    )
                )
                (forAll
                    Hint 
                    (= (what at:(from)) 0)
                )
                (is Sum 3)
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)
Sudoku Mine combines Sudoku puzzle with Minesweeper game.The goal is to place three mines in every row, column and region. The digits in the grid represent the number of mines in the neighbouring cells. 

Construct a Ludii game based on the following description
This game is presented in a group of manuscripts from the Maharaja Krishnaraja Wadiyar III of Mysore. Seventeen people attempt to trap three tigers, and the tigers attempt to eat the people.A triangle, with two lines drawn from the apex to the base. A rectangle is drawn across the triangle, and another line connecting the midpoints of the short sides of the rectangle. One player plays as three tigers, the other as seventeen people. One tiger begins on the apex of the triangle and the other two may be placed anywhere. Players alternate turns, with the person playing as the people first placing a person on the board, and then one of the tigers moving to an empty adjacent spot along the lines of the board. When all of the people have been placed, the people move on the board in the same fashion. The tigers may capture one of the people by jumping over it to an empty adjacent spot immediately on the opposite side of one of the people along the lines of the board. The tigers win when they capture enough people so that the people cannot block the tiger, the people win when they can block the tiger from being able to move. 
(game "Mysore Tiger Game (Three Tigers)" 
    (players 2) 
    (equipment { 
        (board 
            (add
                (remove
                    (merge
                        (shift 0 2 (scale 8 2 (rectangle 3 2)))
                        (scale 1 2 (wedge 5 4)) 
                    )
                    edges:{ {0 1} {2 3} {4 5}}
                )
                edges:{ {0 15} {18 1} {2 11} {14 3} {4 7} {10 5} }
            ) 
            use:Vertex
        ) 
        (hand Each) 
        (piece "Human" P2 ("StepToEmpty"))
        (piece "Tiger" P1
            (or 
                ("StepToEmpty")
                ("HopCapture")
            )
        )
    }) 
    (rules 
        (start {
            (place "Human2" (handSite P2) count:17)
            (place "Tiger1" (sites Top))
            (place "Tiger1" (handSite P1) count:2)
        })
        
        phases:{
        (phase "Opening" P1
            (play (move (from (handSite Mover)) (to (sites Empty)) (then (if ("HandOccupied" Mover) (moveAgain)))))
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        (phase "Opening" P2
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("NoMovesP1NoPiecesP2"))
    )
)

Construct a Ludii game based on the following description
La Dama is a game with leaping captures played in the Canary Islands. This version is played in Puerto de la Cruz, in holes in the ground, with pebbles or shells as pieces. Graffiti found around the islands suggest that the game may have been played by the indigenous Guanche people. In making the game, people first draw a board similar to Alquerque, then they pecked the depressions to be used as the board on the intersections.5x5 holes. Twelve pieces per player, which begin in the two rows closest to each player and in the two holes to the right of the central hole. The central hole remains empty. 
            
            Players alternate turns moving a piece to an empty adjacent hole sideways or forward diagonally or orthogonally. Unpromoted pieces cannot move or capture backwards. A player may capture an opponent's piece by hopping over it to an empty space immediately on the opposite side of it, in one of the allowed directions. 
            
            The huff rules applies: when a player does not make a capture that they should, the opponent removes the piece that should have captured. 
            
            When a piece reaches a corner space on the opposite side of the board from where it starts, it is promoted to Dama. The Dama can move and capture any distance orthogonally or diagonally, and may also move backwards. 
            
        The player who captures all of the opponent's pieces wins. 
(game "La Dama" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 5) use:Vertex)
        (piece "Disc" Each
            (or
                ("HopDisc") 
                ("StepToEmpty" 
                    (directions {Rightward Leftward Forwards} of:All) 
                    (then ("HasNotCaptured"))
                )
                (then ("PromoteIfReach" (sites Next) "DiscDouble"))
            )		
        )
        (piece "DiscDouble" Each
            (or
                ("HopDiscDouble") 
                (move Slide All (then ("HasNotCaptured")))
            )		
        )
        (regions P1 (intersection (sites Corners) (sites Bottom)))
        (regions P2 (intersection (sites Corners) (sites Top)))
    }) 
    
    (rules 
        (start { 
            (place "Disc1" (union {(expand (sites Bottom)) (sites {"D3" "E3"}) }))
            (place "Disc2" (union {(sites {"A3" "B3"}) (expand (sites Top)) }))
        })
        
        (play 
            (or
                (if ("DidNotCaptured")
                    (or
                        (if ("ShouldCapturedButMoved") 
                            ("HuffOnePieceOf" (last To))
                        )
                        ("HuffOnePieceOf" ("SitesWithPossibleCaptureInPreviousTurn"))
                    )
                )
                (do 
                    ("RememberSiteWithPossibleCapture") 
                    next:(forEach Piece)
                )
            )
        ) 
        
        (end ("CaptureAll" Mover)) 
    )
)

Construct a Ludii game based on the following description
Toguz Kumalak is a two-row mancala-style game board from Central Asia, and particularly popular in Kazakhstan and Kyrgyzstan. In Kyrgyzstan, in the early twentieth century, it was mostly played by older people, and was particularly popular during the warm season, when people would gather to play it in the hills. It could be played either on wooden boards or in holes dug into the ground. It is a well-known game throughout the region, and tournament play is becoming increasingly popular. 2x9 board, with two stores in between the holes. Players own the store to their right. Nine counters in each hole. A player takes all of the counters from one of the holes in their row and sows them anti-clockwise. The first stone is dropped into the hole that was just emptied, except when there is only one stone, in which case it is moved to the next hole. If the last counter falls into an opponent's hole making this hole have an even number of counters, these counters are captured and placed in the player's store. Otherwise, the turn ends. When the last counter falls into an opponent's hole, making it contain three counters, it is made into a \ 
(game "Toguz Kumalak" 
    (players 2) 
    
    (equipment { 
        (board 
            (merge {
                (rectangle 1 9)
                (shift 2.5 1 (rectangle 1 1))
                (shift 5.5 1 (rectangle 1 1))
                (shift 0 2 (rectangle 1 9))
            })
            (track "Track" "0,E,19,W" loop:True)
            use:Vertex
        )
        (regions P1 (sites Bottom))    
        (regions P2 (sites Top))       
        (map {(pair P1 9) (pair P2 10)}) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 9 to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow 
                        apply:(if 
                            (and 
                                (is In (to) (sites Next)) 
                                (is Even (count at:(to)))
                            ) 
                            (fromTo 
                                (from (to)) 
                                (to (mapEntry (mover))) 
                                count:(count at:(to))
                            )
                            (if (and { 
                                    (is In (to) (sites Next)) 
                                    (= (count at:(to)) 3) 
                                    (< ("Tuz" Mover) 0) 
                                    (if (< ("Tuz" Next) 0)
                                        True
                                        (!= (+ (to) ("Tuz" Next)) 19)
                                    )
                                }) 
                                (and
                                    (set Value Mover (to))
                                    (fromTo 
                                        (from (to)) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:(to))
                                    )
                                )
                            )
                        )
                        origin:(!= (count at:(last From)) 1)
                        (then
                            (and
                                ("CaptureFromTuzOf" P1)
                                ("CaptureFromTuzOf" P2)
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Describe the mechanics of the following Ludii game
(game "Connect Four" 
    (players 2) 
    (equipment { 
        <Model:board>
        (piece "Disc" Each)
    }) 
    
    (rules
        <Model:rules>
    )
)
Connect Four is a two-player connection game that was designed by Howard Wexler and Ned Strongin, and was first sold under this name by Milton Bradley in 1974.Connect 4 is played on a vertically placed grid of 7x6, where colored disks are dropped from the top of the grid. Players alternate dropping discs, which fall to the bottom of the column in which they are dropped. The first player to create a row of four disks in their color wins. 

Construct a Ludii game based on the following description
Popular since at least the Roman Empire, Nine Men's Morris is an alignment game that is still played today. It appears in texts from Roman authors such as Ovid, and potentially may date to Hellenistic Greece.Played on a board of three concentric squares, with a line bisecting the perimeters of each square on each side, but not extending inside the perimeter of the central square. Play occurs on the intersections of the lines and the corners of the squares. Each player has nine pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. They cannot remove an opponent's piece that is in a three-in-a-row formation unless there are no other options. Once all pieces are placed, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. Once a player is reduced to three pieces, that player may move to any open space on the board. The game is won when the opponent is reduced to two pieces. 
(game "Nine Men's Morris"
    (players 2)
    
    (equipment { 
        ("NineMensMorrisBoard")
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3" Orthogonal exact:True)))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:9))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True))
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveEnemyPiece"
                    (if (> (count Pieces Mover) 3)
                        (forEach Piece)
                        (move 
                            (from (sites Occupied by:Mover))
                            (to (sites Empty))
                        )
                    )
                )
            )
        )
        }
        
        (end ("HavingLessPiecesLoss" Next 2))
    )
)

Construct a Ludii game based on the following description
Players steer cellular automata to dominate the board.Play on an equilateral hexagonal triangle-tessellated grid. The board is seeded randomly with a black stone, a white stone, and a neutral stone. Players take turn seeding new groups. Every placement triggers growth of all enemy groups, where growth is defined as adding a stone to all empty cells adjacent to a group. When the board fills up, the person who has more pieces on the board wins. Played on a size 3 board.
(game "Inkblots"
    (players 2)
    (equipment {
        (board (tri Hexagon <Board>))
        (tile "Triangle" Each) 
        (tile "Triangle" Neutral) 
    })
    (rules
        (meta (swap))
        (start (place Random {"Triangle1" "Triangle2" "Triangle0"}))
        (play
            (move Add (to (sites Empty))
                (then
                    (add (piece (id "Triangle" Next))  
                        (to
                            (intersection
                                (expand (sites Occupied by:Next) Orthogonal)
                                (sites Empty)
                            )
                        )
                    )
                )
            )
        )
        
        (end 
            (if (no Moves Next) 
                (byScore {
                    (score P1 (count Pieces P1)) 
                    (score P2 (count Pieces P2))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Romavoa is a race game that seems to have been attested among the Tarahumara people of the Sierra Madre Occidental in Mexico since the eighteenth century. Played on a board with 36 holes arranged in a square, with a gap in the center of each side. There are two semi circles of five holes on the outside of two opposite corners of the board. Two pieces per player. Four stick dice are used, each with one marked side. Each die is marked differently for a different value: 4, 6, 14, 15. The throws are as follows: All marked sides up = 5; three marked sides up = 3; two marked sides up = 2, one marked side up = the value of the marked side; zero marked sides up = 10. Throws of 14 may instead be played as a throw of 1, whenever the player chooses. Players’ pieces enter on the branching arcs. Players move in opposite directions around the board, and then back down the arc in which they started, moving their pieces off the board. If a player lands on the same spot as the opponent, the opponent’s piece is removed from the board and must re-enter. A player's piece is allowed to occupy the same space as that player's other piece. On the last side of the rectangle before completing a circuit of the board, only throws of 1, 2, or 3 are used. Players must make an exact throw to get a piece off the board. The first player to remove their pieces from the board wins.
         
(game "Romavoa"
    (players 2)
    (equipment {
        ("KintsBoard"
            {
            (track "Track1" "46,5,SSE,N,E,S,W,NNW2,End" P1 directed:True)
            (track "Track2" "47,41,NNW,W,S,E,N,SSE2,End" P2 directed:True)
            }
        )
        (regions "AllSites" (sites Board))
        (regions "LastSide" P1 (sites {6..9 23..27}))
        (regions "LastSide" P2 (sites {27 33..40}))
        (dice d:2 facesByDie:{{0 4} {0 6} {0 14} {0 15}} num:4)
        (piece "Marker" Each ("Movement"))
        (hand Each)
        (map "Throw" {
            (pair 0 10) (pair 39 5) (pair 24 3) (pair 25 3) (pair 35 3) (pair 33 3)
            (pair 10 2) (pair 18 2) (pair 19 2) (pair 20 2) (pair 21 2) (pair 29 2)
        })
    })
    (rules 
        (start {
            (place Stack "Marker1" (handSite P1) count:2)
            (place Stack "Marker2" (handSite P2) count:2)
        })
        (play ("RollMove" (or (forEach Piece) (forEach Piece container:(mover)))))
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
The SpanRups is a graph theory game that uses concepts of spanning tree, and spanning caterpillar tree. A spanning tree T of an undirected graph G is a subgraph that is a tree which includes all of the vertices of G.  The spanning caterpillar tree C is a spanning tree in which all the vertices are within distance 1 from a central path.Starting of the game, the player can select the goal of the puzzle, which can be spanning tree or caterpillar tree. This game has two versions: addition and deletion version. At the addition version, the board graph is initially uncoloured. Players take turns to colour an uncoloured edge by a common colour. After colouring some edges, if the player makes a spanning tree (or caterpillar tree), he wins. At the other version, the game starts with all the same coloured edges. At each turn, a player chooses to remove the colour of a coloured edge. After removing some coloured edges, if the player makes his desired tree (spanning or caterpillar tree), he wins. The game is played on the Graph1. The players play on Addition version.
(game "SpanRups" 
    (players 1)
    (equipment { 
        (board <Version:type> use:Edge)
        (piece "Marker" Each)
    }) 
    
    (rules  	 
        <Play:play>
        (end 	
            <Version:result>
        )
    )
)

Construct a Ludii game based on the following description
Mylna is an alignment game played in Iceland. It is closely related to other games played on this board, such as Nine Men´s Morris.Played on a board of three concentric squares, with a line bisecting the perimeters of each square on each side, but not extending inside the perimeter of the central square. Play occurs on the intersections of the lines and the corners of the squares. Each player has nine pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. They cannot remove an opponent's piece that is in a three-in-a-row formation. Once all pieces are placed, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. The game is won when the opponent is reduced to two pieces. A player may also win by blocking their opponent from being able to move.
         
(game "Mylna"
    (players 2)
    (equipment {
        ("NineMensMorrisBoard")
        (piece "Marker" Each 
            ("StepToEmpty" Orthogonal (then ("ReplayIfLine3" Orthogonal)))
        )
        (hand Each)
    })
    (rules 
        (start (place "Marker" "Hand" count:9))
        phases:{
        (phase "Placement"
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal) 
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty))
                        (then ("ReplayIfLine3" Orthogonal))
                    ) 
                )
            )
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement"
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal) 
                    (forEach Piece)
                )
            )
        )
        }
        (end {
            ("HavingLessPiecesLoss" Next 2)
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
Madelinette is a game with uncertain history. It is similar to Asian blockade games, but has more pieces and playing spaces.Players move their pieces to an adjacent empty point. The goal is to block the other player from being able to move. 
(game "Madelinette" 
    (players 2) 
    (equipment { 
        (board 
            (add
                (remove 
                    ("AlquerqueGraph" 3 3)
                    vertices:{7 1} 
                )
                edges:{{0 1}}
            )
            use:Vertex
        ) 
        (piece "Counter" Each ("StepToEmpty"))
    }) 
    
    (rules 
        (start {
            (place "Counter1" (sites {"A1" "C2" "A3"}))
            (place "Counter2" (sites {"C1" "A2" "C3"}))
        })
        (play (forEach Piece)) 
        (end ("NoMoves" Loss)) 
    )
)

Construct a Ludii game based on the following description
'Um El-Bil is a two-row mancala-style board game played in Tunisia. Typically it is played in holes in the ground, with camel droppings, shells, or nuts as counters. It was rarely played by young girls. 2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction. The first player sows from the hole on their right. When the final counter lands in an occupied hole, the turn ends. When the final counter lands in an empty hole, that counter is captured. The player who captures the most counters wins. The game is played with 6 holes per row.
(game "Um el-Bil" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Column" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top)) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))		
        
        phases:{
        (phase "Opening"
            (play 
                (move Select 
                    (from (- ("Column") 1))
                    (then 
                        (sow 
                            if:(= (count at:(to)) 1)
                            apply:(fromTo 
                                (from (to)) 
                                (to (handSite Mover)) 
                                count:1
                            )
                        )
                    )
                )		
            )
            (nextPhase "Play")
        )
        (phase "Play"
            (play 
                (move Select 
                    (from 
                        (sites Mover) 
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (sow 
                            if:(= (count at:(to)) 1)
                            apply:(fromTo 
                                (from (to)) 
                                (to (handSite Mover)) 
                                count:1
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end ("MancalaByScoreWhen" (all Sites (sites Board) if:(is Empty (site)))))
    )
)

Construct a Ludii game based on the following description
Érhérhé is a two-row mancala-style board game played by the Mpongwe people in Gabon.2x6 board, with stores on either end. The store to a player's left belongs to them. Four counters in each hole. Players sow in an anti-clockwise direction from any hole in their row. When the final counter lands in a hole in the opponent's row, causing it to contain two or four counters, these are captured and put in the store. The player also captures the contents of any adjacent holes in the opponent's row if they also contain two or four counters. Play continues until one player has no counters in their row, their opponent capturing the remaining counters. A new round begins. Players fill up their holes with four counters, beginning from the left. Any excess counters are placed in that player's store; the final hole of the player with fewer counters may contain fewer than four counters. Any empty holes are out of play. Play continues as before. The game repeats in this fashion until one player has no counters remaining, their opponent is the winner. 
(game "Erherhe" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (map "LeftMost" {(pair P1 1) (pair P2 12)})
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start {
            (set Count 4 to:(sites Track))
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })		
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from
                            (sites Mover)
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then
                            (sow
                                apply:(if
                                    (and (is In (to) (sites Next))
                                        (or
                                            (= 2 (count at:(to)))
                                            (= 4 (count at:(to)))
                                        )
                                    )
                                    (and {
                                        (fromTo
                                            (from (to))
                                            (to (mapEntry Mover))
                                            count:(count at:(to))
                                        )
                                        (if ("WestHoleExist")
                                            (if 
                                                (or
                                                    (= 2 (count at:("WestHole")))
                                                    (= 4 (count at:("WestHole")))
                                                )
                                                (fromTo
                                                    (from ("WestHole"))
                                                    (to (mapEntry Mover))
                                                    count:(count at:("WestHole"))
                                                )
                                            )
                                        )
                                        (if ("EastHoleExist")
                                            (if 
                                                (or
                                                    (= 2 (count at:("EastHole")))
                                                    (= 4 (count at:("EastHole")))
                                                )
                                                (fromTo
                                                    (from ("EastHole"))
                                                    (to (mapEntry Mover))
                                                    count:(count at:("EastHole"))
                                                )
                                            )
                                        )
                                    })
                                )
                                skipIf:(not (is In (to) ("PlayableSites")))
                            )
                        )
                    )
                    }
                    (then
                        (if ("OneRowIsEmpty")
                            (and { 
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (mapEntry P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (mapEntry P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "Playable" All)
                            })
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard") {
                    (if (= 0 (count at:(mapEntry P1))) (result P2 Win))
                    (if (= 0 (count at:(mapEntry P2))) (result P1 Win))
                })
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                    (if (<= 4 (count at:(mapEntry Mover)))
                        (move
                            (from (mapEntry Mover))
                            (to "LeftMostEmpty")
                            count:4
                            (then (remember Value "Playable" (last To)))
                        )
                        (move
                            (from (mapEntry Mover))
                            (to "LeftMostEmpty")
                            count:(count at:(mapEntry Mover))
                            (then (remember Value "Playable" (last To)))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        
        }
    )
)

Construct a Ludii game based on the following description
Patok is a game played in Korea that is very similar to Japanese Go and Chinese Wei-Qi. There is a customary opening phase, in which players place pieces on certain spaces before beginning.19x19 intersecting lines. The central, as well as every third spot, in a square with the corners at the fourth point from the corners of the board, are marked. Players alternate turns placing a piece on the board on one of the marked spaces. When all of the marked spaces have been occupied, players may place a piece on any empty spot on the board. If a player surrounds one or more of the opponent's pieces orthogonally, they capture the opponent's pieces. The edge of the board can be included in such an enclosure. A group of pieces which contain two empty or more enclosures cannot be captured by the opponent. Pieces cannot be placed in an enclosure. When no further pieces can be placed, the players count the number of their pieces on the board and the number of empty spaces they enclose, and the player with the higher score wins. 
(game "Patok"
    (players 2)
    (equipment {
        (board (square 19) use:Vertex)
        (piece "Marker" Each)
        (regions "MarkedSites" (sites {"D4" "D7" "D10" "D13" "D16" "G4" "G16" "J4" "J10" "J16" "M4" "M16" "P4" "P7" "P10" "P13" "P16"}))
    })
    (rules
        phases:{
        (phase "MarkedPlacement"
            (play 
                (move Add
                    (to (intersection (sites Empty) (sites "MarkedSites")))
                )
            )
            (nextPhase (= 0 (count Sites in:(intersection (sites "MarkedSites") (sites Empty)))) "Playing")
        )
        (phase "Playing" 
            (play
                (do
                    (move Add
                        (to (sites Empty))
                        (then 
                            "CaptureSurroundedPiece"
                        )
                    )
                    ifAfterwards:("HasFreedom" Orthogonal)
                )
            )
            (end
                (if (no Moves Next)
                    (byScore {
                        (score P1 (+ (score P1) (size Territory P1))) 
                        (score P2 (+ (score P2) (size Territory P2)))
                    })
                )
            )
        )
        }
    )
)

Construct a Ludii game based on the following description
'Dogtown Clans' is a simplification of Double-move Situ and resembles Ki, as well. Differences from Ki include double moves, individual captures requiring a separate move without replacement, a last-able-to-move goal, preference for hex grid, and a parameter to define control.Difference from Situ is that control is based on adjacency.Like Situ, the game is based on the choice of placing one's own piece or removing an opponent's piece.It can be played on hex grids, square grids or square grids with diagonals.Placement must be on empty nodes that are not controlled by the opponent, while removals are taken from nodes that the mover controls. This control is determined by the difference in quantity of the two player's pieces that are adjacent to the given node. This difference is a parameter for the game, and when the value of the parameter is met or exceded, the player with the excess LoS pieces controls the site.The default for the parameter is 3.Structure of Play:
            There is no passing.
            Maroon chooses to remove up to two nodes of the board before passing to White. 
            Then White places an initial stone onto a remaining node on the board.
            
            After this play alternates, two turns per player, until one player cannot complete both turns. That player loses
            
            On each of the turns, the current player must either:
            - - place a stone on an empty node that the opponent does not control, or
            - - remove an opponent's stone that the current player controls.
            
            A player controls a node and any stone on it when the count of his stones that are adjacent to the node, exceed those of his opponent by the node-control value chosen for the game, or more. (default is 3)
            
            -- For example 4 is 3 greater than 1, so a node surrounded by 4 White and 1 Maroon is controlled by White if 3 was chosen as the game parameter (also if 1 or 2 were chosen).
            
        There are options for the board size and type, and the number of surplus stones needed to control a node. Order 2 board Hex N/N+2 grid w/even nodes, no center Highly tactical. Control a site with a surplus of 1 on lines of sight.
(game "Dogtown Clans"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Counter" P1)
        (piece "Counter" P2)
        (piece "X" Neutral)
        (piece "Counter" Neutral)
    })
    (rules
        (meta (passEnd NoEnd))
        (play
            (if
                (and
                    (= -1 (var "DoubleTurnPhase"))
                    (= 1 (mover))
                )
                
                (or
                    (move Pass)
                    (move Add
                        (piece "X0") 
                        (to (sites Empty))
                        (then
                            (if
                                (> 2 (count Pieces in:(sites Occupied by:Neutral)))
                                (moveAgain)
                            )
                        )
                    )
                )
                
                (or
                    {
                    (move Add
                        (to
                            (sites Empty)
                            if:(not ("IsControlledBy" Next (to)))
                        )
                        (then
                            (if
                                (= -1 (var "DoubleTurnPhase"))
                                (set Var "DoubleTurnPhase" 1)
                                ("MoveTwiceThenScore")
                            )
                        )
                    )
                    (move Remove 
                        (forEach
                            (sites Occupied by:Next)
                            if:("IsControlledBy" Mover (site)) 
                        )
                        (then ("MoveTwiceThenScore"))
                    )
                    }
                )
                (then
                    (if
                        (no Moves Next)
                        (and 
                            ("ScoreFor" Mover)
                            ("ScoreFor" Next) 
                        )
                    )
                )
            )
        )
        
        (end 
            (if 
                (no Moves Mover)
                (result Mover Loss) 
            )
        )
    )
)

Construct a Ludii game based on the following description
I is a two-row mancala-style board game played by the Dogon people of Mali. It is generally played by boys in the sand, using pebbles as counters.2x3-7 board. Four counters in each hole. Players sow counters from their side of the board in an anti-clockwise direction. When the final counter of a sowing lands in a hole containing one or two counters, making it now contain two or three, these are captured. Any adjacent holes with two or three counters are also captured. Single counters cannot be sown. When a player only has single counters in holes in their row, they pass. The player who captures the most counters wins. Each row has 3 holes.
(game "I" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 <Board:size> store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top))  
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play
            (move Select 
                (from 
                    (sites Mover) 
                    if:(> (count at:(from)) 1)
                )
                (then 
                    (sow 
                        apply:(if (or (= 2 (count at:(to))) (= 3 (count at:(to))))
                            (and {
                                (fromTo 
                                    (from (to)) 
                                    (to (handSite Mover)) 
                                    count:(count at:(to))
                                )
                                (if (!= (to) (ahead (to) E))
                                    (if (or (= 2 (count at:(ahead (to) E))) (= 3 (count at:(ahead (to) E))))
                                        (fromTo 
                                            (from (ahead (to) E)) 
                                            (to (handSite Mover)) 
                                            count:(count at:(ahead (to) E))
                                        )
                                    )
                                )
                                (if (!= (to) (ahead (to) W))
                                    (if (or (= 2 (count at:(ahead (to) W))) (= 3 (count at:(ahead (to) W))))
                                        (fromTo 
                                            (from (ahead (to) W)) 
                                            (to (handSite Mover)) 
                                            count:(count at:(ahead (to) W))
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (and (no Moves P1) (no Moves P2))))
    )
)

Construct a Ludii game based on the following description
Kiuthi is a two-row mancala-style board game played by the Kikuyu people of Kenya. It was documented in the early twentieth century by Louis Leakey. 2x5-10 holes (six is the most common), two stores on either end six counters in each hole. Play begins from any hole in a player's row, and counters can be sown in either direction. If sowing fails to reach a hole in the opponent's row, the player makes a second move from a loaded hole in the opposite direction, continuing to do so until they can sow in the opponent's row. If the last counter is sown in a loaded hole, the contents are lifted and sowing continues in the opposite direction. Play continues like this until the last counter lands in an empty hole. If the empty hole is in the opponent's row, play ends. If it lands in an empty hole in the player's row, the counters in the opponent's hole opposite it are placed in the store. If the next hole in the direction of sowing in the player's row is empty, the counters in the opponent's hole opposite that hole are also placed in the store. Single counters cannot be sown. Play continues until both players have only single counters in holes or all of the counters have been captured. These are then collected and placed in the store. If each player has the same number of counters, the game is a draw. If the number of counters is unequal, the player with fewer counters arranges them in their row however they wish. The opponent then matches this arrangement, placing any extras in the store. If the player has fewer than half of the original number of counters, the board is decreased in size by one hole. If less than a quarter, it is decreased by two holes, and if less than one eight, decreased by three holes. If in subsequent rounds a player regains more than one half/one quarter/one eighth of the original total, the board size is increased appropriately. Play continues until one player has all the counters. Each player has 5 holes.
(game "Kiuthi" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "TrackCCW" "1,E,N,W" loop:True)
            (track "TrackCW" <Board:CW> loop:True)
            }
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        
        (start {
            (set Count 6 to:(sites Track)) 
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or
                    (if (!= 2 (var "Direction"))
                        (move Select
                            (from
                                (if ("SameTurn")
                                    (if (= 1 (var "ReachOpponent"))
                                        (sites {(var "Replay")})
                                        (sites Mover)
                                    )
                                    (sites Mover)
                                )
                                if:(and (< 1 (count at:(from))) (is In (from) ("PlayableSites")))
                            )
                            (then
                                (if (!= 1 (var "OppositeDirection"))
                                    (sow
                                        "TrackCCW"
                                        apply:(if (!= 1 (var "ReachOpponent"))
                                            (if (is In (to) (sites Next))
                                                (if (< 1 (count at:(to)))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "ReachOpponent" 1)
                                                        (if (= 1 (var "OppositeDirection"))
                                                            (set Var "OppositeDirection" 0)
                                                            (set Var "OppositeDirection" 1)
                                                        )
                                                        (set Var "Direction" 1)
                                                    })
                                                    (and
                                                        (set Var "ReachOpponent" 0)
                                                        (set Var "Direction" 0)
                                                    )
                                                )
                                                (moveAgain)
                                            )
                                            (if (< 1 (count at:(to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Var "Replay" (to))
                                                    (if (= 1 (var "OppositeDirection"))
                                                        (set Var "OppositeDirection" 0)
                                                        (set Var "OppositeDirection" 1)
                                                    )
                                                    (set Var "Direction" 1)
                                                })
                                                (and {
                                                    (set Var "ReachOpponent" 0)
                                                    (set Var "OppositeDirection" 0)
                                                    (set Var "Direction" 0)
                                                    (if (is In (to) (sites Mover))
                                                        (if (is Occupied ("OppositePit" (to)))
                                                            (and
                                                                (fromTo
                                                                    (from ("OppositePit" (to)))
                                                                    (to (mapEntry Mover))
                                                                    count:(count at:("OppositePit" (to)))
                                                                )
                                                                (if (and (is Empty ("NextHole" (to) "TrackCCW" 1)) (is In ("NextHole" (to) "TrackCCW" 1) (sites Mover)))
                                                                    (if (is Occupied ("OppositePit" ("NextHole" (to) "TrackCCW" 1)))
                                                                        (fromTo
                                                                            (from ("OppositePit" ("NextHole" (to) "TrackCCW" 1)))
                                                                            (to (mapEntry Mover))
                                                                            count:(count at:("OppositePit" ("NextHole" (to) "TrackCCW" 1)))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                })
                                            )
                                        )
                                        skipIf:(not (is In (to) ("PlayableSites")))
                                    )
                                    (sow
                                        "TrackCW"
                                        apply:(if (!= 1 (var "ReachOpponent"))
                                            (if (is In (to) (sites Next))
                                                (if (< 1 (count at:(to)))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "ReachOpponent" 1)
                                                        (if (= 1 (var "OppositeDirection"))
                                                            (set Var "OppositeDirection" 0)
                                                            (set Var "OppositeDirection" 1)
                                                        )
                                                        (set Var "Direction" 1)
                                                    })
                                                    (and
                                                        (set Var "ReachOpponent" 0)
                                                        (set Var "Direction" 0)
                                                    )
                                                )
                                                (moveAgain)
                                            )
                                            (if (< 1 (count at:(to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Var "Replay" (to))
                                                    (if (= 1 (var "OppositeDirection"))
                                                        (set Var "OppositeDirection" 0)
                                                        (set Var "OppositeDirection" 1)
                                                    )
                                                    (set Var "Direction" 1)
                                                })
                                                (and {
                                                    (set Var "ReachOpponent" 0)
                                                    (set Var "OppositeDirection" 0)
                                                    (set Var "Direction" 0)
                                                    (if (is In (to) (sites Mover))
                                                        (if (is Occupied ("OppositePit" (to)))
                                                            (and
                                                                (fromTo
                                                                    (from ("OppositePit" (to)))
                                                                    (to (mapEntry Mover))
                                                                    count:(count at:("OppositePit" (to)))
                                                                )
                                                                (if (and (is Empty ("NextHole" (to) "TrackCW" 1)) (is In ("NextHole" (to) "TrackCW" 1) (sites Mover)))
                                                                    (if (is Occupied ("OppositePit" ("NextHole" (to) "TrackCW" 1)))
                                                                        (fromTo
                                                                            (from ("OppositePit" ("NextHole" (to) "TrackCW" 1)))
                                                                            (to (mapEntry Mover))
                                                                            count:(count at:("OppositePit" ("NextHole" (to) "TrackCW" 1)))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                })
                                            )
                                        )
                                        skipIf:(not (is In (to) ("PlayableSites")))
                                    )
                                )
                            )
                        )
                    )
                    (if (!= 1 (var "Direction"))
                        (move Select
                            (from
                                (if ("SameTurn")
                                    (if (= 1 (var "ReachOpponent"))
                                        (sites {(var "Replay")})
                                        (sites Mover)
                                    )
                                    (sites Mover)
                                )
                                if:(and (< 1 (count at:(from))) (is In (from) ("PlayableSites")))
                            )
                            (then
                                (if (!= 1 (var "OppositeDirection"))
                                    (sow
                                        "TrackCW"
                                        apply:(if (!= 1 (var "ReachOpponent"))
                                            (if (is In (to) (sites Next))
                                                (if (< 1 (count at:(to)))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "ReachOpponent" 1)
                                                        (if (= 1 (var "OppositeDirection"))
                                                            (set Var "OppositeDirection" 0)
                                                            (set Var "OppositeDirection" 1)
                                                        )
                                                        (set Var "Direction" 2)
                                                    })
                                                    (and
                                                        (set Var "ReachOpponent" 0)
                                                        (set Var "Direction" 0)
                                                    )
                                                )
                                                (moveAgain)
                                            )
                                            (if (< 1 (count at:(to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Var "Replay" (to))
                                                    (if (= 1 (var "OppositeDirection"))
                                                        (set Var "OppositeDirection" 0)
                                                        (set Var "OppositeDirection" 1)
                                                    )
                                                    (set Var "Direction" 2)
                                                })
                                                (and {
                                                    (set Var "ReachOpponent" 0)
                                                    (set Var "OppositeDirection" 0)
                                                    (set Var "Direction" 0)
                                                    (if (is In (to) (sites Mover))
                                                        (if (is Occupied ("OppositePit" (to)))
                                                            (and
                                                                (fromTo
                                                                    (from ("OppositePit" (to)))
                                                                    (to (mapEntry Mover))
                                                                    count:(count at:("OppositePit" (to)))
                                                                )
                                                                (if (and (is Empty ("NextHole" (to) "TrackCW" 1)) (is In ("NextHole" (to) "TrackCW" 1) (sites Mover)))
                                                                    (if (is Occupied ("OppositePit" ("NextHole" (to) "TrackCW" 1)))
                                                                        (fromTo
                                                                            (from ("OppositePit" ("NextHole" (to) "TrackCW" 1)))
                                                                            (to (mapEntry Mover))
                                                                            count:(count at:("OppositePit" ("NextHole" (to) "TrackCW" 1)))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                })
                                            )
                                        )
                                        skipIf:(not (is In (to) ("PlayableSites")))
                                    )
                                    (sow
                                        "TrackCCW"
                                        apply:(if (!= 1 (var "ReachOpponent"))
                                            (if (is In (to) (sites Next))
                                                (if (< 1 (count at:(to)))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "ReachOpponent" 1)
                                                        (if (= 1 (var "OppositeDirection"))
                                                            (set Var "OppositeDirection" 0)
                                                            (set Var "OppositeDirection" 1)
                                                        )
                                                        (set Var "Direction" 2)
                                                    })
                                                    (and
                                                        (set Var "ReachOpponent" 0)
                                                        (set Var "Direction" 0)
                                                    )
                                                )
                                                (moveAgain)
                                            )
                                            (if (< 1 (count at:(to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Var "Replay" (to))
                                                    (if (= 1 (var "OppositeDirection"))
                                                        (set Var "OppositeDirection" 0)
                                                        (set Var "OppositeDirection" 1)
                                                    )
                                                    (set Var "Direction" 2)
                                                })
                                                (and {
                                                    (set Var "ReachOpponent" 0)
                                                    (set Var "OppositeDirection" 0)
                                                    (set Var "Direction" 0)
                                                    (if (is In (to) (sites Mover))
                                                        (if (is Occupied ("OppositePit" (to)))
                                                            (and
                                                                (fromTo
                                                                    (from ("OppositePit" (to)))
                                                                    (to (mapEntry Mover))
                                                                    count:(count at:("OppositePit" (to)))
                                                                )
                                                                (if (and (is Empty ("NextHole" (to) "TrackCCW" 1)) (is In ("NextHole" (to) "TrackCCW" 1) (sites Mover)))
                                                                    (if (is Occupied ("OppositePit" ("NextHole" (to) "TrackCCW" 1)))
                                                                        (fromTo
                                                                            (from ("OppositePit" ("NextHole" (to) "TrackCCW" 1)))
                                                                            (to (mapEntry Mover))
                                                                            count:(count at:("OppositePit" ("NextHole" (to) "TrackCCW" 1)))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                })
                                            )
                                        )
                                        skipIf:(not (is In (to) ("PlayableSites")))
                                    )
                                )
                            )
                        )
                    )
                    (then
                        (if ("OnlySingleCounters")
                            (and { 
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (mapEntry P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (mapEntry P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "Playable" All)
                                (if (< ("NumCapture" P1) ("NumCapture" P2))
                                    (and
                                        (set NextPlayer (player 1))
                                        (if (< ("NumCapture" P1) (/ ("OriginalNumberCounters") 8))
                                            (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right) steps:3))
                                                (remember Value "Playable" (site))
                                            )
                                            (if (< ("NumCapture" P1) (/ ("OriginalNumberCounters") 4))
                                                (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right) steps:2))
                                                    (remember Value "Playable" (site))
                                                )
                                                (if (< ("NumCapture" P1) (/ ("OriginalNumberCounters") 2))
                                                    (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right)))
                                                        (remember Value "Playable" (site))
                                                    )
                                                    (forEach Site (union (sites Top) (sites Bottom))
                                                        (remember Value "Playable" (site))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (and
                                        (set NextPlayer (player 2))
                                        (if (< ("NumCapture" P2) (/ ("OriginalNumberCounters") 8))
                                            (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right) steps:3))
                                                (remember Value "Playable" (site))
                                            )
                                            (if (< ("NumCapture" P2) (/ ("OriginalNumberCounters") 4))
                                                (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right) steps:2))
                                                    (remember Value "Playable" (site))
                                                )
                                                (if (< ("NumCapture" P2) (/ ("OriginalNumberCounters") 2))
                                                    (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right)))
                                                        (remember Value "Playable" (site))
                                                    )
                                                    (forEach Site (union (sites Top) (sites Bottom))
                                                        (remember Value "Playable" (site))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count at:(mapEntry P1))) (result P2 Win))
                    (if (= 0 (count at:(mapEntry P2))) (result P1 Win))
                    (if (= (count at:(mapEntry P1)) (count at:(mapEntry P2))) (result Mover Draw))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (is Occupied (mapEntry Mover))
                    (forEach Value min:1 max:(count at:(mapEntry Mover))
                        (move
                            (from (mapEntry Mover))
                            (to (sites Mover) if:(is In (to) ("PlayableSites")))
                            count:(value)
                        )
                    )
                    (then
                        (if (is Occupied (mapEntry Mover))		
                            (moveAgain)
                            (forEach Site (sites Mover)
                                (if (is Occupied (site))
                                    (fromTo
                                        (from (mapEntry Next))
                                        (to ("OppositePit" (site)))
                                        count:(count at:(site))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (is Empty (mapEntry Mover)) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Mraha wa Bwe is a capturing game played in Comoros. The game is made on the ground and the pieces are gathered from what is available. Stones are often used, for example.5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on the board, leaving the central space empty. Once all the pieces have been placed, players alternate turns moving one space orthogonally to an empty space. An opponent's piece may be captured by hopping over it to an empty space immediately on the opposite side of it in an orthogonal direction. Multiple captures are allowed, and a player is allowed to land on a space already landed on during the chain of captures. Captures are not compulsory. A player wins when they capture all of their opponent's pieces or the opponent cannot move. 
(game "Mraha wa Bwe" 
    (players 2) 
    (equipment { 
        (board (square 5)) 
        (piece "Counter" Each)
        (hand Each)
    }) 
    
    (rules 
        (start (place "Counter" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover))
                    (to (difference (sites Empty) (sites Centre)))
                    (then (if ("NewTurn") (moveAgain)))
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Play")
        )
        (phase "Play"
            (play 
                (if "SameTurn"
                    (or
                        ("HopCounter" (last To)
                            (then ("ReplayIfCanMove" ("HopCounter" (last To)))) 
                        )
                        (move Pass)
                    )
                    (or 
                        (forEach Piece "Counter"
                            ("HopCounter" (from) 
                                (then ("ReplayIfCanMove" ("HopCounter" (last To)))) 
                            ) 
                        )
                        (forEach Piece "Counter" ("StepOrthogonalToEmpty"))
                    )
                )
            )
        )
        }
        
        (end (if (no Moves Mover) (result Mover Loss))) 
    )
)

Construct a Ludii game based on the following description
Laram Wali is a game with captures played in Mali. It is played on a cross-shaped board, on which pieces are placed and then a capturing phase begins.Cross-shaped board, with any number of squares in the arm with a central square, and a number of pieces per player equal to the number of spaces in two arms. Three squares in each arm with six pieces per player is common. Players alternate turns placing pieces on the board. Players may not place pieces in the central space. When the pieces are placed, players alternate turns move a piece to am empty adjacent square, or hopping over an adjacent opponent's piece or an unbroken line of opponent's pieces with an empty space behind it. The player who captures all of the opponent's pieces wins.
         The game is played on a cross board of arm size of 1.
(game "Laram Wali"
    (players 2)
    (equipment {
        ("CrossBoard" "ArmSize" (* 3 "ArmSize") use:Cell)
        (hand Each)
        (piece "Marker" Each
            (or
                ("StepOrthogonalToEmpty") 
                (move Hop 
                    Orthogonal
                    (between 
                        (range 1 "NumInitPiece")
                        if:("IsEnemyAt" (between)) 
                        (apply (remove (between)))
                    )
                    (to if:(is Empty (to)))
                )
            )
        )
    })
    (rules
        (start (place "Marker" "Hand" count:"NumInitPiece"))
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (difference (sites Empty) (expand (sites Centre) steps:(- (/ "ArmSize" 2) (if (is Even "ArmSize") 1 0)))))
                ) 
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("CaptureAll" Next))
    )	
)

Construct a Ludii game based on the following description
Main Chator is a capturing game played in Malaysia and Indonesia that is very similar to other games derived from Chaturanga. It involves special rules for castling and pawn promotion and a special move when the Rajah is first checked. Played on an 8x8 board with pieces with specialized moves. The pieces are as follows, and placed on the outer rank in the following order, starting from the left corner and moving in, with the placement mirrored on the right side (the Mautri is placed to the right of the Rajah): Tor (2): can move any number of spaces orthogonally; Kudah (2): moves in any direction, one space orthogonally with one space forward diagonally, jumping over any intervening pieces; Gajah (2): can move any number of spaces diagonally;  Rajah (1): can move one space orthogonally or diagonally; Mautri (1): can move any number of spaces orthogonally or diagonally; Bidah (8), placed in front of the other pieces: can move one space forward, or one space diagonally to capture. The Bidah are placed on the second file.  When first checked, the Rajah may move like a Kudah, or move two spaces in any direction. Players capture pieces by moving onto a space occupied by an opponent's piece. Castling may occur in two separate moves: the Tor moves next to the Rajah, and if the Rajah is checked, it may move to the other side of the Tor. Promotion of Bidahs occur when they reach the opposite edge of the board, but only immediately if they reach the Tor's square. Pawns reaching any other square must make two further moves before they can be promoted; the first must be a lateral orthogonal move, the second may be lateral orthogonal or diagonal. If the Rajah can be captured on the opponent's next turn, it is in check. The Rajah must not be in check at the end of the player's turn. If this is impossible, it is checkmate and the opponent wins. 
(game "Main Chator"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (piece "King_noCross"
            (or
                ("StepToNotFriend" ~
                    (then
                        (if (not ("KingMovedOrCheckedBefore" (last To)))
                            ("RememberKingMovedOrChecked" (last To))
                        )
                    )
                )		
                (if ("IsFirstCheck")
                    (or {
                        ("SlideCapture" ~
                            (between
                                (exact 2)
                            )
                        )
                        ("LeapCapture" "KnightWalk")
                        (if (is In (from) ("KingSites"))
                            (or
                                (if (and {
                                        (is Empty (ahead (from) steps:2 W))
                                        ("IsPieceAt" "Rook" Mover (ahead (from) W))
                                        (not ("RookMovedBefore" (ahead (from) W)))
                                    })
                                    (move
                                        (from)
                                        (to (ahead (from) steps:2 W))
                                    )
                                )
                                (if (and {
                                        (is Empty (ahead (from) steps:2 E))
                                        ("IsPieceAt" "Rook" Mover (ahead (from) E))
                                        (not ("RookMovedBefore" (ahead (from) E)))
                                    })
                                    (move
                                        (from)
                                        (to (ahead (from) steps:2 E))
                                    )
                                )
                            )
                        )
                        }
                    )
                )
            )
        )
        ("ChessRook" "Rook" ~
            (then
                (if (and 
                        (not ("RookMovedBefore" (last To)))
                        (not (is In (last To) ("SitesNextToKing")))
                    )
                    ("RememberRookMoved" (last To))
                )
            )
        )
        ("ChessBishop" "Bishop_noCross")
        ("ChessKnight" "Knight")
        (piece "Pawn"
            (if (= 1 (state at:(from)))
                ("StepToEmpty"
                    (directions {Rightward Leftward}) 
                    (then (set State at:(last To) 2))
                )
                (if (= 2 (state at:(from)))
                    ("StepToEmpty"
                        (directions {BR BL Rightward Leftward}) 
                        (then (promote (last To) (piece "Queen") Mover))
                    )
                    (or {
                        "StepForwardToEmpty" 
                        ("StepToEnemy" (directions {FR FL}))
                        }
                        (then
                            (if (is In (last To) (sites Mover "Promotion")) 
                                (if (is In (last To) (sites Corners)) 
                                    (promote (last To) (piece "Queen") Mover)
                                    (set State at:(last To) 1)
                                )
                            )
                        )
                    )	
                )
            )
        ) 
        ("ChessQueen" "Queen")
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"E1") (place "King_noCross1" coord:"D1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        (play 
            (do
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
                (then
                    (if ("IsInCheck" "King_noCross" Next)
                        (if (not ("KingMovedOrCheckedBefore" (where "King_noCross" Next)))
                            (and
                                ("RememberKingMovedOrChecked" (where "King_noCross" Next))
                                ("SetFirstCheck")
                            )
                        )
                    )
                )
            )
        )
        
        (end ("Checkmate" "King_noCross"))
    )
)

Construct a Ludii game based on the following description
A version of Chess where all pieces start in reserve.Same as standard Chess except:
            1. The board is initially empty and each player has the normal complement of 16 pieces in reserve.
            2. During a turn, a player must do one of three things:
            --- place a piece from in hand on an empty square on the board
            --- move a previously placed piece to an empty square
            --- move a previously placed piece onto a square occupied by an opposing piece, capturing it.
            3. Pawns may be entered on the first, second, third or fourth rows only.
            4. No en-passant, castling, or initial double-step pawn moves.
        5. A player's King must be placed before being allowed to make any capturing moves. A piece that controls the square that the enemy King occupies does not check it until the friendly King is entered onto the board. That is called 'quasi-check'. A player is under no compulsion to move out of quasi-check, and may even move into quasi-check. A player may legally move into quasi-check. Original
(game "Unachess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn" ~
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        
        ("ChessRook" "Rook" (then (set Counter)))
        ("ChessKing" "King" (then (set Counter)))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
        (regions "PawnPlacementRows" P1 (expand (sites Bottom) steps:3))
        (regions "PawnPlacementRows" P2 (expand (sites Top) steps:3))
        (hand Each size:6)
    }) 
    (rules 
        (start { 
            (place "Pawn1" (handSite P1 0) count:8)
            (place "Pawn2" (handSite P2 0) count:8)
            (place "Rook1" (handSite P1 1) count:2 state:1) (place "Knight1" (handSite P1 2) count:2) (place "Bishop1" (handSite P1 3) count:2) (place "Queen1" (handSite P1 4)) (place "King1" (handSite P1 5) state:1) 
            (place "Rook2" (handSite P2 1) count:2 state:1) (place "Knight2" (handSite P2 2) count:2) (place "Bishop2" (handSite P2 3) count:2) (place "Queen2" (handSite P2 4)) (place "King2" (handSite P2 5) state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or {
                        (do
                            (move 
                                (from (sites Occupied by:Mover container:"Hand" components:{"King" "Queen" "Rook" "Bishop" "Knight"})) 
                                (to (sites Empty))
                            ) 
                            <PlacementConditions:PlacementConditions>
                        )
                        ("PlacePawn" Mover)
                        (forEach Piece)
                        }
                    )
                    ifAfterwards:(or (not ("IsInCheck" "King" Mover)) (no Pieces Next "King" in:(sites Board)))
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Tsukkalavde is a capturing game played during the nineteenth century by the Sea Sámi people of Norway. It was often played by children and adults on winter evenings.5x5 intersecting lines, forming a grid. Diagonals in each of the quadrants. Twelve pieces per player, which begin on the points closest to the player, and the two points to the right of the center point. Players alternate turns moving a piece to an empty adjacent point along the lines of the board. A player may hop over an adjacent  opponent's pieces to an empty space immediately on the opposite side of it along the lines of the board to capture it. Multiple captures are allowed. A player wins if they capture all of their opponent's pieces, or reduces the opponent to one piece and blocks them from being able to move. 
(game "Tsukkalavde" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Marker" Each
            (or 
                ("HopSequenceCapture")
                ("StepToEmpty")
            )		
        ) 
    }) 
    (rules 
        (start { 
            (place "Marker1" (union (expand (sites Bottom)) (sites {"D3" "E3"})))
            (place "Marker2" (union (expand (sites Top)) (sites {"A3" "B3"})))
        })
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        (end (if (and (no Moves Next) (>= 1 (count Pieces Next))) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Dama is a word used for several capturing games throughout the world. This version is played on the Alquerque board in Comoros, and involves promotion to a long king and played on lines drawn on the ground.5x5 intersecting lines with diagonals drawn in the four quadrants. Twelve pieces per player. which begin on two rows closest to the player and the two spaces in the central row on the player's right. Players alternate turns moving a piece to an empty adjacent point on the board, along the lines in a forward or sideways direction. A player may capture an opponent's piece by hopping over it to an empty space on immediately on the opposite side of it along the lines on the board. Captures are compulsory, and if the opponent realizes that the player did not make a possible capture, the opponent immediately captures the player's piece that could have captured but didn't. Regular pieces cannot capture backwards. When a piece reaches the farthest row on the opposite side of the board from where they started, it is promoted to a king, which can move and capture any distance along the lines of the board. The player who captures all of their opponent's pieces wins. 
(game "Dama (Alquerque)" 
    ("TwoPlayersNorthSouth")
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Counter" Each
            (or
                ("HopCounter") 
                ("StepToEmpty" (directions {Forwards Rightward Leftward})
                    (then ("HasNotCaptured"))
                )
                (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
            )		
        )
        (piece "DoubleCounter" Each
            (or
                ("HopCaptureDistance" ~ ~ ~ (then ("HasCaptured")))
                (move Slide (then ("HasNotCaptured")))
            )		
        )
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    
    (rules 
        (start { 
            (place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"}) }))
            (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top)) }))
        })
        
        (play 
            (or
                (if ("DidNotCaptured")
                    (or
                        (if ("ShouldCapturedButMoved") 
                            ("HuffOnePieceOf" (last To))
                        )
                        ("HuffOnePieceOf" ("SitesWithPossibleCaptureInPreviousTurn"))
                    )
                )
                (do 
                    ("RememberSiteWithPossibleCapture") 
                    next:(forEach Piece)
                )
            )
        ) 
        
        (end ("CaptureAll" Mover)) 
    )
)

Construct a Ludii game based on the following description
Symple is an abstract strategy game in which two players strive to get as much area as possible with as few groups as possible.Players alternate making a move. White plays with the white stones and makes the first move, Black plays with the black stones. On his turn, a player may choose either a) to place a stone on the board without contact to other stones of his color in order to start a new group, or b) to grow all possible groups by one stone. When you grow your groups in this implementation, you place grey stones adjacent to your groups until each of your groups is adjacent to exactly one grey stone. At no point may a group of yours be adjacent to more than one grey stone. When your turn ends, all grey stones are replaced with stones of your color.
    
    For balancing, there is an extra rule: Black is allowed to grow all his groups and place a single stone as long as neither player has not yet grown any groups.
    
The game ends when the board is filled in. The score is the number of stones each player has on the board minus 'P' times the number of groups he has, where 'P' is en even number of 4 or higher (the Ludii implementation also allows 0 and 2 as values of 'P'). With an even penalty and an odd boardsize, draws are not possible. A size 7 board is currently selected A group penalty of 0 points is currently selected
(game "Symple"
    (players 2)
    (equipment {
        (board (square <Size>) use:Vertex)
        (piece "Marker" Each)
        (piece "Marker" Neutral)
    })
    (rules
        (play
            (if
                (= (count Moves) (var "MoveThatMustBePlant"))
                ("Plant")
                (if
                    (= 0 (count MovesThisTurn))
                    (or
                        ("Plant")
                        ("Grow")
                    )
                    ("Grow")
                )
            )
        )
        (end 
            (if (is Full) 
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Tablan is a game of captures played in southwest India. It is played similarly to Tab and similar games from North Africa and Southwest Asia, and they are probably related.4x12 board. Twelve pieces per player. Pieces begin in the outer rows of the board. Four sticks serve as dice, painted on one side and blank on the other. The throws are as follows: one blank side up = 2; two blank sides up = 0; three blank sides up = 0; four blank sides up = 8; four painted sides up = 12. Throws of 2, 8, and 12 give the player another throw. Players must use each throw to move a piece. They may only subdivide a throw in half to move two pieces, otherwise they must use one full throw to move a piece. The first move for each piece must be a throw of 2. This can be divided into two throws of 1 to move two pieces. Play moves from left to right in the player's home row, from right to left in the second row, left to right in the third row, and right to left in the opponent's home row. When a piece enters the opponent's home row, it can no longer move. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. A player may not land on the same space as another of the player's pieces. The player which fills up the most of the opponent's home row wins. 
(game "Tablan"
    (players 2)
    (equipment {
        (board (rectangle 4 12) 
            {
            (track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True)
            (track "Track2" "47,W,S1,E,S1,W,S1,E" P2 directed:True)
            }
            use:Vertex
        )
        (piece "Stick" Each
            (if (and (not (is In (from) (sites Next "Home"))) (!= 0 ("ThrowValue")))
                (or
                    (if (not ("PlayedHalfThrow"))
                        (move
                            (from 
                                (from)
                                if:(if ("ActivatedPiece" (from))
                                    True
                                    ("ThrowToActivate")
                                )	
                            )
                            (to 
                                ("SiteToMoveOnTrack" ("ThrowValue"))
                                if:(not ("IsFriendAt" (to)))
                                (apply "CaptureMove")
                            )
                            (then
                                (if (not ("ActivatedPiece" (last To)))
                                    ("ActivePiece" (last To))
                                )
                            )
                        )
                    )
                    (move
                        (from 
                            (from)
                            if:(if ("ActivatedPiece" (from))
                                True
                                ("ThrowToActivate")
                            )	
                        )
                        (to 
                            ("SiteToMoveOnTrack" (/ ("ThrowValue") 2))
                            if:(not ("IsFriendAt" (to)))
                            (apply "CaptureMove")
                        )
                        (then
                            (and
                                (if (not ("ActivatedPiece" (last To)))
                                    ("ActivePiece" (last To))
                                )
                                (if (not ("PlayedHalfThrow"))
                                    (and
                                        (set Var 1)
                                        (moveAgain)
                                    )
                                    (set Var 0)
                                )
                            )
                        )
                    )
                )
            )
        )
        (regions "Home" P1 (sites Bottom))
        (regions "Home" P2 (sites Top))
        (map "Throw" {(pair 0 8) (pair 1 0) (pair 2 0) (pair 3 2) (pair 4 12)})
        (dice d:2 from:0 num:4)
    })
    (rules 
        (start { 
            (place "Stick1" (sites Bottom))
            (place "Stick2" (sites Top))
        })
        (play 
            (do 
                (if (not ("PlayedHalfThrow")) (roll))
                next:(if (can Move (forEach Piece))
                    (forEach Piece)
                    (move Pass (then (set Var 0)))
                )
                (then
                    (if ("IsSpecialThrow")
                        (moveAgain)
                    )
                )
            )
        )
        (end 
            (if (and (= 0 ("NumPieceNotInEnemyHome" P1 P2)) (= 0 ("NumPieceNotInEnemyHome" P2 P1)))
                (byScore {
                    (score P1 ("PiecesOwnedOnEnemyHomedBy" P2 P1)) 
                    (score P2 ("PiecesOwnedOnEnemyHomedBy" P1 P2))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Sujiken (from Japanese \The puzzle consists of a triangular grid of cells containing digits from 1 to 9. The objective is to fill a grid with digits so that each cell contains a digit and no digit is repeated in any column, row and diagonal in any direction. Also, no digit occurs twice in any of the three larger 3 x 3 square regions and any of the three larger triangular regions enclosed by thick borders. 
(game "Sujiken" 
    (players 1) 
    (equipment { 
        (board 
            (remove
                (square 9) 
                cells:{
                73 74 75 76 77 78 79 80
                65 66 67 68 69 70 71
                57 58 59 60 61 62
                49 50 51 52 53
                41 42 43 44
                33 34 35
                25 26
                17
                }
            )
            (values Cell (range 1 9))
        ) 
        (regions {Columns Rows})
        (regions {39 43})
        (regions {35 40})
        (regions {30 36 41})
        (regions {24 31 37})
        (regions {17 25 32 38})
        (regions {9 18 26 33})
        (regions {0 10 19 27 34})
        (regions {1 11 20 28})
        (regions {2 12 21 29})
        (regions {3 13 22})
        (regions {4 14 23})
        (regions {5 15})
        (regions {6 16})
        (regions {9 1})
        (regions {17 10 2})
        (regions {24 18 11 3})
        (regions {30 25 19 12 4})
        (regions {35 31 26 20 13 5})
        (regions {39 36 32 27 21 14 6})
        (regions {42 40 37 33 28 22 15 7})
        (regions {44 43 41 38 34 29 23 16 8})
        (regions {0 1 2 9 10 11 17 18 19})
        (regions {3 4 5 12 13 14 20 21 22})
        (regions {6 7 8 15 16 23})
        (regions {24 25 26 30 31 32 35 36 37})
        (regions {27 28 29 33 34 38})
        (regions {39 40 41 42 43 44})
    }) 
    (rules
        (start <Challenge>)
        (play (satisfy (all Different)))
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
Awari is a two-row mancala-style board game played by the Ndyuka people of Suriname. It is closely similar to other games found throughout West Africa and the Caribbean.2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction. The hole from which sowing begins must remain empty throughout the player's turn. Captures are made when the last counter of a sowing fall into the opponent's row in a hole containing one or two counters (thus making two or three), capturing all of the counters in that hole. A continuous series of holes holding two or three counters behind it are also captured, provided the player's sowing caused them to contain this number. If a player has no counters in their holes, the opponent must play to place seeds in their row, if possible. The game ends when players have holes with only empty and single counters. The player who captured the most counters wins.  
(game "Awari" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (do 
                (move Select 
                    (from 
                        (sites Mover) 
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (sow 
                            if:(and 
                                (is In (to) (sites Next)) 
                                (or 
                                    (= (count at:(to)) 2) 
                                    (= (count at:(to)) 3)
                                )
                            ) 
                            apply:(fromTo 
                                (from (to)) 
                                (to (handSite Mover)) 
                                count:(count at:(to))
                            )
                            includeSelf:False
                            backtracking:True
                        )
                    )
                )
                ifAfterwards:(< 0 (count in:(sites Next)))
            )
        )
        
        (end ("MancalaByScoreWhen" (all Sites (sites Track) if:(<= (count at:(site)) 1))))
    )
)

Describe the mechanics of the following Ludii game
(game "Aj T'iwil"
    (players <Player:num>)
    (equipment {
        (board
            (rectangle 1 <Player:size>)
            <Player:tracks> 
            use:Edge
        )
        (regions "AllSites" (sites Board Vertex))
        (piece "Stick" Each
            (forEach Value (values Remembered "Throws")
                (if ("IsOffBoard" ("NextSiteOnTrack" (value) from:(from) "Track"))
                    (move 
                        (from (from) level:(level))
                        (to 
                            (handSite Mover)
                            (apply (forget Value "Throws" (value)))		
                        )
                    )
                    (move 
                        (from (from) level:(level)
                            if:(if (is In (from) (sites Hand Mover))
                                ("NoPieceOnBoard")
                                True
                            )
                        )
                        (to 
                            ("NextSiteOnTrack" (value) from:(from) "Track")
                            (apply (and ("CaptureMove") (forget Value "Throws" (value))))
                        )
                    )
                )
            )		
        )
        ("StickDice" 4)
        (hand Each)
    })
    (rules 
        (start {
            <Player:team>
        })
        
        phases:{
        (phase "ThrowPhase" 
            (play 
                ("RollMove"
                    (move Pass
                        (then
                            (if (not (no Pieces Mover))
                                (and {
                                    (if (!= 0 ("ThrowValue"))
                                        (do
                                            (remember Value "Throws" ("ThrowValue"))
                                            ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece)))
                                        )
                                    )
                                    (moveAgain)
                                    (if ("SameTurn") (set Pending))
                                })
                            )
                        )
                    )
                )	
            )
            (nextPhase (is Pending) "MovePhase")
        )
        (phase "MovePhase" 
            (play 
                (or (forEach Piece) (forEach Piece container:(mover))
                    (then
                        (if (< 0 (size Array (values Remembered "Throws")))
                            (moveAgain)
                        )
                    )
                )
            )
            (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase")
        )
        }
        
        (end ("CaptureAllTeam"))
    )
)
Aj T'iwil, \Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, and then back to home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the team's home field, the piece may be re-entered. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured and immediately leaved the board with the capture. Neither piece is reentered. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces.
         The game has 6 players.

Construct a Ludii game based on the following description
Schuster is a European Tables game played in Sweden by women. Played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. Each player's pieces begin in three stacks of five on the first point of their track. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If a player places all of their pieces on all of the points on the final six points of their side of the board, with three on each of the final three points, they win two points. Otherwise, they move into the opposite side of the board. When an opponent's piece lands on a point occupied by one of the player's pieces on the opponent's side of the board, the piece is removed from the board and must enter again. A player's pieces cannot be hit on their own side of the board. Once a player has brought all of their pieces into the final six points of the board, they may begin to bear off. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
             
(game "Schuster"
    (players 2)
    (equipment {
        ("BackgammonBoard" ("BackgammonTracksWithBar" End)) 
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die
                if:("DieNotUsed")
                (if ("IsEndTrack" ("NextSiteFrom" (from) (pips)))
                    (if ("AllPiecesInFinalQuadrant")
                        (move Remove (from))
                    )
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NotEnemyOrOnlyOne")
                            ("HittingCapture" (mapEntry "Bar" Next))
                        )
                    )
                )
                (then 
                    (and
                        ("ReplayNotAllDiceUsed")
                        (if ("SpecialWin")
                            (addScore Mover 2)
                        )
                    )
                )
            )		
        )
        (regions "FinalQuadrant" P1 (sites {20..25}))
        (regions "FinalQuadrant" P2 (sites {7..12}))
        (regions "OppositeSide" P1 (sites {25..20 18..13}))
        (regions "OppositeSide" P2 (sites {0..5 7..12}))
        (map "Bar" {(pair P1 6) (pair P2 19)})
    })
    (rules 
        (start { 
            (place Stack "Disc1" 12 count:15)
            (place Stack "Disc2" 25 count:15) 
        })
        (play ("RollEachNewTurnMove" (forEach Piece top:True)))
        
        (end {
            (if ("SpecialWin") (result Mover Win))
            ("EscapeWin")
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Oure Ngat" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 4 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Bottom)) 
        (regions "Home" P2 (sites Top)) 
        (hand Each)
    }) 
    (rules 
        (start (set Count 6 to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (sites Mover "Home") 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        origin:True
                        (then
                            (forEach Site (sites Track)
                                (if (is In (count at:(site)) (sites {2 4 6}))
                                    (fromTo 
                                        (from (site))
                                        (to (handSite Mover))
                                        count:(count at:(site))
                                    )
                                )
                            )
                        )
                    )
                )
            )		
        )
        
        (end ("MancalaByScoreWhen" (= 0 ("NumPiecesOnBoard"))))
    )
)
Ouré Ngat is a two-row mancala-style board game played in Senegal during the early twentieth century. It is not typically played on a board; instead, the counters are arranged in heaps on the ground.Two rows of four piles. Six counters in each pile. A player picks up the counters in one of her piles and sows them anti-clockwise, beginning in the place from which the pile originated. Any piles containing 2, 4, or 6 counters at the end of sowing are captured. Play continues until all of the counters have been captured. The player who captures the most counters wins. 

Construct a Ludii game based on the following description
This game, the name of which was unrecorded, is a game with leaping captures played in Ethiopia in the early twentieth century.5x5 intersecting lines, with diagonals in the four quadrants. Twelve pieces per player, arranged on the two rows closest to the player and the two spots in the central row to the player's right, leaving the central space empty. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece belonging to the opponent may be captured when a piece hops over it to an empty adjacent spot immediately on the opposite side of the piece, along the lines of the board. The player who reduces the opponent to five pieces wins. 
(game "Ethiopian Capture Game"
    (players 2)
    (equipment {
        ("AlquerqueBoard" 5 5)
        (piece "Marker" Each
            (or 
                ("HopCapture") 
                ("StepToEmpty")
            )
        )
    })
    (rules 
        (start { 
            (place "Marker1" (union {(expand (sites Bottom)) (sites {"D3" "E3"}) }))
            (place "Marker2" (union {(sites {"A3" "B3"}) (expand (sites Top)) }))
        })
        (play (forEach Piece))
        (end ("HavingLessPiecesLoss" Next 5))
    )
)

Construct a Ludii game based on the following description
Ishighän is a race game played by the Kel Ferwan people near Agadez, Niger. It is said to be typically for boys, but all ages participate in the game. Extra values are sometimes awarded to players on their throws when they grab a throwing stick that lands on its end, which is not modeled in this version.The board is drawn in the sand, with any large number of holes in a spiral pattern. The starting point is before the first hole in the outer ring of the spiral, and is made as a mound of sand; the goal is another mound of sand at the center of the spiral. Each player has one piece, which they place on the starting mound. Another piece, the hyena, also begins on the starting mound. Four throwing sticks, with a black side and a white side, used as dice. The values of the throws are as follows: four white sides = 20; three white sides = 5; two white sides = 0; one white sides = 9; all black sides = 80. Players throw, move, and throw again until they throw a 0. When a player reaches the goal, they then play as the hyena on their turn. When the hyena catches up to another player's piece, it drags the piece with it, until throwing a 0. When a 0 is thrown, the player moves back to the place where they were before the hyena dragged them, and must overtake the hyena in this turn. If the player cannot, they are removed from the game. If the player is overtaken by the hyena a second time, they are removed from the game.   The game has 2 players.
(game "Ishighan"
    (players <Player:number>)
    (equipment {
        (board 
            (spiral turns:5 sites:86) 
            {
            (track "Track" {86..0} directed:True)
            }
            use:Vertex
        )
        ("StickDice" 4)
        (map "Throw" {(pair 0 20) (pair 1 5) (pair 2 0) (pair 3 9) (pair 4 80)})
        (piece "Stick" Each
            (if ("IsOffBoard" ("SiteToMoveOnTrack" "Track" ("ThrowValue")))
                (move
                    (from (from) level:(level))
                    (to 0)
                    (then
                        (if (= 1 (value Player Mover))
                            (forEach Site (sites Track "Track" from:(last From) to:(last To)) 
                                (forEach Level (site) FromTop
                                    (if ("IsPieceAt" "Hyena" Neutral (site) level:(level))
                                        (set Value Mover 2)
                                    )
                                )
                            )
                        )
                    )
                )
                (move
                    (from (from) level:(level))
                    (to
                        ("SiteToMoveOnTrack" "Track" ("ThrowValue"))
                        if:True
                    )
                    (then
                        (if (= 1 (value Player Mover))
                            (forEach Site (sites Track "Track" from:(last From) to:(last To)) 
                                (forEach Level (site) FromTop
                                    (if ("IsPieceAt" "Hyena" Neutral (site) level:(level))
                                        (set Value Mover 2)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            maxState:85
        )
        (piece "Hyena" Neutral)
        (hand P1)
    })
    (rules 
        (start {
            (place Stack items:<Player:init> (handSite P1))
            (place Stack "Hyena0" (handSite P1))
        })
        
        (play 
            ("RollMove"
                (if (= ("Center") (where "Stick" Mover))
                    (if ("NotThrow0") 
                        ("MoveHyena")
                        (move Pass 
                            (then 
                                (forEach Site (sites Board)
                                    (forEach Level (site) FromTop
                                        (if (!= 0 (state at:(site) level:(level)))
                                            (if (< 0 (value Player (who at:(site) level:(level))))
                                                (remove (site) level:(level))
                                                (fromTo
                                                    (from (site) level:(level))
                                                    (to (state at:(site) level:(level))
                                                        (apply
                                                            (and	
                                                                (set State at:(site) level:(level) 0)
                                                                (set Value (player (who at:(site) level:(level))) 1)
                                                            )
                                                        )		
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (if ("NotThrow0") 
                        (or (forEach Piece) (forEach Piece container:1))
                        (move Pass
                            (then 
                                (if (= 1 (value Player Mover))
                                    (remove (where "Stick" Mover) level:(where Level "Stick" Neutral at:(where "Stick" Mover)))
                                )
                            )
                        )
                    )
                )
                (then (if ("NotThrow0") (moveAgain)))
            )
        )
        (end {
            (forEach Player
                if:(no Pieces Player) 
                (result Player Loss)
            )
            (forEach Player
                if:("HyenaPhaseDone")
                (result Player Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
A variation of the game of chess invented by the former World Chess Champion Bobby Fischer.Before the game, a starting position is randomly determined and set up, subject to certain requirements. White's pieces (not pawns) are placed randomly on the first rank, following two rules: The bishops must be placed on opposite-color squares. The king must be placed on a square between the rooks. Black's pieces are placed equal-and-opposite to White's pieces. (For example, if the white king is randomly determined to start on f1, then the black king is placed on f8.) Pawns are placed on the players' second ranks as in classical chess. After setup, the game is played the same as classical chess in all respects. 
(game "Fischer Random Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
                )
                "EnPassant"
            )
            (then
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Rook1" (sites Random (difference (sites Bottom) (expand (sites Right)))) state:1)
            (place "King1" (sites Random (difference (intersection {(sites Bottom) (expand (sites Occupied by:Mover) steps:8 E) (sites Empty)}) (sites Right))) state:1)
            (place "Rook1" (sites Random (intersection {(sites Bottom) (expand (sites Occupied by:Mover component:"King") steps:8 E) (sites Empty)})) state:1)
            (place "Bishop1" (sites Random (intersection {(sites Bottom) (sites Empty) (sites Phase 0)})))
            (place "Bishop1" (sites Random (intersection {(sites Bottom) (sites Empty) (sites Phase 1)})))
            (place "Knight1" (sites Random (intersection (sites Bottom) (sites Empty)) num:2))
            (place "Queen1" (sites Random (intersection (sites Bottom) (sites Empty))))
            (place "Pawn1" (sites Row 1))
            
            (place "Rook2"
                (forEach (sites Top)
                    if:(= (id "Rook1") (what at:(ahead (site) steps:7 S)))
                )
                state:1
            )
            (place "Bishop2"
                (forEach (sites Top)
                    if:(= (id "Bishop1") (what at:(ahead (site) steps:7 S)))
                )
            )
            (place "Knight2"
                (forEach (sites Top)
                    if:(= (id "Knight1") (what at:(ahead (site) steps:7 S)))
                )
            )
            (place "Queen2"
                (forEach (sites Top)
                    if:(= (id "Queen1") (what at:(ahead (site) steps:7 S)))
                )
            )
            (place "King2"
                (forEach (sites Top)
                    if:(= (id "King1") (what at:(ahead (site) steps:7 S)))
                )
                state:1
            )
            (place "Pawn2" (sites Row 6))
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        (if (and 
                                ("HasNeverMoved" (where "King" Mover))
                                (not ("IsInCheck" "King" Mover)) 
                            )
                            (if (is Mover P1) 
                                (forEach Site (sites Occupied by:Mover component:"Rook")
                                    (if ("HasNeverMoved" (site)) 
                                        (if (< (column of:(site)) (column of:(where "King" Mover))) 
                                            (if (or
                                                    (can Move 
                                                        (slide 
                                                            (from (site)) 
                                                            (if (< (column of:(site)) (column of:(coord "D1")))
                                                                E
                                                                W
                                                            ) 
                                                            (between 
                                                                (exact (count Steps (coord "D1") (site))) 
                                                                if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))
                                                            )
                                                            (to 
                                                                if:True
                                                                (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) ("PieceHasMoved" (from)))
                                                            )
                                                        )
                                                    )
                                                    (= (site) (coord "D1"))
                                                )
                                                (if (= (where "King" Mover) (coord "C1"))
                                                    (do (set Var "RookToMove" (site)) next:(move Select (from (where "King" Mover))))
                                                    (move
                                                        Slide 
                                                        (from (where "King" Mover)) 
                                                        (if (< (column of:(where "King" Mover)) (column of:(coord "C1")))
                                                            E
                                                            W
                                                        ) 
                                                        (between 
                                                            (exact (count Steps (coord "C1") (where "King" Mover))) 
                                                            if:(and 
                                                                (or (is Empty (to)) (= (to) (site)))
                                                                (not ("IsInCheck" "King" Mover at:(to)))
                                                            ) 
                                                        ) 
                                                        (to 
                                                            if:True
                                                            (apply 
                                                                if:(or (= (to) (site)) (is Empty (to)))
                                                                (and
                                                                    ("PieceHasMoved" (from))
                                                                    (set Var "RookToMove" (site))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (then
                                                        (if ("IsPieceAt" "Rook" Mover (var "RookToMove"))
                                                            (slide 
                                                                (from (var "RookToMove")) 
                                                                (if (< (column of:(var "RookToMove")) (column of:(coord "D1")))
                                                                    E
                                                                    W
                                                                ) 
                                                                (between 
                                                                    (exact (count Steps (coord "D1") (var "RookToMove"))) 
                                                                    if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))
                                                                )
                                                                (to 
                                                                    if:True
                                                                    (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) ("PieceHasMoved" (from)))
                                                                )
                                                            )
                                                            (add (piece (id "Rook" Mover)) (to (coord "D1")))
                                                        )
                                                    )
                                                )
                                            )
                                            (if (or
                                                    (can Move 
                                                        (slide 
                                                            (from (site)) 
                                                            (if (< (column of:(site)) (column of:(coord "F1")))
                                                                E
                                                                W
                                                            ) 
                                                            (between 
                                                                (exact (count Steps (coord "F1") (site))) 
                                                                if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))
                                                            )
                                                            (to 
                                                                if:True
                                                                (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) ("PieceHasMoved" (from)))
                                                            )
                                                        )
                                                    )
                                                    (= (site) (coord "F1"))
                                                )
                                                (if (= (where "King" Mover) (coord "G1"))
                                                    (do (set Var "RookToMove" (site)) next:(move Select (from (where "King" Mover))))
                                                    (move
                                                        Slide 
                                                        (from (where "King" Mover)) 
                                                        (if (< (column of:(where "King" Mover)) (column of:(coord "G1")))
                                                            E
                                                            W
                                                        ) 
                                                        (between 
                                                            (exact (count Steps (coord "G1") (where "King" Mover))) 
                                                            if:(and 
                                                                (or (is Empty (to)) (= (to) (site)))
                                                                (not ("IsInCheck" "King" Mover at:(to)))
                                                            ) 
                                                        ) 
                                                        (to 
                                                            if:True
                                                            (apply 
                                                                if:(or (= (to) (site)) (is Empty (to)))
                                                                (and
                                                                    ("PieceHasMoved" (from))
                                                                    (set Var "RookToMove" (site))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (then
                                                        (if ("IsPieceAt" "Rook" Mover (var "RookToMove"))
                                                            (slide 
                                                                (from (var "RookToMove")) 
                                                                (if (< (column of:(var "RookToMove")) (column of:(coord "F1")))
                                                                    E
                                                                    W
                                                                ) 
                                                                (between 
                                                                    (exact (count Steps (coord "F1") (var "RookToMove"))) 
                                                                    if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))
                                                                )
                                                                (to 
                                                                    if:True
                                                                    (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) ("PieceHasMoved" (from)))
                                                                )
                                                            )	
                                                            
                                                            (add (piece (id "Rook" Mover)) (to (coord "F1")))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (forEach Site (sites Occupied by:Mover component:"Rook")
                                    (if ("HasNeverMoved" (site)) 
                                        (if (> (column of:(site)) (column of:(where "King" Mover))) 
                                            (if (or
                                                    (can Move 
                                                        (slide 
                                                            (from (site)) 
                                                            (if (< (column of:(site)) (column of:(coord "F8")))
                                                                E
                                                                W
                                                            ) 
                                                            (between 
                                                                (exact (count Steps (coord "F8") (site))) 
                                                                if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))
                                                            )
                                                            (to 
                                                                if:True
                                                                (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) ("PieceHasMoved" (from)))
                                                            )
                                                        )
                                                    )
                                                    (= (site) (coord "F8"))
                                                )
                                                (if (= (where "King" Mover) (coord "G8"))
                                                    (do (set Var "RookToMove" (site)) next:(move Select (from (where "King" Mover))))
                                                    (move
                                                        Slide 
                                                        (from (where "King" Mover)) 
                                                        (if (< (column of:(where "King" Mover)) (column of:(coord "G8")))
                                                            E
                                                            W
                                                        ) 
                                                        (between 
                                                            (exact (count Steps (coord "G8") (where "King" Mover))) 
                                                            if:(and 
                                                                (or (is Empty (to)) (= (to) (site)))
                                                                (not ("IsInCheck" "King" Mover at:(to)))
                                                            ) 
                                                        ) 
                                                        (to 
                                                            if:True
                                                            (apply
                                                                if:(or (= (to) (site)) (is Empty (to)))
                                                                (and
                                                                    ("PieceHasMoved" (from))
                                                                    (set Var "RookToMove" (site))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (then
                                                        (if ("IsPieceAt" "Rook" Mover (var "RookToMove"))
                                                            (slide 
                                                                (from (var "RookToMove")) 
                                                                (if (< (column of:(var "RookToMove")) (column of:(coord "F8")))
                                                                    E
                                                                    W
                                                                ) 
                                                                (between 
                                                                    (exact (count Steps (coord "F8") (var "RookToMove"))) 
                                                                    if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))
                                                                )
                                                                (to 
                                                                    if:True
                                                                    (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) ("PieceHasMoved" (from)))
                                                                )
                                                            )
                                                            (add (piece (id "Rook" Mover)) (to (coord "F8")))
                                                        )
                                                    )
                                                )
                                            )
                                            (if (or
                                                    (can Move 
                                                        (slide 
                                                            (from (site)) 
                                                            (if (< (column of:(site)) (column of:(coord "D8")))
                                                                E
                                                                W
                                                            ) 
                                                            (between 
                                                                (exact (count Steps (coord "D8") (site))) 
                                                                if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))
                                                            )
                                                            (to 
                                                                if:True
                                                                (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) ("PieceHasMoved" (from)))
                                                            )
                                                        )
                                                    )
                                                    (= (site) (coord "D8"))
                                                )
                                                (if (= (where "King" Mover) (coord "C8"))
                                                    (do (set Var "RookToMove" (site)) next:(move Select (from (where "King" Mover))))
                                                    (move
                                                        Slide 
                                                        (from (where "King" Mover)) 
                                                        (if (< (column of:(where "King" Mover)) (column of:(coord "C8")))
                                                            E
                                                            W
                                                        ) 
                                                        (between 
                                                            (exact (count Steps (coord "C8") (where "King" Mover))) 
                                                            if:(and 
                                                                (or (is Empty (to)) (= (to) (site)))
                                                                (not ("IsInCheck" "King" Mover at:(to)))
                                                            ) 
                                                        ) 
                                                        (to 
                                                            if:True
                                                            (apply
                                                                if:(or (= (to) (site)) (is Empty (to)))
                                                                (and
                                                                    ("PieceHasMoved" (from))
                                                                    (set Var "RookToMove" (site))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (then
                                                        (if ("IsPieceAt" "Rook" Mover (var "RookToMove"))
                                                            (slide 
                                                                (from (var "RookToMove")) 
                                                                (if (< (column of:(var "RookToMove")) (column of:(coord "D8")))
                                                                    E
                                                                    W
                                                                ) 
                                                                (between 
                                                                    (exact (count Steps (coord "D8") (var "RookToMove"))) 
                                                                    if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))
                                                                )
                                                                (to 
                                                                    if:True
                                                                    (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) ("PieceHasMoved" (from)))
                                                                )
                                                            )	
                                                            
                                                            (add (piece (id "Rook" Mover)) (to (coord "D8")))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Tennessee Waltz is a game of making and breaking couples.
                It was designed as a tactical game that involves the whole board.
                On large boards there are some territorial aspects.
                
            First presented for Hex grids. Later, a square grid version was added. Small Board (Hex 3 / Limping 2,3 / Square 4) Hex Board
(game "Tennessee Waltz" 
        (players 2)
        (equipment
            {
            (board <BoardShape:gridType> use:Vertex)
            (hand Each size:1)
            (piece "Disc" Each) 
            }
        )
        (rules
            (play
                (or
                    {
                    ("PassingIsAllowedAfterFirstPairScores")
                    (move Add (to (sites Empty) if:(not ("IsAPairOfAt" Mover (to)))))
                    (do
                        (set Var "StartTurnEnemy" ("CurrentEnemyCount"))
                        next:(do
                            (move Select
                                (from (sites Empty) if:("IsAPairOfAt" Mover (from)))
                                (to (sites Around (from) <BoardShape:sashayDirections> )) 
                                (then
                                    (and
                                        "RecordTheSitesInvolvedInTheMove"
                                        (add (piece (id "Disc" Mover)) (to (last From))
                                            (then ("PushConsquences4ThePair"))
                            ))))
                            ifAfterwards:(and ("PairHasStayedOnBoard") ("NoEnemyWasPushedOff"))
                    ))
                    }
                    (then
                        (and
                            ("ShiftTokenFromToAndScore" Next Mover)
                            ("ShiftTokenFromToAndScore" Mover Next)
            ))))
            (end 
                (if
                    (or
                        "IsWinningCondition"
                        (all Passed)
                    )
                    (byScore)
    ))))

Describe the mechanics of the following Ludii game
(game "Reversi" 
    (players 2) 
    (equipment { 
        (board (square <Board:size>))
        (piece "Disc" Neutral (flips 1 2))
    }) 
    (rules 
        
        <Rules:start> 
        
        phases:{ 
        <Rules:play>
        (phase "Playing" 
            (play (forEach Site 
                    (sites Empty)
                    (append 
                        "ReverseBoundedPieces" 
                        (then
                            (and
                                (set Score 
                                    P1 
                                    (count Sites in:(sites State 1))
                                )
                                (set Score 
                                    P2 
                                    (count Sites in:(sites State 2))
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end
            (if (all Passed)
                (byScore)
            )
        )
    )
)
Reversi is a game purportedly invented in the early nineteenth century by either Lewis Waterman or John W. Mollett, but may actually be an older game. It is currently sold and marketed as Othello worldwide.Reversi is played on an 8x8 board. Pieces are double-sided, with each side distinct in some way from the other. Each side designates ownership of that pieces to a certain player when face-up. Play begins with the players taking turns placing pieces into the central four squares until they are full. Then players may place their pieces next to an opponent's piece, a long as a straight line can be drawn between the new piece and an existing piece belonging to that player that goes through the opponent's piece. The opponent's pieces between the new piece and the old piece are then flipped and now belong to the player who just played. If a player cannot make a legal move, they pass. Play continues until the board is full or neither player cannot make a legal move. The player with the most pieces on the board wins. The pieces are placed on the board. The board is a square board of size 4x4.

Construct a Ludii game based on the following description
Qelat is a two-row mancala-style board game that is played in western Eritrea. It is very similar to the Gabata game from Shoa in Ethiopia, which is one of the more widely played Gabata games in the region.2x6 board. Play begins with four counters in each hole. A player picks up the contents of any of their holes and sowing them in an anti-clockwise direction, picking up the contents of the last hole in which his counters fall, and continuing sowing. This continues until the last counter falls in an empty hole. Then it is the other player's turn. A hole is captured when the last ball is dropped into an opponent's hole containing three counters, making it four. A player cannot then take from one of these holes that they have captured. Therefore, the player cannot begin a turn from their own captured hole nor can they continue sowing from it if their last counter falls into it. If the last counter of a sowing falls into an opponent's captured hole, one of those counters are removed from the board and placed in the store, and the sowing continues with the contents of any of the player's holes. Ownership of a hole continues even if it becomes empty. When a player cannot move (i.e., there are no counters in their holes except any that are in captured holes), the opponent continues to move until the player is able to move. Play continues until all counters are either placed in the store or in captured holes and thus cannot be moved. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra they draw lots to see who gets an extra hole. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes. 
(game "Qelat"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightMost" {(pair P1 5) (pair P2 6)})
    }) 
    (rules 
        (start {
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
            (set Count 4 to:(sites Track)) 
        })
        
        phases:{
        (phase "Sowing" 
            (play
                (or {
                    (move Select
                        (from 
                            (if (and ("SameTurn") (= 1 (var "ContinueSowing")))
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))
                        )
                        (then
                            (sow
                                "TrackCCW"
                                apply:(if (and { 
                                        (= 0 (state at:(to))) 
                                        (= 4 (count at:(to)))
                                        (is In (to) ("OpponentOwnedHoles"))
                                    })
                                    (set State at:(to) (mover))
                                    (if (< 1 (count at:(to)))
                                        (if (= 0 (state at:(to)))
                                            (and {
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                                (set Var "ContinueSowing" 1)
                                            })
                                            (if (!= (mover) (state at:(to)))
                                                (and {
                                                    (fromTo
                                                        (from (to))
                                                        (to (handSite Mover))
                                                        count:(min 2 (count at:(to)))
                                                    )
                                                    (set State at:(to) (state at:(to)))
                                                    (moveAgain)
                                                    (set Var "ContinueSowing" 0)
                                                })
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OnlyPiecesInMarked")
                            (and { 
                                (forEach Site ("SitesMarkedBy" 1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site ("SitesMarkedBy" 2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("RightMostEmpty"))
                        count:4
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 4 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 3 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("RightMostEmpty"))
                                                count:3
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("RightMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("RightMostEmpty"))
                                        })
                                        (if (= 2 (count Cell at:(handSite Mover)))
                                            (and {
                                                (fromTo 
                                                    (from (handSite Mover))
                                                    (to ("RightMostEmpty"))
                                                    count:2
                                                )
                                                (fromTo 
                                                    (from (handSite Next))
                                                    (to ("RightMostEmpty"))
                                                    count:2
                                                )
                                                ("RememberOwnedHolesRandom" ("RightMostEmpty"))
                                            })
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        
        }
    )
)

Construct a Ludii game based on the following description
Crossline is a mathematical game published in the october 2009 issue of Games Magazine. It's a pencil and paper game for two players.Players begin by drawing a circle with ten dots evenly spaced around it (the spacing can be approximate). The first player starts by drawing a straight line connecting any two dots that are not adjacent. After that, each player in turns draws a straight line that connects any two dots and that crosses exactly one (and only one) previously drawn line. The player who draws the last legal line is the winner. 
(game "Crossline" 
    (players 2)
    (equipment { 
        (board 
            (graph
                vertices:{ {7 0.5} {12 2} {14.5 6} {14.5 10} {12 14} {7 15.5} {3 14} {0 10} {0 6} {3 2}}
                edges:{{0 1} {1 2} {2 3} {3 4} {4 5} {5 6} {6 7} {7 8} {8 9} {9 0}
                {0 2} {0 3} {0 4} {0 5} {0 6} {0 7} {0 8}
                {1 3} {1 4} {1 5} {1 6} {1 7} {1 8} {1 9}
                {2 4} {2 5} {2 6} {2 7} {2 8} {2 9} 
                {3 5} {3 6} {3 7} {3 8} {3 9}
                {4 6} {4 7} {4 8} {4 9}
                {5 7} {5 8} {5 9} {6 8} {6 9}
                {7 9}}
            )
        use:Edge) 
        (piece "Marker" Each) 
        (piece "Disc" Shared)
    }) 
    
    (rules 
        (start
            (set Shared Edge (sites {0..9}))      
        ) 
        phases:{
        (phase "Init" P1 
            (play 
                (move Add 
                    (to Edge (sites Empty Edge))	     	
                )
            )
            (nextPhase "Cross") 
        )
        
        (phase "Cross" P1 
            (play
                (do 
                    (move Add 
                        (to Edge (sites Empty Edge))   				
                    )
                    ifAfterwards:"CrossLine"
                )
            )	   
        )
        (phase "Continue" P2 
            (play
                (do 
                    (move Add 
                        (to Edge (sites Empty Edge))   				
                    )
                    ifAfterwards:"CrossLine"
                )
            )	   
        )
        
        } 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Place pieces to connect all three board sides.Players take turns placing two pieces of their colour on empty cells. White places only one stone on their first turn. A player wins by connecting all three board sides with a connected group of their pieces. Played on a size 3 board. The first player to connect all three sides wins.
(game "Master Y" 
    (players 2) 
    (equipment { 
        (board (hex Triangle <Board>)) 
        (piece "Disc")
    }) 
    (rules 
        
        phases:{
        (phase "Opening" P1 
            (play (move Add (to (sites Empty))))
            (nextPhase "Playing")
        )
        (phase "Playing" 
            (play 
                (move Add (to (sites Empty))
                    (then 
                        (if (= 0 (count MovesThisTurn)) 
                            (moveAgain)
                        )
                    )
                ) 
            )
        )
        }
        (end 
            (if 
                (is Connected 3 Sides) 
                (result Mover <Result>) 
            ) 
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Tides" 
    (players 2) 
    (equipment { 
        (board (square 5))
        (piece "Marker" Each 
            (or 
                ("HopSequenceCapture")
                ("StepToEmpty")
            )
        )
        (hand Each)
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover))
                    (to (difference (sites Board) (centrePoint)) if:(is Empty (to)))
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Move")
        )
        (phase "Move"
            (play 
                (if "SameTurn"
                    (or
                        ("HopSequenceCaptureAgain")
                        (move Pass)
                    )
                    (forEach Piece)
                )
            )
            (end ("CaptureAll" Next))
        )
        }
    )
)
Tides is a capturing game played by the Tuareg people in the Haggar region of Algeria. The game is usually played in the sand, with stones and camel droppings used as pieces.5x5 board. Twelve pieces per player. Players alternate turns placing a piece on the board, leaving the central space empty. Once all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent space in an orthogonal or diagonal direction. A player may capture an opponent's piece adjacent to one of their own by hopping over it to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of their opponent's pieces wins. 

Construct a Ludii game based on the following description
Kulaochal is a hunt game played by the Ho people of India during the early twentieth century. It was said to sometimes take hours when played by skilled players. 5x5 intersecting lines, with diagonals drawn in each quadrant. One player plays as four tigers, places on the four corners of the board. The other player plays as twenty goats, which are placed on the remaining points, leaving the central point open. Players alternate turns moving a piece to an empty adjacent point along the lines. The tigers may capture a goat by hopping over it to an empty adjacent spot immediately on the opposite side of the goat along the lines. The tigers win when they capture all of the goats; the goats win by blocking the tigers from being able to move.  
(game "Kulaochal" 
    (players 2)
    (equipment { 
        ("AlquerqueBoard" 5 5) 
        (piece "Tiger" P1 (or ("StepToEmpty") ("HopCapture")))
        (piece "Goat" P2 ("StepToEmpty"))
    }) 
    
    (rules 
        (start { 
            (place "Tiger1" (sites Corners))
            (place "Goat2" (difference (sites Board) (union (sites Corners) (sites Centre))))
        })
        
        (play (forEach Piece)) 
        
        (end ("NoMovesP1NoPiecesP2"))
    )
)

Construct a Ludii game based on the following description
Shatr ikh Padan is a game from nineteenth century India that was described by Lala Raja Babu Sahib, Superintendent of the Palace Games Department of Patiala.. It is played  with only the Shah and eight Pawns.8x8 board. Two players. Pieces and movement are as follows: King x1, placed on the fifth space from the left on one edge of the board: Moves one space orthogonally or diagonally. Pawns x8, arranged along the row in front of the king: moves one space forward orthogonally or one space forward diagonally to capture. The opponent's pieces are placed in the same position on the opposite side of the board. If the King can be taken on the next turn it is in check, it must not remain in check on the next turn. If the king cannot move out of check, checkmate is declared and the opponent wins. 
(game "Shatr ikh Padan" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        ("ChessPawn" "Pawn")
        ("ChessKing" "King_noCross")
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "King_noCross1" coord:"E1") 
            (place "King_noCross2" coord:"D8") 
        })
        
        (play 
            (do (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        
        (end ("Checkmate" "King_noCross"))
    )
)

Describe the mechanics of the following Ludii game
(game "La Yagua" 
    (players 2) 
    (equipment { 
        (board 
            (add
                (rotate 180 ("AlquerqueGraphWithBottomTriangle"))
                edges:{{27 29} {29 25}}
            )
            use:Vertex
        ) 
        (piece "Jaguar" P1 (or "HopCapture" "StepToEmpty"))
        (piece "Dog" P2 "StepToEmpty") 
    }) 
    (rules 
        (start { 
            (place "Dog2" (union (expand (sites Bottom) steps:1) (sites {"A3" "E3"})))
            (place "Jaguar1" coord:"C7")
        })
        
        (play (forEach Piece)) 
        
        (end ("NoMovesLossAndLessNumPiecesPlayerLoss" P2 6))
    )
)
La Yagua is a hunt game played in South America. This version was played by the Chiriguano-Chane people of Argentina.It was usually drawn on the ground and played with seeds or stones.5x5 grid, with diagonals in each quadrant. A triangle, with the apex connecting to the midpoint of one side of the grid. A line is drawn connecting the apex of the triangle to the midpoint of its base, and another triangle is drawn within the triangle connecting the midpoints of the larger triangle. One player plays as twelve dogs, arranged on the lower two rows of points and the two outer points on the central line; the other plays as one jaguar, placed on the apex of the smaller triangle. The jaguar moves first. Pieces move to an empty adjacent space along the lines of the board. The jaguar may hop over an adjacent dog to an empty space immediately on the opposite side of it, capturing the dog. Dogs cannot capture. The dogs win by blocking the jaguar so it cannot move; the jaguar wins when only six dogs remain.
         

Construct a Ludii game based on the following description
Salta was invented by Konrad Heinrich Büttgenbach in 1899. It is related to Halma.Players alternate moving their pieces forward or backward diagonally. A piece may also jump over one adjacent piece of the opponent diagonally forward. This does not capture the opponent's piece. Jumps are compulsory. A player cannot block the other player's pieces such that he or she cannot perform a legal move. The player that can first bring each of their pieces seven rows forward is the winner. The pieces must retain their original order in each row. 
(game "Salta" 
    (players 2) 
    (equipment { 
        (board (square 10)) 
        (piece "Salta1Dot" Each)
        (piece "Salta2Dot" Each)
        (piece "Salta3Dot" Each)
        (piece "Salta4Dot" Each)
        (piece "Salta5Dot" Each)
        (piece "Salta1Moon" Each)
        (piece "Salta2Moon" Each)
        (piece "Salta3Moon" Each)
        (piece "Salta4Moon" Each)
        (piece "Salta5Moon" Each)
        (piece "Salta1Star" Each)
        (piece "Salta2Star" Each)
        (piece "Salta3Star" Each)
        (piece "Salta4Star" Each)
        (piece "Salta5Star" Each)
    }) 
    
    (rules 
        (start { 
            (place "Salta1Star1" coord:"A1") (place "Salta2Star1" coord:"C1") (place "Salta3Star1" coord:"E1") (place "Salta4Star1" coord:"G1") (place "Salta5Star1" coord:"I1")
            (place "Salta1Moon1" coord:"B2") (place "Salta2Moon1" coord:"D2") (place "Salta3Moon1" coord:"F2") (place "Salta4Moon1" coord:"H2") (place "Salta5Moon1" coord:"J2")
            (place "Salta1Dot1" coord:"A3") (place "Salta2Dot1" coord:"C3") (place "Salta3Dot1" coord:"E3") (place "Salta4Dot1" coord:"G3") (place "Salta5Dot1" coord:"I3")
            
            (place "Salta1Star2" coord:"J10") (place "Salta2Star2" coord:"H10") (place "Salta3Star2" coord:"F10") (place "Salta4Star2" coord:"D10") (place "Salta5Star2" coord:"B10")
            (place "Salta1Moon2" coord:"I9") (place "Salta2Moon2" coord:"G9") (place "Salta3Moon2" coord:"E9") (place "Salta4Moon2" coord:"C9") (place "Salta5Moon2" coord:"A9")
            (place "Salta1Dot2" coord:"J8") (place "Salta2Dot2" coord:"H8") (place "Salta3Dot2" coord:"F8") (place "Salta4Dot2" coord:"D8") (place "Salta5Dot2" coord:"B8")
        })
        
        (play 
            (if "SameTurn"
                ("HopSequence" (last To))
                (priority { 
                    (forEach Piece ("HopSequence" (from)))
                    (forEach Piece "StepDiagonalToEmpty")
                }) 
            )
        ) 
        
        (end {
            (if "GoalOfP1Filled" 
                (result P1 Win)
            )
            (if "GoalOfP2Filled" 
                (result P2 Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Connect6 is a game invented by I-Chen Wu in Taiwan in 2003 and played on a Go board. The goal of the game is to make a line of six pieces.Played on a Go-like board (6x6 or larger, but a 19x19 go board is ideal) with two colors of stones (usually white and black). Black goes first by placing one stone. Play continues with each player playing two stones per turn. The first player to make a line of six in a row wins. 
(game "Connect6" 
    (players 2) 
    (equipment { 
        (board (square 19) use:Vertex) 
        (piece "Marker" Each) 
    }) 
    (rules 
        
        phases:{
        (phase "Opening" 
            (play (move Add (to (sites Empty))))
            (nextPhase "Playing")
        )
        (phase "Playing" 
            (play 
                (move Add
                    (to (sites Empty)) 
                    (then 
                        (if 
                            (is Even (count Moves)) 
                            (moveAgain)
                        )
                    )
                )
            )
            (nextPhase "Playing")
        )
        }
        
        (end (if (is Line 6 All) (result Mover Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Egara Guti" 
    (players 2) 
    (equipment { 
        (board 
            (graph
                vertices:{ {0 0} {2 0} {4 0} {6 0} {8 0} {2 2} {4 2} {6 2} {3 3} {4 3} {5 3} {4 4} {3 5} {4 5} {5 5} {2 6} {4 6} {6 6} {0 8} {2 8} {4 8} {6 8} {8 8}}
                edges:{ {0 1} {0 5} {1 2} {1 5} {2 3} {2 6} {3 4} {3 7} {4 7} {5 6} {5 8} {5 15} {6 7} {6 9} {7 10} {7 17} {8 9} {8 11}
                {9 10} {9 11} {10 11} {11 12} {11 13} {11 14} {12 13} {12 15} {13 14} {13 16} {14 17} {15 16} {15 18} {15 19} {16 17} {16 20} {17 21}
                {17 22} {18 19} {19 20} {20 21} {21 22}}
            )
            use:Vertex
        )
        (piece "Counter" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Counter1" (union (expand (sites Bottom)) (sites Row 2)))
            (place "Counter2" (union (expand (sites Top)) (sites Row 4)))
        })
        
        (play (forEach Piece))
        
        (end ("NoMoves" Loss))
    )
)
Egara Guti was documented in India during the early twentieth century. It is similar to other games found in India which seem to be related to alquerque games on various board configurations. The board is laid out like a Lau Kata Kati board, but with the second lines of each triangle connected on each side.Each player begins with their eleven pieces arrayed on the intersections of the lines in one of the triangles. Pieces move to an adjacent point along one of the lines connecting it to its present location. Captures are made by hopping over an opponent's piece. The player who captures all of the opponent's pieces wins. 

Describe the mechanics of the following Ludii game
(game "Tchela"
    (players 2)
    (equipment {
        (board 
            <Board:board>
            <Board:tracks>
            use:Vertex
        )
        (piece "Seed" Shared)
        (regions "HomeNotExtented" P1 (sites Track "TrackCCW1")) 
        (regions "HomeNotExtented" P2 (sites Track "TrackCCW2")) 
        (regions "Home" P1 (sites Track "TrackExtendedCCW1")) 
        (regions "Home" P2 (sites Track "TrackExtendedCCW2")) 
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        <Board:stores>
    })
    (rules
        <Board:start>
        phases:{
        (phase "Opening"
            (play
                (move
                    Select
                    (from
                        (if (< (value Player Mover) 0)
                            (sites Mover "HomeNotExtented")
                            (sites {("NextSite" (value Player Mover) "TrackCCW" 2)})
                        )
                    )
                    (then 
                        (and
                            (sow
                                "TrackCCW"
                                owner:(mover)
                            )
                            (set Value Mover (last To))
                        )
                    )
                )
            )
            (nextPhase Mover (= 0 (count at:("NextSite" (value Player Mover) "TrackCCW" 2))) "OpeningPair")
        )
        
        (phase "OpeningPair"
            (play
                (move Select
                    (from (sites {("NextSite" (value Player Mover) "TrackCCW" 1)}))
                    (then 
                        (sow
                            "TrackCCW"
                            owner:(mover)
                        )
                    )
                )
            )
            
            (nextPhase Mover "Playing")
        )
        
        (phase "Playing"
            (play
                (or
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                "LastHoleSowed" 
                                (sites Mover "HomeNotExtented") 
                            ) 
                            if:(< 0 (count at:(from)))
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                owner:(mover)
                                apply:(if (> (count at:(to)) 1)
                                    (moveAgain)
                                    (if (and 
                                            (is In (to) (sites Mover "Inner")) 
                                            (> (count at:"OppositePit") 0)
                                        )
                                        (and
                                            (fromTo 
                                                (from "OppositePit") 
                                                (to (mapEntry Mover)) 
                                                count:(count at:"OppositePit")
                                            ) 
                                            (if (> (count at:"OppositePit") 0)
                                                (fromTo 
                                                    (from ("OppositeOuterPit")) 
                                                    (to (mapEntry Mover)) 
                                                    count:(count at:("OppositeOuterPit"))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (do
                        (move Select
                            (from 
                                (if 
                                    ("SameTurn") 
                                    "LastHoleSowed" 
                                    (sites Mover "Home") 
                                ) 
                                if:(< 0 (count at:(from)))
                            )
                            (then 
                                (sow
                                    "TrackExtendedCCW"
                                    owner:(mover)
                                    apply:(if (!= (to) (mapEntry "ExtraStore" Mover))
                                        (if (> (count at:(to)) 1)
                                            (moveAgain)
                                            (if (and 
                                                    (is In (to) (sites Mover "Inner")) 
                                                    (> (count at:"OppositePit") 0)
                                                )
                                                (and
                                                    (fromTo 
                                                        (from "OppositePit") 
                                                        (to (mapEntry Mover)) 
                                                        count:(count at:"OppositePit")
                                                    ) 
                                                    (if (> (count at:"OppositePit") 0)
                                                        (fromTo 
                                                            (from ("OppositeOuterPit")) 
                                                            (to (mapEntry Mover)) 
                                                            count:(count at:("OppositeOuterPit"))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        ifAfterwards:(<= (count at:(mapEntry "ExtraStore" Mover)) 1)
                    )
                )
            )
        )
        }
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)
Tchela is a four-row mancala-style board game played by the Chokwe people of Angola. It begins with a stylized opening play, and can also be played on a smaller board.4x8 board. May have one or two stores per player. Stores are located to the right hand side of the player's two rows, centered with respect to the player's two rows. If each player has two stores, the second store is located between the fourth and fifth holes of the player's rows; i.e., in the center of the board. One counter in each hole except the stores. Opening play: Player sows from any one of their holes, thus making a pair. They then take the counter in the next hole and sow it, making another pair. This continues until the last pair is made. When the last pair is made, the player sows this pair normally. Main phase: Sowing occurs in an anti-clockwise direction. When the final counter falls into an occupied hole, these are picked up and sowing continues. The turn ends when the final counter falls into an empty hole. When this empty hole is in the inner row, the counters in the opponent's hole opposite are captured. If the opponent's inner row hole are occupied, then any contents in the outer row opposite are also captured. Several rules apply to the stores: They are not used during the opening play; They may only hold one counter at a time; The counter in the store cannot be captured; It is the player's choice whether to include the store in sowing; they are considered to be in the player's inner row of holes for the purposes of sowing. The game is played on a 4x6 board.

Construct a Ludii game based on the following description
Dris at-Talata is a simple game of alignment played in Egypt during the eighteenth century, but likely to be much older.3x3 grid. Three pieces per player. Players alternate turns placing a piece on the board. When all of the pieces are placed, players alternate turns moving a piece to any empty space on the board. The player who places three pieces in an orthogonal  row wins.  
(game "Dris at-Talata"
    (players 2)
    (equipment {
        (board (square 3))
        (hand Each)
        (piece "Marker" Each)
    })
    (rules
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                )
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        (phase "Movement"
            (play 
                (move 
                    (from (sites Occupied by:Mover))
                    (to (sites Empty))
                )
            )
        )
        }
        
        (end ("Line3Win" Orthogonal))
    )	
)

Construct a Ludii game based on the following description
A chess variant played on a board made of hexagons invented by Yakov Brusky.Brusky Chess is played on a hexagonal board with sides of length 4, 5, and 9, and each space oriented vertically. It has 84 spaces.
            
            Piece Movement:
            * Queens, Rooks, Bishops, and Knights move as in Glinski Chess.
            - Queens slide in any of the 12 directions.
            - Rooks slide in any of the 6 adjacent directions.
            - Bishops slide in any of the 6 'diagonal' directions.
            - Knights move two spaces in any adjacent direction, then one space in another direction.
            * Kings step in any of the 12 direction, and castle either kingside (moving two spaces) or queenside (moving three spaces). Castling can only take place when neither the King nor the Rook being moved have moved before.
            * Pawns, when moving from a Pawn start space, can advance without capturing to either of the two spaces slightly left of forward, or either of the two spaces slightly right of forward, unless they are 'blocked'. A Pawn on a Pawn start space is 'blocked' if an enemy piece is adjacent to it in either of the forward adjacent directions. Pawns not on a Pawn start space can only advance one space without capturing. Pawns capture in a forward diagonal direction (i.e., to a space one row forward and off to the side, to a space connected by an edge, and having the same colour). A Pawn on a Pawn start space can also capture forwards (i.e., to the space directly ahead, having the same colour). En passant capture and Pawn promotion take place as in Glinski Chess.
            
        The game ends on a checkmate or stalemate. 
(game "Brusky Chess"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board
            (remove
                (hex Rectangle 8 13)
                cells:{0 1 13 25 75 88 11 12 24 37 62 74 86 87 98 99}
            )
        )
        
        (piece "King" Each
            (or {
                ("KingCaptureStep" All "History_SaveMovementChange")
                (if "Castle_PreCheck"
                    (or {
                        "Castle_KingSide"
                        "Castle_QueenSide"
                    })
                )
            })
        )
        (piece "Queen" Each ("SlideCaptureMove" All))
        (piece "Rook" Each ("SlideCaptureMove" Orthogonal "History_SaveMovementChange"))
        (piece "Bishop" Each ("SlideCaptureMove" Diagonal))
        ("ChessKnight" "Knight" (then (set Counter)))
        
        (piece "Pawn" Each
            (or {
                "PawnCapture_Diag" 
                (if "IsPawnUnblocked" "StepOrthoToEmpty")
                (if "IsFromInStartCell"
                    (or "PawnCapture_Forward" 
                        (if "IsPawnUnblocked" "PawnStep_Double")
                    )
                    "EnPassant_Diag" 
                )
                }
                (then
                    (and
                        ("ReplayInMovingOn" (sites Mover "PromotionZone"))
                        (set Counter)
                    )
                )
            )
        )
        
        (map "King"  {(pair 1 "F1") (pair 2 "I8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "D8")})
        (map "RookRight" {(pair 1 "I1") (pair 2 "L8")})
        
        (regions "PromotionZone" P1 (sites Top))
        (regions "PromotionZone" P2 (sites Bottom))
        
        (regions "Region-Dark" (sites Phase 2))
        (regions "Region-Light" (sites Phase 1))
        (regions "Region-Medium" (sites Phase 0))
    })
    
    (rules
        (start {
            (place "King1" coord:"F1" state:1)
            (place "Queen1" coord:"D1")
            (place "Rook1" {"A1" "I1"} state:1)
            (place "Bishop1" {"C1" "G1" "E1"})
            (place "Knight1" {"B1" "H1"})
            
            (place "King2" coord:"I8" state:1)
            (place "Queen2" coord:"G8")
            (place "Rook2" {"D8" "L8"} state:1)
            (place "Bishop2" {"F8" "H8" "J8"})
            (place "Knight2" {"E8" "K8"})
            
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
        })
        phases:{
        (phase "Movement"
            (play
                (if ("SameTurn")
                    ("PromoteTo" (piece {"Queen" "Rook" "Bishop" "Knight"}))
                    (do (forEach Piece)
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
            )
            (end {
                ("Checkmate" "King")
                (if (or
                        (no Moves Mover)
                        (= (counter) 100)
                    )
                    (result Mover Draw)
                )
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Gamacha is a term used by Hadiya and Kambati people of Ethiopia for mancala-style games. This is a two-row version that was typically played by male nobility of the Hadiya people.2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an empty hole on the player's own row, the contents of the opponent's opposite hole are captured only if it contains one counter. If the final counter lands in an occupied hole, the contents of it are picked up and sowing continues. If the final counter lands in a hole in the opponent's row, causing it to contain four counters, the hole becomes a qasamo, and it can no longer be sown from. Play continues until all of the counters are captured or are in a qasamo. The player with the most counters captured and in all qasamo belonging to them wins. 
(game "Gamacha (Nobility)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)		
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top)) 
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (move Select
                (from 
                    (if ("SameTurn")
                        ("LastHoleSowed") 
                        (sites Mover) 
                    )
                    if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))
                )
                (then
                    (sow
                        apply:(if (and 
                                (is In (to) (sites Mover))
                                (= 1 (count at:(to)))
                            )
                            (if (= 1 (count at:("OppositePit" (to))))
                                (fromTo
                                    (from ("OppositePit" (to)))
                                    (to (handSite Mover))
                                    count:1
                                )
                            )
                            (if (< 1 (count at:(to)))
                                (and
                                    (moveAgain)
                                    (if (and {(is In (to) (sites Next)) (= 0 (state at:(to))) (= 4 (count at:(to))) })
                                        (set State at:(to) (mover))
                                    )
                                )
                            )
                        )
                    )
                )
            )		
        )
        
        (end ("MancalaByScoreWhen" ("NoFreeSeed")))
    )
)

Construct a Ludii game based on the following description
Dam Hariman is a game with captures played in Malaysia during the nineteenth century.5x5 intersecting lines and with a triangular appendage on either side. Each player has sixteen pieces, which are placed on the intersections and move along the lines to the next open intersection. Players can hop opponents pieces to capture them. Multiple captures in one turn are allowed. A player wins when they capture all of the opponent's pieces or block them from being able to move.
         
(game "Dam Hariman"
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (piece "Marker" Each 
            (or 
                ("HopSequenceCapture")
                ("StepToEmpty")
            )
        )
    }) 
    (rules 
        (start { 
            (place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3)}))
            (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8)}))
        })
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("NoMoves" Loss))
    )	
)

Construct a Ludii game based on the following description
58 holes was a game popular in ancient Southwest Asia from the second and first millennia BCE. The earliest known board comes from Egypt, but it appears very quickly in widely dispersed places throughout the region very quickly, so an origin somewhere else cannot be ruled out. After the middle of the second millennium BCE, it was mostly played only in Mesopotamia, the Levant, and Iran. The ancient name for the game is unknown. In the center of the board are two parallel lines of ten holes, which are surrounded by an arc of 39-41 holes, typically with a larger or marked square at the apex. Pieces are typically pegs to be inserted into the holes, but in some cases discs, stones, or seeds may be used.Five pieces per player. The goal is to reach hole thirty with all five of the player's pieces. Each player has either the left or the right track. Movement is decided by dice. If a piece lands on a space with a connecting line, the piece must move backward along that line, never forward. Holes 15 and 25 are special holes, which grant a second roll. The game is using stick dices. Parallel Connections board. Rules from Carnarvon and Carter.
(game "58 Holes" 
    (players 2) 
    (equipment { 
        <Board>
        <Variant:hand>
        <Dice>
        <Variant:region>
        
        (piece "Marker" Each <Variant:pieceMove>)
        
        
        <Variant:map>
    }) 
    <Variant:rules>
)

Construct a Ludii game based on the following description
Awagagae is a two-row mancala-style board game from Eritrea. It is closely related to other Gabata games from the region.2x6 board. Play begins with four counters in each hole. A player picks up the contents of any of their holes and sowing them in an anti-clockwise direction, picking up the contents of the last hole in which his counters fall, and continuing sowing. This continues until the last counter falls in an empty hole. Then it is the other player's turn. A hole is captured when the last ball is dropped into an opponent's hole containing three counters, making it four. A player cannot then take from one of these holes that they have captured. Therefore, the player cannot begin a turn from their own captured hole nor can they continue sowing from it. If the last counter of a sowing falls into an opponent's captured hole, nothing happens on the first instance, but every time after that, one of those counters are removed from the board and placed in the store, and the sowing ends. Ownership of a hole continues even if it becomes empty. When a player cannot move (i.e., there are no counters in their holes except any that are in captured holes), the opponent continues to move until the player is able to move. Play continues until all counters are either placed in the store or in captured holes and thus cannot be moved. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra the weaker player is given the two extra counters. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes. 
(game "Awagagae" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        (start {
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
            (set Count 4 to:(sites Track))
        })
        
        phases:
        {
        (phase "Sowing"
            (play 
                (or {
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                "LastHoleSowed" 
                                ("OwnedHoles") 
                            )
                            if:(and ("PossibleSowFrom") (< 0 (count at:(from))))
                        )
                        (then 
                            (sow 
                                "Track"
                                apply:(if (not ("CapturedHole" (mover) (to)))
                                    (if (and 
                                            (is In (to) (sites Next)) 
                                            (= (count at:(to)) 4)
                                        ) 
                                        (if (is Mover P1)
                                            (remember Value "CapturedP1" (to))
                                            (remember Value "CapturedP2" (to))
                                        )
                                        (if ("CapturedByOpponent" (mover) (to))
                                            (fromTo
                                                (from (to))
                                                (to (handSite Next))
                                                count:1
                                            )
                                            (if (> (count at:(to)) 1)
                                                (moveAgain)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then 
                        (if ("NoFreePiece")
                            (and { 
                                (forEach Site (sites Board)
                                    (if 
                                        (and
                                            (is In (site) (values Remembered "CapturedP1"))
                                            (is Occupied (site))
                                        )
                                        (fromTo
                                            (from (site))
                                            (to (handSite P1))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site (sites Board)
                                    (if 
                                        (and
                                            (is In (site) (values Remembered "CapturedP2"))
                                            (is Occupied (site))
                                        )
                                        (fromTo
                                            (from (site))
                                            (to (handSite P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                                (forget Value "CapturedP1" All)
                                (forget Value "CapturedP2" All)
                            })
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Next) (sites Mover))
                            if:(is Empty (to))
                        )
                        count:4
                        (then
                            (and 
                                ("RemmemberOwnedHoles" (last To))
                                (if (and (> 4 (count Cell at:(handSite P1))) (> 4 (count Cell at:(handSite P2))))
                                    (and {
                                        (fromTo 
                                            (from Cell (handSite P1))
                                            (to (sites Empty))
                                            count:(count Cell at:(handSite P1))
                                        )
                                        (fromTo 
                                            (from Cell (handSite P2))
                                            (to (sites Empty))
                                            count:(count Cell at:(handSite P2))
                                        )
                                        (if (= 3 (count Cell at:(handSite P1))) 
                                            (remember Value "OwnedP1" (regionSite (sites Empty) index:0))
                                            (remember Value "OwnedP2" (regionSite (sites Empty) index:0))
                                        )
                                    })
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Chomp" 
    (players 2)
    (equipment { 
        (board (rectangle <Rows:num> <Columns:num>)) 
        (piece "Chocolate" Shared)
    }) 
    (rules 
        (start (place "Chocolate" (sites Board)))
        (play ("EatChocolate")) 
        (end 
            (if 
                ("EatTopLeftCorner") 
                (result Mover Loss)
            )
        ) 
    )
)
Chomp is a two-player strategy game played on a rectangular grid made up of smaller square cells, which can be thought of as the blocks of a chocolate bar.The players take it in turns to choose one block and \ The board has 1 row. The board has 2 columns.

Describe the mechanics of the following Ludii game
(game "Pyrga"
    (players 2)
    (equipment {
        (board (square 4) use:Cell)
        (hand Each size:15)
        (piece "Disc" Each)
        (piece "SquareOrtho" Each)
        (piece "SquareDiag" Each)
        (piece "TriangleN" Each)
        (piece "TriangleS" Each)
        (piece "TriangleE" Each)
        (piece "TriangleW" Each)
    })
    (rules
        ("SetupHands")
        (play
            
            (priority
                (or {
                    ("AddDisc" "Disc" ("ToSitesAllowedFor" "Disc" 1))  
                    ("AddSquare" <Square:rotation> ("ToSitesAllowedFor" "SquareOrtho" 2))
                    ("AddTriangle" N "TriangleN" ("ToSitesAllowedFor" "TriangleN" 3) SW SE)
                    ("AddTriangle" E "TriangleE" ("ToSitesAllowedFor" "TriangleN" 3) NW SW)
                    ("AddTriangle" S "TriangleS" ("ToSitesAllowedFor" "TriangleN" 3) NW NE)
                    ("AddTriangle" W "TriangleW" ("ToSitesAllowedFor" "TriangleN" 3) NE SE)
                })
                (or {
                    ("AddDisc" "Disc" ("EmptySite4" "Disc"))
                    ("AddSquare" <Square:rotation> ("EmptySite4" "SquareOrtho"))
                    ("AddTriangle" N "TriangleN" ("EmptySite4" "TriangleN") SW SE)
                    ("AddTriangle" E "TriangleE" ("EmptySite4" "TriangleN") NW SW)
                    ("AddTriangle" S "TriangleS" ("EmptySite4" "TriangleN") NW NE)
                    ("AddTriangle" W "TriangleW" ("EmptySite4" "TriangleN") NE SE)
                })
                (then 
                    (and {
                        (<Control:majorityOrTop> (mover))
                        (<Control:majorityOrTop> (next))
                    })
                )
            )
            
        )
        (end
            (if
                (or {
                    (>= (score Mover) 300)
                    (>= (score Next) 300)
                    (no Moves Next)
                })
                (byScore)
            )
        )
    )
)
Pyrga is a 2 player abstract 4x4 square stacking game with a limited supply of 5 each of 3 types of pieces per player.     There is no movement, nor capture.     Shapes and their orientation restrict the locations of the subsequent placements.    Stacks ownership is by majority.     Duplicate shapes are not allowed in the same stack.     Goal is ownership of 3 complete stacks, or if not possible, ownership of the majority of the tallest non-tied stacks    Draws are possible.White starts by playing any piece on any space.
            Players take turns to play one of their pieces.
            Each space of the board can support only one Tower. Each Tower is made of one piece of each kind (Square, Triangle, Circle), and pieces may be played in any order.
            If the active player cannot play according to the last piece's rule, they may play on any empty space.
            A Tower is controlled by the player with the most pieces.
            
            SQUARES
            The opponent must play in an orthogonally adjacent space.
            
            TRIANGLES
            The active player selects the orientation, it must point to at least one space.
            The opponent must play in the line indicated by the Triangle.
            
            CIRCLES
            The opponent must play on the same space.
            
            SCORES: The scores show the column counts. For example: 211 means 2 Towers, 1 controlled pair and 1 singleton
            
            GAME END
            The first player to control 3 completed Towers wins (i.e. a score of 300+).
        If the active player has no possible moves the game ends with tiebreaks: most completed towers, or most two-piece towers, or most one-piece towers. Stack is owned by player with majority of pieces there. Square is placed othogonally - next piece goes on adjacent spaces. Next piece may be placed any distance ahead of triangle but may not be placed around its tails.

Construct a Ludii game based on the following description
EcoSys is a game from a comment by Michael Amundsen about my concurrently developed game 'Off-Shore', causing me to strip away all elements of that game except for the placement rule:   'A stone must not be placed next to a group that has the same or more stones than there are friendly groups.'      It turns out that this rules is very similar to that found in Mark Steere's Bamboo 2021 - On a hexagon, the games differ only by whether merging is alowed to form groups larger than the number of groups or not.      The game does not work on a square grid with orthogonal connectivity due to the ability to create large numbers of groups using crosscuts. It works best on grids with high connectivity.      Given the opacity of the opening play, I have chosen to use a relatively small square grid with orthogonal plus diagonal connectivity for groups. It is of an odd order to discourage mirror play.      In 3D, a cubic close packing grid would be appropriate in an order-3 rhombic dodecahedron (93-cell).With the board empty, Black starts.
            
            Players take turns in alternation, placing a stone on to an empty cell.
            However, a stone must not be placed next to a group that already has the same (or more) stones as there are friendly groups.
            
        The game is lost by the first player forced to place a stone next to a friendly group that has as many (or more) stones as there are friendly groups. 5 Square
(game "Ecosys"
    (players 2)
    (equipment {
        (<Board:type>)
        (piece "Disc" Each)
    })
    (rules
        (start (set Score Each 0))
        (play
            (move Add
                ("ToToSites")
                (then
                    (and
                        ("SetNewGroupValue")
                        (set Score Mover (size Array (sizes Group <Board:directions> Mover))) 
                    )
                )
            )
        )
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
Chopsticks is a combinatorial hand game of uncertain origin. No equipment is required; people play by showing a number of fingers on their hands.Players begin with one finger extended on each hand. They take turns tapping a hand, either the opponent's or their own. The number of fingers on the tapping hand is added to the tapped hand, the tapping hand is unchanged. The tapped hand must extend the appropriate number of fingers. If the total exceeds five on a hand, that hand then shows the number over five (for example, if it has three and is tapped by three, it shows one.). Points can be transferred between a player's hands by tapping them together. If the score is exactly five on one hand, it is out and goes to zero. The goal is to force a player to either have all five fingers on both hands showing, or to force them to have one hand out and one with all five fingers showing. 
(game "Chopsticks"
    (players 2) 
    (equipment { 
        (board (square 2))
        (piece "Hand" Each)
        (piece "HandFlip" Each)
    }) 
    (rules 
        (start { 
            (place "HandFlip1" coord:"A1" state:1) 
            (place "Hand1" coord:"B1" state:1) 
            (place "Hand2" coord:"A2" state:1) 
            (place "HandFlip2" coord:"B2" state:1) 
        })
        (play 
            (move Select
                (from 
                    (sites Occupied by:Mover) 
                    if:(!= (state at:(to)) 0)
                )
                (to 
                    (sites Occupied by:Next) 
                    if:(!= (state at:(to)) 0)
                )
                (then 
                    (set State 
                        at:(last To) 
                        (% (+ (state at:(last From)) (state at:(last To))) 5)
                    )
                ) 
            )
        )
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Okwe is the name for several mancala-style board games played in Nigeria. This version is a two-row board game played by the Igbo, Edo, Umon, Ibibio, and Owerri people during the early twentieth century.2x10-20 board, 10 most common. Opening arrangement: Each player has this opening arrangement (number of counters in each hole, starting from the leftmost hole): 5-5-5-5-5-5-5-1-1-5-1-0-0-0-0-0-0-0-0-0. Boards have even numbers of holes, and the farthest left and farthest right holes are eliminated in succession from this opening arrangement to make smaller boards. The challenger concedes the first move. Opening phase: Player 1 removes the counters in the opponent's final four holes with counters and conceals them from the opponent. Player 2 removes the same counters, except leaving the single counter in the opponent's final hole with counters. Players take the counters from any of their holes and sow them in an anti-clockwise direction. When sowing, the first counter is dropped into the hole from which it just came, unless it is a single counter. If the last counter lands in the opponent's row and the opposite hole contains one, three, or five counters, theses are taken and added to the concealed store. In place of a move, a player may add some or all of the counters from the concealed store, sowing from the leftmost hole in their row. If the sowing reaches the rightmost hole in this row, sowing continues from the leftmost hole rather than continuing into the opponent's rows. Each row has 10 holes.
(game "Okwe (Nigeria)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            {
            (track "Track" "0,E,N,W" loop:True)
            <Board:homeTracks>
            }
        )
        <Board:openingRegions>
        (piece "Seed" Shared)
        (hand Each)
        (map "LeftMost" {(pair P1 0) (pair P2 (- (* ("Columns") 2) 1))})
        (regions "Home" P1 (sites Bottom))
        (regions "Home" P2 (sites Top))
    }) 
    (rules 
        
        <Board:start>	
        
        phases:
        {
        (phase "Opening"
            (play 
                (move
                    (from (sites Mover "OpeningRegion") if:(is Occupied (from)))
                    (to (handSite Mover))
                    count:(count at:(from))
                )
            )
            (nextPhase (all Sites (union (sites P1 "OpeningRegion") (sites P2 "OpeningRegion")) if:(is Empty (site))) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (or
                    (move Select
                        (from (sites Mover "Home") if:(is Occupied (from)))
                        (then
                            (sow
                                "Track"
                                apply:(if (and
                                        (is In (to) (sites Next "Home"))
                                        (or {
                                            (= 1 (count at:("OppositePitTwoRows" (to))))
                                            (= 3 (count at:("OppositePitTwoRows" (to))))
                                            (= 5 (count at:("OppositePitTwoRows" (to))))
                                        })
                                    )
                                    (fromTo
                                        (from ("OppositePitTwoRows" (to)))
                                        (to (handSite Mover))
                                        count:(count at:("OppositePitTwoRows" (to)))
                                    )
                                )
                                origin:(< 1 (count at:(from)))
                            )
                        )
                    )
                    (if (is Occupied Cell (handSite Mover))
                        (do (set Var "NumToSow" (count Cell at:(handSite Mover)))
                            next:(move
                                (from (handSite Mover))
                                (to (mapEntry "LeftMost" Mover))
                                count:(count Cell at:(handSite Mover))
                                (then
                                    (and 
                                        (sow
                                            count:(var "NumToSow")
                                            "TrackSpecialHome"
                                            owner:(mover)
                                            origin:True
                                        )
                                        (set Var "NumToSow" 0)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end (if (all Sites (sites Board) if:(= 0 (count at:(site))))
                {
                (if (is Empty (handSite P1)) (result P2 Win))
                (if (is Empty (handSite P2)) (result P1 Win))
                }
            )
        )
    )
)

Construct a Ludii game based on the following description
A 3 dimensional game of skill and strategy for two players.Each player in turn places one of his marbles in an open space on the board, on top of a square (i.e. 4 marbles next to each other). After the placement of each marble, check to see if a square or marbles have been formed. If at least 3 of the 4 marbles that form a square are of the same color, a piece of that color go on top of that square. If as a result other squares are formed, the same rule is applied. The winner is the first player to have at least 27 marbles of his colour on the board.
            
         
(game "Upper Hand"
    (players 2)
    (equipment {
        (board (square 5 pyramidal:True) use:Vertex) 
        (piece "Ball" Each) 
        (piece "Ball" Neutral)
    })
    (rules 
        (start (place "Ball0" (centrePoint)))
        (play 
            (move Add 
                (to (sites Empty) 
                    if:(is Flat)
                )
                (then ("PutOnTop"))
            )
        )
        (end 
            (if 
                (<= 27 (count Sites in:(sites Occupied by:Mover))) 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
The game LastEdge is a 2-player mathematical game. The game has three different versions: LastEdge, LastEdgeR-B, and LastEdgeR-G-B. The LastEdge is the basic version which can be played on some green (shared) edges.The game LastEdge can be played in an undirected and unweighted graph. The edge colours are related to the playing rules of each version. For the basic version, LastEdge all the edges are in the same colour (green). At each turn, a player selects a vertex, which contains at least one green edge and after each turn, all the edges of the selected vertex are removed. The game is over when there are no green edges in the graph. The second version is the  Red blue version (LastEdgeR-B). There are one red player and one blue player. The players can select only those vertices, that contain at least one friendly edge. After each turn, all the edges (any colour) of the selected vertex are removed. The last version is LastEdgeR-G-B; there is a graph with red, green, and blue edges. The players can select a vertex, which has at least one friendly colour or shared colour edge. Importantly, the green edges are used as shared edges between both players. After each turn, all the edges (any colour) of the selected vertex are removed. For all the versions of LastEdge, if the current player has no move, then the opponent player wins. The game is played on the Graph1. The players play on LastEdge version.
(game "LastEdge" 
    (players 2)
    (equipment { 
        (board <Board:type> use:Vertex)  
        (piece "Disc" Each) 
        (piece "Marker" Shared) 
    }) 
    
    (rules
        (start
            <Version:start>
        ) 
        
        (play   
            <Version:play>
        )
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Woli is a two-row mancala-style game played in the Senegal Valley of West Africa. It was popular among young married women.2x6 board. Six counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a clockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. Players capture counters when the final counter is sown in the opponent's row and the hole containing it has two or three counters (counting the counter just dropped into it). If the hole before it also has two or three counters, these are also captured and so on until reaching a hole without two or three counters or one not belonging to the opponent. A move which would capture all of the opponent's counters is not allowed. If an opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row. 
(game "Woli" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "5,W,N,E" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    
    (rules 
        (start (set Count 6 to:(sites Track)))		 
        (play 
            (if (is Proposed "End")
                (or (move Vote "End") (move Vote "No"))
                (or
                    (if (is Cycle) (move Propose "End")) 
                    (do 
                        (move Select 
                            (from 
                                (sites Mover) 
                                if:(< 0 (count at:(from)))
                            )
                            (then 
                                (sow 
                                    if:(and 
                                        (is In (to) (sites Next)) 
                                        (or 
                                            (= (count at:(to)) 2) 
                                            (= (count at:(to)) 3)
                                        )
                                    ) 
                                    apply:(fromTo 
                                        (from (to)) 
                                        (to (handSite Mover)) 
                                        count:(count at:(to))
                                    )
                                    includeSelf:False
                                    backtracking:True
                                )
                            )
                        )
                        ifAfterwards:(< 0 (count in:(sites Next)))
                    )
                )
            )
        )
        (end ("MancalaByScoreWhen" (or (no Moves Mover) (is Decided "End"))))
    )
)

Construct a Ludii game based on the following description
Jungle is a modern game played in China and Southeast Asia and popular with children. Its origins are not well understood.Each turn consists of moving a piece one square orthogonally in any direction. An animal may eat any animal smaller than itself by moving on to its square. The only exception to this rule is that the rat can kill the elephant. If the same animals meet, the animal moving on to a square eats the animal already there. Three pieces have special powers. When the rat reaches the river it can enter it and move along those squares squares as if it were any other. If it is in the river no other animal can attack it. The rat is unable to attack the elephant from the river. If both rats meet in the river the moving piece eats the other one. When a lion or a tiger reaches a square on the edge of the river, at the next move it can jump over the river in any orthogonal direction, landing on the nearest land square. It captures any smaller animal on that square: if, however, there is a rat in the river in the line of the jump, it blocks this move. Each side has three trap-squares and the player's own pieces may move on and off them without restriction, but if an enemy animal occupies a trap-square, it loses all its power and becomes weaker than any defending piece. As soon as it moves out of the trap it regains its full strength. A player may not move any of his animals on to his own den. The player who moves any of their pieces into the enemy's den wins. 
(game "Jungle" 
    (players 2) 
    (equipment { 
        (board (rectangle 9 7))
        
        (piece "Elephant" Each "StepMove") 
        (piece "Lion" Each 
            (or {
                "StepMove" 
                ("HopTheWater" (directions {W E}) (max 2))
                ("HopTheWater" (directions {N S}) (max 3))
            })
        )  
        (piece "Tiger" Each 
            (or {
                "StepMove"
                ("HopTheWater" (directions {W E}) (max 2))
                ("HopTheWater" (directions {N S}) (max 3))
            })
        )  
        (piece "Leopard" Each "StepMove") 
        (piece "Dog" Each "StepMove") 
        (piece "Wolf" Each "StepMove") 
        (piece "Cat" Each "StepMove") 
        (piece "Rat" Each 
            (move Step 
                Orthogonal 
                (to 
                    if:(and 
                        (is In (to) (difference (union (sites Occupied by:Next) (sites Empty)) (sites Mover))) 
                        (or 
                            (<= (state at:(to)) (state at:(from))) 
                            
                            (and 
                                (not (is In (from) (sites "Water"))) 
                                ("IsPieceAt" "Elephant" Next (to))
                            )
                        ) 
                    ) 
                    (apply (remove (to)))
                )
            )
        ) 
        
        (regions "Water" (sites {"B4" "C4" "B5" "C5" "B6" "C6" "E4" "F4" "E5" "F5" "E6" "F6"})) 
        (regions "Trap" (sites {"C1" "E1" "D2" "D8" "C9" "E9"})) 
        (regions "Den" P1 (sites {"D1"})) 
        (regions "Den" P2 (sites {"D9"})) 
        
        
        (map {(pair 1 8) (pair 2 8) (pair 3 7) (pair 4 7) (pair 5 6) (pair 6 6) (pair 7 5) (pair 8 5) (pair 9 4) (pair 10 4) (pair 11 3) (pair 12 3) (pair 13 2) (pair 14 2) (pair 15 1) (pair 16 1)}) 
        }
    ) 
    (rules 
        (start {
            (place "Rat1" coord:"G3" state:1) (place "Rat2" coord:"A7" state:1)
            (place "Cat1" coord:"B2" state:2) (place "Cat2" coord:"F8" state:2)
            (place "Wolf1" coord:"C3" state:3) (place "Wolf2" coord:"E7" state:3)
            (place "Dog1" coord:"F2" state:4) (place "Dog2" coord:"B8" state:4)
            (place "Leopard1" coord:"E3" state:5) (place "Leopard2" coord:"C7" state:5)
            (place "Tiger1" coord:"A1" state:6) (place "Tiger2" coord:"G9" state:6)
            (place "Lion1" coord:"G1" state:7) (place "Lion2" coord:"A9" state:7)
            (place "Elephant1" coord:"A3" state:8) (place "Elephant2" coord:"G7" state:8)
        })
        
        (play 
            (forEach Piece 
                (then 
                    (and 
                        (if
                            (is In (last From) (sites "Trap")) 
                            "RestoredPower"
                        ) 
                        (if 
                            (is In (last To) (sites "Trap")) 
                            "LosePower"
                        )
                    )
                )
            )
        )
        
        (end ("ReachWin" (sites Next) Mover))
    )
)

Construct a Ludii game based on the following description
Tavli is played in the eastern Mediterranean, particularly Greece and Cyprus, where the games Portes, Plakoto, and Fevga are played in succession.Portes, Plakoto, and Fevga are played in succession. One point is awarded to the winner of each game, two points if the opponent hasn't moved pieces out of their starting quadrant. It is typically played to five or seven points. 
(games {
        (subgame "Portes" next:1 result:(score Mover))
        (subgame "Plakoto" next:2 result:(score Mover))
        (subgame "Fevga" next:0 result:(score Mover))
    })

Describe the mechanics of the following Ludii game
(game "A Simple Game"
    (players 2)
    (equipment {
        (board (square 4) use:Vertex)
        (piece "Ball" Each ("StepToEmpty" Orthogonal))
        (hand Each)
    })
    (rules
        (start {
            (place "Ball1" (intersection (sites Phase 0) (union (sites Top) (sites Bottom))))
            (place "Ball2" (intersection (sites Phase 1) (union (sites Top) (sites Bottom))))
        })
        (play (forEach Piece))
        (end ("Line3Win" All))
    )
)
his game is played on the following 4x4 square board.MOVE - On each turn, each player move one of his stones into an adjacent orthogonal empty cell.
        GOAL - Wins the player that makes a (orthogonal or diagonal) 3 in-a-row. 

Construct a Ludii game based on the following description
Azigo is a two-row mancala-style board game played by the Igbo people of Nigeria. 2x20 board. Opening arrangement: Each player has this opening arrangement (number of counters in each hole, starting from the leftmost hole): 5-5-5-5-5-5-5-1-1-5-2-1-0-0-0-0-0-0-0-0. Opening phase: Players remove the counters in their final four holes with counters and conceals them from the opponent. Players take the counters from any of their holes and sow them in an anti-clockwise direction. When sowing, the first counter is dropped into the hole from which it just came, unless it is a single counter. If the last counter lands in the opponent's row and this hole contains one or three, counters, these are taken and added to the concealed store. Also, if the hole from which a capture was made is preceded by an unbroken sequence of holes with one or three counters, these are also taken. In place of a move, a player may add all of the counters from the concealed store, sowing from the leftmost hole in their row. If the sowing reaches the rightmost hole in this row, sowing may continue from the leftmost hole or may continue into the opponent's row. If the player continues into the opponent's row, subsequent holes after the one in which the final counter was dropped are captured if they contain one or three counters, in an unbroken sequence. 
(game "Azigo" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 20 store:None
            {
            (track "Track" "0,E,N,W" loop:True)
            (track "TrackSpecialHome1" "0,E" loop:True P1)
            (track "TrackSpecialHome2" "39,W" loop:True P2)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (map "LeftMost" {(pair P1 0) (pair P2 39)})
        (regions "OpeningRegion" P1 (sites {8..11}))
        (regions "OpeningRegion" P2 (sites {28..31}))
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    (rules 
        
        (start {
            (set Count 5 to:(sites {0 1 2 3 4 5 6 9 39 38 37 36 35 34 33 30})) 
            (set Count 1 to:(sites {7 8 11 32 31 28})) 
            (set Count 2 to:(sites {10 29})) 
        })
        
        phases:
        {
        (phase "Opening"
            (play 
                (move
                    (from (sites Mover "OpeningRegion") if:(is Occupied (from)))
                    (to (handSite Mover))
                    count:(count at:(from))
                )
            )
            (nextPhase Mover (all Sites (sites Mover "OpeningRegion") if:(is Empty (site))) "Sowing")
        )
        (phase "Sowing"
            (play
                (or
                    (move Select
                        (from (sites Mover) if:(is Occupied (from)))
                        (then
                            (sow
                                "Track"
                                apply:(if (and
                                        (is In (to) (sites Next))
                                        (or
                                            (= 2 (count at:(to)))
                                            (= 4 (count at:(to)))
                                        )
                                    )
                                    (fromTo
                                        (from (to))
                                        (to (handSite Mover))
                                        count:(count at:(to))
                                    )
                                )
                                origin:(< 1 (count at:(from)))
                                backtracking:True
                            )
                        )
                    )
                    (if (is Occupied Cell (handSite Mover))
                        (or
                            (do (set Var "NumToSow" (count Cell at:(handSite Mover)))
                                next:(move
                                    (from (handSite Mover))
                                    (to (mapEntry "LeftMost" Mover))
                                    count:(count Cell at:(handSite Mover))
                                    (then
                                        (and
                                            (sow
                                                count:(var "NumToSow")
                                                "Track" 
                                                if:(and
                                                    (is In (to) (sites Next))
                                                    (or
                                                        (= 2 (count at:(to)))
                                                        (= 4 (count at:(to)))
                                                    )
                                                )
                                                apply:(if (and
                                                        (is In (to) (sites Next))
                                                        (or
                                                            (= 2 (count at:(to)))
                                                            (= 4 (count at:(to)))
                                                        )
                                                    )
                                                    (fromTo
                                                        (from (to))
                                                        (to (handSite Mover))
                                                        count:(count at:(to))
                                                    )
                                                )
                                                origin:True
                                                forward:True
                                            )
                                            (set Var "NumToSow" 0)
                                        )
                                    )
                                )
                            )
                            (do (set Var "NumToSow" (count Cell at:(handSite Mover)))
                                next:(move
                                    (from (handSite Mover))
                                    (to (mapEntry "LeftMost" Mover))
                                    count:(count Cell at:(handSite Mover))
                                    (then
                                        (and
                                            (sow
                                                count:(var "NumToSow")
                                                "TrackSpecialHome"
                                                owner:(mover)
                                                origin:True
                                            )
                                            (set Var "NumToSow" 0)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Two of several Games inspired by Kanare Kato's 'Squish'                        Originally 'Squish' was a unification game with step movement toward a friendly piece in-line, possibly involving a capture.  'Advanced Squish' added a requirement on non-capturing steps for the piece to become part of a larger group. (Singletons were exempted.)                        -- 'Keep-a-Riding' and 'Conflagration' differ from 'Squish' by being explicitly stalemate games: Last to move wins or loses, respectively.              They also differ by using slide captures, and by not including the 'Squish' core principle that requires movement toward in-line friendly pieces.             Instead, they require the step move to bring the moving piece into new contact with another friendly piece.                        They typically end with only a few pieces on the board, and one player may be entirely eliminated.                        'Keep-a-Riding' is themed as a 'last man standing' team demolition derby. But, knocking out an opponent's piece can only be done with pieces that cannot step to become part of a larger group.                        'Conflagration', is themed 'fighting fire with fire': Getting eliminated is a win. Containment, where none of your flame pieces can move, is also a win.                    Conflagration has 2 subvariants 'Firestorm' and 'BackFire' in which the choice of moves that each flame piece can take are prioritized.        - BackFire is shorter, more aggressive, because a flame piece must capture (become a 'backfire') if it can.         - Firestorm requires a flame piece to step to join its own kind if it can, leading to a slower elimination of the flames in the end game.Setup: Pieces of each color are distributed symmetrically on every 3rd cell of the board.
            (For a game on an order 4 board, the outer cells are not used.)
            Four game options are provided:
            
            1. Keep-a-riding - Goal: Last to move. 
            Play: No passing. Pieces step to join larger group. When they can't step to join larger group, they can slide to capture.
            
            2. Conflagration, - Goal: Win when you you have no fire left or can't make a move. 
            Play: No passing. A piece can either take a single step to join a larger group, or slide to capture an opponent's piece.
            
            3. Conflagration, - Firestorm Variant (longer)
            Rule restriction: A piece can only slide to capture when it cannot step to join a larger group.
            
            4. Conflagration, - Backfire Variant (shorter), 
        Rule restriction: A piece can only step to join a larger group when it cannot slide to capture. Keep-a-riding Order 4 board
(game "Conflagration and Keep-a-riding"
    (players 2)
    (equipment {
        (board (hex Hexagon <Board:side>) use:Cell)
        (piece "Disc" Each)
    })
    (rules
        (start {<Board:white> <Board:black>})
        (play
            <Game:structure>
        )
        (end 
            <Game:winCondition>
        )
    )
)

Construct a Ludii game based on the following description
Shogi puzzles are known in some of the earliest texts about the game. The are similar to Chess puzzles, where players are given a scenario on the Shogi board to solve.In this Shogi Puzzle, you have to checkmate the black Osho, using the regular rules of Shogi, with the smallest number of moves possible. 
(game "Shogi Puzzle" 
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        (board (square 9))
        
        
        (piece "Osho" Each ("StepMove"))
        
        (piece "Fuhyo" Each 
            ("StepMove" 
                Forward 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InLastRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                )
            )
        )
        
        (piece "Ginsho" Each ("StepMove" (directions {Forward BL BR FL FR}) "CanPromote"))
        
        (piece "Hisha" Each ("SlideMove" Orthogonal "CanPromote"))
        
        (piece "Kakugyo" Each ("SlideMove" Diagonal "CanPromote"))
        
        (piece "Keima" Each 
            (forEach Direction 
                Forward 
                (to 
                    if:True 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL}) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (add 
                                                (piece (mapEntry "Captured" (what at:(to)))) 
                                                (to (mapEntry "Where" (what at:(to))))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                ) 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InTwoFurthestRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                ) 
            ) 
        )
        
        (piece "Kyosha" Each
            ("SlideMove" 
                Forward 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InLastRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                )
            ) 
        )
        
        ("ShogiGold" "Kinsho" "CapturePiece")
        
        ("ShogiGold" "Tokin" "CapturePiece")
        
        ("ShogiGold" "Narigin" "CapturePiece")
        
        (piece "Ryuo" Each (or ("SlideMove" Orthogonal) ("StepMove" Diagonal)))
        
        (piece "Ryuma" Each (or ("SlideMove" Diagonal) ("StepMove" Orthogonal)))
        
        ("ShogiGold" "Narikei" "CapturePiece")
        
        ("ShogiGold" "Narikyo" "CapturePiece")
        
        (regions "LastRankP1" P1 (sites Top))
        (regions "LastRankP2" P2 (sites Bottom))
        (regions "TwoFurthestRankP1" P1 (expand (sites Top)))
        (regions "TwoFurthestRankP2" P2 (expand (sites Bottom)))
        (regions "Promotion" P1 (expand (sites Top) steps:2))
        (regions "Promotion" P2 (expand (sites Bottom) steps:2))
        (map "where" {(pair 3 88) (pair 4 81) (pair 5 89) (pair 6 82) (pair 7 90) (pair 8 83) (pair 9 91) (pair 10 84) (pair 11 92) (pair 12 85) (pair 13 93) (pair 14 86) (pair 15 94) (pair 16 87) (pair 17 88) (pair 18 81) (pair 19 89) (pair 20 82) (pair 21 90) (pair 22 83) (pair 23 91) (pair 24 84) (pair 25 92) (pair 26 85) (pair 27 93) (pair 28 86)})
        (map "captured" {(pair 3 4) (pair 4 3) (pair 5 6) (pair 6 5) (pair 7 8) (pair 8 7) (pair 9 10) (pair 10 9) (pair 11 12) (pair 12 11) (pair 13 14) (pair 14 13) (pair 15 16) (pair 16 15) (pair 17 4) (pair 18 3) (pair 19 6) (pair 20 5) (pair 21 8) (pair 22 7) (pair 23 10) (pair 24 9) (pair 25 12) (pair 26 11) (pair 27 14) (pair 28 13)})
        (map "promoted" {(pair 3 17) (pair 4 18) (pair 5 19) (pair 6 20) (pair 7 21) (pair 8 22) (pair 9 23) (pair 10 24) (pair 11 25) (pair 12 26) (pair 13 27) (pair 14 28)})
        
        (hand Each size:7)
    })
    
    (rules 
        (start { 
            <challenge:start>
        })
        
        (play
            (if "SameTurn"
                (or
                    "Promote"
                    (move Pass)
                )
                (do 
                    (or {
                        (move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) 
                        "PlaceAPawn"
                        "PlaceALance"
                        "PlaceAKnight" 
                        (forEach Piece) 
                    })
                    ifAfterwards:(not ("KingCheck" Mover))
                )
            )
        )
        
        (end {
            (if (and {
                    ("KingCheck" Next)
                    "NextCanNotMove"
                    (<= (count Turns) <challenge:limit>)
                }) 
                (result P1 Win)
            ) 
            (if (or (no Moves Next) (and (= <challenge:limit> (count Turns)) (not (is Mover Next)))) (result P1 Loss))
        })
    )
)

Construct a Ludii game based on the following description
Santorini is an accessible strategy game, simple enough for an elementary school classroom while aiming to provide gameplay depth and content for hardcore gamers to explore.The game is played on a 5x5 grid where each turn players build a town by placing building pieces up to four levels high. To win the game, players must move one of their two workers to the third level of the town.
            
            Beginning turns :
            The first player places his two workers on the board, then the second does the same.
            
            Normal turns :
            Each turn, the current player moves one of his two workers in an adjacent position (in horizontal, vertical or diagonal, i.e. king chess move) then he places a building tile adjacent to the moved worker (in a horizontal, vertical or diagonal adjacent position). The level of a position (i.e. a grid square) is the number of tiles.
            Workers can move onto a position with zero, one, two, or three tiles (but not with four tiles) only if the level of the destination position is less than or equal to the level of departure destination plus one. There can be no more than 4 tiles per position.
        The primary winning condition is to get one of his workers onto the third level (i.e. on a position with three tiles), though players may also win if their opponent is unable to make a move. 
(game "Santorini" 
    (players 2) 
    (equipment { 
        (board (square 5)) 
        (hand Each)
        
        (map {(pair 0 "SquareLarge0") (pair 1 "SquareSmall0") (pair 2 "Octagon0") (pair 3 "Marker0")})
        (piece "Pawn3d" Each 
            (move Step
                (to 
                    if:(and 
                        ("LevelBetweenGroundAndDestinationPlusOne") 
                        ("EmptyOrNeutralPiece")
                    )
                )
                (then (moveAgain))
            )
        )
        (piece "SquareLarge" Neutral)
        (piece "SquareSmall" Neutral)
        (piece "Octagon" Neutral)
        (piece "Marker" Neutral)
    }) 
    (rules 
        (start {
            (place Stack "Pawn3d1" (handSite P1) count:2)
            (place Stack "Pawn3d2" (handSite P2) count:2)
        })
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                    (then 
                        (if 
                            ("HandOccupied" Mover) 
                            (moveAgain)
                        )
                    )
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        (phase "Movement" 
            (play 
                (if ("SameTurn")
                    (move Select 
                        (from
                            (sites Around 
                                (last To) 
                                if:(and 
                                    (< (size Stack at:(to)) 4) 
                                    ("EmptyOrNeutralPiece")
                                )
                            ) 
                        )
                        (then 
                            (add 
                                (piece (mapEntry (size Stack at:(last To)))) 
                                (to (last To)) 
                                stack:True
                            )
                        )
                    )
                    (forEach Piece)
                )
            )
        )
        }
        
        (end {
            (if 
                (and 
                    (= 3 (topLevel at:(last To)))
                    ("IsPieceAt" "Pawn3d" Mover (last To) level:(topLevel at:(last To))) 
                )
                (result Mover Win) 
            )
            (if (no Moves P1) (result P2 Win))
            (if (no Moves P2) (result P1 Win))
        })
    )
)

Construct a Ludii game based on the following description
A hybrid of Checkers and Go, for two players. The Guerrilla player, using small Go stones, plays on the intersection points of the checkerboard squares to surround and capture the enemy pieces. Meanwhile, the Counterinsurgent player, using checkers, moves on the checkerboard squares to jump and capture the enemy.This game is played on an empty 8x8 square chess board. Use 6 checkers and 66 Go stones.
            
            The Counterinsurgent (COIN) player places his checkers on black squares in the middle of the board. The Guerrilla player starts with no pieces on the board, but begins by placing one stone anywhere on the board, then a second stone orthogonally adjacent to the first.
            
            The Guerrilla player does not move his pieces. Instead, he places two and only two stones per turn on the board, on the intersections of the squares.
            The first stone must be orthogonally adjacent to any stone on the board; the second stone must be orthogonally adjacent to the first stone placed.
            He may not place stones on the board edge points.
            He captures an enemy checker by surrounding it.
            
            COIN player moves one checker per turn, one square diagonally as a King in regular checkers, or makes captures by jumping over the point between two squares.
            He is not forced to capture if he does not want to, but if he does he must take all possible captures. Captured stones are removed from the board.
            
        GOAL - The player who clears the board of all enemy pieces at the end of his turn wins. The Guerrilla player loses if he runs out of stones 
(game "Guerrilla Checkers" 
    (players 2)
    (equipment {
        (board (square 9) use:Vertex)
        (hand P1)
        (piece "Marker" P1)
        (piece "Counter" P2 
            (move Step
                (from Cell)
                Diagonal
                (to Cell if:(is Empty Cell (to)))
                ("RemoveHoppedEnemyOnVertex")
            )
        )
    })
    (rules
        (start {
            (place "Counter2" Cell {"E3" "D4" "C5" "D6" "E5" "F4"}) 
            (place "Marker1" "Hand1" count:66)
        })
        
        phases:{
        (phase "InitGuerrilla" P1 
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to
                        Vertex 
                        (difference (sites Empty Vertex) (sites Outer))
                    )
                    (then (moveAgain))
                )
            )
            (nextPhase (is Next Mover) "GuerrillaMove")
        )
        
        (phase "GuerrillaMove" P1 
            (play 
                (if "SameTurn"
                    (move 
                        (from (handSite Mover)) 
                        (to
                            Vertex 
                            (difference (sites Around (last To) Orthogonal if:(is Empty (to))) (sites Outer))
                        )
                        (then 
                            (forEach Site
                                (forEach (sites Occupied by:P2 on:Cell) if:(all Sites (sites Incident Vertex of:Cell at:(site)) if:(is Occupied Vertex (site))))
                                (remove Cell (site))
                            )
                        )
                    )
                    (move 
                        (from (handSite Mover)) 
                        (to
                            Vertex 
                            (difference (sites Empty Vertex) (sites Outer))
                            if:"NextToOwnPiece"
                        )
                        (then 
                            (and
                                (forEach Site
                                    (forEach (sites Occupied by:P2 on:Cell) if:(all Sites (sites Incident Vertex of:Cell at:(site)) if:(is Occupied Vertex (site))))
                                    (remove Cell (site))
                                )
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        
        (phase "CoinMove" P2 
            (play 
                (if "SameTurn"
                    "CaptureJumpAgain"
                    (forEach Piece)
                )
            )
        )
        
        }
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Pereaüni is a four-row mancala-style board game played by several different groups in Uganda. In some places, it can be played on a larger board, but typically when people are bored with the typical course of play.4x8 board. Two counters in each hole. Opening play: Two players play simultaneously, lifting and sowing counters from their outer rows. Rules for sowing and capturing are the same as in the main phase of the game except that all holes in each player's outer rows are considered to be in opposition and back captures can be made from them. Once a counter has been sown into the inner row, this ceases and captures can only be made from the inner row. The opening ends when both players reach an empty hole, and the first player to do so begins play in the main phase. Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over. For capturing: four holes are in opposition when one player has the front row hole occupied and the opponent has both of the holes opposite it occupied. If the last hole in a sowing is in opposition, the player takes the counters in both of the opponent's holes and places them in the empty hole from which the player lifted the counters. The player then sows the captured counters from this hole. Further captures in the sowing can occur in the same way. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses. Each row has 8 holes.
(game "Pereauni" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))          
        (regions "Outer" P2 (sites Top))           
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))
        )
        
        phases:{
        (phase "OuterPhase"
            (play
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover "Outer") 
                        )
                        if:(if ("SameTurn")
                            (< 0 (count at:(from)))
                            (< 1 (count at:(from)))
                        )
                    )
                    (then 
                        (sow
                            count:(if ("SameTurn") (var "Count") (count at:(last From)))
                            "TrackCCW"
                            owner:(mover)
                            apply:(and
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and 
                                                (is Occupied ("OppositePit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            )
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to ("CorrespondingOuterPit" (to)))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (if (is Occupied ("OppositeOuterPit" (to)))
                                                    (fromTo
                                                        (from ("OppositeOuterPit" (to)))
                                                        (to ("CorrespondingOuterPit" (to)))
                                                        count:(count at:("OppositeOuterPit" (to)))
                                                    )
                                                )
                                                (set Var "Replay" ("CorrespondingOuterPit" (to)))
                                                (if (= 1 (count at:("CorrespondingOuterPit" (to))))
                                                    (set Var "Count" (+ { 1 (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))) }))
                                                    (set Var "Count" (+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to)))))
                                                )
                                            })
                                            (and
                                                (set Var "Replay" (to))
                                                (set Var "Count" (count at:(to)))
                                            )
                                        )
                                    )
                                )
                                (if (!= 1 (value Player Mover)) (set Value Mover 1))
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (= 1 (count at:(last To afterConsequence:True))) "MainPhase")
        )
        
        (phase "MainPhase"
            (play
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover) 
                        )
                        if:(if ("SameTurn")
                            (< 0 (count at:(from)))
                            (< 1 (count at:(from)))
                        )
                    )
                    (then 
                        (sow
                            count:(if ("SameTurn") (var "Count") (count at:(last From)))
                            "TrackCCW"
                            owner:(mover)
                            apply:
                            (if (< 1 (count at:(to)))
                                (and
                                    (moveAgain)
                                    (if (and {
                                            (is Occupied ("OppositePit" (to)))
                                            (is In (to) (sites Mover "Inner"))
                                        })
                                        (and {
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to ("CorrespondingOuterPit" (to)))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to ("CorrespondingOuterPit" (to)))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                            )
                                            (set Var "Replay" ("CorrespondingOuterPit" (to)))
                                            (if (= 1 (count at:("CorrespondingOuterPit" (to))))
                                                (set Var "Count" (+ { 1 (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))) }))
                                                (set Var "Count" (+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to)))))
                                            )
                                        })
                                        (and
                                            (set Var "Replay" (to))
                                            (set Var "Count" (count at:(to)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Wagner is a two-player graph theory game based on the Wagner graph, which is a Mobius ladder with 8 vertices. In this graph, the diameter and the radius are both equal to 2.  Wagner is a non-capturing game. Initially, each player places a stone at any vertex (not the centre) to maintain the graph colouring rules (i.e., no two friendly pieces are adjacent to each other). Each turn a player moves a friendly stone to an adjacent empty site. The goal is to make all the friendly pieces into a single group. 
         
(game "Wagner" 
    (players 2) 
    (equipment { 
        (board 
            (graph
                vertices:{ {2 0} {5 0} {0 2} {0 5} {7 2} {7 5} {2 7} {5 7}}
                edges:{ {0 1} {0 2} {0 7} {1 4} {1 6} {2 3} {2 5} {3 4} {3 6} {4 5} {5 7} {6 7}}
            )
            use:Vertex
        ) 
        (piece "Marker" Each ("StepToEmpty"))   
    }) 
    
    (rules
        (start {
            (set P1 Vertex (sites {0 5 6}))
            (set P2 Vertex (sites {1 2 7}))
        })
        
        (play (forEach Piece)) 
        
        (end 
            (if (= 1 (count Groups if:(= (who at:(to)) (mover)))) 
                (result Mover Win) 
            )     
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Aralzaa" 
    (players 2)
    (equipment {
        (board (square 3))
        (piece "Knight" Each ("LeapToEmpty" "KnightWalk"))
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    })
    (rules 
        (start {
            (place "Knight1" (sites P1))
            (place "Knight2" (sites P2))
        })
        (play (forEach Piece))
        (end ("FillWin" (sites Next)))
    )
)
Aralzaa is a replacement game played on a small board from Mongolia.3x3 board. Each player plays with three Horse-shaped pieces, which begin on the row of squares closest to the player. Pieces move one space forward and one space diagonally, jumping over any intervening pieces. The first player to place their pieces in the squares where the opponent started wins. 

Construct a Ludii game based on the following description
In this Chess Puzzle, you must checkmate the black king with the smallest number of moves possible with the white pieces.Play using the standard rules of chess. 
(game "Chess Puzzle" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8))
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            <challenge:start>
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        ("Castling")
                    )
                    ifAfterwards:(not ("KingCheck" Mover))
                )
            )
        )
        
        (end {
            (if (and {
                    ("KingCheck" Next)
                    "NextCanNotMove"
                    (<= (count Turns) <challenge:limit>)
                }) 
                (result P1 Win)
            ) 
            (if (or (no Moves Next) (and (= <challenge:limit> (count Turns)) (not (is Mover Next)))) (result P1 Loss))
        }) 
    )
)

Construct a Ludii game based on the following description
Invented by Carl Renström in 1971, Castello is a game in which players must capture certain spaces on the board, known as \There are 30 game-pieces for each player and eleven castles. The gameboard is divided into three sections: homes and center section. Object of the game is to capture four castles (among those of the central section and the other side) or 28 pawns of your opponent. In a turn a player moves one of their pieces, horizontally, vertically. A pawn can step to an adjacent empty cell. Additionally a pawn can jump over another pawn as long as the square behind that pawn is free. Multiple jumps are allowed and all enemy pawns are captured this way and removed from the deck. A pawn can capture a maximum of five enemy pieces, and his movement ends after the fifth piece is captured. A castle is conquered when it is surrounded by three pawns. 
(game "Castello" 
    (players 2) 
    (equipment { 
        (board (rectangle 15 21)) 
        (piece "Pawn" Each 
            (or 
                (move Hop
                    Orthogonal
                    (between 
                        if:"NotEmptyAndNoCastle" 
                        "CaptureEnemyPiece" 
                    )
                    (to if:(is Empty (to)))
                    (then 
                        (if "CanJumpAgain" 
                            (moveAgain) 
                            (set Counter)
                        ) 
                    )
                )
                ("StepToEmpty" Orthogonal) 
            )
        ) 
        (piece "Castle" Neutral)
        (hand Each size:3) 
        (regions "LeftPart" (expand (sites Left) steps:6))
        (regions "RightPart" (expand (sites Right) steps:6))
        (regions "Middle" (expand (sites Centre)))
    }) 
    (rules 
        (start {
            (place "Pawn1" (expand (sites Left)))
            (place "Pawn2" (expand (sites Right)))
            (place "Castle0" (sites {"G2" "F6" "G10" "F14" "K3" "K8" "K13" "P2" "O6" "P10" "O14"}))
        })
        (play 
            (if "SameTurn"
                (or
                    "JumpAgain"
                    (move Pass)
                )
                (forEach Piece)
                (then (and 
                        (if (is In (last To) (sites "LeftPart"))
                            (if (< (count Cell at:(handSite Mover)) 3)
                                ("CaptureCastleAndStoreItTo" "StorageLeftCastle")
                            )
                            (if (is In (last To) (sites "RightPart"))
                                ("CaptureCastleAndStoreItTo" "StorageRightCastle")
                                (if (is In (last To) (sites "Middle"))
                                    (if (> (count Cell at:(handSite Mover 2)) 0)							
                                        ("CaptureCastleAndStoreItTo" "StorageMiddleCastle")
                                    )			
                                    ("CaptureCastleAndStoreItTo" "StorageMiddleCastle")
                                )
                            )
                        )
                        (set Counter)
                    ) 
                )
            )
        )
        (end {
            ("HavingLessPiecesLoss" Next 3) 
            (if (> (count in:(sites Hand Mover)) 3) (result Mover Win))
        }) 
    )
)

Construct a Ludii game based on the following description
Kotu Ellima is a leaping capture game played in Sri Lanka since at least the nineteenth century, but which may potentially be older.From the starting position, each player takes turns moving one piece to an adjacent point connected to its current position by a line. Captures are made by hopping over an adjacent piece. The player who captures all the opponent's pieces wins. 
(game "Kotu Ellima" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithFourTriangles")
        (piece "Marker" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    (rules 
        (start { 
            (place "Marker1" (union {(expand (sites Bottom) steps:2) (expand (sites Right) steps:3) (sites {"F3" "G3" "E4" "F4" "F6" "F7" "G7"}) }))
            (place "Marker2" (union {(expand (sites Top) steps:2) (expand (sites Left) steps:3) (sites {"C3" "D3" "D4" "D6" "E6" "D7" "C7"}) }))
        })
        
        (play (forEach Piece))
        
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
A'imé is a simple race game played by children in what is now Benin. The game represents people going to the market (located in the center of the board) to buy afiti fruits.Seven concentric circles. Three points outside the circles. The center contains a circle, the market. There are three balls, placed near the board. Each player plays with one piece, which begins in the outermost point. The first player holds something in their hand, and asks the second player to guess which hand it is in. If the guessing player guesses correctly, they move their piece to the next point, or to the next ring of the spiral toward the market. If the guessing player guesses incorrectly, the player holding the object moves one space forward. The guessing player now takes the object, and asks the next player to guess which hand the object is in, and so on. When a player reaches the market, they take one of the three balls next to the board. The player who fails to collect a ball loses. 
(game "Aime"
    (players 4)
    (equipment {
        (board
            (merge {
                (concentric {4 4 4 4 4 4 4 4})
                (shift -7 7 (square 1))
                (shift -6 7 (square 1))
                (shift -7 6 (square 1))
            })
            {
            (track "Track1" {28 24 20 16 12 8 4 0} P1 directed:True)
            (track "Track2" {29 25 21 17 13 9 5 1} P2 directed:True)
            (track "Track3" {30 26 22 18 14 10 6 2} P3 directed:True)
            (track "Track4" {31 27 23 19 15 11 7 3} P4 directed:True)
            }
            use:Vertex
        )
        (piece "Marker" Each)
        (piece "Stick" Shared)
        (piece "Ball" Each)
        (piece "Ball" Shared)
        (hand Each size:2)
    })
    (rules
        (start {
            (place "Marker1" 28)
            (place "Marker2" 29)
            (place "Marker3" 30)
            (place "Marker4" 31)
            (place "Ball" (sites {32..34}))
        })
        
        phases:{
        (phase "Hiding"
            (play
                (move Add
                    (piece (id "Stick" Shared))
                    (to Cell (sites Hand Mover))
                    (then (set Hidden Cell at:(last To) to:Next))
                )
            )
            (nextPhase "Guessing")
        )
        
        (phase "Guessing"
            (play
                (move Select
                    (from Cell (sites Hand Prev))
                    (then
                        (and
                            (if (is Empty (last To))
                                (and
                                    (fromTo 
                                        (from (where "Marker" Prev))
                                        (to ("NextSitePrev"))
                                    )
                                    (if (not (is In ("NextSitePrev") ("Centre")))
                                        (set NextPlayer (player (prev)))
                                        ("TakeBall" Prev)
                                    )
                                )
                                (and {
                                    (moveAgain)
                                    (fromTo 
                                        (from (where "Marker" Mover))
                                        (to ("NextSite" from:(where "Marker" Mover)))
                                    )
                                    (if (is In ("NextSite" from:(where "Marker" Mover)) ("Centre"))
                                        ("TakeBall" Mover)
                                    )
                                })
                            )
                            (remove Cell (sites Hand Prev))
                        )
                    )
                )
            )
            (nextPhase "Hiding")
        )
        }
        
        (end 
            (if (!= (- (count Players) (count Active)) (count Sites in:(difference ("Centre") (sites Empty))))
                {
                (if (and (is Active P1) (is In (where "Marker" P1) ("Centre"))) (result P1 Win))
                (if (and (is Active P2) (is In (where "Marker" P2) ("Centre"))) (result P2 Win))
                (if (and (is Active P3) (is In (where "Marker" P3) ("Centre"))) (result P3 Win))
                (if (and (is Active P4) (is In (where "Marker" P4) ("Centre"))) (result P4 Win))
                }
            )
        )
    )
)

Construct a Ludii game based on the following description
DisPath is a 2-player graph theory game, which can be played on vertices or edges of any graph. The aim of the game is to make more disjoint paths. Every disjoint path needs to be fully disconnected from any other friendly path. The length of the path can be any integer (in this game, we have used k = 3). The motivation comes from the Disjoint path problem in graph theory. Each turn, a player selects a graph element (vertex or edge) to create a disjoint path with size k. When a player successfully makes a path of a specific size, he gets a point. The player with the highest score wins the game.   The players play on edges of the graph.
(game "DisPath"
    (players 2)
    (equipment { 
        (board <Board:type> use:Vertex)
    }) 
    (rules
        (play 
            (or 
                <Play:type>
                (move Pass)	   
            )
        )	  
        (end 	 	
            (if (all Passed)	
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Fight over left-overs in this quick territorial game.On your turn, you place a hexagonal tile of your color that covers three mutually orthogonally adjacent rhombuses. In Ludii this is done by first selecting one of the rhombuses the tile will cover, then another. The third one is determined by these two selections. When no more placements  are possible, the game is over and the winner is the player with the higher score.
            
            The general idea behind the scoring is simple: You get 1 point per empty rhombus that ends up adjacent to more of your hexagons than your opponent's hexagons. However, two slight complications are necessary to exclude all draws in as fair a manner as possible:
            
            1: You score 1 point every time you make a placement that closes off an odd number of tied rhombuses. (A rhombus is closed off when it is adjacent to no rhombus that can be filled in on a future turn.) This is equivalent to dividing tied cells between you in a \ 
(game "Residuel"
    (players 2)
    (equipment {
        (board 
            (remove 
                (rotate 30 (dual (tiling T3636 5))) 
                cells:{0 4 5 73 81 97 142 143 152}
            )
        )
        (tile "Rhombus" Each)
    })
    (rules
        (play 
            ("Select" 
                (then
                    (do
                        ("Mark")
                        next:(do
                            ("Place")
                            next:("Score")
                        )
                    )
                )
            )
        )
        (end 
            (if (no Moves Next) 
                (byScore {
                    (score P1
                        (+ {
                            (score P1)
                            (- 
                                (max
                                    (/ (count Sites in:(sites Occupied by:P1)) 3)
                                    (/ (count Sites in:(sites Occupied by:P2)) 3)
                                )
                                (/ (count Sites in:(sites Occupied by:P1)) 3)
                            )
                            (count Sites 
                                in:(forEach
                                    (sites Empty)
                                    if:(>
                                        (count Sites
                                            in:(intersection
                                                (sites Around (site) Orthogonal)
                                                (sites Occupied by:P1)
                                            )
                                        )
                                        (count Sites
                                            in:(intersection
                                                (sites Around (site) Orthogonal)
                                                (sites Occupied by:P2)
                                            )
                                        )
                                    )
                                )
                            )
                        })
                    )
                    (score P2
                        (+ {
                            (score P2)
                            (- 
                                (max
                                    (/ (count Sites in:(sites Occupied by:P1)) 3)
                                    (/ (count Sites in:(sites Occupied by:P2)) 3)
                                )
                                (/ (count Sites in:(sites Occupied by:P2)) 3)
                            )
                            (count Sites 
                                in:(forEach
                                    (sites Empty)
                                    if:(>
                                        (count Sites
                                            in:(intersection
                                                (sites Around (site) Orthogonal)
                                                (sites Occupied by:P2)
                                            )
                                        )
                                        (count Sites
                                            in:(intersection
                                                (sites Around (site) Orthogonal)
                                                (sites Occupied by:P1)
                                            )
                                        )
                                    )
                                )
                            )
                        })
                    )
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Dablot Prejjesne is a capturing game played by the Sámi people of Finland. The game pits Sámi soldiers, a prince, and a king against peasants and their prince and king.6x7 lines forming a grid. Diagonals in each small square, with a point where the diagonals cross. 28 pieces, which begin on opposite sides of the board. In addition, each player has a Prince piece, which begins on the rightmost point immediately in front of the other pieces, and a King piece, which begins on the rightmost point in the line in front of the Prince. All pieces move one space to an empty adjacent spot along the lines. A piece may capture an adjacent opponent's piece by hopping over it to an empty adjacent spot on the opposite side of it. Multiple captures are allowed. Captures are not compulsory and neither are the maximum number of captures. Pieces may only capture other pieces of the same rank or lower. A player wins when they capture all of the opponent's pieces, or by blocking a higher ranking piece from being able to move if it is the only remaining piece belonging to the opponent. If players are left with only one piece each of the same rank, one player may declare single combat, and both pieces must move toward one another until one captures the other. If only the Kings are left on the board the game is a draw.  
(game "Dablot Prejjesne"
    (players {(player S) (player N)})
    (equipment {
        (board (rectangle 7 6 diagonals:Solid) use:Vertex)
        (piece "Cone" Each 
            (or
                ("StepToEmpty")
                ("HopSequenceCapture")
            )
        )
        (piece "Prince" Each
            (or
                ("StepToEmpty")
                ("HopSequenceCapture")
            )		
        )
        (piece "King" Each
            (or
                ("StepToEmpty")
                ("HopSequenceCapture")
            )		
        )
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
    })
    
    (rules 
        (start { 
            (place "Cone1" (expand (sites Bottom) steps:2))
            (place "Cone2" (expand (sites Top) steps:2))
            (place "Prince1" coord:"H4" value:1)
            (place "Prince2" coord:"E9" value:1)
            (place "King1" coord:"I4" value:2)
            (place "King2" coord:"D9" value:2)
        })
        (play
            (if	("SameTurn")
                (or
                    ("HopSequenceCapture" 
                        (from (last To)) 
                    )
                    (move Pass)
                )
                (if ("OneSinglePieceSameRank")
                    (forEach Piece
                        (priority
                            ("HopCapture")
                            ("StepToEmptyToward")
                        )
                    )
                    (forEach Piece)
                )
            )
        ) 
        (end {
            ("CaptureAll" Next)	
            (if ("SingleEnemyHigherPieceBlocked") (result Mover Win))
            (if ("OnlyKings" Next) (result Mover Draw))	
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Hoshi" 
    (players 1) 
    (equipment { 
        (board 
            (union {
                (tri 3) 
                (shift 1 0.87 (rotate 180 (tri 3)))
                (shift 0 3.47 (tri 3))
                (shift -2 2.6 (rotate 180 (tri 3)))
                (shift -3 1.73 (tri 3))
                (shift -2 -0.87 (rotate 180 (tri 3)))
            })
            (values Cell (range 1 9))
        )
        (regions {0 3 1 4 2 5 7 6 8})
        (regions {17 16 14 15 11 13 10 12 9})
        (regions {18 19 20 21 22 23 24 25 26})
        (regions {27 28 29 30 31 32 33 34 35})
        (regions {36 37 38 39 40 41 42 43 44})
        (regions {45 46 47 48 49 50 51 52 53})
        (regions {36 39 41 43 44 33 31 28})
        (regions {47 37 40 42 35 34 32 30 27})
        (regions {51 49 46 38 18 21 23 25 26})
        (regions {53 52 50 48 45 11 19 22 24})
        (regions {0 3 5 7 8 15 13 10 20})
        (regions {1 4 6 17 16 14 12 9})
        (regions {53 52 51 49 47 37 39 41})
        (regions {0 50 48 46 38 40 42 43 44})
        (regions {1 3 5 45 35 34 33 31 29})
        (regions {2 4 6 7 8 18 32 30 28})
        (regions {17 16 15 13 11 19 21 23 27})
        (regions {14 12 10 20 22 24 25 26})
        (regions {2 4 1 3 0 50 52 51})
        (regions {17 6 7 5 45 48 46 49 47})
        (regions {14 16 15 8 38 40 37 39 36})
        (regions {9 12 10 13 11 35 42 43 41})
        (regions {20 22 19 21 18 32 34 33 44})
        (regions {24 25 23 27 30 28 31 29})
    }) 
    (rules
        (start <Challenge>)
        (play
            (satisfy {
                (all Different)
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)
Hoshi is a variant of Sudoku played on triangle basis.Hoshi Sudoku consists of six large triangles. You must place the numbers 1-9 into the triangular cells of each large triangle. Every line, even an uncontinuous line, contains every number only once. 

Construct a Ludii game based on the following description
SnipSnip is an outgrowth of 'Tri-It-Out', a pattern capture game, in which the capture pattern involves pieces of both player's symmetrically, and is used to exclude captured sites from immediate replacement. SnipSnip uses more local capture patterns: options of between, or diagonally between, opposing pieces. These patterns are self-limiting in the sense of not allowing cyclic captures.
            
            These capture patterns dictate dead sites that typically result in alternating linear and honeycomb arrangements of pieces with tactical exceptions.
            
            In addition the goal of 'SnipSnip' is changed from 'Tri-It-Out's 'most pieces' to 'largest Group', which creates greater drama and opportunities for turn-around tactics, and is the reason for the SnipSnip name.
            
        'Tri-It-Out' is Misere. 'SnipSnip' also includes non-Misere variants.SnipSnip is a 2-player strategy game
            It may be played: 
            -- on a hex grid
            -- on a square grid
            -- on a square plus diagonal grid
            Goal: Largest Group (in Misere, the largest Group loses.)
            
            Definitions:
            A Group is a set of all the pieces that can be reached from any one of them by a series of steps, where a step means movement from one piece to another of the same color, next to it.
            
            Note: For the Diagonal-Linked Group options a step also include diagonals (double-steps that are not in the same grid direction).
            
            A site is a board intersection.
            
            'Between' Variant:
            -- A Capture site is any site adjacent to two stones of opposite color in the same line (i.e. directly between them.)
            
            'Diagonal' Variant:
            -- A Capture site is any site adjacent to each of two stones of opposite color, where those stones are not on the same grid-line.
            
            Play:
            Players take turn, starting on an empty board with White to play.
            
            On a turn
        1) The mover places to an empty site that is not a Capture site.
    2) Then, if possible, the mover removes one of the opponent's checkers from a Capture site that lies adjacent to the placement just made.
    
    In the case of Misere, the mover must take an additional turn after each capture.
    
    Otherwise, the next player becomes the mover.
    
    The game ends when no placement is possible.
In the case of a tie, the player who would have been next to place loses. Misere: Score one negative point for each stone in your largest group of adjacent stones Capture opponent's stones between your stone and an opponent's stone in a line of 3. Board & size: Hexhex with edges alternating 2 and 4
(game "SnipSnip"
    (players 2)
    (equipment
        {
        (board <Board:size> use:Vertex)
        (piece "Ball" Each)
        }
    )
    (rules
        (start
            {
            (set Score Each 0)
            }   
        ) 
        (play
            (if
                (= 1 (value Player Mover))
                (move Remove (<Pattern:capture> Next)
                    (then
                        (and
                            {
                            (set Value Mover 0)
                            <Scoring:forcedTurns> 
                            }
                )))
                (move Add
                    (to <Pattern:placement>)
                    (then
                        (if
                            (< 0
                                (count Pieces 
                                    in:(<Pattern:capture> Next)
                            ))
                            (set Value Mover 1 
                                (then 
                                    (moveAgain)
                )))))
                (then <Scoring:option>)
        ))
        (end 
            {
            
            (if 
                (and
                    (no Moves Next)
                    (= (score P1) (score P2))
                )
                (result Next Loss)
            )
            
            (if 
                (and
                    (no Moves Next)
                    (!= (score P1) (score P2))
                )
                (byScore)
            )
            }
        )
    )
)

Construct a Ludii game based on the following description
Lifeline is a territorial elimination game for two players. It was invented by Michael Amundsen and Luis Bolanos Mures in February 2022, and was inspired by Go and Kanare Kato's Meridians.Lifeline is a territorial strategy game for two players (Black and White) that is played on the cells of an initially empty hexhex board. The recommended board sizes are between 3 and 12 cells per side.
            
            Definitions:
            
            A group is an entire set of connected stones of the same color. A single stone, not connected to others of its color, is also a group.
            A group is dead if there is no path of connected empty cells between that group and any other of its color.
            
            Play:
            
            On your turn, perform the following actions in the stated order:
            
            1. Place a stone of your color on an empty cell. If it is your first turn of the game, perform this action twice.
            2. Remove all dead enemy groups.
            3. Remove all dead friendly groups.
            
            The board positions at the start and at the end of your turn must be different.
            
            The last player to make a placement wins. Note that, after your first turn, you will always have a placement available unless you have no groups on the board.
            
            To make the game fair, White will have the option, on their first turn only, to swap sides with Black instead of making a regular move.
            
            Note that, in this implementation, the two stones you place on your first turn are only visible after both cells to place on have been selected.
            
            Alternative balancing methods:
            
            The balancing method described above is what is called 'strong pie' in the options. 
            This implementation also offers two other methods, for players who would like to explore alternatives.
            
            Weak pie: Just like with strong pie, White will have the option, on their first turn only, to swap sides with Black instead of making a regular move.
            But instead of placing twice on their first move, players alternate placing one piece each (with no removals) until 4 setup stones are placed.
            Consequently, White's choice will be made after Black has placed only one stone.
            
            Komi pie: The first player chooses a whole number of komi (between 1 and 12) and the second player chooses whether to play as White (pass) or as Black (place a stone).
            The first 4 stones are placed in the same order as with weak pie (Black, White, Black, White).
            Throughout the game proper, White will have the option to spend a point of komi instead of making a placement.
        A point of komi is spent by clicking the shield icon next to White's name. The strong pie rule is currently in force. A board of size 3 is currently selected.
(game "Lifeline" 
    (players 2) 
    (equipment { 
        (board (dual <Board>)) 
        (piece "Disc" Each) 
        (piece "Shi_Western" P2) 
        (hand P2)
    })
    (rules 
        <Balance:meta>
        <Balance:start>
        phases:{
        <Balance:setup>
        (phase "Play"
            (play 
                (or
                    ("SpendKomi")
                    ("Place"
                        (then 
                            ("Remove" Enemy 
                                (then ("Remove" Mover ~))
                            )
                        )
                    )
                )
            )
        )
        }
        (end 
            (if
                (and (no Moves Next) (< 2 (count Moves)))
                (result Next Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Rampart"
    (players 2)
    (equipment {
        (board (square <Size>) use:Vertex)
        (piece "Disc" Each)
    })
    (rules
        (start {
            (place "Disc1" 
                (forEach 
                    (sites Phase 0) 
                    if:(and {
                        (is Even (row of:(site)))
                        (!= 0 (% (site) 4))
                        (= 0 (% (row of:(site)) 4))
                    })
                )
            )
            (place "Disc2" 
                (forEach 
                    (sites Phase 0) 
                    if:(and {
                        (is Even (row of:(site)))
                        (!= 0 (% (site) 4))
                        (= 2 (% (row of:(site)) 4))
                    })
                )
            )
        })
        (play
            (or
                ("Place")
                ("Remove")
            )
        )
        (end ("CaptureAll" Next))
    )
)
Rampart is an annihilation game in which players grow a set number of groups attempting to capture the opponent's groups.Play starts with black. On his turn a player may either drop a stone of his color or remove a dead enemy group. Players may only legally drop stones adjacent to at least one of their stones already on the board. For boards sized 11x11 and smaller a group is considered dead if any stone within it meets the following criteria.
            
        a)The stone has no empty points orthogonally adjacent
    b)The stone has at least one enemy stone adjacent
    
For boards larger than 11x11 only the first criterion applies when determining if a group is dead. You may never remove your own dead groups. If a player has no legal move on his turn he must pass. Passing is otherwise not permitted. The player to remove all opposing groups from the board wins. A size 5 board is currently selected

Construct a Ludii game based on the following description
Shatranj Diwana Shah is a game from nineteenth century India that was described by Lala Raja Babu Sahib, Superintendent of the Palace Games Department of Patiala. One Shah plays against the other player's full complement of pieces.8x8 board. One player plays as one Shah, which can move like any of the other pieces. The other player has the usual complement of pieces, as in Chess. Pawns (x8): can move one space forward and capture one space forward diagonally; Rook (x2): can move any number of spaces orthogonally; Elephant (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Shah (x1): can move one space orthogonally or diagonally, but can also move like the horse on its first move, if it has not yet been checked. The pieces are arranged as in Chess, with the Vizier is place to the left of the Shah. Players capture pieces by moving onto a space occupied by an opponent's piece. When a pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When a player can capture the opponent's Shah on the next turn, the Shah is in check, the opponent's next move must free the Shah from check. If the opponent cannot, it is checkmate and the player wins. 
(game "Shatranj Diwana Shah" 
    (players 2) 
    (equipment { 
        (board (square 8)) 
        
        (piece "Pawn" P2 S
            (do
                (or {
                    "StepForwardToEmpty" 
                    ("StepToEnemy" (directions {FR FL}))
                })
                ifAfterwards:(if (is In (last To) (sites Mover "Promotion"))
                    (!= Undefined ("PromotedPiece"))
                    True
                )
                (then ("PromoteIfReach" (sites Mover "Promotion") "PromotedPiece"))
            )
        )
        
        (piece "Boat" P2 ("SlideCapture" Orthogonal))
        (piece "King_noCross" Each
            (if (is Mover P1)
                (or
                    ("LeapCapture" "KnightWalk")
                    ("SlideCapture")
                )
                (or
                    ("StepToNotFriend")
                    (if ("HasNeverMoved" (from))
                        ("LeapCapture" "KnightWalk")
                    )
                    "RememberPieceHasMoved"
                )
            )
        )
        (piece "Elephant" P2 ("SlideCapture" Diagonal))
        (piece "Knight" P2 ("LeapCapture" "KnightWalk"))
        (piece "Queen" P2 ("SlideCapture"))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn2" (sites Row 6))
            (place "King_noCross1" coord:"D1")
            (place "Boat2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8" state:1) 
        })
        
        (play 
            (do 
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
                (then
                    (if (and ("IsPieceAt" "King_noCross" P1 (last To)) ("HasNeverMoved" (where "King_noCross" P2)))
                        (if ("IsInCheck" "King_noCross" P2)
                            (set State at:(where "King_noCross" P2) 0) 
                        )
                    )
                )
            )
        )
        
        (end
            (if 
                (and 
                    ("IsInCheck" "King_noCross" Next)
                    ("NextCanNotMoveToProtect" "King_noCross")
                ) 
                (result Mover Win)
            ) 
        )
    )
)

Construct a Ludii game based on the following description
Kalah is a mancala-style game \The board has two rows of six holes with a larger hole on either end. Play begins with four seeds in each hole. Each player controls the row nearest them. Seeds are sown consecutively in a counterclockwise pattern including the player's own larger hole but not the opponent's. If the last seed is placed in an opponent's empty hole, that seed and any opposite are captured and put in the player's larger hole. If the last seed falls in the larger hole, the player gets another turn. When one player has no seeds in any of their holes, the game ends. The other player captures all of the other seeds, and the player with the most captured seeds wins. 
(game "Kalah" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns"
            (track "Track" "0,ESE,E,ENE,WNW,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 LastSite) (pair P2 FirstSite)}) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 4 to:(union (sites P1) (sites P2))))
        
        (play (move Select 
                (from 
                    (sites Mover) 
                    if:(> (count at:(from)) 0)
                ) 
                (then 
                    (sow
                        apply:(if (= (to) (mapEntry (mover)))
                            (moveAgain)
                            (if (and { 
                                    (is In (to) (sites Mover)) 
                                    (= (count at:(to)) 1) 
                                    (> (count at:("OppositePit" (to))) 0)
                                })
                                (and 
                                    (fromTo 
                                        (from (to)) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:(to))
                                    ) 
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:("OppositePit" (to)))
                                    ) 
                                ) 
                            )
                        )
                        skipIf:(= (to) (mapEntry (next)))
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Place stones in line of sight of the most recent stone until it is trapped. Whoever dominates the trapped area wins.Play on a hexagonal grid composed of hexagons. Use a neutral pawn and black/white checkers. Players take turns moving a neutral pawn around on the board (passing is not allowed). The neutral pawn can move any number of empty points, in any direction in a straight line, but cannot move onto, or jump over occupied points. When a player moves the pawn, first they place a checker of their own color, onto the destination point. Then they move the pawn on top of it. When the pawn is trapped, the game is over. At the end of the game, each player gets a point for each checker of their own color adjacent to the pawn; if the number of adjacent checkers is equal, the checker under the trapped pawn breaks the tie. The person with the highest score wins. Played on a Hexagonal Board. Played on a size 3 board.
(game "HexTrike"
    (players 2)
    (equipment {
        (board (hex <Boundary:shape> <Board>))
        (piece "Ball" Each)
    })
    
    (rules
        (meta (swap))
        <Boundary:cornerSetup>
        phases:{
        (phase "Opening" P1
            (play
                (move Add 
                    (to (sites Empty)) 
                    (then 
                        (set Var (last To))
                    )
                )
            )
            (nextPhase)
        )
        
        (phase "Play"
            (play
                (move Add 
                    (to (sites LineOfSight Empty at:(var)))
                    (then
                        (set Var (last To))
                    )
                )
            )
        )
        }
        
        (end {
            (if 
                (no Moves Next) {
                (if
                    (> ("Nbors" (last To) P1) ("Nbors" (last To) P2)) (result P1 Win)
                )
                
                (if
                    (> ("Nbors" (last To) P2) ("Nbors" (last To) P1)) (result P2 Win)
                )
                
                (if
                    (and (= ("Nbors" (last To) P1) ("Nbors" (last To) P2)) (is Mover P1)) (result P1 Win)
                )
                
                (if
                    (and (= ("Nbors" (last To) P1) ("Nbors" (last To) P2)) (is Mover P2)) (result P2 Win)
                )
                }
            )
        })
    )
)

Construct a Ludii game based on the following description
Sarvatobhadra is a variation on Chaturanga played in medieval India, documented in the Manasollasa. It is played with dice, and one player plays as the king against the opponent's full complement of pieces.Played on an 8x8 board. One player plays as one Raja, the other with the following pieces: 8 Bhata (or Padati; move like Chess pawns but without being able to move two on the first turn); 2 Ashva (horses; move like Chess knights); 2 Gaja (elephants; two spaces in any orthogonal direction, jumping over the first square); 2 Ratha (chariots; moves like a rook in chess); 1 Mantri (counselor; moves one square diagonally in any direction); 1 Raja (king; moves one square in any direction). These are set up along one edge of the board: Ratha-Ashva-Gaja-Mantri-Raja-Gaja-Ashva-Ratha, with the eight Bhata lined up in the row in front of these, as in chess. The player with the full complement of pieces rolls a six-sided die to determine which piece to move: 6=Raja, 5= Mantri, 4=Gaja, 3 = Ashva, 2=Ratha, 1= Bhata. The player with the single Raja can move it according to the moves of any piece. Players take turns moving. When one piece lands on the space occupied by another piece, it is captured. The goal of the player with a full complement of pieces is to block the single Raja so that it cannot move. The Goal of the single Raja is to checkmate the opponent's Raja. 
(game "Sarvatobhadra"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 		
        (dice d:6 from:1 num:1)
        (piece "King_noCross" P1 ("KingMove"))
        (piece "Ferz_noCross" P1 ("QueenMove"))
        (piece "Knight" P1 ("KnightMove"))
        (piece "Elephant" P1 ("ElephantMove"))
        (piece "Rook" P1 ("RookMove"))
        (piece "Pawn" P1
            (or 
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                (then ("PromoteIfReach" (sites Top) "Ferz_noCross"))
            )		
        )
        (piece "King_noCross" P2
            (or {
                ("RookMove")
                ("KnightMove")
                ("ElephantMove")
                ("QueenMove")
                ("QueenMove")
                ("KingMove")
            })
        )
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "King_noCross2" coord:"E8") 
        })
        (play 
            (do
                (if (is Mover P1)
                    (do (roll) 
                        next:(if (= (count Pips) 6)
                            (forEach Piece "King_noCross")
                            (if (= (count Pips) 5)
                                (forEach Piece "Ferz_noCross")
                                (if (= (count Pips) 4)
                                    (forEach Piece "Elephant")
                                    (if (= (count Pips) 3)
                                        (forEach Piece "Knight")
                                        (if (= (count Pips) 2)
                                            (forEach Piece "Rook")
                                            (forEach Piece "Pawn")
                                        )
                                    )
                            ))
                        )
                    )
                    (forEach Piece)
                )
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover (forEach Piece Next)))
            )
        )
        
        (end {
            (if (and {
                    (is Mover P2)
                    ("IsInCheck" "King_noCross" Next)
                    ("NextCanNotMove")
                }) 
                (result P2 Win)
            )
            (if
                (and
                    (is Mover P1)
                    (no Moves P2) 
                )
                (result P1 Win)
            )
            (if
                (and {
                    (is Mover P1)
                    ("IsInCheck" "King_noCross" P1)
                    (no Moves P1)
                })
                (result P2 Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Namudilakunze is a four-row mancala-style board game played by the Ba-Ila people of Zambia. It was played there in the early twentieth century.4x7-10 board (seven most common). One counter in each hole, with the player's leftmost hole in the outer row empty. On the first turn, sowing occurs in a clockwise direction. On the second turn, the player may sow in either direction, but must continue in the chosen direction for the rest of the game. Captures are made when the final counter of a sowing lands in an empty hole in the inner row. Captures are only made from the opponent's opposite outer row hole, and only when their inner row hole is empty. If the final counter lands in an occupied hole, the player picks up these counters and continues sowing. The player who captures all of the opponent's counters wins. Each player has 7 holes.
(game "Namudilakunze" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            {
            <Board:tracks>
            }
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 1 to:(difference (sites Board) (sites { 0 (- (* ("Columns") 4) 1)})))
        )
        
        phases:{
        (phase "FirstTurn"
            (play 
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            ("LastHoleSowed")
                            (sites Mover "Home") 
                        ) 
                        if:(is Occupied (from))
                    )
                    (then
                        (sow
                            "TrackCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (is Occupied ("OppositePit" (to)))
                                        (remove ("OppositePit" (to)))
                                        (if (is Occupied ("OppositeOuterPit" (to)))
                                            (remove ("OppositeOuterPit" (to)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (not (is Next Mover)) "Main")
        )
        (phase "Main"
            (play 
                (or
                    (if (or (>= 0 (value Player Mover)) (= (value Player Mover) 1))
                        (move Select
                            (from 
                                (if 
                                    ("SameTurn") 
                                    ("LastHoleSowed")
                                    (sites Mover "Home") 
                                ) 
                                if:(is Occupied (from))
                            )
                            (then
                                (sow
                                    "TrackCCW"
                                    owner:(mover)
                                    apply:(and
                                        (if (< 1 (count at:(to)))
                                            (moveAgain)
                                            (if (is In (to) (sites Mover "Inner"))
                                                (if (is Empty ("OppositePit" (to)))
                                                    (if (is Occupied ("OppositeOuterPit" (to)))
                                                        (remove ("OppositeOuterPit" (to)))
                                                    )
                                                )
                                            )
                                        )
                                        (if (!= 1 (value Player Mover))
                                            (set Value Mover 1)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (if (or (>= 0 (value Player Mover)) (= (value Player Mover) 2))
                        (move Select
                            (from 
                                (if 
                                    ("SameTurn") 
                                    ("LastHoleSowed")
                                    (sites Mover "Home") 
                                ) 
                                if:(is Occupied (from))
                            )
                            (then
                                (sow
                                    "TrackCW"
                                    owner:(mover)
                                    apply:(and
                                        (if (< 1 (count at:(to)))
                                            (moveAgain)
                                            (if (is In (to) (sites Mover "Inner"))
                                                (if (is Empty ("OppositePit" (to)))
                                                    (if (is Occupied ("OppositeOuterPit" (to)))
                                                        (remove ("OppositeOuterPit" (to)))
                                                    )
                                                )
                                            )
                                        )
                                        (if (!= 2 (value Player Mover))
                                            (set Value Mover 2)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
J'erin is a two-row mancala-style board game played by the Yoruba people of Nigeria.2x6 board. Four counters in each hole. Sowing proceeds in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, the counters are picked up and sowing continues. When the final counter lands in an occupied hole in the player's own row causing it to contain four counters, these are captured and the turn ends. If the final counter falls into an empty hole, the turn ends. If at any point in the sowing a hole in the player's own row is made to contain four counters, they are taken. When there are only eight counters left on the board, the first player to make four counters in a hole captures all the remaining counters. At the end of the game, players place their captured counters four by four into the remaining holes. Players may thus capture holes from the opponent's row, one for every four counters placed in a hole. They may capture from these holes in the next round. Play continues until one player owns no holes. 
(game "J'erin" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (hand Each)
    }) 
    (rules 
        
        (start {
            (set Count 4 to:(sites Track)) 
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))	
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from 
                            (if ("SameTurn")
                                ("LastHoleSowed") 
                                ("OwnedHoles") 
                            )
                            if:(< 0 (count at:(from)))
                        )
                        (then
                            (do
                                (set Var "NumSowed" (count at:(last To)))
                                next:(if (and 
                                        ("EightPiecesOnBoard") 
                                        (not (all Sites (sites Track from:("NextSiteOnTrack" 1 from:(last From) "Track") to:("NextSiteOnTrack" (var "NumSowed") from:(last From) "Track"))
                                                if:(!= 3 (count at:(site)))
                                        ))
                                    )
                                    (forEach Site (sites Board)
                                        (if (is Occupied (site))
                                            (fromTo
                                                (from (site))
                                                (to Cell (handSite Mover))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                    (sow
                                        apply:(if
                                            (if (= 4 (count at:(to)))
                                                (not (is In (to) ("OwnedHoles")))
                                                (!= 0 (count at:(to))) 
                                            )
                                            (moveAgain)
                                        )
                                    )
                                    (then
                                        (and
                                            (forEach Site (intersection ("OwnedHoles") (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed"))))
                                                (if (= 4 (count at:(site)))
                                                    (fromTo
                                                        (from (site))
                                                        (to (handSite Mover))
                                                        count:4
                                                    )
                                                )
                                            )
                                            (set Var "NumSowed" 0)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then (if ("NoPieceOnBoard")
                            (and
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            )
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 4 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 4 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                        (move
                            (from (handSite Mover))
                            (to (sites Mover) if:(is Empty (to)))
                            count:4
                            (then ("RemmemberOwnedHoles" (last To)))
                        )
                        (move
                            (from (handSite Mover))
                            (to (sites Board) if:(is Empty (to)))
                            count:4
                            (then ("RemmemberOwnedHoles" (last To)))
                        )
                    )
                )
            )
            (nextPhase (and (> 4 (count Cell at:(handSite P1))) (> 4 (count Cell at:(handSite P2)))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Banqi is a two-player Chinese board game played on a 4×8 grid, or half of the xiangqi (Chinese chess) board. The pieces, as in Western chess, are placed inside the squares, rather than on the intersections as in Chinese chess.The 32 pieces are shuffled and randomly allocated face-down to squares on the board. 
            
            The first player turns up a piece to begin the game. The color of that first uncovered piece is the color he or she will play in the game. The second player then makes a move, and the two alternate until the game is finished.
            
            There are three kinds of moves. A player may turn a piece face-up, move a piece, or capture an enemy piece. In some game variants, multiple captures may be made in one turn.
            
            Turning a piece face-up is a legal move if there are any face-down pieces on the board. Once revealed, a piece may move, capture, or be captured. 
            
            A player may only move face-up pieces of their own color.
            
            Unlike Xiangqi, all pieces move identically: a piece may move only one square up, down, left, or right. A piece may never move onto a square that is already occupied unless such a move is a legal capture.
            
            A player may only capture with a face-up piece of their own color, and may only capture a face-up piece of the opposing color. In all captures, the captured piece is removed from the board and its square is occupied by the capturing piece.
            
            The pieces are ranked, forming a hierarchy with the general at the top and soldiers at the bottom. Only pieces of equal or lower rank may be captured, with one exception. For instance, a chariot may capture a horse, and the general may capture either, but a horse cannot capture a chariot, and neither can capture the general. The one exception concerns generals and soldiers: the general cannot capture soldiers, and soldiers can capture the general.
            
            In the Hong Kong version, the pieces are ranked in this order: General>Chariot>Horse>Cannon, Advisor>Minster>Soldier. This ranking reflects the approximate value of the corresponding pieces in Xiangqi (though the relative rank of horse and cannon is arguable). All pieces capture exactly as they move: one square up, down, left, or right.
            
        The game ends when a player cannot move, and that player is the loser. Most often, the game is lost because all of a player's pieces have been captured and so he has no pieces to move. However, it is possible for one player to surround all of the other player's remaining pieces in a manner that makes it impossible for them to move. 
(game "Banqi" 
    (players 2)
    (equipment { 
        (board (rectangle 4 8)) 
        
        
        (piece "Jiang" Each ("StepMove")) 
        
        
        (piece "Ju" Each ("StepMove")) 
        
        
        (piece "Ma" Each ("StepMove")) 
        
        
        (piece "Pao" Each ("StepMove")) 
        
        
        (piece "Shi" Each ("StepMove")) 
        
        
        (piece "Xiang" Each ("StepMove")) 
        
        
        (piece "Zu" Each ("StepMove")) 
    }) 
    
    (rules 
        (start { 
            (place Random {"Zu1"} count:5 value:1) (place Random {"Zu2"} count:5 value:1) 
            (place Random {"Pao1"} count:2 value:4) (place Random {"Pao2"} count:2 value:4) 
            (place Random {"Ju1"} count:2 value:6) (place Random {"Ju2"} count:2 value:6) 
            (place Random {"Ma1"} count:2 value:5) (place Random {"Ma2"} count:2 value:5) 
            (place Random {"Xiang1"} count:2 value:2) (place Random {"Xiang2"} count:2 value:2) 
            (place Random {"Shi1"} count:2 value:3) (place Random {"Shi2"} count:2 value:3) 
            (place Random {"Jiang1"} count:1 value:7) (place Random {"Jiang2"} count:1 value:7) 
            (set Hidden {What Who} (sites Board) to:P1)
            (set Hidden {What Who} (sites Board) to:P2)
        })
        
        phases:{
        (phase "Opening" P1
            (play 
                ("RevealAPiece" 
                    (set NextPlayer (player (who at:(last To))))
                )
            )
            (nextPhase Mover "Play")
        )
        (phase "Play" 
            (play 
                (or
                    (forEach Piece)
                    ("RevealAPiece")
                )
            )
        )
        }
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Veloop is an original game with a loop forming goal.                         There are two versions: this shorter Hexagonal grid game, and a longer game played on a square grid.            While the game in theory can cycle cooperatively, in practice it is decisive.                        The concept to form a loop by means of placements that also involve forced stone swapping. This swapping allows for either the surrounding of an opponent's stone with a loop, or enveloping it into a loop, possibly forming the loop with the swap at the same time.                        The game, when played by competitive players, typically needs only a limited space. This is enforced with a minimal board. The board, in turn, affects play by providing greater security for pieces along the edges, and by forcing the board to reach densities that limit move choices.                        This area restriction is offset by a soft phase change that allows placement over existing opponent's pieces when no placement to an empty site would allow swapping. This phase greatly increases the opportunity for game-ending moves by opening up many move choices, but it also allows cycles. To ensure the game is finite, any given site may only be stacked to level 2, and only the visible pieces are swapped.  (On a physical board this would be tracked by stacking)                        If there are no moves left for either player, the game is a draw. However, on all but the smallest board sizes offered here, games typically end with a winner, even before the piece replacement phase is reached.                     The larger size boards additionally minimize the edge effects and the transition to the replacement phase.  Playing on even larger boards, does not affect play very much, other thanto minimize stacking.Goal: Form an orthogonally connected path of friendly stones that surrounds at least one non-friendly stone.
            
            Set-up:
            Two stones, one of each colour, are placed next to each other adjacent to the center of the board. 
            Then Black starts.
            
            Play:  
            Each turn has two parts that both must be completed: A PLACEMENT and a SWAP.
            
            -- The PLACEMENT is made diagonally from a selected stone of the same color.
            
            -- The SWAP is done by exchanging the contents of the 2 cells that lie between the selected stone and the placed stone. For a SWAP to be valid, the contents of these cells must be different, i.e.: two stones of different color, or an empty space and a stone. 
            
            If a turn cannot be completed with a placement to an empty position, the placement must be made by placing on top of an opponent's stone. 
            The placement and swap rules apply to the visible stones and must still be followed.
            
            Voluntary passing is not allowed. When neither player can move, the game ends in a draw.
            
            To help visualise the moves, the 'Show Last Move' option shows an arrow from the placement site to the supporting friendly piece and the swap pieces are to either side of this arrow. 
            
            Optional Variants: 
            -- Larger Board to reduce the strategic effect of the edge cells. / Smaller board to focus on stacked play as a significant part of the game.
        -- Double move protocol for a shorter, more tactical game, that maintains a balance of material on every turn. Order 4 Hexagon Turns alternate
(game "Veloop (Hex)"
    (players 2)
    (equipment {
        (board (renumber (rotate 90 <Board:type>)) use:Cell)
        (piece "Disc" Each)
    })
    (rules
        (start {
            (place "Disc1" <Board:bStart>)
            (place "Disc2" <Board:wStart>)
        })
        (play
            (priority
                ("Placement" (sites Empty))
                ("Placement" (sites Occupied by:Next))
                (then 
                    ("MakeSwap")
                )
            )
        )
        (end 
            (if 
                (!= 0 (+ (score P1) (score P2)))
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
O An Quan is a two-row mancala-style board game played by children in Vietnam.Oval board. Two semi-circles on the ends are stores, the middle section divided into two rows of five squares. Five counters in each of the rows of squares and one large stone in each end space. Sowing begins in any of the squares on the player's side of the board, and proceeds in either direction. Sowing also includes both end spaces. When the final counter is sown, the contents of the next square are picked up and sowing continues. If the end space is the next space, the turn ends. When the space after the one in which the final counter fell is empty, the contents of the hole after the empty hole are captured, including the end spaces. If there is an unbroken sequence of alternating empty and occupied squares, the contents of the occupied squares are captured. If there are two or more empty squares, the turn ends. If at any time the squares in a player's rows are empty, the player must place one of their captured counters into each of their squares. The game ends when both of the large stones in the end spaces are captured. The remaining counters belong to the player on whose row they are placed. The player with the most counters wins, with the large stones counting as ten. A new game begins. Players fill their holes with their captured stones. The player with fewer counters must then \ The rules come from the Mancala World.
(game "O An Quan" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 5 largeStack:True
            {
            (track "TrackCCW" "0,1,E,11,10,W" loop:True)
            (track "TrackCW" "0,6,E,11,5,W" loop:True)
            }
        )
        (piece "Seed" Shared)
        (piece "Ball" Shared)
        (hand Each size:2)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (regions "EndHoles" (sites {"A1" "G1"}))
    }) 
    (rules 
        
        (start {
            (place Stack "Seed" (union (sites Bottom) (sites Top)) count:5)
            (place Stack "Ball" (sites {"A1" "G1"}))
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:
        {
        (phase "Sowing"
            (play
                (or {
                    (if (!= (var "Direction") 2)
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    ("OwnedHoles") 
                                )
                                if:(!= 0 (size Stack at:(from)))
                            )
                            (then
                                (and {
                                    (forEach Value min:1 max:(size Stack at:(last From))
                                        (fromTo
                                            (from (last From) level:(- (size Stack at:(last From)) (value)))
                                            (to ("NextHole" (last From) "TrackCCW" (value)))
                                            stack:True
                                        )
                                    )
                                    (if (or (is In ("NextHole" (last From) "TrackCCW" (+ 1 (size Stack at:(last From)))) (sites "EndHoles")) (>= (size Stack at:(last From)) 10))
                                        (set Var "Direction" 0)
                                        (if (!= 0 (size Stack at:("NextHole" (last From) "TrackCCW" (+ 1 (size Stack at:(last From))))))
                                            (and {
                                                (set Var "Direction" 1)
                                                (moveAgain)
                                                (set Var "Replay" ("NextHole" (last From) "TrackCCW" (+ 1 (size Stack at:(last From)))))
                                            })
                                            (and
                                                (set Var "Direction" 0)
                                                (if (is Occupied ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))))
                                                    (forEach Level ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) FromTop
                                                        (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level)))
                                                            (fromTo
                                                                (from ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                                (to (handSite Mover))
                                                            )
                                                            (fromTo
                                                                (from ("NextHole" (last From) "TrackCCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                                (to (handSite Mover 1))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                })
                            )
                        )
                    )
                    (if (!= (var "Direction") 1)
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    ("OwnedHoles") 
                                ) 
                                if:(!= 0 (size Stack at:(from)))
                            )
                            (then
                                (and
                                    (forEach Value min:1 max:(size Stack at:(last From))
                                        (fromTo
                                            (from (last From) level:(- (size Stack at:(last From)) (value)))
                                            (to ("NextHole" (last From) "TrackCW" (value)))
                                            stack:True
                                        )
                                    )
                                    (if (or (is In ("NextHole" (last From) "TrackCW" (+ 1 (size Stack at:(last From)))) (sites "EndHoles")) (>= (size Stack at:(last From)) 10))
                                        (set Var "Direction" 0)
                                        (if (!= 0 (size Stack at: ("NextHole" (last From) "TrackCW" (+ 1 (size Stack at:(last From))))))
                                            (and {
                                                (set Var "Direction" 2)
                                                (moveAgain)
                                                (set Var "Replay" ("NextHole" (last From) "TrackCW" (+ 1 (size Stack at:(last From)))))
                                            })
                                            (and
                                                (set Var "Direction" 0)
                                                (if (is Occupied ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))))
                                                    (forEach Level ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) FromTop
                                                        (if (= (id "Seed" Shared) (what at:("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level)))
                                                            (fromTo
                                                                (from ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                                (to (handSite Mover))
                                                            )
                                                            (fromTo
                                                                (from ("NextHole" (last From) "TrackCW" (+ 2 (size Stack at:(last From)))) level:(level))
                                                                (to (handSite Mover 1))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if (= 2 ("NumBigPiecesCaptured"))
                            (and {
                                (forEach Site
                                    (intersection (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))
                                    (if (is Occupied (site))
                                        (and
                                            (forEach Level (site) FromTop
                                                (if (>= (level) (/ (size Stack at:(site)) 2))
                                                    (fromTo
                                                        (from (site) level:(level))
                                                        (to (handSite P1))
                                                        stack:True
                                                    )
                                                )
                                            )
                                            (forEach Level (site) FromTop
                                                (if (< (level) (/ (size Stack at:(site)) 2))
                                                    (fromTo
                                                        (from (site) level:(level))
                                                        (to (handSite P2))
                                                        stack:True
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (forEach Site
                                    (union (difference (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) (sites {(mapEntry P1)}))
                                    (if (is Occupied (site))
                                        (forEach Level (site) FromTop
                                            (fromTo
                                                (from (site) level:(level))
                                                (to (handSite P1))
                                                stack:True
                                            )
                                        )
                                    )
                                )
                                (forEach Site
                                    (union (difference (sites (values Remembered "OwnedP2")) (sites (values Remembered "OwnedP1"))) (sites {(mapEntry P2)}))
                                    (if (is Occupied (site))
                                        (forEach Level (site) FromTop
                                            (fromTo
                                                (from (site) level:(level))
                                                (to (handSite P2))
                                                stack:True
                                            )
                                        )
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                            (and
                                (if (and ("NoPieceOnOwnedHoles" P1) (>= (size Stack Cell at:(handSite P1)) ("NumOwnedHoles" P1)))
                                    (forEach Value min:1 max:("NumOwnedHoles" P1)
                                        (fromTo
                                            (from Cell (handSite P1) level:(- (size Stack Cell at:(handSite P1)) (value)))
                                            (to (regionSite (sites (values Remembered "OwnedP1")) index:(- (value) 1)))
                                            stack:True
                                        )
                                    )
                                )
                                (if (and ("NoPieceOnOwnedHoles" P2) (>= (size Stack Cell at:(handSite P2)) ("NumOwnedHoles" P2)))
                                    (forEach Value min:1 max:("NumOwnedHoles" P2)
                                        (fromTo
                                            (from Cell (handSite P2) level:(- (size Stack Cell at:(handSite P2)) (value)))
                                            (to (regionSite (sites (values Remembered "OwnedP2")) index:(- (value) 1)))
                                            stack:True
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (>= 9 (size Stack Cell at:(handSite P1))) 
                        (result P2 Win)
                    )
                    (if (>= 9 (size Stack Cell at:(handSite P2))) 
                        (result P1 Win)
                    )
                    }
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 5 (size Stack Cell at:(handSite Mover)))
                    (move Select
                        (from Cell (handSite Mover))
                        (to ("LeftMostEmpty"))
                        (then
                            (and {
                                (forEach Value min:1 max:5
                                    (fromTo
                                        (from Cell (last From) level:(- (size Stack Cell at:(last From)) (value)))
                                        (to (last To))
                                        stack:True
                                    )
                                )
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 10 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (or (= 8 (count Cell at:(handSite Mover))) (= 9 (count Cell at:(handSite Mover))))
                                        (and {
                                            (forEach Value min:1 max:(- (count Cell at:(handSite Mover)) 5)
                                                (fromTo
                                                    (from Cell (handSite Mover) level:(- (- (size Stack Cell at:(handSite Mover)) 5) (value)))
                                                    (to ("NextLeftMostEmpty"))
                                                    stack:True
                                                )
                                            )
                                            (forEach Value min:1 max:(- 5 (- (count Cell at:(handSite Mover)) 5))
                                                (fromTo
                                                    (from Cell (handSite Next) level:(- (size Stack Cell at:(handSite Next)) (value)))
                                                    (to ("NextLeftMostEmpty"))
                                                    stack:True
                                                )
                                            )
                                            ("RemmemberOwnedHoles" ("NextLeftMostEmpty"))
                                            ("RemmemberOpponentOwnedHoles" ("NextLeftMostEmpty"))
                                        })
                                    )
                                )
                            })
                        )
                    )
                    (then
                        (if (and (is Empty Cell (handSite P1)) (is Empty Cell (handSite P2))) 
                            (if (= (size Stack Cell at:(handSite P1 1)) 2)
                                (and
                                    (fromTo
                                        (from Cell (handSite P1 1) level:1)
                                        (to (mapEntry P1))
                                        stack:True
                                    )
                                    (fromTo
                                        (from Cell (handSite P1 1) level:0)
                                        (to (mapEntry P2))
                                        stack:True
                                    )
                                )
                                (if (= (size Stack Cell at:(handSite P2 1)) 2)
                                    (and
                                        (fromTo
                                            (from Cell (handSite P2 1) level:1)
                                            (to (mapEntry P1))
                                            stack:True
                                        )
                                        (fromTo
                                            (from Cell (handSite P2 1) level:0)
                                            (to (mapEntry P2))
                                            stack:True
                                        )
                                    )
                                    (and
                                        (fromTo
                                            (from Cell (handSite P1 1) level:0)
                                            (to (mapEntry P1))
                                            stack:True
                                        )
                                        (fromTo
                                            (from Cell (handSite P2 1) level:0)
                                            (to (mapEntry P2))
                                            stack:True
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (and (is Empty Cell (handSite P1)) (is Empty Cell (handSite P2))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Xonin Shatar is an alignment game played in Mongolia. This version is played on a more complex board, allowing more movement options.Three concentric squares, with lines connecting the corners and the midpoints of the sides. Two diamonds drawn, one connecting the midpoints of the outer square and intersecting the corners of the second square; the second connecting the midpoints of the second square and intersecting the corners of the central square. Twelve pieces per plays. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. Pieces which are in a three-in-a-row pattern cannot be removed. The player who removes all of the opponent's pieces wins. 
(game "Xonin Shatar (Complex)"
    (players 2)
    
    (equipment { 
        (board
            (add
                (remove
                    (merge {
                        (shift 3 3 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}}))
                        (shift 2 2 (scale 2 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}})))
                        (scale 4 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}}))
                    })
                    vertices:{4}
                )
                edges:{
                {17 19} {17 20} {20 22} {22 19}
                {17 9} {19 11} {22 14} {12 20}
                {21 13} {23 15} {18 10} {16 8}
                {11 9} {9 12} {12 14} {14 11}
                {9 1} {11 3} {6 14} {4 12}
                {0 8} {5 13} {7 15} {10 2}
                }
            )
            use:Vertex
        ) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3")))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3")) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Fettas is an alignment game played in Morocco. It was described by Moroccan immigrants in France, who described games played during their childhood.Three concentric squares, with lines connecting the midpoints of the sides. Eleven pieces per player. Players alternate turns placing a piece on the board. When a player lines up three of their pieces in a row along one of the lines of the board, the player removes one of the opponent's pieces. When all of the pieces are placed, players move their pieces one spot along the lines of the board. The player who captures all of the opponent's pieces wins. 
(game "Fettas"
    (players 2)
    
    (equipment { 
        ("NineMensMorrisBoard") 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~
                (then ("ReplayIfLine3" Orthogonal exact:True))
            )
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:11))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPiece")
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True)) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPiece")
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Damspel is a Draughts game played in Sweden.8x8 checkered board, the dark spaces placed so that the bottom right corner is a dark space. Twelve pieces per player, placed on the dark spaces of the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space, in a forwards or backwards direction. Captures are not compulsory, multiple captures are possible, the maximum capture possible is not required. When a piece reaches the opposite edge of the board from where it started at the end of its turn, it it promoted. If it lands on the edge of the board in the middle of a capturing sequence, it is not promoted. Promoted pieces may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins.
         
(game "Damspel" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 8)) 
    (rules 
        ("WhiteCellsSetup" 3)
        
        (play 
            (if	("SameTurn")
                (if ("IsUnpromoted")
                    (or
                        (move Pass 
                            (then 
                                (forEach Site (sites Next) 
                                    (if ("IsPieceAt" "Counter" Mover (site))
                                        (promote (site) (piece "DoubleCounter") Mover) 
                                    )
                                )
                            )
                        )
                        ("HopCapture" (from (last To)) Diagonal
                            (then ("ReplayIfCanMove" 
                                    ("HopCapture" (from (last To)) Diagonal)
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                )
                            )
                        )
                    )
                    (or 
                        (move Pass)
                        ("HopCaptureDistance" (from (last To)) Diagonal (range 1 (count Rows))
                            (then ("ReplayIfCanMove" ("HopCaptureDistance" (from (last To)) Diagonal (range 1 (count Rows)))))
                        )
                    )
                )
                
                (or
                    (forEach Piece "Counter" 
                        (or 
                            ("StepToEmpty" (directions {FR FL})
                                (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                            )
                            "HopDiagonalCounter"
                        )
                    )
                    (forEach Piece "DoubleCounter" 
                        (or
                            (move Slide Diagonal)
                            ("HopDiagonalDoubleCounter")
                        )
                    )
                )
            )
            
        ) 
        
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
The game is played on the board of Kensington. It follows the rules of Go except when a capture is made, the pieces captured are flipped. 
(game "Lotus" 
    (players 2) 
    (equipment { 
        (board (rotate 90 (tiling T3464 2)) use:Vertex)
        (piece "Marker" Each)
    }) 
    
    (rules 
        (play 
            (or
                (do
                    (move Add
                        (to (sites Empty))
                        (then 
                            "CaptureSurroundedPiece"
                        )
                    )
                    ifAfterwards:"HasFreedom"
                )
                (move Pass (then (addScore Mover 1)))
            )
        )
        
        (end
            (if (all Passed)
                (byScore {
                    (score P1 (+ {(score P1) (size Territory P1) (count Sites in:(sites Occupied by:P1))})) 
                    (score P2 (+ {(score P2) (size Territory P2) (count Sites in:(sites Occupied by:P2)) }))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
This game was designed to meet a challenge of making a territorial game without placement or capture.     It also is a loop-forming game, as territory is defined as the area contained within loops - but the goal is not first to make a loop, but rather territory scoring.        The scoring is unique as far as I know. The score is the product of two factors:     The first factor is the count of all the empty spaces fully surrounded by the player's pieces (edges don't count as an enclosure)    The second factor is the number of distinct regions that a player's pieces enclose. A region includes both empty sites and sites occupied by the opponent.        As a player fills a space to sub-divide it, one factor is traded off for the other.    The board is scaled to be half full with each player having roughly the square of the number of pieces needed to enclose an area equal to the pieces used to enclose it.        Movement is designed to progressively increase density. This moves pieces into contact to form loops, subdived them, and in the extreme, to fill them.     Players determine when their score is optimized and pass successively to end the game.         For flexibility, of movement, pieces can also move to sites of equal friendly density, which makes the game a race with the potential for cooperative cycles.         To prevent cold positions that would cause forced cycling, there is a secondary restriction for this case: pieces most move to have fewer adjacent enemies.         This makes filling an opponent's territory difficult, or impossible if one doesn't already have a presence there.    It also means pieces within or associated with enemy territory have high mobility, and may be used to create or expand territories in the end game (but often at the cost of significantly increasing the other player's score.)        Tie breaker is the last to play loses, in keeping with the nature of a race for the highest score.         This game was designed in consultation with Alexander Brady.Goal: Player with the largest, most complex 'warren' wins.
            
            A warren is the entire networks of friendly stones, that separate areas of the board (enclosures) from each other and from external areas in contact with the board edges.
            
            -- Each distinct enclosure may contain any mixture of empty and enemy occupied sites. 
            -- The sites of an enclosure cannot reach any additional site or reach an edge of the board, except by crossing friendly stones or the connections between them.
            
            The score is the product of warren complexity and free-space. The actual calculation depends on the board grid: see 'Options', below.
            
            Play:
            The player of the light stones starts by moving a single stone.  
            Thereafter play alternates with each play performing two stone-moves on his turn.
            
            Each stone move is in one of the 6 grid directions, either
            -- to an empty cell surrounded by more friendly stones than before, or
            -- alternatively, to an empty cell surrounded by the same number of friendly stones, but fewer other neighbors.
            
            The moving stone may travel any distance, and pass over any number of stones of either player when moving.
            
            A player may pass part or all of his turn.
            
            When both players successively pass their entire turns, the game ends and is scored. 
            The player with the higher score wins.
            
        If the scores are the same, the last player to move, loses. Rabbit Warrens (hex 6,8). Scoring: Product of the number of distinct enclosures, times the total number of empty sites within the enclosures.
(game "Rabbit Warrens"
    (players 2)
    (equipment {
        (board <Board:side> use:Cell)
        (hand P1 size:2)
        (hand P2 size:2)
        (piece "Ball" Each)
        (piece "<Board:shape>" Each)
        (piece "<Board:shape>" Neutral)
    })
    (rules
        (start {
            <Board:white> 
            <Board:black>
            (place "<Board:shape>1" (handSite P1 0) value:0)
            (place "<Board:shape>2" (handSite P2 0) value:0)
            (place "<Board:shape>0" (handSite P1 1) value:0) 
            (place "<Board:shape>0" (handSite P2 1) value:0)  
        })
        (play
            (or
                (move Pass)
                "RabbitMove"
            )
        )
        (end {
            (if 
                (and
                    (= (score P1) (score P2))
                    (all Passed)
                )
            (byScore {(score Mover 0)}) 
        )
        (if 
            (all Passed)
            (byScore)
        )
    })
)
)

Construct a Ludii game based on the following description
Tayam Sonalu is a race game played on  a cross-shaped board played by Tamil people of Sri Lanka. It is closely related to other race games on a cross-shaped board played throughout South Asia.Four 3x8 rectangles, arranged in a cross shape around large central square. Four players. Four pieces per player. Two rectangular four-sided die, each marked as follows: 0, 1, 2, 4. When the throw is 0 and 1, the throw is called Tayam, when it is 0 and 4 it is called Sonal. Pieces enter the board from the central square onto the central row of their arm of the board, proceed down the central row, and then in an anti-clockwise direction around the circumference of the board, and back up the central row of their arm of the board, having to enter the central square with an exact throw. The first counter of each player must be entered with a throw of Tayam. After this, pieces may be entered with a throw of 1, 5, or Sonal, each of which enter the piece on the first square of the central row of their arm. These three throws also grant the player another throw. The throws made after entering a piece are made at once, and then the pieces moved afterward, the undivided value of each throw being used to move a piece. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. If the opponent has two pieces on such a space, they both are sent back to start, but both may reenter the board with a single throw of 1, 5, or Sonal. The first player to place all of their pieces in the central square wins.  
(game "Tayam Sonalu" 
    (players 4) 
    (equipment {
        ("PachisiBoard"
            {
            (track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True)
            (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True)
            (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True)
            (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)
            }
        )
        (hand Each) 
        (dice d:4 faces:{0 1 2 4} num:2)
        (piece "Pawn" Each
            (if ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) ("ThrowValue")))
                (move Remove (from) level:(level))
                (move 
                    (from (from) level:(level))
                    (to
                        ("SiteToMoveOnTrack" from:(from) ("ThrowValue"))
                        if:True
                        (apply
                            (if ("IsEnemyAt" (to))
                                (if ("IsSingletonStack" (to))
                                    (forEach Level (to) FromTop
                                        (fromTo
                                            (from (to) level:(level))
                                            (to (centrePoint))
                                        )
                                    )
                                    (forEach Level (to) FromTop
                                        (fromTo
                                            (from (to) level:(level))
                                            (to (handSite (who at:(to) level:(level))))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )		
        )
        (map "Start" {(pair P1 9) (pair P2 26) (pair P3 52) (pair P4 27)})
    }) 
    (rules 
        (start {
            (place Stack "Pawn1" (handSite P1) count:4)
            (place Stack "Pawn2" (handSite P2) count:4)
            (place Stack "Pawn3" (handSite P3) count:4)
            (place Stack "Pawn4" (handSite P4) count:4)
        })
        
        (play 
            ("RollMove"
                (if (!= 0 ("ThrowValue"))
                    (or
                        (if (and 
                                (is Occupied (handSite Mover)) 
                                (or
                                    (and (= Undefined (value Player Mover)) ("Tayam"))
                                    (and (= 1 (value Player Mover)) (or ("IsSpecialThrow") ("Sonal")))
                                )
                            )
                            (move
                                (from (handSite Mover))
                                (to (mapEntry "Start" Mover))
                                (then
                                    (if (= Undefined (value Player Mover))
                                        (set Value Mover 1)
                                    )
                                )
                            )
                        )
                        (forEach Piece)
                    )
                )
                (then
                    (if (and (not (no Pieces Mover)) (or ("IsSpecialThrow") ("Sonal")))	
                        (moveAgain)
                    )
                )
            )
        )
        
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Ludus Latrunculorum (\Played on a rectangular grid. 6x7 to 14x14. Two players. Pieces move orthogonally. Pieces can be blocked. Custodial captures.  States can be repeated. Rules suggested by Ulrich Schadler in 1994.
(game "Ludus Latrunculorum" 
    (players 2) 
    <Version>
)

Construct a Ludii game based on the following description
Maze is a structure that consists of convoluted paths. The human piece can move to any orthogonal empty cells if the edge belonging to these two cells is empty. After moving a cross is added to the previous cell. The goal is to find the path between the starting point and the door. A lost is encountered in case of no legal moves. The board in Cross+A.
(game "Maze"
    (players 1)
    (equipment {
        (board
            (remove
                (square 20)
                cells:{
                0 20 40 60 80 100 120 140 1 21 41 61 81 2 22 42 62 3 23 4 5 6
                19 39 59 79 99 119 139 159 18 38 58 78 98 17 37 57 77 16 36 15 14 13
                }
            )
        )
        (piece "Marker" Shared)
        (piece "Cross" Neutral)
        (piece "Human" P1
            (move Step 
                Orthogonal 
                (to 
                    if:(and (is Empty (to)) ("NoEdgeBetweenCells" (from) (to)))
                )
                (then 
                    (add 
                        (piece (id "Cross" Neutral))
                        (to (last From))
                    )
                )
            )
        )
        (regions "Exit" {<Board:exit>})
    })
    (rules
        (start {
            (set 
                Shared 
                Edge 
                (union 
                    (sites Outer Edge) 
                    (sites {<Board:walls>})
                )
            )
            (place "Human" 336)
        })
        
        (play (forEach Piece))
        
        (end {
            (if (no Moves Mover) (result Mover Loss))
            (if (is In (where (id "Human")) (sites "Exit")) (result Mover Win))
        })
    )
)

Construct a Ludii game based on the following description
Insanity is a small game played on a board with holes and pegs of two colors.The pieces start with each color on opposite ends of the board, with two empty holes in between. The goal is to move the pieces so that they end up on opposite sides of the board from their starting position. Pieces can only be moved forward. 
(game "Insanity" 
    (players 1) 
    (equipment { 
        (board (rectangle 1 10)) 
        (piece "Marker1" P1 E "MoveOfThePiece") 
        (piece "Marker2" P1 W "MoveOfThePiece") 
    }) 
    (rules
        (start {
            (place "Marker1" (expand (sites Left) steps:3))
            (place "Marker2" (expand (sites Right) steps:3))
        }) 
        (play (forEach Piece))
        
        (end 
            (if 
                (is Target {2 2 2 2 0 0 1 1 1 1}) 
                (result P1 Win) 
            )
        )
    )
)

Construct a Ludii game based on the following description
A scoring game involving diagonals of the board.TURN - On each turn, each player drops a friendly stone on an empty cell. If a diagonal line is full (i.e., there are no empty cells on that diagonal), the player who dropped the last stone achieves so many points as the number of friendly stones on the finished line.
            
            Two lines can be finished on one turn, the player achieves points for both lines (the dropped stone counts twice, once for each diagonal).
            A diagonal line must have at least 2 stones. So, corner cells do not count as diagonals.
            
        GOAL - When all cells are occupied, wins the player with more points. 
(game "Diagonals"
    (players 2)
    (equipment {
        (board (square 8) use:Vertex)
        (piece "Ball" Each)
    })
    (rules
        (play 
            (move Add (to (sites Empty))
                (then
                    (and
                        (if (not (is In (last To) (sites {"A8" "H1"})))
                            (if (all Sites ("DiagonalNESW") if:(is Occupied (site)))
                                (addScore Mover (count Sites in:(forEach ("DiagonalNESW") if:("IsFriendAt" (site)))))
                            )
                        )
                        (if (not (is In (last To) (sites {"A1" "H8"})))
                            (if (all Sites ("DiagonalSENW") if:(is Occupied (site)))
                                (addScore Mover (count Sites in:(forEach ("DiagonalSENW") if:("IsFriendAt" (site)))))
                            )
                        )
                    )
                )
            )
        )
        (end (if (is Full) (byScore))) 
    )
)

Construct a Ludii game based on the following description
Nao Gutiya Baithaneka is a solitaire game played in the Bihar region of India. The player attempts to place nine pieces on a star-shaped board with a distinct pattern of moves.The board is a five-pointed star. The player has nine pieces. The player attempts to place all the pieces on the board. The player choses a point, then moves the piece two spaces in a straight line. The piece may move through a spot occupied by another piece, but must land on an empty space. The player wins by successfully placing all nine pieces.
         
(game "Nao Gutiya Baithaneka"
    (players 1) 
    (equipment { 
        ("StarBoard" 5)
        (hand Each) 
        (piece "Marker" P1 ("HopFriendCapture"))
    }) 
    (rules 
        (start 
            (place "Marker" (handSite P1) count:9)
        )
        
        (play 
            (if (is Even (count Moves))
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                    (then (moveAgain))
                ) 
                (forEach Piece
                    (if (= (from) (last To))
                        (move Hop 
                            (between 
                                if:(or ("IsFriendAt" (between)) (is Empty (between)))
                            )
                            (to if:(is Empty (to)))
                        )
                    )
                )
            )
        )
        (end { 
            (if (and (is Even (count Moves)) ("HandEmpty" Mover)) (result Mover Win))
            (if (no Moves Next) (result Mover Loss))
        })
    )		
)

Construct a Ludii game based on the following description
Nedilmarth is a graph theory game. It is a game for two players on an undirected cyclic graph.The board graph is initially coloured with a neutral colour. Players take turns removing colour from a coloured edge. The game is won by the player who removes the last cycle from the coloured graph. The game is played on the Graph1.
(game "Nedilmarth" 
    (players 2) 
    (equipment { 
        (board <Board:type> use:Edge) 
        (piece "Marker" Neutral) 
    }) 
    (rules
        (start
            <Board:start>
        )
        
        (play
            (move Remove
                (sites Occupied by:Neutral on:Edge)
            )
        )
        (end  
            (if (is Tree Neutral) (result Mover Win))
        )  
    )
)

Construct a Ludii game based on the following description
Hufesay is a two-row mancala-style board game played in the Maychew area of Ethiopia. 2x6 board. Four counters in each hole. Sowing proceeds in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, the contents are picked up and sowing continues. When the final counter falls in an empty hole, the turn ends. If the empty hole is in the player's row, any counters in the opponent's opposite hole are captured. If a player cannot play, they pass their turn until they are able. The player who captures all of the counters wins. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra they draw lots to see who gets an extra hole. Play then begins again as before. Play continues until one player owns all of the holes. 
(game "Hufesay" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions "Home" P1 (sites Bottom)) 
        (regions "Home" P2 (sites Top)) 
        (piece "Seed" Shared)
        (hand Each)
        (map "LeftMost" {(pair P1 0) (pair P2 11)})
    }) 
    (rules 
        
        (start {
            (set Count 4 to:(sites Track)) 
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Sowing"
            (play 
                (or {
                    (move Select 
                        (from 
                            (if 
                                ("SameTurn") 
                                "LastHoleSowed" 
                                ("OwnedHoles") 
                            ) 
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                apply:(if (> (count at:(to)) 1)
                                    (moveAgain)
                                    (if (and 
                                            (is In (to) (sites Mover)) 
                                            (> (count at:("OppositePit" (to))) 0)
                                        )
                                        (fromTo 
                                            (from ("OppositePit" (to))) 
                                            (to (handSite Mover)) 
                                            count:(count at:("OppositePit" (to)))
                                        ) 
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OneRowIsEmpty")
                            (and {
                                (forEach Site (sites (values Remembered "OwnedP1"))
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (handSite P1))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site (sites (values Remembered "OwnedP2"))
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (handSite P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                                (if (>= ("NumCapturedPieces" P1) ("NumCapturedPieces" P2))
                                    (set NextPlayer (player 1))
                                    (set NextPlayer (player 2))
                                )
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 4 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 4 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:4
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 4 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 3 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("LeftMostEmpty"))
                                                count:3
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("LeftMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("LeftMostEmpty"))
                                        })
                                        (fromTo 
                                            (from (handSite Mover))
                                            (to (handSite Next))
                                            count:(count Cell at:(handSite Mover))
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Tavelspel is a game played in northern Sweden during the nineteenth century. This version was documented among Swedish settlers to Dåres, but it was said to have  been much  older, and local to the village.13x13 intersecting lines. Two players. Each player has 26 pieces. Pieces begin on the two lines closest to each player, opposite sides of the board. Pieces move along the lines of the board to an adjacent spot. A piece can be captured by hopping over an opponent's adjacent piece to an empty spot immediately on the opposite side of it. Multiple captures are allowed. The player who captures all of the opponent's pieces wins. 
(game "Tavelspel" 
    (players 2) 
    (equipment { 
        (board 
            (square 13) 
            use:Vertex
        )
        (piece "Marker" Each)
    }) 
    (rules 
        (start { 
            (place "Marker1" (expand (sites Bottom)))
            (place "Marker2" (expand (sites Top)))
        })
        
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")
                    (move Pass)
                )
                (forEach Piece "Marker" 
                    (or
                        ("HopSequenceCapture")
                        ("StepToEmpty")
                    )
                )
            )
        )
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Esa Hex is a variant of the game Hex.The rules are similar to Hex.
            
            Players take turns placing their pieces on one space on the board, with the goal of connecting the opposite sides of the board corresponding to the color of their pieces with a line of pieces.
            
        However, in the first turn, P1 places a piece of their colour as first move. Then, players alternate placing two pieces of their colour per turn. No swap rule is needed. The game is played on a 3x3 board. The game uses the swap rule. The first player to connect their two sides wins.
(game "Esa Hex" 
    (players 2) 
    (equipment { 
        (board 
            (hex Diamond <Board>)
        ) 
        (piece "Marker" Each)
        (regions P1 {(sites Side NE) (sites Side SW) })
        (regions P2 {(sites Side NW) (sites Side SE) })
    }) 
    (rules 
        <Meta:rule>
        
        phases:{
        (phase "Opening" P1 
            (play (move Add (to (sites Empty))))
            (nextPhase "Playing")
        )
        (phase "Playing" 
            (play 
                (move Add (to (sites Empty))
                    (then 
                        (if 
                            (= 0 (count MovesThisTurn)) 
                            (moveAgain)
                        )
                    )
                ) 
            )
        )
        }
        (end (if (is Connected Mover) (result Mover <Result>))) 
    )
)

Construct a Ludii game based on the following description
Daldøs is a capturing game played in Scandinavia. Though it was on the wane in the nineteenth and twentieth centuries, it had somewhat of a revival when it was sold commercially. It was likely to have been much more widespread, as evidenced by its persistence in regional Danish dialects and its similarity to games games in Norway and Finland. It is remarkably similar to the game Tab, played in North Africa and Southwest Asia.Three-row board, outer rows with sixteen holes and the central with seventeen. Sixteen pieces per player, which start the board in each of the holes in the outer row belonging to a player. Two four-sided dice. Players move their pieces according to the throws of the dice, moving one piece the value of one of the dice and another the value of the other die, or one piece the value of both dice. Players move from their row into the central row, and when reaching the end of the central row, proceed into the opponent's row. Opponent's pieces are taken when a player's piece lands in the same spot as the opponent's piece. Players may not move one of their pieces past one of their other pieces. 
(game "Daldos"
    (players 2)
    (equipment {
        (board 
            (merge {
                (rectangle 1 16)
                (shift -1 1 (rectangle 1 17))
                (shift 0 2 (rectangle 1 16))
            })
            {
            (track "Track1" {0..15 32..16 33..48 32..16} loop:True P1)
            (track "Track2" {33..48 32..16 0..15 32..16} loop:True P2)
            }
            use:Vertex
        )
        (regions "AllSites" (sites Board))
        (dice d:4 num:2)
        (piece "Minus" P1 ("MoveAPiece" "Track1"))
        (piece "Minus" P2 ("MoveAPiece" "Track2"))
    })
    (rules 
        (start {
            (place "Minus1" (sites Bottom))
            (place "Minus2" (sites Top))
        })
        (play 
            ("RollEachNewTurnMove"
                (forEach Die 
                    replayDouble:(and (= (face 36) 1) (= (face 37) 1))
                    (forEach Piece
                        (then 
                            (if (not (all DiceUsed))
                                ("ReplayIfCanMove" (forEach Die (forEach Piece)))
                            )
                        )
                    )
                )
            )
        )
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
A chess variant played on a board made of hexagons. invented in 1936 by Władysław Gliński, and first launched in 1949. It is the most popular variant of hexagonal chess.Glinski Chess is played on a hexagonal board with each side having length 6, and each space oriented horizontally. The board has 91 spaces.
            
            Piece Movement:
            * Kings can move one space in any of the 12 directions from the current space. There is no castling.
            * Rooks can slide in any of the six 'adjacent' directions from their current space---North, South, or 60 degrees off either of those.
            * Bishops can slide in the six 'diagonal' directions: West, East, or 30 degrees off due North or 30 degrees off due South. Note that, given the 3-colour colouring of the board, each of the three Bishops remains on the same colour that it started the game on.
            * Queens can make any move that would be available to a Rook or a Bishop on the current space.
            * Knights can leap to any space that is two spaces away in an adjacent direction (North, South, or 60 degrees off either of those), plus one more space 60 degrees off of that direction. Note that a Knight always moves to a space of a different colour than the space it moved from.
            * Pawns can advance one space forward without capturing. They capture by moving to one of the two adjacent spaces 60 degrees left or right of forward. A Pawn on a Pawn start space can advance two spaces forward without capturing, even if it has previously moved (by capturing) to a different Pawn start space than it started the game on. A Pawn can capture an opponent Pawn 'en passant' if the opponent Pawn just advanced two spaces on its previous turn, and the capture direction of the current player's Pawn lands it on the space that the opponent Pawn just skipped over. On reaching the farthest rank in a given file, Pawns are promoted to a Queen, Rook, Bishop, or Knight, as the player chooses.
            
            The game ends on a checkmate or stalemate. By convention, the player that causes the stalemate is awarded 3/4 of a point, while the other player is awarded 1/4 of a point.
            
        Variations: Shift the innermost 3 or 5 Pawns toward the edge of the board by one space, as proposed in A Player's Guide to Table Games, by John Jackson, Stackpole Books, 1975. Pawns in the starting position chosen by Władysław Gliński in 1936
(game "Glinski Chess"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board (rotate 90 (hex 6)))
        
        (piece "King" Each ("KingCaptureStep" All ~))
        (piece "Queen" Each ("SlideCaptureMove" All ~))
        (piece "Rook" Each ("SlideCaptureMove" Orthogonal ~))
        (piece "Bishop" Each ("SlideCaptureMove" Diagonal ~))
        (piece "Knight" Each (move Leap
                "KnightWalk"
                (to if:"IsToEmptyOrEnemy"
                    "CaptureToPieceAndResetCounter"
                )
            )
        )
        
        (piece "Pawn" Each
            (or {
                "StepForwardToEmpty"
                (if "IsFromInStartCell" "PawnStep_Double")
                "PawnCapture_Ortho"
                "EnPassant_Ortho"
                }
                (then
                    (and
                        (if (is In (last To) (sites Mover "PromotionZone"))
                            (moveAgain)
                        )
                        (set Counter)
                    )
                )
            )
        )
        
        (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE)))
        (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE)))
        
        (regions "Region-Dark" (sites Phase 0))
        (regions "Region-Light" (sites Phase 2))
        (regions "Region-Medium" (sites Phase 1))
    })
    
    (rules
        (start {
            (place "King1" coord:"B1")
            (place "Queen1" coord:"A2")
            (place "Rook1" {"A4" "D1"})
            (place "Bishop1" {"A1" "B2" "C3"})
            (place "Knight1" {"A3" "C1"})
            
            (place "King2" coord:"K10")
            (place "Queen2" coord:"J11")
            (place "Rook2" {"H11" "K8"})
            (place "Bishop2" {"K11" "J10" "I9"})
            (place "Knight2" {"I11" "K9"})
            
            (place "Pawn1" <Placement:Pawn1>)
            (place "Pawn2" <Placement:Pawn2>)
        })
        
        phases:{
        (phase "Movement"
            (play
                (if ("SameTurn")
                    ("PromoteTo" (piece {"Queen" "Rook" "Bishop" "Knight"}))
                    (do (forEach Piece)
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
            )
            (end {
                ("Checkmate" "King")
                (if (or
                        (no Moves Mover)
                        (= (counter) 100)
                    )
                    (result Mover Draw)
                )
            })
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Nard"
    (players 2)
    (equipment {
        ("BackgammonBoard" ("BackgammonTracksWithBar" End)) 
        (dice d:6 num:2)
        (map "Bar" {(pair P1 6) (pair P2 19)})
        (regions "FinalQuadrant" P1 (sites {20..25}))
        (regions "FinalQuadrant" P2 (sites {7..12}))
        (piece "Disc" Each
            (forEach Die
                if:("DieNotUsed")
                (if ("IsEndTrack" ("NextSiteFrom" (from) (pips)))
                    (if ("AllPiecesInFinalQuadrant")
                        (move Remove (from))
                    )
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NoEnemyOrOnlyOne" (to))
                            ("HittingCapture" (mapEntry "Bar" Next))
                        )
                    )
                )
                (then ("ReplayNotAllDiceUsed"))
            )
        )
    })
    (rules 
        (start {
            (place Stack "Disc1" 7 count:5) (place Stack "Disc1" 4 count:3) 
            (place Stack "Disc1" 13 count:5) (place Stack "Disc1" 25 count:2)
            (place Stack "Disc2" 20 count:5) (place Stack "Disc2" 17 count:3) 
            (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 12 count:2)
        })
        (play 
            ("RollEachNewTurnMove"
                (priority {
                    ("EnterPieces")
                    (if (is Empty (mapEntry "Bar" Mover)) (max Distance (forEach Piece top:True)))
                })
                (then
                    (if (no Pieces Mover)
                        (if (no Pieces Enemy in:(sites Mover "FinalQuadrant")) (addScore Mover 1) (addScore Mover 2))
                    )
                )
            )
        )
        (end ("EscapeWin"))
    )
)
Nard is a race game from Persia, documented since at least 600 CE. It is thought to be an ancestor to Backgammon and other games, like Japanese Ban-Sugoroku.The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according to the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. The winner gains one point, or two points if the opponent has pieces in their starting quadrant.
         

Construct a Ludii game based on the following description
Galatjan is a two-row mancala-style board game from the island of Celebes in Indonesia. It was played by the Macassar people in the middle of the nineteenth century. Kaudern states that it is played throughout Indonesia. It was customary to play this game during times of mourning.2x6 board with two stores. Seven counters in each hole. Play moves in an anti-clockwise direction and players sow into the store on their right hand side. A move may begin from any of the player's holes except their store. If the last counter falls into the store, they can sow again from any of the holes in their row. If it lands in a hole with counters in it, these are picked up and sowing continues. If the last counter falls into an empty hole the move ends, but if the hole is in the player's own row, any counters in the hole opposite it are captured and placed in the store. When no more moves can be made, a new round begins and each player fills as many holes as they can by putting seven in each. Surplus counters are placed in the store. Any unfilled holes are excluded from play. Play continues until one player cannot fill a hole with seven counters, and the opponent wins. 
(game "Galatjang" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns"
            { 
            (track "Track1" "1,E,ENE,WNW,W" loop:True P1)
            (track "Track2" "12,W,WSW,ESE,E" loop:True P2)
            }
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Bottom))    
        (regions "Home" P2 (sites Top))     
        (map {(pair P1 LastSite) (pair P2 FirstSite)}) 
    }) 
    (rules 
        
        (start {
            (set Count 7 to:(union (sites Bottom) (sites Top))) 
            (forEach Value min:1 max:12 (set RememberValue (value)))
        })
        
        phases:{
        (phase "Round"
            (play 
                (move Select
                    (from 
                        (if 
                            (and (not (is Pending)) ("SameTurn")) 
                            ("LastHoleSowed") 
                            ("PlayableSites") 
                        ) 
                        if:(> (count at:(from)) 0)
                    )
                    (then 
                        (sow
                            "Track"
                            owner:(mover)
                            apply:
                            (if (= (to) (mapEntry Mover))
                                (and (moveAgain) (set Pending))
                                (if (> (count at:(to)) 1)
                                    (moveAgain)
                                    (if (and (is In (to) (sites Mover "Home")) (> (count at:("OppositePit" (to))) 0))
                                        (fromTo 
                                            (from ("OppositePit" (to))) 
                                            (to (mapEntry Mover)) 
                                            count:(count at:("OppositePit" (to)))
                                        )
                                    )
                                )
                            )
                            (then 
                                (if ("NoLegalMoves")
                                    (and 
                                        (forEach Site 
                                            (difference (sites P1 "Home") (sites Empty))
                                            (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site)))
                                        )
                                        (forEach Site 
                                            (difference (sites P2 "Home") (sites Empty))
                                            (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase ("NoLegalMoves") "BetweenRound")
        )
        (phase "BetweenRound"
            (play 
                (if (>= (count at:(mapEntry Mover)) 7)
                    (move
                        (from (mapEntry Mover))
                        (to (intersection (sites Empty) (sites Mover "Home")))
                        count:7
                    )
                    (then 
                        (if ("AllPossibleHolesFilled")
                            (and 
                                (forget Value All)
                                (forEach Site (sites Board)
                                    (if (= 7 (count at:(site)))
                                        (remember Value (site))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase ("AllPossibleHolesFilled") "Round")
        )
        }
        
        (end
            (if ("CaptureEnoughSeed")
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Product is played on an empty 5x5 hexagonal board.GROUP - A connected chain of friendly stones.
            
            TURN - Initially, Black drops one stone of either color, then for the remaining turns players drop two stones of either color.
            
        GOAL - After the board is full, wins the player with the higher product between its two largest groups. If both products are equal, wins the player with less stones on board (note: draws are impossible). 
(game "Product" 
    (players 2) 
    (equipment { 
        (board (hex 5))
        (piece "Marker" Each) 
    }) 
    (rules 
        (play (move Add (to (sites Empty)))) 
        
        (end
            (if (is Full)
                (byScore {
                    (score P1 ("ProductBiggestGroups" P1))
                    (score P2 ("ProductBiggestGroups" P2))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Nsolo is a four-row mancala-style board game played by the Ngoni people of East Africa.4x10-20 board, with even numbers. Two counters in each hole, except the rightmost hole in the inner row of each player, which has zero. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from one other hole on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 10 holes.
(game "Nsolo" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(union {
                    (sites Bottom)
                    (sites Top)
                    (difference (sites P1 "Inner") (sites Right))
                    (difference (sites P2 "Inner") (sites Left))
                })
            )
        )
        
        (play 
            (if (and ("SameTurn") (= (var "Replay") Undefined))
                (move Remove 
                    (sites Next "Home")
                )
                (if ("AllSitesNoMoreThanOne")
                    (move Select
                        (from (sites Mover "Home") if:(and (is Occupied (from)) (is Empty ("NextHole" (from) 1))))
                        (then 
                            (sow
                                "Track"
                                owner:(mover)		
                            )
                        )
                    )
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                (sites {(var "Replay") })
                                (sites Mover "Home") 
                            ) 
                            if:(> (count at:(from)) 1)
                        )
                        (then
                            (sow
                                "Track"
                                owner:(mover)
                                apply:(if (< 1 (count at:(to)))
                                    (if (and 
                                            (is In (to) (sites Mover "Inner"))
                                            (is Occupied ("OppositePit" (to)))
                                        )
                                        (and
                                            (remove ("OppositePit" (to)))
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Var "Replay" Undefined)
                                                    (remove ("OppositeOuterPit" (to)))
                                                })	
                                            )
                                        )
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Bajr is a replacement game played in Mongolia.6x6 board. Two or four players. Three pieces per player, which begin in opposite corners of the board. Players alternate turns moving one piece to an empty adjacent space, orthogonally or diagonally. The first player to place their pieces in the squares in the opposite corner where the opponent's pieces started wins.  The board is a square 6x6 The game involves two players.
(game "Bajr" 
    (players <Players:numPlayers>) 
    (equipment { 
        (board (square <Board:size>)) 
        (piece "Counter" Each "StepToEmpty")
        <Players:home>
    }) 
    (rules 
        (start { 
            <Players:start>
        })
        
        (play (forEach Piece)) 
        
        (end ("FillWin" (sites (player (mapEntry (mover)))))) 
    )
)

Construct a Ludii game based on the following description
Chaturanga is a replacement capture game played in India. This version was described in the Kridakausalya of Harikrna during the nineteenth century.8x8 board. Pieces move as follows: Raja (x1): moves one space in any direction; Mantri (x1): moves any distance orthogonally or diagonally; Ushtra (x2): moves diagonally any distance; Vaha (x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (x2): moves orthogonally any distance. Padati (x8): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja).  
(game "Chaturanga (Kridakausalya)"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        ("ChessKing" "King_noCross")
        ("ChessQueen" "Ferz_noCross")
        ("ChessKnight" "Knight")
        ("ChessBishop" "Elephant")
        ("ChessRook" "Rook")
        ("ChessPawn" "Pawn" ~
            (then
                (if (is In (last To) (sites Mover "Promotion"))
                    (and
                        (promote (last To) (piece "Ferz_noCross") Mover)
                        (fromTo (from (last To)) (to (last From)))	
                    )
                )
            )		
        )
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        
        (play 
            (if (can Move ("Move"))
                ("Move")
                (move Remove (difference (sites Occupied by:Next) (sites Occupied by:Next component:"King_noCross")))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if ("OnlyRajaAndPadati" Next) (result Mover Win))
        })
    )
)

Construct a Ludii game based on the following description
La Chascona is an alignment game played on Fuertaventura in the Canary Islands. It is commonly played by women, who have a reputation for being masters of the game. It is also played by shepherds, who played with pieces that were not easily distinguished between one another, but the players were able to keep track of their own pieces.Three concentric squares, with lines connecting the midpoints of the sides. Nine pieces per player. Players alternate turns placing a piece on the board. When a player places three of their pieces in a line of three along one of the lines on the board, they capture one of the opponent's pieces. When all of the pieces have been placed, players alternate turns moving one of their pieces to an adjacent empty spot on the board. Players cannot capture one of their opponent's pieces which is in a three-in-a-row alignment. The player who either captures seven of their opponent's pieces or blocks the opponent from being able to move wins. 
(game "La Chascona"
    (players 2)
    
    (equipment { 
        ("NineMensMorrisBoard") 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~
                (then ("ReplayIfLine3" Orthogonal exact:True)) 
            )
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:9))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True)) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveEnemyPiece"
                    (forEach Piece)
                )
            )
        )
        }
        
        (end (if (or (no Moves Next) (<= (count Pieces Next) 2)) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
A draughts variant with both orthogonal and diagonal movement and capture.Men can move one step forwards orthogonally or diagonally, or can jump an opponent's adjacent piece to capture it, in any direction. When a man ends its turn on the opposite edge of the board from its starting position, it becomes a king and may move or jump over any number of spaces in any direction. Captures are compulsory and the maximum number of jumps must be made. The first player unable to move, loses. The game is played on a 6x6 board
(game "Omnidirectional Draughts" 
    (players 2) 
    ("DraughtsEquipment" (square <Board>))
    
    (rules 
        
        (start {
            (place "Counter1" (expand (sites Bottom) steps: (- (/ <Board> 2) 2))) 
            (place "Counter2" (expand (sites Top) steps: (- (/ <Board> 2) 2)))    
        })
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves
                        ("HopCounter" (last To)
                            (then 
                                ("ReplayIfCanMove" ("HopCounter" (last To)) 
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                    )
                    (max Moves ("HopSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn))
                )
                (priority {
                    (max Moves
                        (or 
                            (forEach Piece "Counter"
                                ("HopCounter" (from) 
                                    (then 
                                        ("ReplayIfCanMove" ("HopCounter" (last To))
                                            ("PromoteIfReach" (sites Next) "DoubleCounter")
                                        ) 
                                    ) 
                                ) 
                            )
                            (forEach Piece "DoubleCounter" ("HopSequenceCapture" before:(count Rows) after:(count Rows) at:EndOfTurn))
                        )
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions Forwards))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide))
                    )
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
This version of Shatranj, which is played by four players, was played in the Punjab region of what is now Pakistan during the nineteenth century. Players play on two teams.Four players, playing on teams of two. 1 x Shah (king): moves one space orthogonally or diagonally. 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): any distance diagonally; 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. The pieces of one team are arranged with Shahs on the two central squares of the outer rows, then the Pils, ASbs, and Rukhs, with the Sarbaz in the row in front of them. When a piece moves onto a space occupied by an opponent's piece, the opponent's piece is captured. When a Shah can be captured on the next turn, it is in check, and cannot remain in check at the end of that player's turn. When this is not possible, it is checkmate, and that player is out of the game. A team wins by checkmating both opposing Kings, or by capturing all of the opponents' pieces aside from the Kings. If all four Kings are the only remaining pieces, the game is a draw.  
(game "Chatrang" 
    (players {(player N) (player S) (player N) (player S)}) 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn" "InitialPawnMove")
        ("ChessRook" "Rook")
        ("ChessKing" "King_noCross")
        ("ChessBishop" "Elephant")
        ("ChessKnight" "Knight")
    }) 
    (rules 
        
        (start { 
            (place "Pawn1" (intersection (expand (sites Left) steps:3) (sites Row 1)))
            (place "Pawn2" (intersection (expand (sites Right) steps:3) (sites Row 6)))
            (place "Pawn3" (intersection (expand (sites Right) steps:3) (sites Row 1)))
            (place "Pawn4" (intersection (expand (sites Left) steps:3) (sites Row 6)))
            (place "Rook1" {"A1"}) (place "Knight1" {"B1"}) (place "Elephant1" {"C1"}) (place "King_noCross1" coord:"D1") 
            (place "Rook3" {"H1"}) (place "Knight3" {"G1"}) (place "Elephant3" {"F1"}) (place "King_noCross3" coord:"E1") 
            (place "Rook2" {"H8"}) (place "Knight2" {"G8"}) (place "Elephant2" {"F8"}) (place "King_noCross2" coord:"E8") 
            (place "Rook4" {"A8"}) (place "Knight4" {"B8"}) (place "Elephant4" {"C8"}) (place "King_noCross4" coord:"D8")
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
        })
        
        (play 
            (do 
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
                (then
                    (and {
                        ("RemovePiecesIfCheckmate" P1 1)
                        ("RemovePiecesIfCheckmate" P2 2)
                        ("RemovePiecesIfCheckmate" P3 3)
                        ("RemovePiecesIfCheckmate" P4 4)
                    })
                )
            )
        )
        
        (end {
            (forEach NonMover
                if:("IsOffBoard" (where "King_noCross" Player)) 
                (result Player Loss)
            )
            (if 
                (and {
                    (no Pieces Enemy "Pawn") 
                    (no Pieces Enemy "Knight") 
                    (no Pieces Enemy "Elephant") 
                    (no Pieces Enemy "Rook") 
                })
                (result TeamMover Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Atoll is a two player game played on a hexagonal pattern grid. The game starts with eight “islands” of stones surroundingan empty grid. Each player takes possession of an entire set of stones of one color, black or white. Each player owns the islands of his stones’ color. STONE PLACEMENT Players take turns adding their stones to the board, one stone per turn. Black makes the first placement of the game. Each player will always have a placement available on his turn and must
            make one.
            
        OBJECT OF THE GAME To win you must connect two of your islands, which are exactly opposite each other, with a contiguous sequence of your stones. The stones of your islands can be included in the sequence.  
(game "Atoll"
    (players 2)
    (equipment {
        (board 
            (remove
                (rotate 90 (hex Rectangle 13 12))
                cells:{138 139 148 149 0 1 10 11 69 80}
            )
        )
        (piece "Marker" Each)
    })
    (rules
        (start {
            (place "Marker1" (sites {132 133 134 135 131 120 108 97 85 7 6 5 4 8 19 31 42 54}))
            (place "Marker2" (sites {136 137 138 139 64 53 41 30 18 3 2 1 0 121 109 98 86 75}))
        })
        (play (move Add (to (sites Empty))))
        (end 
            (if (is Mover P1)
                {
                (if (or 
                        (is Connected {(sites {132..135}) (sites {4..7})}) 
                        (is Connected {(sites {131 120 108 97 85}) (sites {54 42 31 19 8})}) 
                    )
                    (result Mover Win)
                )
                (if (or 
                        (is Connected {(sites {121 109 98 86 75}) (sites {64 53 41 30 18})}) 
                        (is Connected {(sites {136..139}) (sites {0..3})}) 
                    )
                    (result Mover Win)
                )
                }
            )
        )
    )
)

Construct a Ludii game based on the following description
Altıev (\2x6 board. Three counters in each hole. Sowing occurs from one of the holes in the player's row. If the final counter lands in an occupied hole, these counters are picked up and sowing continues. If the final counter lands in an empty hole in the player's own row, any counters in the opposite row hole are captured. A player wins when the opponent's row is empty. 
(game "Altiev" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))   
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 3 to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (if ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover) 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        apply:(if (> (count at:(to)) 1)
                            (moveAgain)
                            (if (is In (to) (sites Mover))
                                (fromTo 
                                    (from ("OppositePitTwoRows" (to))) 
                                    (to (handSite Mover)) 
                                    count:(count at:("OppositePitTwoRows" (to)))
                                ) 
                            )
                        )
                    )
                )
            )	
        )
        
        (end {
            (if (all Sites (sites P1) if:(= 0 (count at:(site)))) (result P2 Win))
            (if (all Sites (sites P2) if:(= 0 (count at:(site)))) (result P1 Win))
        })
    )
)

Construct a Ludii game based on the following description
Anti-Knight Sudoku is a variant of Sudoku involving the concept of Chess knight move. 
(game "Anti-Knight Sudoku" 
    (players 1) 
    (equipment { 
        (board (square 9) (values Cell (range 1 9))) 
        (regions {Columns Rows SubGrids})
    }) 
    (rules
        (start <Challenge>)
        (play 
            (satisfy { 
                ("NoPairValuesEqualInKnightMove")
                (all Different)
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
Kanji Guti is a two-row mancala-style board game that is played in the Orissa region of India. Is was documented in the early twentieth century.Two rows of seven holes. Twelve counters in each hole, except in the central hole of each row, one of which has one counter and the other is empty. Players do not own a row of holes, rather each player owns the six holes on one side of the central holes. Sowing occurs in an anti-clockwise direction. Neither player may begin sowing from the central holes. When sowing ends, if the next hole after the hole in which the final counter was placed is occupied, these counters are picked up and sown. If this hole is empty, the counters in the hole opposite it are captured. Play continues until all of the counters have been captured. The player who captures the most pieces wins. 
(game "Kanji Guti" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions "Home" P1 (expand (sites Left) steps:2)) 
        (regions "Home" P2 (expand (sites Right) steps:2)) 
    }) 
    (rules 
        
        (start {
            (set Count 1 at:(coord "D1")) 
            (set Count 12 to:(difference (sites Track) (sites Centre))) 
        })
        
        (play 
            (move Select 
                (from 
                    (if 
                        ("SameTurn") 
                        (sites {("NextHole" "LastHolePlayed")})
                        (sites Mover) 
                    ) 
                    if:(< 0 (count at:(from)))
                )
                (then 
                    (sow 
                        apply:(if (> (count at:("NextHole" (to))) 0)
                            (moveAgain)
                            (if (> (count at:("OppositePitTwoRows" ("NextHole" (to)))) 0)
                                (fromTo 
                                    (from ("OppositePitTwoRows" ("NextHole" (to)))) 
                                    (to (handSite Mover)) 
                                    count:(count at:("OppositePitTwoRows" ("NextHole" (to))))
                                )
                            )
                        )
                    )
                )
            )		
        )
        
        (end ("MancalaByScoreWhen" (= 0 ("NumPiecesOnBoard"))))
    )
)

Construct a Ludii game based on the following description
Takuzu, also known as Binairo, is a logic puzzle involving placement of two symbols, often 1s and 0s, on a rectangular grid.Each box should contain a zero or a one. No more than two similar numbers next to or below each other are allowed. Each row and each column should contain an equal number of zeros and ones. Each row is unique and each column is unique. 
(game "Takuzu" 
    (players 1) 
    (equipment { 
        (board (square <Challenge:size>) (values Cell (range 0 1))) 
        (regions {Columns Rows})
    }) 
    (rules 
        (start (set { <Challenge:start> }))
        (play 
            (satisfy {
                (not (is Line 3 Orthogonal))
                (is Unique)
                (is Sum (/ (count Rows) 2))
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
'Goats Wintering' gives the impression of goats gathering into herds in a sheltered area as winter approaches. The goal is to maximize the connections between the goats. However, goats may not be placed too close to others of their kind along sight-lines. So there is tension in who can place and move their goats together most efficiently.The novel movement mechanism is that a goat's movement is restricted to steps that increase its friendly contact, -- or, when increasing friendly contact is not avaiable to it, steps that decrease its contact with competing goats.When goats get close enough to others of their kind, they can then thus move to join a flock and increase the connections. But frequently they will need the presence of the opponent's goats to be able to get this close to their own flocks. This is because goats allow movement choices for any goats near them: isolated goats can't move. So, the tension is in finding places to enter one's goats that are at a suitable range to gather them together.There is capture: Moves that fully surround any of the opponents goats cause those goats to leave the play area. To prevent cycling, the subordinate kind of goat move is not allowed after a pass. This allows a player with a strong lead to pass until the other player runs out of moves and the game ends.        The game is inspired from Infuse by the same Author, but the clumping here is more open and pronounced and clumps are distance-limited, not line-of-sight limited. It may be played on either hex grids with adjacent movement, or square grids with ortho-diagonal diagonal movement.--- Goal: Have the warmest goats at end.  The warmth of you goats is the total number of contacts they have with other goats. To find the winner, it is only necessary to count goat-to-goat contacts between their own kind.
            
            The game start on an empty board. Play alternates.
            
            On a turn either: 
            1. Pass (sometimes this is forced); or 
            
            2. Place a goat on an empty cell that is not too close to another goat of its color: 
            -- If they are in line, they need gap of 2 or 3 spaces (as selected in Options.)
            
            3. Move one of your goats one step with the following condition:
            -- the goat must gain more contacts with adjacent goats of its own kind than before; or 
            
            4. Use the following alternate condition to step-move a goat that cannot move using the previous rule: 
            -- the step must reduce your goat's net contact with enemy goats.  
            
            Exception: Moves using rule 4. are not allowed immediately after the previous player has passed.
            
            Capture
            -- After moving, simultaneously remove all individual enemy goats that have no adjacent space empty.
            -- Capturing does not happen on a passing turn: to capture one must play a piece. 
            
            Ending the game 
            -- The game ends with 2 passes. Then the number of connections are compared. 
            -- In the case of a tie, the last to pass loses.
            
        Variants not implemented: No capture. / Score simple goat count. Edge 2,3 Hex board Placements must leave a gap of 2 spaces if in sight of a friendly piece No graphic on pieces
(game "Goats Wintering"
    (players 2)
    (equipment {
        (board <BoardSize:gridType> use:Cell)
        (piece "Disc" P1)
        (piece "Disc" P2)
    })
    (rules
        (start (set Score Each 0))
        (play
            (or {
                (move Pass)
                ("PlaceOutOfSight")   
                (forEach Piece 
                    (or
                        ("Move2Friends") 
                        (if 
                            (and 
                                (not (was Pass))
                                (not (can Move ("Move2Friends")))
                            ) 
                            ("MoveFromEnemies")
                        )
                    )
                )
                }
            )
        )
        (end 
            {
            (if 
                (and
                    (all Passed)
                    (> (score Mover) (score Next))
                )
                (result Mover Win)
            )
            (if 
                (and
                    (all Passed)
                    (<= (score Mover) (score Next))
                )
                (result Next Win)
            )
            }
        )
    )
)

Construct a Ludii game based on the following description
'Faraday' is a two-player, maximal-group-connection game that can be played on a variety of grids but is best on a hexagonal grid, or on a semiregular triangle-square grid with diagonals.                        The gist of this placement game is that pieces, like localized electric charges, attract opposites and repel similar charges, so placement can only be on cells surrounded by excess of the opposite charge; or else, where at least half of the surounding cells are oppositely charged.                     The result is a conflict between attempting to connect your pieces together, but to do so, needing the opponent's pieces near at hand where they may also obstruct.Goal: End the game with the highest scoring group. A group scores one point for each stone it contains.
            
            Definitions: A group, as in Go, is every stone that can be reached from a selected stone through a series of adjacent stones of the same color.
            
            Play:
            Start with a pie offer of 1 to 3 stones of any color combination. (Player 1 does this by making 3 placements, or passes; after which Player 2 may choose to play, or to have the pieces exchanged with the opposite colors)
            
            Turns alternate.
            
            On a turn, a player places a series of stones, one at a time, (as described below) until no more placements are possible, and then passes. Order of placement matters.
            
            Placements are made to empty cells that:
        -- 1) have more neighbors that are oppositely charged than similarly charged, or
    -- 2) have 3 or more oppositely charged neighbors.
    
    The game ends when neither player can play.
    The largest group for each player is then scored. In case of a tie the last to place a stone loses. 
    
    Variants: 
    Exception for Surplus Charge
Immediately after placing to a cell with 4 or more oppositely charged neighbors, the player MUST, if possible, place the next stone on an otherwise unplayable empty cell with an equal number of both types of charge around it. Triangle-Square Omni-Grid - Recommended Variant Order 4 board Largest orthogonal group scores 1 point per piece.
(game "Faraday"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Ball" P1)
        (piece "Ball" P2)
    })
    (rules
        (meta (no Repeat Positional))
        (start (set Score Each 0))
        phases:{ 
        "PiePhase"
        (phase "Placement" 
            (play
                (move Add 
                    (piece (mover))
                    (to (sites Empty) 
                        if:(or
                            (<= <BoardShape:ForcedFillLevel> (count Pieces Next in:(sites Around (to) <BoardShape:directionsUsed>)))
                            (< 0 
                                (- 
                                    (count Pieces Next in:(sites Around (to) <BoardShape:directionsUsed>))
                                    (count Pieces Mover in:(sites Around (to) <BoardShape:directionsUsed>))
                                )
                            )
                        )
                    )
                    (then 
                        (and
                            {
                            (<Scoring:calculation>)
                            (set Var "Last2Move" (mover))
                            (if (not (no Moves Mover)) (moveAgain))
                            }
                        )
                    )
                )
            )
            (end 
                (if 
                    (all Passed)
                    {
                    (if 
                        (!= (score Mover) (score Next))
                        (byScore)
                    )
                    (if 
                        (and
                            (= (score Mover) (score Next))
                            (= (var "Last2Move") (mover))
                        )
                        (result Mover Loss)
                    )
                    (if 
                        (and
                            (= (score Mover) (score Next))
                            (!= (var "Last2Move") (mover))
                        )
                        (result Mover Loss)
                    )
                    }
                    (byScore)
                )
            )
        )
        }
    )
)

Construct a Ludii game based on the following description
Bára Guti is a game with captures played in the Punjab region of what is now India and Pakistan.The board consists of 5x5 intersecting lines with diagonals of each quadrant. Pieces are placed on the intersections and can move along the lines. Each player has 12 pieces. Pieces can move to one adjacent point. Captures can be made by hopping over an opponent's piece. The goal is to capture all of the opponent's pieces.
            
         
(game "Bara Guti" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Marker" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    (rules 
        ("BeforeAfterCentreSetup" "Marker1" "Marker2")
        
        (play (forEach Piece))
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
This game was reportedly played in Holland in the early nineteenth century. It is essentially Polish draughts, with some pieces which are already promoted at the beginning of the game. The name of the game is unknown.10x10 board. Twenty pieces per player, which begin on the four rows closest to the player. The row of pieces on the edge of the board closest to each player begins with the pieces already as Queens. Pieces move diagonally one space forward, or can jump an adjacent piece belonging to the opponent to capture it. Captures are mandatory, and the maximum number of captures possible must be taken. When pieces reach the opposite edge of the board from where they started, they are promoted to Queen. Queens move any number of spaces diagonally, and jump over any number of opponents' pieces over any distance. When a Queen reaches that edge of the board a second time (or, for the first time if one of those which began the game as a Queen), they are further promoted, gaining the power to move and take orthogonally over any distance. The player who captures all of the opponent's pieces wins.   
(game "Unnamed Dutch Draughts Game" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 10) ~ (piece "CounterStar" Each))
    (rules 
        (start { 
            (place "Counter1" (difference (expand (sites Bottom) steps:3) (union (sites Bottom) (sites Phase 1)) ))
            (place "Counter2" (difference (expand (sites Top) steps:3) (union (sites Top) (sites Phase 1))))
            (place "DoubleCounter1" (difference (sites Bottom) (sites Phase 1)))
            (place "DoubleCounter2" (difference (sites Top) (sites Phase 1)))
        })
        
        (play 
            (if ("SameTurn")
                (if ("IsUnpromoted")
                    (max Moves
                        ("HopInternationalDraughtsStyle" (from (last To))
                            (then 
                                ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To)))
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                    )
                    (if ("IsQueen")
                        (max Moves ("HopDoubleCounter" (from (last To)) before:(count Rows) after:(count Rows) at:EndOfTurn))
                        (max Moves ("HopSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn))
                    )
                )
                (priority {
                    (max Moves
                        (or {
                            (forEach Piece "Counter"
                                ("HopInternationalDraughtsStyle" (from)
                                    (then 
                                        ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To))) 
                                            ("PromoteIfReach" (sites Next) "DoubleCounter")
                                        )
                                    ) 
                                ) 
                            )
                            (forEach Piece "DoubleCounter" ("HopDoubleCounter" (from) before:(count Rows) after:(count Rows) at:EndOfTurn))
                            (forEach Piece "CounterStar" ("HopSequenceCapture" before:(count Rows) after:(count Rows) at:EndOfTurn))
                        })
                    )
                    (or {
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal)
                            (then ("PromoteIfReach" (sites Next) "CounterStar"))
                        )
                        (forEach Piece "CounterStar" (move Slide))
                    })
                })
            )
        )
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Chuka is a puzzle played in Russia. It contains the sowing mechanism seen in many mancala-style board games. Five holes arranged in a circle. One hole is called the Rumba. Two counters in each hole, except the Rumba. The player sows the counters in one direction. When the final counter lands in an occupied hole, the counters in that hole are picked up and sowing continues. When the final counter lands in the Rumba, the player may pick up the counters from any one of the other holes and continue sowing. If the final counter lands in an empty hole that is not the Rumba, they lose. The goal of the player is to accumulate all of the counters into the Rumba.  
(game "Chuka"
    (players 1)
    (equipment {
        (board 
            (concentric {5}) 
            (track "Track" {0 1 3 4 2} loop:True)
            use:Vertex
        )
        (piece "Seed" Shared)
    })
    (rules
        (start (set Count 2 to:"AllSitesNotRumba"))
        (play 
            (move Select
                (from
                    (if 
                        (!= ("Rumba") (value Pending)) 
                        (sites {"LastHole"})
                        ("AllSitesNotRumba")
                    )
                    if:(!= 0 (count at:(from)))
                )
                (then
                    (sow 
                        apply:(if (> (count at:(to)) 1)
                            (set Pending (to))
                        )
                    )
                )
            )
        )
        (end {
            (if ("AllCountersInRumba") (result Mover Win))
            (if 
                (and (= 1 (count at:("LastHole"))) (!= ("LastHole") ("Rumba"))) 
                (result Mover Loss)
            )
        })
    )
)

Construct a Ludii game based on the following description
Seesaw is a Draughts-inspired elimination game invented by Alek Erickson and Michael Amundsen in 2021.Overview:
            In Seesaw the players (North and South) command opposing armies with soldiers that can promote. Your army starts out as a single soldier and your promotion area evolves as you deploy more soldiers. Every time a soldier promotes it grows - first into a 2-stack, then a 3-stack, and so on. 
            
            The central idea of Seesaw is the 2-fold significance of stack-size: 
            (i) Odd-sized stacks move forwards and even-sized stacks move backwards, and 
            (ii) on any given turn, a stack can take as many steps as it likes from 1 up to its size. 
            
            This results in soldiers seesawing up and down the board as their strength increases to the point where the game is forced to conclude in one side completely eliminating the other.
            
            How to play:
            On your turn, you must either make a stack-move, or place a new stack. 
            
            1. Placing a new stack: 
            A newly placed stack will always be of size 1. You may only place a stack on an empty cell next to a cell of your color. These cells are promotion cells, and each cell you place a new stack on automatically turns into a promotion cell of your color.
            
            2. Stackmoves:
            You only ever move one stack per turn, but that stack may be able to move several steps or capture several enemiy stacks, depending on its size.
            The number of steps a stack may take is the number of pieces in it, i.e. its size.
            
            2.1 Noncapturing moves: On turns where you do not have to capture an enemy (see below) all the steps a stack takes is either constrained to the 3 upward directions or to the 3 downward directions, depending on the size and the owner of the stack. South's forward directions are the 3 upward directions, and North's forward directions are the 3 downward directions.
            
            2.2 Capturing moves: If one or more of your stacks can reach an enemy by lifting the restraint on direction, you must capture such a reachable enemy by replacement. If that stack did not spend all its steps reaching the captured enemy, you can, before you end your turn, spend the left-over steps by making a noncapturing move. However, if yet an enemy is in range immediately after you have captured (counting only the steps left over), you must capture again.
            
            3. Promoting: Your odd-sized stacks promote when they end up on a promotion cell belonging to your opponent at the end of your turn. Your even-sized stacks promote when they end up on a promotion cell belonging to you at the end of your turn.
            
        The object of Seesaw is to capture all your opponent's soldiers. More precisely: If, at the end of your turn, your opponent has no stacks on the board, you have won the game. A base 4 board is currently selected
(game "Seesaw"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board (rotate 30 (hex <Board>)))
        (piece "Disc" Each)
        (tile "Hex" Each)
    })
    (rules
        (start {
            (place Stack "Hex1" 0)
            (place Stack "Disc1" 0)
            (place Stack "Hex2" (* <Board> (* 3 (- <Board> 1))))
            (place Stack "Disc2" (* <Board> (* 3 (- <Board> 1))))
        })
        (play
            (if
                (can Move
                    (forEach Piece "Disc" 
                        ("Capture")
                        top:True
                    )
                )
                (forEach Piece "Disc" 
                    ("Capture")
                    top:True
                    (then
                        ("DeductMoves"
                            (then
                                (if
                                    (< 0 (var))
                                    (moveAgain)
                                    ("Promote")
                                )
                            )
                        )
                    )
                )
                (if
                    (< 0 (count MovesThisTurn))
                    (or
                        (forEach Piece "Disc" 
                            ("Step")
                            top:True
                        )
                        (move Pass)
                        (then ("Promote"))
                    )
                    (or
                        (forEach Piece "Disc" 
                            ("Step")
                            top:True
                            (then ("Promote"))
                        )
                        ("Deploy")
                    )
                )
            )
        )
        (end 
            (if 
                (= 0
                    (count Sites
                        in:(sites Occupied by:Next component:"Disc")
                    )
                )
                (result Next Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Tavan Tal is an alignment game played in Mongolia on a pentagonal board.Three concentric pentagons, with lines connecting the corners and the midpoints of each side. Fourteen pieces per player. Players alternate turns placing one of their pieces on an empty spot on the board. When all of the pieces are placed, they alternate turns moving one of their pieces to an empty adjacent spot along the lines of the board. During either phase, when a player places three of their pieces in a row, they may remove one of the opponent's pieces from the board. Pieces which are in a three-in-a-row arrangement cannot be removed from the board. The player who captures all of the opponent's pieces wins.
         
(game "Tavan Tal"
    (players 2)
    
    (equipment { 
        (board
            (add
                (merge {
                    (shift 2 2
                        (merge {
                            (rectangle 1 3)
                            (shift -1.31 0.95 (rotate 108 (rectangle 1 3)))
                            (shift -0.81 2.49 (rotate 216 (rectangle 1 3)))
                            (shift 1.31 0.95 (rotate -108 (rectangle 1 3)))
                            (shift 0.81 2.49 (rotate -216 (rectangle 1 3)))
                        })
                    )
                    
                    (shift 1 1
                        (scale 2
                            (merge {
                                (rectangle 1 3)
                                (shift -1.31 0.95 (rotate 108 (rectangle 1 3)))
                                (shift -0.81 2.49 (rotate 216 (rectangle 1 3)))
                                (shift 1.31 0.95 (rotate -108 (rectangle 1 3)))
                                (shift 0.81 2.49 (rotate -216 (rectangle 1 3)))
                            })
                        )
                    )
                    
                    (scale 3
                        (merge {
                            (rectangle 1 3)
                            (shift -1.31 0.95 (rotate 108 (rectangle 1 3)))
                            (shift -0.81 2.49 (rotate 216 (rectangle 1 3)))
                            (shift 1.31 0.95 (rotate -108 (rectangle 1 3)))
                            (shift 0.81 2.49 (rotate -216 (rectangle 1 3)))
                        })
                    )
                    
                })
                edges:{
                {26 16} {16 6} {5 15} {15 25} {29 19} {19 9} {7 17} {17 27} {28 18} {18 8} {22 12} {12 2}
                {1 11} {11 21} {20 10} {10 0} {3 13} {13 23} {24 14} {14 4}
                }
            )
            use:Vertex
        ) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3")))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:14))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3")) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Forge is a two-player game played on an NxM square board. I will consider here an 8x6 board.MOVEMENT - A stone must move as far as it can (no jumps) in a forward direction (orthogonal or diagonal). 
            - At the first move, a player may choose any of his stones to move.
            - After that, a player must move a stone that is adjacent to the last moved enemy stone. If that is not possible, the player may choose any unblocked of his stones to move. 
            - There is no capturing.
            
        GOAL  - Wins the player that moved the last stone. 
(game "Forge" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (rectangle 8 6) use:Vertex)
        (piece "Ball" Each (move Slide (directions Forwards of:All))) 
    }) 
    (rules 
        (start {
            (place "Ball1" (expand (sites Bottom)))
            (place "Ball2" (expand (sites Top)))
        })
        phases:{
        (phase "Opening"
            (play (forEach Piece))
            (nextPhase "Main")
        )
        (phase "Main"
            (play
                (priority {
                    (forEach Piece
                        (move Slide 
                            (from (from) if:(is In (from) (sites Around (last To) All)))
                            (directions Forwards of:All)
                        )
                    )
                    (forEach Piece)
                })	
            )
        )
        }
        
        (end ("BlockWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "Sujjua"
    (players 2)
    (equipment {
        ("NineMensMorrisBoard")
        (piece "Marker" Each ("StepToEmpty" Orthogonal))
        (hand Each)
    })
    (rules 
        (start (place "Marker" "Hand" count:9))
        (play
            (or
                (if ("HandOccupied" Mover)
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty))
                    ) 
                )
                (forEach Piece)
            )
        )
        (end ("Line3Win" Orthogonal))
    )
)
Sujjua is a game of alignment played in India. In the Karwi subdivision, it is played in the meeting place of the village. It is also found as graffiti on a ruined temple nearby, leaving the possibility open that the game is much older.Three concentric squares with lines connecting their midpoints. Nine pieces per player. Players alternate turns placing pieces on the board or moving one piece on the board to an adjacent empty spot. The first player to get three of their pieces in a row wins. 

Construct a Ludii game based on the following description
Pretwa is a game played in India by the same rules of Alquerque, but with a circular board.Each player begins with nine pieces. Pieces moves along the lines to the next intersection point. Players may hop an opponent's piece to capture it. Captures can be made in sequence if another capture is available after the previous one is made. The player who captures all of their opponent's pieces wins. The player loses when he has no piece.
(game "Pretwa" 
    (players 2) 
    (equipment { 
        (board (concentric {1 6 6 6}) use:Vertex)
        (piece "Counter" Each 
            (or 
                ("HopRotationalSequenceCapture") 
                ("StepRotationalToEmpty") 
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Counter1" (sites {2..4 8..10 14..16}) )
            (place "Counter2" (sites {1 6 5 7 12 11 13 18 17}))
        })
        
        (play 
            (if "SameTurn"
                (or
                    ("HopRotationalSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end <End>) 
    )
)

Construct a Ludii game based on the following description
Gifia is a two-row mancala-style board game that was played in the early twentieth century in Nigeria. 2x4 board with two stores on the ends. Six counters in each hole. Instead of owning the row of holes closest to them, players own the holes on the left half of the board. Play begins from any of the player's holes, sowing in either direction. When the last counter is sown, making the hole contain two or four counters, these are captured. If the adjacent holes also contain two or four counters, these are also captured. If the last counter falls into a hole, making it contain a number other than two or four, and adjacent holes contain two or four, the counters from only one of these adjacent holes may be captured. Play ends when each player is reduced to one counter. A second round begins with each player placing six counters in as many of their holes as they can, returning surplus to the store. Play continues as before. Rounds are played until one player loses all their counters. 
(game "Gifia" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 4
            {
            (track "TrackCCW" "1,E,N,W" loop:True)
            (track "TrackCW" "4,W,N,E" loop:True)
            }
        )
        (regions P1 (difference (expand (sites Left) steps:2) (sites Left))) 
        (regions P2 (difference (expand (sites Right) steps:2) (sites Right))) 
        (map {(pair P1 FirstSite) (pair P2 LastSite)})       
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 6 to:(sites Track)))
        
        phases:{
        (phase "Sowing"
            (play 
                (if ("SameTurn") 
                    (or
                        (move 
                            (from (ahead ("LastHole") W))
                            (to (mapEntry Mover))
                            count:(count at:(ahead ("LastHole") W))
                        )
                        (move 
                            (from (ahead ("LastHole") E))
                            (to (mapEntry Mover))
                            count:(count at:(ahead ("LastHole") E))
                        )
                    )
                    (or
                        (move Select
                            (from
                                (sites Mover)
                                if:(is Occupied (from))
                            )
                            (then
                                (sow
                                    "TrackCCW"
                                    apply:(if 
                                        (or
                                            (= 2 (count at:(to)))
                                            (= 4 (count at:(to)))
                                        )
                                        (and {
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:(count at:(to))
                                            )
                                            (if ("WestHoleExist")
                                                (if 
                                                    (or
                                                        (= 2 (count at:("WestHole")))
                                                        (= 4 (count at:("WestHole")))
                                                    )
                                                    (fromTo
                                                        (from ("WestHole"))
                                                        (to (mapEntry Mover))
                                                        count:(count at:("WestHole"))
                                                    )
                                                )
                                            )
                                            (if ("EastHoleExist")
                                                (if 
                                                    (or
                                                        (= 2 (count at:("EastHole")))
                                                        (= 4 (count at:("EastHole")))
                                                    )
                                                    (fromTo
                                                        (from ("EastHole"))
                                                        (to (mapEntry Mover))
                                                        count:(count at:("EastHole"))
                                                    )
                                                )
                                            )
                                        })
                                        (if 
                                            (and
                                                (if ("WestHoleExist")
                                                    (if 
                                                        (or
                                                            (= 2 (count at:("WestHole")))
                                                            (= 4 (count at:("WestHole")))
                                                        )
                                                        False
                                                    )
                                                )
                                                (if ("EastHoleExist")
                                                    (if 
                                                        (or
                                                            (= 2 (count at:("EastHole")))
                                                            (= 4 (count at:("EastHole")))
                                                        )
                                                        False
                                                    )
                                                )
                                            )
                                            (moveAgain)
                                        )
                                    )
                                )
                            )
                        )
                        (move Select
                            (from
                                (sites Mover)
                                if:(is Occupied (from))
                            )
                            (then
                                (sow
                                    "TrackCW"
                                    apply:(if 
                                        (or
                                            (= 2 (count at:(to)))
                                            (= 4 (count at:(to)))
                                        )
                                        (and {
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:(count at:(to))
                                            )
                                            (if ("WestHoleExist")
                                                (if 
                                                    (or
                                                        (= 2 (count at:("WestHole")))
                                                        (= 4 (count at:("WestHole")))
                                                    )
                                                    (fromTo
                                                        (from ("WestHole"))
                                                        (to (mapEntry Mover))
                                                        count:(count at:("WestHole"))
                                                    )
                                                )
                                            )
                                            (if ("EastHoleExist")
                                                (if 
                                                    (or
                                                        (= 2 (count at:("EastHole")))
                                                        (= 4 (count at:("EastHole")))
                                                    )
                                                    (fromTo
                                                        (from ("EastHole"))
                                                        (to (mapEntry Mover))
                                                        count:(count at:("EastHole"))
                                                    )
                                                )
                                            )
                                        })
                                        (if 
                                            (and
                                                (if ("WestHoleExist")
                                                    (if 
                                                        (or
                                                            (= 2 (count at:("WestHole")))
                                                            (= 4 (count at:("WestHole")))
                                                        )
                                                        False
                                                    )
                                                )
                                                (if ("EastHoleExist")
                                                    (if 
                                                        (or
                                                            (= 2 (count at:("EastHole")))
                                                            (= 4 (count at:("EastHole")))
                                                        )
                                                        False
                                                    )
                                                )
                                            )
                                            (moveAgain)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (then
                        (if ("OneSingleCounterPerPlayer")
                            (and 
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (mapEntry P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (mapEntry P2))
                                        count:(count at:(site))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 6 (count at:(mapEntry P1))) (result P2 Win))
                    (if (> 6 (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                    (if (<= 6 (count at:(mapEntry Mover)))
                        (move
                            (from (mapEntry Mover))
                            (to (sites Mover) if:(is Empty (to)))
                            count:6
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Camelot is a Chess variant invented by George Parker in the late nineteenth century and published by Parker Brothers.The object of the game is to be the first player to occupy the opponent's castle with two of your own pieces, or, to capture all of your opponent's pieces while retaining two or more of your own pieces. Both knights and pawns can move either horizontally, vertically, or diagonally in three ways, as follows: One space in any direction (like a king in chess). This is called a plain move. A leaping move (called cantering) over an adjacent friendly piece to a vacant space immediately beyond. Multiple leaps over a player's own pieces are permitted. Cantering is always optional (never obligatory). A jumping move over an adjacent enemy piece to a vacant space immediately beyond. The enemy piece is captured and removed from the board. As in checkers, multiple jumps are allowed, and capturing is obligatory whenever it is possible. Pawns may make any of the three moves, but only one type of move per turn. Knights have a fourth option: a combination move consisting of a canter immediately followed by a jump (capture). This is called the knight's charge. The knight may, in this single move, perform multiple canters (or just one), followed by multiple jumps (or just one); but the canter(s) must precede the jump(s). A knight may not combine a plain move with a canter or a jump. 
(game "Camelot" 
    (players 2) 
    (equipment { 
        (board 
            (keep 
                (rectangle 12 16) 
                (poly { {0 7} {1 10} {4 13} {12 13} {15 10} {16 7} 
                {16 5} {15 2} {13 0} {3 0} {1 2} {0 5} })
            )
        )
        (piece "Pawn" Each
            (or
                (if (not ("InTheGoal" (from))) ("HopSequence" (from) "OnAFriend" "MoveAgainAfterJumpingFriend"))
                "Step"
            )
        )
        
        (piece "Knight" Each 
            (or
                (if (not ("InTheGoal" (from))) ("HopSequence" (from) "OnAFriend" "MoveAgainAfterJumpingFriend"))
                "Step"
            )
        )
        
        (regions P1 (sites {"A6" "A7"})) 
        (regions P2 (sites {"P6" "P7"})) 
    }) 
    (rules 
        (start {
            (place "Pawn1" {"F4" "F5" "F6" "F7" "F8" "F9" "G5" "G6" "G7" "G8"})
            (place "Knight1" {"F3" "G4" "G9" "F10"})
            (place "Pawn2" {"K4" "K5" "K6" "K7" "K8" "K9" "J5" "J6" "J7" "J8"})
            (place "Knight2" {"K3" "J4" "J9" "K10"})
        })
        
        (play 
            (if "SameTurn"
                (if "WasJumpingAFriend"
                    (if "WasAKnight"
                        
                        (priority {
                            ("HopSequence" (last To) "OnAnEnemy" "MoveAgainAfterJumpingEnemy")
                            (or
                                ("HopSequence" (last To) "OnAFriend" "MoveAgainAfterJumpingFriend")
                                (move Pass)
                            )
                        })
                        (or
                            ("HopSequence" (last To) "OnAFriend" "MoveAgainAfterJumpingFriend")
                            (move Pass)
                        )
                    )
                    ("HopSequence" (last To) "OnAnEnemy" "MoveAgainAfterJumpingEnemy")
                )
                
                (priority {
                    
                    (forEach Site
                        (sites Mover)
                        (if (= (who at:(site)) (mover))
                            (priority {
                                ("HopSequence" (site) "OnAnEnemy" "MoveAgainAfterJumpingEnemy")
                                (or
                                    ("HopSequence" (site) "OnAFriend" "MoveAgainAfterJumpingFriend")
                                    "Step"
                                )
                            })
                        )
                    )
                    
                    (forEach Piece 
                        (move Hop 
                            "OnAnEnemy"
                            (to 
                                if:(if 
                                    ("InTheGoal" (from))
                                    (and 
                                        (is Empty (to)) 
                                        ("InTheGoal" (to))
                                    ) 
                                    (is In (to) "EmptyButNotEnemyGoal")
                                )
                            ) 
                            (then 
                                (if 
                                    (and 
                                        (not ("InTheGoal" (last To))) 
                                        (can Move 
                                            (hop 
                                                (from (last To)) 
                                                "OnAnEnemy"
                                                (to if:(is Empty (to))) 
                                            ) 
                                        ) 
                                    ) 
                                    "MoveAgainAfterJumpingEnemy" 
                                ) 
                            ) 
                        ) 
                    )
                    (forEach Piece)
                })
            )
        )
        
        (end {
            (if ("GoalFilledby" P1 P2) (result P1 Win))
            (if ("GoalFilledby" P2 P1) (result P2 Win))
            (if "NotEnoughPieceForTheMover" (result Mover Win)) 
            (if "NotEnoughPieceForBothPlayer" (result Mover Draw)) 
        }) 
    )
)

Construct a Ludii game based on the following description
Los Palos is a capturing game played by the Chinantec people of Oaxaca, Mexico. Played by two teams, two teams move their pieces along a track in an attempt to capture all of the opponent's pieces. The main track of the board is a row of eleven squares, with both end squares and the central square marked with an X. On the left side, a row of four squares runs under and adjacent to the first four squares of the central row. Perpendicular to the left end square of the central row, there is a square and then three triangles. On the opposite end, below and perpendicular to the right end of the central track is a row of four squares, curving slightly to the right. Above the end square of the central row, a triangular space, adjacent to an oval divided into three. Two teams with two players on each team. Players each start from a different point: one from the right square in the bottom left row, one from one of the triangle spaces on the left, one from the end of the curving track on the right, and the other from one of the spaces in the oval. Three pieces per player. Five sticks, with a flat side and a curved sides, used as dice. The value of a throw is equal to the number of flat sides that land face up; five curved sides up = 5. Players move their pieces from their entry points onto the central track of the board and progressing to the opposite end of the board from where they started. Pieces must move backward when they reach the end of the central track. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is taken. A piece resting on a space marked with an X is safe from capture. The team to successfully capture all of their opponent's pieces wins. 
(game "Los Palos" 
    (players 4)
    (equipment {
        (board 
            (merge {
                (shift 11.3 -3.7
                    (graph 
                        vertices:{ {0 0} {1.3 -1} {2 0} {1.1 0.6} }
                        edges:{{0 1} {1 2} {2 3} {3 0}}
                    )
                )
                (shift 10.4 -2.4
                    (graph 
                        vertices:{ {0 0} {0.9 -1.3} {2 -0.7} {1 0.4} }
                        edges:{{0 1} {1 2} {2 3} {3 0}}
                    )
                )
                (shift 10.1 -1.1
                    (graph 
                        vertices:{ {0 0} {0.3 -1.3} {1.3 -0.9} {1 0.2} }
                        edges:{{0 1} {1 2} {2 3} {3 0}}
                    )
                )
                (shift 10 0 
                    (graph 
                        vertices:{ {0 0} {0.1 -1.1} {1.1 -0.9} {1 0} }
                        edges:{{0 1} {1 2} {2 3} {3 0}}
                    )
                )
                (shift 11 1.87 
                    (graph 
                        vertices:{ {0 0} {0.5 0.5} {0 1} }
                        edges:{{0 1} {1 2} {2 0}}
                    )
                )
                (shift 10 1.87 
                    (graph 
                        vertices:{ {0 0} {-0.5 0.5} {0 1} }
                        edges:{{0 1} {1 2} {2 0}}
                    )
                )
                (shift 10 1.87 (square 1))
                (shift 10 1 (tri 1))
                (shift 1 2 
                    (graph 
                        vertices:{ {1 0} {-0.5 0.87} {0 0} }
                        edges:{{0 1} {1 2} {2 0}}
                    )
                )
                (shift 0 2 
                    (graph 
                        vertices:{ {-1 0} {0.5 0.87} {0 0} }
                        edges:{{0 1} {1 2} {2 0}}
                    )
                )
                (shift 0 2 (tri 1))
                (shift 0 1 (square 1))
                (rectangle 1 11)
                (shift 0 -1 (rectangle 1 4))
            })
            {
            (track "Track1"  "20,W,N1,E" P1 directed:True)
            (track "Track2"  "11,12,S2,E" P2 directed:True)
            (track "Track3"  "6,E1,9,S1,W" P3 directed:True)
            (track "Track4"  "0,1,2,3,4,W" P4 directed:True)
            (track "TrackRight" "14,E,W" directed:True) 
            (track "TrackLeft" "4,W,E" directed:True) 
        })
        ("StickDice" 5)
        (piece "Marker" Each
            (move
                (from (from))
                (to 
                    ("SiteToMoveOnTrack")
                    if:(or 
                        (and (not (is In (to) (sites "SafeSites"))) ("IsEnemyAt" (to)))
                        (is Empty (to))
                    )
                    (apply (if ("IsEnemyAt" (to))
                            (remove (to))
                        )
                    )
                )
                (then ("UpdateState"))
            )
        )
        (map "Throw" {(pair 0 5) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 5)})
        (map "EntryPoint" {(pair 1 20) (pair 2 11) (pair 3 6) (pair 4 0)})
        (regions "SafeSites" (sites {4 14 23}))
        (regions "CentralTrack" (sites {4 5 14 15 19 21..26}))
    })
    (rules 
        (start {
            (place "Marker1" (mapEntry "EntryPoint" P1) count:3)
            (place "Marker2" (mapEntry "EntryPoint" P2) count:3)
            (place "Marker3" (mapEntry "EntryPoint" P3) count:3)
            (place "Marker4" (mapEntry "EntryPoint" P4) count:3)
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
        })
        (play ("RollMove" (forEach Piece)))
        (end ("CaptureAllTeam"))
    )
)

Construct a Ludii game based on the following description
Quendo is a game played by children of the Lunda-Quioco people of Angola. It involves the sowing mechanism of mancala games, but differs from others in that the holes which a player controls are those in which their counters are located, rather than determined by the placement of the holes on the board.4x8 board, played only along the perimeter. One to four counters per hole. Any number of players, holes are distributed equally among the players. Sowing occurs in an anti-clockwise direction. Each player owns the holes in which their counters are located at the beginning of their turn, and they must sow from the leftmost hole. When a counter falls into a hole containing counters belonging to the opponent, this hole and the counters in it are captured by the player, but remain in place and in play. When a player has a single counter and empty holes in from of it, this counter leaps to the next hole occupied by the opponent. The player who captures all of the opponent's holes wins.  1 seed per hole. The board is a 4x8.
(game "Quendo" 
    (players 4) 
    
    (equipment { 
        <Board:board>
        (piece "Seed" Each)
        (hand Each)
    }) 
    
    (rules 
        
        <Board:start>
        
        (play 
            (if (!= 1 (count Pieces Mover))
                (move
                    Select 
                    (from 
                        ("LeftMost") 
                    )
                    (then
                        (sow
                            sowEffect:(if (and (!= (mover) (what at:(to))) (is Occupied (to)))
                                (and
                                    (remove (to) count:(count at:(to)))
                                    (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to)))
                                )
                            )		
                        )
                    )
                )
                (move
                    (from ("LeftMost"))
                    (to 
                        (trackSite FirstSite from:(from) if:("IsEnemyAt" (to)))
                        (apply
                            (and
                                (remove (to) count:(count at:(to)))
                                (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to)))
                            )	
                        )	
                    )
                )
            )
        )
        
        (end 
            (forEach NonMover 
                if:(no Pieces Player) 
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Zamma is a leaping capture game played in North Africa. It has been documented since at least the twentieth century, but is probably much older. It is related to other similar games from the area such as Draughts and Alquerque.Played on a square Alquerque board with 9x9 intersecting lines with diagonals. Each player has 40 pieces. Pieces are placed on the intersections of the lines, and move forward along the lines to an adjacent unoccupied intersection. Once pieces reach the opposite side of the board from their starting position at the end of their turn, they are promoted and can move in any direction and over any distance. Opponent's pieces are captured by jumping them. Captures are obligatory if possible. If a player does not capture when they are supposed to, the opponent may remove that piece immediately and then play as normal. The player who captures all of their opponent's pieces or blocks them from being able to move wins. 
(game "Zamma" 
    ("TwoPlayersNorthSouth")
    (equipment { 
        ("AlquerqueBoard" 9 9)
        (piece "Disc" Each 
            (or
                ("HopDisc") 
                ("StepToEmpty" Forwards (then ("HasNotCaptured")))
                (then ("PromoteIfReach" (sites Next) "DiscDouble"))
            )
        )
        (piece "DiscDouble" Each
            (or
                ("HopDiscDouble") 
                (move Slide (then ("HasNotCaptured")))
            )
        )
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    
    (rules 
        ("BeforeAfterCentreSetup" "Disc1" "Disc2")
        
        (play 
            (or
                (if ("DidNotCaptured")
                    (or
                        (if ("ShouldCapturedButMoved") 
                            ("HuffOnePieceOf" (last To))
                        )
                        ("HuffOnePieceOf" ("SitesWithPossibleCaptureInPreviousTurn"))
                    )
                )
                (do 
                    ("RememberSiteWithPossibleCapture") 
                    next:(forEach Piece)
                )
            )
        ) 
        
        (end (if (no Moves Mover) (result Next Win))) 
    )
)

Construct a Ludii game based on the following description
Seys Dos y As is a race game from medieval Spain that is related to other European Tables games. It is documented in Alfonso X's Libro de los Juegos.2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Both players begin in the same quadrant of the board. One player's pieces are arranged as follows: Eight on the first point of the quadrant to their left, four on the fifth, and three on the sixth. The other player places five on the second, third, and fourth space of the same quadrant. The track proceeds in a clockwise direction around the board. When a player's piece lands on a space occupied by a single piece of the opponent, it is sent back to the beginning of the quadrant to the right of the starting quadrant. Pieces bear off from the quadrant diagonal from the starting quadrant. The first player to bear off all their pieces wins. 
(game "Seys Dos y As"
    (players 2)
    (equipment {
        ("TableBoard"
            {
            (track "Track1" {24 11..0 12..17} P1 directed:True)
            (track "Track2" {25 11..0 12..17} P2 directed:True)
            }
        )
        (dice d:6 num:3)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" ("NextSiteFrom" (from) (pips)))
                    (move Remove (from))
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NoEnemyOrOnlyOne" (to))
                            ("HittingCapture" (handSite Next))
                        )
                    )
                )
                (then ("ReplayNotAllDiceUsed"))
            )		
        )
        (hand Each)
    })
    (rules 
        (start {
            (place Stack "Disc1" 11 count:8) (place Stack "Disc1" 6 count:3) 
            (place Stack "Disc1" 7 count:4) (place Stack "Disc2" (sites {10..8}) count:5) 
        })
        (play 
            ("RollEachNewTurnMove" 
                (or (forEach Piece top:True) (forEach Piece container:(mover) top:True))
            )
        )
        
        (end ("EscapeWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "Temeen Tavag"
    (players 2)
    (equipment {
        <Board>
        (hand Each)
        (piece "Disc" Each "StepToEmpty")
    })
    (rules 
        (start (place "Disc" "Hand" count:2))
        phases:{
        (phase "Placement" 
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        ) 
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("BlockWin"))
    )
)
Temeen Tavag (\An X, with a rounded line connecting the four endpoints of the X, but leaving two unconnected. A circle is drawn between these two unconnected endpoints. Two pieces per player. Players alternate turns placing one of their pieces on an empty point on the board. When all of the pieces are placed, players alternate turns moving one of the pieces to an empty adjacent point on the board, moving along the lines. The player who blocks their opponent from being able to move wins. The board is a circle.

Construct a Ludii game based on the following description
This game is played on the following 10x4 square board.TURNS - At each turn, each player must move one of his stones
            - A stone moves (orthogonal and diagonal) forward to an empty cell.
        GOAL - A player wins by making a (orthogonal or diagonal) 4 in-a-row. 
(game "Roll-Ing to Four"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board (rectangle 10 4) use:Vertex)
        (piece "Ball" Each ("StepToEmpty" (directions Forwards of:All)))
    })
    (rules
        (start {
            (place "Ball1" (sites {"A1" "B1" "C1" "B6" "C6" "D6"}))
            (place "Ball2" (sites {"A5" "B5" "C5" "B10" "C10" "D10"}))
        })
        (play (forEach Piece))
        (end (if (is Line 4 All) (result Mover Win))) 
    )
)

Construct a Ludii game based on the following description
Niranchy is a game of alignment played in Sri Lanka during the nineteenth century. It was a common game played by people of all ages, often played in breaks between \Three concentric squares, with lines connecting the midpoints and diagonals of the squares. Twelve pieces per player. Players alternate turns placing one of their pieces on the board. When all of the pieces are placed, the pieces may be moved to an empty adjacent spot on the board. One player wins  by placing three of their pieces in a row. The other player wins by blocking their opponent from being able to move. Player 1 wins by blocking.
(game "Niranchy"
    (players 2)
    
    (equipment { 
        (board (concentric Square rings:3 joinCorners:True) use:Vertex) 
        (hand Each)
        (piece "Marker" Each ("StepToEmpty")) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end {
            (if (no Moves <Players:player1>) (result <Players:player2> Win))
            (if (is Line 3 <Players:player1>) (result <Players:player1> Win))
        })
    )
)

Construct a Ludii game based on the following description
These rules for Shatranj were reported from early modern Iraq. They are given in a note on an earlier manuscript on Shatranj in the British Library, noting the differences between the contemporary game and that played in the manuscript.8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): Any distance orthogonally or diagonally, or like the Asb. 2 x Rukh (rook): Any number of spaces orthogonally. No castling. 2 x Pil (elephant): Any distance diagonally, jumping over the first. Cannot capture another Pil. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the eighth rank. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it.
         
(game "Shatranj (Iraq)" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        ("ChessKing" "King_noCross")
        (piece "Ferz_noCross"
            (or
                ("SlideCapture")
                ("LeapCapture" "KnightWalk")
            )
        )
        (piece "Elephant"
            (move Slide Diagonal 
                (between if:(or (is In (between) (sites Around (from))) (is Empty (between)))) 
                (to 
                    if:(and (not ("IsPieceAt" "Elephant" Next (to))) ("IsEnemyAt" (to)))
                    (apply 
                        if:(not (is In (to) (sites Around (from))))
                        (if ("IsEnemyAt" (to))
                            (remove (to))
                        )
                    ) 
                ) 
            )		
        )
        ("ChessKnight" "Knight")
        ("ChessRook" "Rook")
        ("ChessPawn" "Pawn" ~ (then ("PromoteIfReach" (sites Mover "Promotion") "Ferz_noCross")))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        (play 
            (do (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (no Moves Mover) (result Mover Loss))
        })
    )
)

Construct a Ludii game based on the following description
Spava is based on Yavalath but adapted to the Shibumi set.Starting with white, each player places a marble on an empty space or platform (2x2 arrangement of marbles). A player wins by making a line of L pieces of their colour orthogonally or diagonally (where L is the layer size) but loses by making a line of L-1 of their colour beforehand (without also making a line of L). Two players. 2x2 square pyramidal board.
(game "Spava" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board (square <Board> pyramidal:True) use:Vertex) 
        (piece "Ball" Each) 
    }) 
    (rules 
        (play 
            (move Add 
                (to (sites Empty) 
                    if:(is Flat)
                )
            )
        )
        (end {
            (if 
                (is Line (- (count Rows) (layer of:(last To))) SameLayer) 
                (result Mover Win)
            )
            (if 
                (is Line (- (- (count Rows) (layer of:(last To))) 1) SameLayer) 
                (result Mover Loss)
            )
        })
    )
)

Construct a Ludii game based on the following description
Russian Fortress Chess is a game that was played in Russia during the eighteenth and nineteenth centuries.12x12 board, with yellow and green squares, with four 4x4 extensions overlapping the 2x2 squares in each corner of the board. There are two walls next to each fortress, one on the outer side of the bottom two squares of the left hand side of each fortress and one on the top edge of the two top left squares. Pieces cannot move across the wall or diagonally across the end of the wall. Four players, white and red play as a team, and black and blue as a team. Players are are arranged as follows, clockwise from the top: red, blue, white, black. Each team has the usual complement of Chess pieces, with an extra Knight, Rook, and Bishop, The pieces are as in chess, with the Kings on the players' right, on the central eight squares of each side of the board. The three extra pieces begin in the 4x4 extension at the player's right, placed anywhere they please. Kings move one square orthogonally or diagonally; Queens move any distance orthogonally or diagonally; Bishops move any distance diagonally; Knights move orthogonally one square and then diagonally another square or diagonally one square and then orthogonally one square (this is important for calculating moves near walls), jumping over any intervening pieces; Rooks move orthogonally any distance; Pawns move forward one space orthogonally, or diagonally one space forward to capture. Pawns may move two spaces on their first turn. When a pawn reaches the back row of one of the other players' sides, it is promoted to any piece. When a player moves a piece onto a space occupied by an opponent's piece, the opponent's piece is captured. When a King can be captured on the next turn, it is in check. The King must not be in check at the end of the player's next turn. If this is impossible, it is checkmate and that player's pieces are removed from the game. The team who checkmates both of their opponents wins. 
(game "Russian Fortress Chess"
    (players {(player S) (player W) (player N) (player E)})
    (equipment { 
        (board 
            (merge {
                (square 4)
                (shift 2 2 (square 12))
                (shift 12 0 (square 4))
                (shift 0 12 (square 4))
                (shift 12 12 (square 4))
            })
        )
        (piece "Disc" Shared)
        (piece "King" Each
            (if (is Active (who at:(from)))
                (or
                    (move Step
                        Orthogonal
                        (to if:(and (not ("IsFriendAt" (to))) ("NoEdgeBetweenCells" (from) (to)))
                            ("CaptureToPiece")
                        )
                    )
                    (move Step
                        Diagonal
                        (to if:(and (not ("IsFriendAt" (to))) ("NoVertexUsedByWallBetweenCells" (from) (to)))
                            ("CaptureToPiece")
                        )
                    )
                )
            )
        )
        (piece "Queen" Each
            (if (is Active (who at:(from)))
                (or
                    (move Slide 
                        Orthogonal
                        (to 
                            if:("IsEnemyAt" (to)) 
                            (apply 
                                if:("NoWallBetweenFromTo" (from) (to))
                                (if ("IsEnemyAt" (to))
                                    (remove 
                                        (to) 
                                    )
                                )
                            ) 
                        ) 
                    )	
                    (move Slide 
                        Diagonal
                        (to 
                            if:("IsEnemyAt" (to)) 
                            (apply 
                                if:("NoWallUsedByVerticesBetweenFromTo" (from) (to))
                                (if ("IsEnemyAt" (to))
                                    (remove 
                                        (to) 
                                    )
                                )
                            )
                        ) 
                    )
                )
            )
        )
        (piece "Knight" Each
            (if (is Active (who at:(from)))
                (move 
                    (from (from))
                    (to 
                        (union
                            (intersection
                                (sites Around 
                                    (forEach (sites Around (from) Diagonal)
                                        if:("NoVertexUsedByWallBetweenCells" (from) (site))
                                    )
                                    Orthogonal
                                    if:(and ("NoEdgeBetweenCells" (from) (to)) (not ("IsFriendAt" (to))))
                                )
                                (sites Distance Orthogonal from:(from) (exact 3))
                            )
                            (intersection
                                (sites Around 
                                    (forEach (sites Around (from) Orthogonal)
                                        if:("NoEdgeBetweenCells" (from) (site))
                                    )
                                    Diagonal
                                    if:(and ("NoVertexUsedByWallBetweenCells" (from) (to)) (not ("IsFriendAt" (to))))
                                )
                                (sites Distance Orthogonal from:(from) (exact 3))
                            )
                        )
                        (apply 
                            if:("IsEnemyAt" (to))
                            (remove (to))
                        )
                    )
                )
            )
        )
        (piece "Bishop" Each
            (if (is Active (who at:(from)))
                (move Slide 
                    Diagonal 
                    (to 
                        if:("IsEnemyAt" (to)) 
                        (apply 
                            if:("NoWallUsedByVerticesBetweenFromTo" (from) (to))
                            (if ("IsEnemyAt" (to))
                                (remove (to))
                            )
                        )
                    ) 
                )	
            )
        )
        (piece "Rook" Each
            (if (is Active (who at:(from)))
                (move Slide 
                    Orthogonal
                    (to 
                        if:("IsEnemyAt" (to)) 
                        (apply 
                            if:("NoWallBetweenFromTo" (from) (to))
                            (if ("IsEnemyAt" (to))
                                (remove 
                                    (to) 
                                )
                            )
                        ) 
                    ) 
                )	
            )
        )
        (piece "Pawn" Each
            (if (is Active (who at:(from)))
                (or { 
                    (if (is In (from) (sites Start (piece (what at:(from)))))
                        ("DoubleStepForwardToEmpty")
                    )
                    (move Step
                        Forward
                        (to if:(and (is Empty (to)) ("NoEdgeBetweenCells" (from) (to))))
                    )
                    (move Step
                        (directions {FR FL})
                        (to if:(and ("IsEnemyAt" (to)) ("NoVertexUsedByWallBetweenCells" (from) (to)))
                            (apply (remove (to)))
                        )
                    )
                    }
                    (then
                        (if (is In (last To) (sites Mover "Promotion")) 
                            (moveAgain)
                        )
                    )
                )
            )
        )
        (hand Each size:3)
        (regions "ExtraSquare" P1 (expand origin:181 steps:3))
        (regions "ExtraSquare" P2 (expand origin:191 steps:3))
        (regions "ExtraSquare" P3 (expand origin:174 steps:3))
        (regions "ExtraSquare" P4 (expand origin:0 steps:3))
        (regions "Promotion" P1 (union (sites {"E3".."L3"}) (sites Bottom)))
        (regions "Promotion" P2 (union (sites {"C5".."C12"}) (sites Left)))
        (regions "Promotion" P3 (union (sites {"E14".."L14"}) (sites Top)))
        (regions "Promotion" P4 (union (sites {"N5".."N12"}) (sites Right)))
    })
    (rules 
        (start {
            (place "Disc" Edge (sites {26 35 278 279 300 325 88 89 36 37 391 382 353 344 396 397}))
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
            (place "King1" coord:"H14") (place "King2" coord:"N9")
            (place "King3" coord:"I3") (place "King4" coord:"C8")
            (place "Queen1" coord:"I14") (place "Queen2" coord:"N8")
            (place "Queen3" coord:"H3") (place "Queen4" coord:"C9")
            (place "Bishop1" (sites {"G14" "J14"})) (place "Bishop2" (sites {"N7" "N10"}))
            (place "Bishop3" (sites {"G3" "J3"})) (place "Bishop4" (sites {"C10" "C7"}))
            (place "Knight1" (sites {"F14" "K14"})) (place "Knight2" (sites {"N6" "N11"}))
            (place "Knight3" (sites {"F3" "K3"})) (place "Knight4" (sites {"C11" "C6"}))
            (place "Rook1" (sites {"E14" "L14"})) (place "Rook2" (sites {"N5" "N12"}))
            (place "Rook3" (sites {"E3" "L3"})) (place "Rook4" (sites {"C12" "C5"}))
            (place "Pawn1" (sites {"E13".."L13"})) (place "Pawn2" (sites {"M5".."M12"}))
            (place "Pawn3" (sites {"E4".."L4"})) (place "Pawn4" (sites {"D5".."D12"}))
            (place "Bishop1" (handSite P1)) (place "Bishop2" (handSite P2))
            (place "Bishop3" (handSite P3)) (place "Bishop4" (handSite P4))
            (place "Knight1" (handSite P1 1)) (place "Knight2" (handSite P2 1))
            (place "Knight3" (handSite P3 1)) (place "Knight4" (handSite P4 1))
            (place "Rook1" (handSite P1 2)) (place "Rook2" (handSite P2 2))
            (place "Rook3" (handSite P3 2)) (place "Rook4" (handSite P4 2))
        })
        phases:{
        (phase "Placing"
            (play
                (forEach Site (sites Hand Mover)
                    (if (is Occupied (site))
                        (move
                            (from (site))
                            (to (intersection (sites Empty) (sites Mover "ExtraSquare")))
                        )
                    )
                )
            )
            (nextPhase Mover (no Pieces Mover in:(sites Hand Mover)) "Playing")
        )
        (phase "Playing"
            (play
                (if "SameTurn"
                    (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                    (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King" Mover)))
                    (then
                        (and {
                            ("RemoveKingIfCheckmate" P1 1)
                            ("RemoveKingIfCheckmate" P2 2)
                            ("RemoveKingIfCheckmate" P3 3)
                            ("RemoveKingIfCheckmate" P4 4)
                        }) 
                    )
                )
            )
        )
        }
        (end {
            (forEach NonMover
                if:("IsOffBoard" (where "King" Player)) 
                (result Player Loss)
            )	
            (if (and {(not (is Active P1)) (not (is Active P3)) (is Active P2) }) (result P2 Win))
            (if (and {(not (is Active P1)) (not (is Active P3)) (is Active P4) }) (result P4 Win))
            (if (and {(not (is Active P2)) (not (is Active P4)) (is Active P1) }) (result P1 Win))
            (if (and {(not (is Active P2)) (not (is Active P4)) (is Active P3) }) (result P3 Win))
        })
    )
)

Construct a Ludii game based on the following description
Line and Cross is a multi-player mathematical game.Initially, there is a number of edges in a plane, where some of them cross each other. At each turn, a player selects an edge to remove it and all of its intersecting edges. The number of edges with which a selected edge intersects is added to the player's score. When there are no moves left, the game is over. Finally, the player with the highest score wins.  The version of the game played with 2 players.
(game "Line and Cross" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board <Board:type> use:Edge)
        (piece "Marker" Shared)
    }) 
    
    (rules  	 
        (start
            <Board:start>
        )
        
        (play	   
            (move
                Remove (sites Occupied by:Shared)
                (then
                    (and
                        (remove Edge (last To))    	    	 	 	
                        (forEach Site
                            (sites Crossing at:(last To) All)
                            (and	
                                (remove Edge (to))
                                (addScore Mover 1)
                            )	    			
                        )    	 	
                    )
                )
            )	   
        )
        (end
            (if (no Moves Next)	
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Clobber is an abstract strategy game invented in 2001 by combinatorial game theorists Michael H. Albert, J.P. Grossman and Richard Nowakowski.To start the game, each of the squares on the checkerboard is occupied by a stone. White stones are placed on the white squares and black stones on the black squares. To move, the player must pick up one of his or her own stones and 'clobber' an opponent's stone on an adjacent square, either horizontally or vertically. Once the opponent's stone is clobbered, it must then be removed from the board and replaced by the stone that was moved. The player who, on their turn, is unable to move, loses the game. The board has 1 row. The board has 2 columns. Pieces must step onto an enemy piece.
(game "Clobber" 
    (players 2) 
    (equipment { 
        (board (rectangle <Rows> <Columns>)) 
        (piece "Marker" Each <Moves>)
    }) 
    (rules 
        (start { 
            (place "Marker1" (sites Phase 1))
            (place "Marker2" (sites Phase 0))
        })
        (play (forEach Piece))
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
Flume is a simple territory game made by Mark Steere. Its placement protocol bears some similarity to Dots and Boxes.Players take turns placing stones of their color on empty squares. If you place orthogonally adjacent to more than 2 stones, regardless of their color, you must place again. You continue until you place orthogonally adjacent to 2 or fewer stones. When the board is full, the player with the most stones on the board is the winner. A 5x5 playing area is currently selected
(game "Flume"
    (players 2)
    (equipment {
        (board (square <Board>))
        (piece "Disc" Each)
        (piece "Disc" Neutral)
    })
    (rules
        (meta (swap))
        (start (place "Disc0" (sites Outer)))
        (play
            (move Add
                (to (sites Empty))
                (then
                    (and
                        (addScore Mover 1)
                        (if
                            (< 2 (count Sites in:(sites Around (last To) NotEmpty Orthogonal)))
                            (moveAgain)
                        )
                    )
                )
            )
        )
        (end 
            (if (is Full) 
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Invented in 2003 by Omar Syed, Arimaa was invented as a Chess variant to be difficult for computers to learn, but easy for humans.Played on an 8x8 board with \ 
(game "Arimaa" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8))
        (hand Each size:6) 
        
        (piece "Rabbit" Each ("PieceMove" (directions {Forward Rightward Leftward})))
        (piece "Cat" Each ("PieceMove" Orthogonal))
        (piece "Dog" Each ("PieceMove" Orthogonal))
        (piece "Horse" Each ("PieceMove" Orthogonal))
        (piece "Camel" Each ("PieceMove" Orthogonal))
        (piece "Elephant" Each ("PieceMove" Orthogonal))
        
        (regions "Traps" (sites {"C3" "C6" "F3" "F6"}))
        (regions "Home" P1 (expand (sites Bottom)))
        (regions "Home" P2 (expand (sites Top)))
        (regions "Goal" P1 (sites Top))
        (regions "Goal" P2 (sites Bottom))
        }
    ) 
    (rules 
        (start { 
            (place "Rabbit" "Hand" count:8 value:1)
            (place "Cat" "Hand" count:2 value:2)
            (place "Dog" "Hand" count:2 value:3)
            (place "Horse" "Hand" count:2 value:4)
            (place "Camel" "Hand" count:1 value:5)
            (place "Elephant" "Hand" count:1 value:6)
        })
        
        phases:{
        (phase "PlacementP1"
            (play 
                (move 
                    (from (sites Occupied by:Mover container:(mover))) 
                    (to (forEach (sites Mover "Home") if:(is Empty (site)))) 
                    (then (if ("HandOccupied" P1) (moveAgain))) 
                ) 
            ) 
            (nextPhase ("HandEmpty" P1) "PlacementP2")
        )
        
        (phase "PlacementP2"
            (play 
                (move 
                    (from (sites Occupied by:Mover container:(mover))) 
                    (to (forEach (sites Mover "Home") if:(is Empty (site)))) 
                    (then (if ("HandEmpty" P2) (remember State) (moveAgain))) 
                ) 
            ) 
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        (phase "Movement" 
            (play
                (avoidStoredState
                    (if "HasToPushAPiece"
                        "PushThePiece"
                        (or 
                            (or
                                (if 
                                    (and 
                                        "SameTurn" 
                                        (is In (last From) (sites Board))
                                    ) 
                                    "PullAPiece"
                                )
                                (forEach Piece)
                                (then 
                                    (and
                                        "AllPieceInATrapAreRemoved"
                                        (if "NotMyLastMove" 
                                            (moveAgain) 
                                            (remember State)
                                        )
                                    )
                                )
                            )
                            "FinishMyTurn"
                        )
                    )
                )
            ) 
            
            (end 
                (if (not (is Next Mover))
                    {
                    ("RabbitReachedGoal" P1 Win) 
                    ("RabbitReachedGoal" P2 Win) 
                    ("NoRabbit" P1 P2 Win) 
                    ("NoRabbit" P2 P1 Win) 
                    ("NoMoves" Loss)
                    }
                )
            )
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Scaffold"
    (players 2)
    (equipment {
        (board (square <Board:size>) use:Vertex)
        (piece "Marker" Each)
        (regions P1 {(sites Side N) (sites Side S) })
        (regions P2 {(sites Side W) (sites Side E) })
    })
    (rules
        (meta (swap))
        (play
            (if (< 0 (count MovesThisTurn))
                ("Connect")
                (move Add (to (sites Empty)))
                (then
                    (if 
                        (can Move ("Connect"))
                        (moveAgain)
                    )
                )
                
            )
        )
        (end (if (is Connected Orthogonal Mover) (result Mover Win)))
    )
)
Scaffold is a drawless square connection game invented by Andrew Lannan in 2022 with inspiration and input from the designers on Boardgamegeek.com's Abstract Game forum. Luis Bolaños Mures helped clarify the presentation of the rules. It is similar to Bill Taylor's Quadrex, but was discovered independently.Definitions
            Group: Either a single stone (a group of one) or any number of stones of the same color connected through a continuous series of orthogonal adjacencies.
            
            Rules
            Scaffold is a drawless connection game played on the intersections of a square grid using stones (as in Go). Black is trying to connect N-S edges of the board, White E-W with an orthogonally connected group.
            
            First player places a single black stone on any grid intersection, after which the second player decides which color they will play (pie rule). Players then alternate taking turns.
            
        On your turn, place a stone of your color on an empty point. Then, if possible, place a stone of your color on an empty point that is orthogonally adjacent to two groups of your color, and keep making such placements until no more are possible. A 4x4 board is currently selected

Construct a Ludii game based on the following description
Weiqi is a territory game that is one of the oldest surviving games today. It is the ancestor of Go, and its rules are largely the same. It originated in China, and inspired similar games throughout East Asia, most notably Go in Japan and Baduk in Korea.Played on a 19x19 board. The board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones may be placed in a position where they are surrounded. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players then fill in the spaces in their captured territory with their own pieces. Players total the number of intersections their pieces occupy. The player with the highest total wins.
         
(game "Weiqi"
    (players 2)
    (equipment {
        (board (square 19) use:Vertex)
        (piece "Marker" Each)
    })
    (rules 
        (meta
            (no Repeat)
        )
        (play   
            (or
                (move Add
                    (to (sites Empty))
                    (then ("EncloseCapture" Orthogonal))
                )
                (move Pass)
            )
        )
        (end
            (if (all Passed)
                (byScore {
                    (score P1 (+ (count Pieces P1) (size Territory P1))) 
                    (score P2 (+ (count Pieces P2) (size Territory P2)))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Meridians is an annihilation game featuring anti-connection and territory as emergent themes. The game was invented by Kanare Kato in 2021.DEFINITIONS
            Group: like-colored stones adjacent to each other. Singletons are considered groups of size 1.
            Path: an empty point, or an uninterrupted straight line of empty points that have a pair of like-colored stones on both ends, which are not part of the same group. Such a pair is said to have a path.
            Dead group: a group in which all stones belonging to it have no path. If any stone belonging to a group has a path, the group is said to have a path.
            
            GAME PLAY (Overview)
            Decide which player plays as which color (Light or Dark) in any adequate way.
            Light goes first, then alternate turns.
            On each player's first turn, players place a stone of their own color on any empty point.
            On each player's second turn, players place another stone of their color so that their own two stones have a path.
            
            Then players take actions below on each turn, in this order.
            1. Remove all opponent’s dead groups. This happens automatically in Ludii.
            2. Place a stone of their own color on an empty point that is on at least one same straight line with an existing friendly stone, and no opponent's stone in between. Passing is not allowed.
            
        After the second turn, the player with no stones of their color on the board at the beginning of their turn loses. A board with side lengths 5 and 6 is currently selected
(game "Meridians"
    (players 2)
    (equipment {
        (board (dual (hex Prism <Size>)) use:Vertex)
        (piece "Disc" Each)
    })
    (rules
        phases:{
        (phase "Opening"
            (play
                (move Add 
                    (to
                        (if
                            (< 0 (count Sites in:(sites Occupied by:Mover)))
                            (forEach
                                (sites Empty)
                                if:(and
                                    (>
                                        (count Pieces Mover in:(sites LineOfSight at:(site)))
                                        0
                                    )
                                    (= 
                                        (count Sites in:(sites Around (site) Own))
                                        0 
                                    )
                                )
                            )
                            (sites Empty)
                        )
                    )
                )
            )
            (nextPhase (= 4 (count Moves)) "Play")
        )
        (phase "Play"
            (play
                (if
                    (can Move ("Move" ~))
                    ("Move" (then ("Remove")))
                    (move Pass (then ("Remove")))
                )
            )
        )
        }
        (end 
            (if 
                (and 
                    (< 4 (count Moves))
                    (or
                        (= 0
                            (count Sites in:(sites Occupied by:P1))
                        )
                        (= 0
                            (count Sites in:(sites Occupied by:P2))
                        )
                    ) 
                )
                (result Mover Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Ultimate Chess is a variant of Chess.Ultimate Chess is a variant of Chess played on a 9x9 Sudoku checkerboard as shown, with same rules as Chess except:
            - Pawns can move 2 or 3 steps forward in their first move. The pawn can be captured by En Passant if they do a such move.
            - Kings can make a large casting in either side.
        - The next player must move from the sub-grid corresponding to the cell just moved to (if they have a legal move from there). 
(game "Ultimate Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 9)) 
        (piece "Pawn" Each ("PawnMove"))
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E9")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A9")})
        (map "RookRight" {(pair 1 "I1") (pair 2 "I9")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 7))
            (place "Rook1" {"A1" "I1"} state:1) (place "Knight1" {"B1" "H1"}) (place "Bishop1" {"C1" "G1"}) (place "Queen1" {"D1" "F1"}) (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A9" "I9"} state:1) (place "Knight2" {"B9" "H9"}) (place "Bishop2" {"C9" "G9"}) (place "Queen2" {"D9" "F9"}) (place "King2" coord:"E9" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (priority {
                    (if (!= 0 (count Moves))
                        (do 
                            (or {
                                (forEach Piece "Queen" 
                                    (if ("RightSection")
                                        ("QueenMove") 
                                    )
                                )
                                (forEach Piece "Knight" 
                                    (if ("RightSection")
                                        ("KnightMove")
                                    )
                                )
                                (forEach Piece "Bishop" 
                                    (if ("RightSection")
                                        ("BishopMove")
                                    )
                                )
                                (forEach Piece "King" 
                                    (if ("RightSection")
                                        ("KingMove")
                                    )
                                )
                                (forEach Piece "Rook" 
                                    (if ("RightSection")
                                        ("RookMove")
                                    )
                                )
                                (forEach Piece "Pawn" 
                                    (if ("RightSection")
                                        ("PawnMove")
                                    )
                                )
                                (if (and (= "RowSquareSection" 0) (= "ColumnSquareSection" 1)) 
                                    (if (and {
                                            "KingInTheInitialPlace" 
                                            ("HasNeverMoved" "King")
                                            (not ("IsInCheck" "King" Mover)) 
                                        })
                                        (or
                                            (if (and 
                                                    ("HasNeverMoved" "RookLeft")
                                                    (can Move ("DoCastle" "RookLeft" E 3 (is Empty (to))))
                                                )
                                                "LeftCastling"
                                            )
                                            (if (and 
                                                    ("HasNeverMoved" "RookRight")
                                                    (can Move ("DoCastle" "RookRight" W 2 (is Empty (to))))
                                                )
                                                "RightCastling"
                                            )
                                        )
                                    )
                                )
                            })
                            ifAfterwards:(not ("IsInCheck" "King" Mover (forEach Piece)))
                        )
                    )
                    (do 
                        (or 
                            (forEach Piece)
                            (if (and {
                                    "KingInTheInitialPlace" 
                                    ("HasNeverMoved" "King")
                                    (not ("IsInCheck" "King" Mover)) 
                                })
                                (or
                                    (if (and 
                                            ("HasNeverMoved" "RookLeft")
                                            (can Move ("DoCastle" "RookLeft" E 3 (is Empty (to))))
                                        )
                                        "LeftCastling"
                                    )
                                    (if (and 
                                            ("HasNeverMoved" "RookRight")
                                            (can Move ("DoCastle" "RookRight" W 3 (is Empty (to))))
                                        )
                                        "RightCastling"
                                    )
                                )
                            )
                        )
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                })
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Shashki" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 8)) 
    (rules 
        ("BlackCellsSetup" 3)
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    ("HopCounter" (last To)
                        (then 
                            (if "JumpToPromotionZone" 
                                (and 
                                    (promote (last To) (piece "DoubleCounter") Mover)
                                    ("ReplayIfCanMove" ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows)))
                                )
                                ("ReplayIfCanMove" ("HopCounter" (last To))) 
                            )
                        ) 
                    )
                    ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows))
                )
                (priority {
                    (or 
                        (forEach Piece "Counter"
                            ("HopCounter" (from) 
                                (then 
                                    (if "JumpToPromotionZone" 
                                        (and 
                                            (promote (last To) (piece "DoubleCounter") Mover)
                                            ("ReplayIfCanMove" ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows)))
                                        )
                                        ("ReplayIfCanMove" ("HopCounter" (last To))) 
                                    )
                                ) 
                            ) 
                        )
                        (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture" before:(count Rows) after:(count Rows)))
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal))
                    )
                })
            )
        ) 
        
        (end ("CaptureAll" Next)) 
    )
)
Shashki is a game with leaping captures related to other European Draughts games. The first description comes from the nineteenth century, though the term is older.Played on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them if they are adjacent. Capturing must happen if it is possible, multiple captures are allowed, and can happen in a forward or backward direction. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. A piece may become a king in the midst of a sequence of captures, and then capture as a king in the same turn. Kings may capture over any distance, leaping over all opponent's pieces in a line. The goal is to capture all of the opponent's pieces.
         

Describe the mechanics of the following Ludii game
(game "Tourne-Case"
    (players 2)
    (equipment {
        ("BackgammonBoard" 
            {
            (track "Track1" {6 0..5 7..12 25..20 18..13} P1 directed:True)
            (track "Track2" {19 13..18 20..25 12..7 5..0} P2 directed:True)
            } 
        ) 
        (dice d:6 num:2)
        (piece "Disc" Each
            (move
                (from (from))
                (to 
                    ("NextSiteFrom" (from) ("ThrowValue"))
                    if:(and
                        (or 
                            (is Empty (to)) 
                            (and
                                (= (to) (mapEntry "FinalPoint" Mover))
                                (no Pieces Next in:(sites {(mapEntry "FinalPoint" Mover)}))
                            )
                        )
                        (if (< 1 ("ThrowValue")) 
                            (no Pieces Mover 
                                in:(sites Track Mover
                                    from:("NextSiteFrom" (from) 1) 
                                    to:("NextSiteFrom" (from) (- ("ThrowValue") 1))
                                )
                            ) 
                            True
                        )
                    )
                    (apply
                        (if (and 
                                ("IsEnemyAt" (mapEntry "Opposite" (to)))
                                ("IsSingletonStack" (mapEntry "Opposite" (to)))
                            )
                            (fromTo
                                (from (mapEntry "Opposite" (to)))	
                                (to (mapEntry "Bar" Next))	
                            )
                        )
                    )
                )
            )
        )
        (map "FinalPoint" {(pair P1 13) (pair P2 0)})
        (map "Bar" {(pair P1 6) (pair P2 19)})
        (map "Opposite" {
            (pair 0 13) (pair 1 14) (pair 2 15) (pair 3 16) (pair 4 17) (pair 5 18) 
            (pair 7 20) (pair 8 21) (pair 9 22) (pair 10 23) (pair 11 24) (pair 12 25)
            (pair 13 0) (pair 14 1) (pair 15 2) (pair 16 3) (pair 17 4) (pair 18 5) 
            (pair 20 7) (pair 21 8) (pair 22 9) (pair 23 10) (pair 24 11) (pair 25 12)
        })
    })
    (rules 
        (start {
            (place Stack "Disc1" 6 count:3) 
            (place Stack "Disc2" 19 count:3) 
        })
        (play 
            ("RollMove"
                (forEach Piece top:True)
            )
        )
        (end (if ("ThreePiecesOnFinalPoint") (result Mover Win)))
    )
)
Tourne-Case is a race game played on a Backgammon board from seventeenth century France. It involves three pieces racing to one end of the board, and only the lowest value of the dice can be used.Played on a Backgammon board. Three pieces per player. Two dice. Only the lower value of the dice is used. One player plays from their let toward their right, and the other player from their right to their left. Pieces begin on the outer edge of the board. Pieces move according to the throw of the dice toward the point on the opposite side of their side of the board. No more than one piece can be on a point (except the final point) at any time. Pieces cannot pass each other. When a piece lands on an empty point that is opposite an opponent's point with a piece on it, the opponent's piece is sent back to start. The first player to place all three of their pieces on the final point wins. 

Describe the mechanics of the following Ludii game
(game "Imperial" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" ("BackgammonTracksWithBar")) 
        (dice num:3)
        (map {(pair 1 19) (pair 2 6)}) 
        (piece "Disc" Each) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 10 count:5)
            (place Stack "Disc1" 11 count:5)
            (place Stack "Disc1" 12 count:5)
            (place Stack "Disc2" 23 count:5) 
            (place Stack "Disc2" 24 count:5) 
            (place Stack "Disc2" 25 count:5) 
        })
        
        (play 
            ("RollEachNewTurnMove"
                (forEach Die
                    if:("DieNotUsed")
                    (forEach Site
                        (sites Occupied by:Mover)
                        (if ("CanEscape" ("NextSiteFrom" (site))) 
                            ("RemoveAPiece")
                            (move 
                                (from (site))
                                (to ("NextSiteFrom" (site))
                                    if:("NoEnemyOrOnlyOne" (to))
                                    ("HittingCapture" ("Bar")) 
                                )
                            )
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (result Mover Win)
            )
        )
    )
)
Imperial is a European Tables game played in medieval England. It is one of a group of similar games that are described in an early fourteenth century manuscript.2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Three six-sided dice. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions, one from their bottom right to the top right, the other from their bottom left to their top left. Pieces begin on the board, five each on the sixth, seventh, and eighth point in their track. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the beginning of the player's track. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins.
         

Construct a Ludii game based on the following description
Fission is a game where players attempt to eliminate all of their opponents stones but must have at least one stone left on the board in order to win.TURN - On each turn, each player slides (orthogonally or diagonally) a stone until it hits another stone or a wall.
            
            If it stops because of a stone, the moving stone and all adjacent stones (of either color) are removed.
            
            GOAL - The player with no stones onboard loses.
            
        The game is a draw if (i) the board becomes empty, or (ii) each player has just one stone, or (iii) the moving player has no valid moves. 
(game "Fission" 
    (players 2) 
    (equipment { 
        (board (square 8))
        (piece "Ball" Each
            (move 
                (from (from))
                (to (sites LineOfSight Farthest at:(from))
                    if:(not (is In (to) (sites Around (from))))		
                )
                (then
                    (if (!= (ahead (last To) ("LastDirection" Cell)) (last To))
                        (remove
                            (sites Around (last To) includeSelf:True)
                        )
                    )
                )
            )
        ) 
    }) 
    (rules 
        (start {
            (place "Ball1" (intersection (sites Phase 1) (expand (sites Centre) steps:2 Orthogonal)))
            (place "Ball2" (intersection (sites Phase 0) (expand (sites Centre) steps:2 Orthogonal)))
        })
        
        (play (forEach Piece)) 
        
        (end {
            (if (and (not (no Pieces Mover)) (no Pieces Next))
                (result Mover Win)
            )
            (if 
                (or 
                    (no Moves Next)
                    (and
                        (= 1 (count Pieces P1))
                        (= 1 (count Pieces P2))
                    )
                )
                (result Mover Draw)
            )
        })
    )
)

Construct a Ludii game based on the following description
Gabata is a name that is widely used for different mancala-style games in the northern Horn of Africa. This game, played near Adwa in Ethiopia, it is a three-row game.3x6 board. Three counters per hole. Each player owns the row closest to them and the right half of the central row. Sowing occurs in the following direction: from left to right in the player's full row, right to left in the player's half of the central row, proceeding to the opponent's full row and sowing right to left, then left to right in the opponent's part of the central row, then proceeding back to the player's full row and proceeding as before. Sowing always begins from a player's own holes. When the last counter falls into an empty hole, the turn ends. If the last counter falls into an occupied hole, the contents of that hole are picked up and sowing continues. A hole is captured by dropping the last counter of a sowing into an opponent's hole which contains three counters, making it have four counters, and becomes a wegue. Captures cannot be made until after the original three counters placed in the holes at the beginning of the game have been moved. Once a wegue is created, the player cannot sow from it. When the final counter of a sowing lands in a wegue owned by the opponent, the player captures two counters from it. Play continues until all of the counters are captured or all of the counters are accumulated in wegue. A new round begins. Players then collect the counters in their captured holes. They count their takings by filling their holes with three counters each as in the beginning, and the player would own every hole they could fill with three counters. If the player has two counters remaining, they also gain another hole and the opponent surrenders their extra counter. At the end of play, if a player captures the opponent's single remaining hole as a wegue, the player captured three counters from it, leaving one for the opponent to continue to play. Play continues until one player cannot fill any holes. 
(game "Gabata (Adowa)" 
    (players 2) 
    (equipment { 
        (mancalaBoard 3 "Columns" store:None
            (track "Track" "0,E,N1,W2,17,W,S1,E2" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (union (sites Bottom) (intersection (sites Row 1) (expand (sites Right) steps:2)))) 
        (regions P2 (union (sites Top) (intersection (sites Row 1) (expand (sites Left) steps:2))))  
        (map "LeftMost" {(pair P1 0) (pair P2 17)})
    }) 
    (rules 
        
        (start { 
            (set Count 3 to:(sites Track))
            (set RememberValue "OwnedP1" (union (sites Bottom) (intersection (sites Row 1) (expand (sites Right) steps:2))))
            (set RememberValue "OwnedP2" (union (sites Top) (intersection (sites Row 1) (expand (sites Left) steps:2))))
        })
        
        phases:{
        (phase "Sowing" 
            (play
                (or {
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))
                        )
                        (then
                            (sow
                                apply:(if (and { 
                                        (= 0 (state at:(to))) 
                                        (= 4 (count at:(to)))
                                        (is In (to) ("OpponentOwnedHoles"))
                                    })
                                    (set State at:(to) (mover))
                                    (if (< 1 (count at:(to)))
                                        (if (= 0 (state at:(to)))
                                            (and {
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            })
                                            (if (!= (mover) (state at:(to)))
                                                (and {
                                                    (fromTo
                                                        (from (to))
                                                        (to (handSite Mover))
                                                        count:(min 2 (count at:(to)))
                                                    )
                                                    (set State at:(to) (state at:(to)))
                                                })
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OnlyPiecesInMarked")
                            (and { 
                                (forEach Site ("SitesMarkedBy" 1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site ("SitesMarkedBy" 2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (>= 1 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (>= 1 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 3 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:3
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 3 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 2 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("LeftMostEmpty"))
                                                count:2
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("LeftMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("LeftMostEmpty"))
                                        })
                                    )
                                )
                            })
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Triodi is an alignment game played in Greece. Boards for this game have been found in Greece going back to antiquity, and it was still played there in the early twentieth century.Three concentric squares, the midpoints of the squares connected with lines. Nine pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, the players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row along the lines, the player removes any one of the opponent's pieces. The player who reduces the opponent to two pieces wins. 
(game "Triodi"
    (players 2)
    
    (equipment { 
        ("NineMensMorrisBoard")
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3" Orthogonal exact:True)))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:9))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True)) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("HavingLessPiecesLoss" Next 2))
    )
)

Construct a Ludii game based on the following description
Groups was created by Richard Hutnik in 1998. It is a connection game with the goal of creating an orthogonally connected group of six.Pieces move to any adjacent empty square or jumping one of their pieces over an adjacent piece to the empty point immediately beyond. The game is won by the first player to move all six pieces into a single orthogonally connected group 
(game "Groups" 
    (players 2) 
    (equipment { 
        (board (square 8)) 
        (piece "Disc" Each 
            (or 
                ("StepToEmpty")
                ("HopAllPiecesToEmpty")
            )
        )
    }) 
    
    (rules 
        (start { 
            (place "Disc1" {"D3" "C4" "E4" "D5" "F5" "E6"})
            (place "Disc2" {"E3" "D4" "F4" "C5" "E5" "D6"})
        })
        
        (play (forEach Piece))
        
        (end ("SingleGroupWin" Mover Orthogonal)) 
    )
)

Construct a Ludii game based on the following description
Sáhkku is a capturing game played by the Sami people of northern Scandinavia. While similar to other games such as Daldos and Daldøsa, Sáhkku differs in that it is played with a \3x15 board, with the central spot marked. Fifteen pieces per player, arranged along the outer two rows of the board. Another piece, the Gonagas (\ 
(game "Sahkku"
    (players 2)
    (equipment {
        (board (rectangle 3 15)
            {
            (track "Track1" "0,E,N1,W,N1,E,S1,W" loop:True P1)
            (track "Track2" "44,W,S1,E,S1,W,N1,E" loop:True P2)
            }
        )
        (dice d:4 from:0 num:3)
        (piece "Marker" Each
            (forEach Die
                if:("DieNotUsed")
                (move
                    (from (from) level:(level)
                        if:(or ("IsActivated" (from) (level)) ("Sahkku" (pips)))
                    )
                    (to ("NextSiteOnTrack" (pips) from:(from))
                        if:(or {
                            (= (id "Gonagas" Shared) (what at:(to))) 
                            (is Empty (to))
                            (and ("IsEnemyAt" (to)) ("IsActivated" (to) (topLevel at:(to))))
                        })
                        (apply 
                            (and {
                                (if (not ("IsActivated" (from) (level))) ("ActivePiece" (from) (level))) 
                                (forget Value "Pips" (pips))
                                (if (= (what at:(to)) (id "Gonagas" Shared))
                                    (set State at:(to) (mover))
                                    (if ("IsEnemyAt" (to))
                                        (remove (to))
                                    )
                                )
                            })
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
            )		
        )
        (piece "Gonagas" Shared
            (forEach Die
                if:("DieNotUsed")
                (move Slide
                    (from (from) level:(level)
                        if:(= (state at:(from) level:(level)) (mover))
                    )
                    Orthogonal
                    (between (exact (pips)) if:True)
                    (to 
                        (apply 
                            if:(or 
                                (is Empty (to))
                                (and ("IsEnemyAt" (to)) ("IsActivated" (to) (topLevel at:(to))))
                            )
                        )
                    )
                    (then
                        (and
                            (forEach Level (last To)
                                (if (!= (topLevel at:(last To)) (level))
                                    (remove (last To) level:(level))
                                )
                            )
                            ("ReplayNotAllDiceUsed")
                        )
                    )
                )
            )
        )
    })
    (rules 
        (start { 
            (place Stack "Marker1" (sites Bottom))
            (place Stack "Marker2" (sites Top))
            (place Stack "Gonagas" (centrePoint))
        })
        phases:{
        (phase "Opening"
            (play
                (do (and 
                        (roll)
                        (if (and (!= 0 (value Player Mover)) (= 0 (count MovesThisTurn)))
                            (set Value Mover 0)
                        )
                    )
                    next:(move Pass 
                        (then
                            (and
                                (if ("IsASahkku")
                                    (set Value Mover (+ ("NumberOfSahkku")(value Player Mover)))
                                )
                                (forEach Die
                                    (if (!= 0 (pips))
                                        (remember Value "Pips" (pips))
                                    )
                                )
                            )
                        )
                    )
                    (then 
                        (if (or (<= 3 (value Player Mover)) (!= 2 (count MovesThisTurn)))
                            (moveAgain)
                            (and (forget Value "Pips" All) (set Value Mover 0))
                        )
                    )
                )
            )
            (nextPhase Mover (<= 3 (value Player Mover)) "PlayingPips")
        )
        (phase "PlayingPips"
            (play 
                ("RollEachNewTurnMove"
                    (or (forEach Piece "MovePieceWithStoredPips") (forEach Piece "MoveGonagasWithStoredPips" Shared))
                )
            )
            (nextPhase Mover (= 0 (size Array (values Remembered "Pips"))) "Playing")
        )
        (phase "Playing"
            (play 
                ("RollEachNewTurnMove"
                    (or (forEach Piece) (forEach Piece Shared))
                )
            )
        )
        }
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Aj Sayil, \Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, and then back to home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the team's home field, the piece may be re-entered. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured. The captures piece is placed on top of the piece that captured it, and the stack now moves toward the capturing player's home space. If the player successfully carries the captured piece to the team's home space, the piece is permanently captured and removed from play. If the opposing side lands on the same space as the stack, they are stacked with the opponent's piece, and the opponent begins carrying the stack to the opposing team's side. Any pieces captured belonging to the team which brings them back to their home are returned to their players. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces. The game has 6 players.
(game "Aj Sayil"
    (players <Player:num>)
    (equipment {
        (board
            (rectangle 1 <Player:size>)
            <Player:tracks> 
            use:Edge
        )
        (regions "AllSites" (sites Board Vertex))
        (piece "Stick" Each
            (forEach Value (values Remembered "Throws")
                (or
                    (if ("FreePiece" (state at:(from) level:(level)))
                        (if ("IsOffBoard" ("NextSiteOnTrack" (value) from:(from) "Track"))
                            (move 
                                (from (from) level:(level))
                                (to 
                                    (handSite Mover)
                                    (apply (forget Value "Throws" (value)))		
                                )
                            )
                            (move 
                                (from (from) level:(level)
                                    if:(if (is In (from) (sites Hand Mover))
                                        ("NoPieceOnBoard")
                                        True
                                    )
                                )
                                (to 
                                    ("NextSiteOnTrack" (value) from:(from) "Track")
                                    (apply (forget Value "Throws" (value)))
                                )
                                (then 
                                    (if ("AtLeastAnEnemyPieceThere" (last To))
                                        ("CaptureMove")
                                    )
                                )
                            )
                        )
                    )
                    (if ("CapturingPiece" (state at:(from) level:(level)))
                        (if ("IsOffBoard" ("NextSiteOnTrack" (value) from:(from) "CaptureTrack"))
                            (do (forget Value "Throws" (value))
                                next:(move Remove (from) level:(level)
                                    (then
                                        (and {
                                            ("UnsetCapturingPieces")
                                            ("RemoveCapturedPieces")	
                                            ("RebirthCapturingPiece")
                                        })
                                    )
                                )
                            )
                            (move 
                                (from (from) level:(level))
                                (to 
                                    ("NextSiteOnTrack" (value) from:(from) "CaptureTrack")
                                    (apply (forget Value "Throws" (value)))
                                )
                                (then 
                                    (and
                                        ("CapturedPiecesFollowCapturingPiece")
                                        ("UnsetCapturingPieces")
                                    )
                                )
                            )
                        )
                    )
                )
            )		
        )
        ("StickDice" 4)
        (hand Each)
    })
    (rules 
        (start {
            <Player:team>
        })
        
        phases:{
        (phase "ThrowPhase" 
            (play 
                ("RollMove"
                    (move Pass
                        (then
                            (if (not (no Pieces Mover))
                                (and {
                                    (if (!= 0 ("ThrowValue"))
                                        (do
                                            (remember Value "Throws" ("ThrowValue"))
                                            ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece)))
                                        )
                                    )
                                    (moveAgain)
                                    (if ("SameTurn") (set Pending))
                                })
                            )
                        )
                    )
                )	
            )
            (nextPhase (is Pending) "MovePhase")
        )
        (phase "MovePhase" 
            (play 
                (or (forEach Piece) (forEach Piece container:(mover))
                    (then
                        (if (< 0 (size Array (values Remembered "Throws")))
                            (moveAgain)
                        )
                    )
                )
            )
            (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase")
        )
        }
        
        (end ("CaptureAllTeam"))
    )
)

Describe the mechanics of the following Ludii game
(game "Motiq" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 7 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions "Home" P1 (sites Bottom)) 
        (regions "Home" P2 (sites Top)) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        (start {
            (set Count 4 to:(sites Track)) 
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles")
                            )
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                apply:(if (= 4 (count at:(to)))
                                    (and 
                                        (fromTo
                                            (from (to))
                                            (to (handSite Mover))
                                            count:4
                                        )
                                        (if (is Occupied ("NextHoleFrom" (to) 1))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" ("NextHoleFrom" (to) 1))
                                            )
                                        )
                                    )
                                    (if (< 1 (count at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OneRowIsEmpty")
                            (and { 
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 4 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 4 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to 
                            (if (all Sites (sites Mover) if:(is Occupied (site)))
                                (sites Board)
                                (sites Mover)
                            )
                            if:(is Empty (to))
                        )
                        count:4
                        (then
                            ("RemmemberOwnedHoles" (last To))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)
Motiq is a two-row mancala-style board game played by the Kédang people on the island of Lembata in Indonesia. 2x7 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction and begins from one of the holes in the player's row. When the final counter lands in an occupied hole, these are picked up and sowing continues. If the occupied hole has three counters (four including the final counter from the sowing), these are captured. Then, the player picks up the counters in the next hole after the one from which the capture was made and continues sowing from there. When the final counter lands into an empty hole the turn ends. The game ends when one player no longer has any counters on their side of the board. The opponent then captures the remaining counters on the board. A new game begins, with each player filling holes with the counters they captured, four to each hole. The player now controls as many holes as they can fill with counters. Play begins with the player who played second in the previous game. Subsequent games are played until one player captures all of the holes, becoming the winner. 

Construct a Ludii game based on the following description
Double-move Situ is based on 'Situ' a finite, Line-of-Sight game with the goal of being the last player able to complete their turn. The game is based on the choice of placing one's own piece or removing an opponent's piece.It can be played on hex grids, square grids or square grids with diagonals.The original Situ was played on a Hex grid with N, N+1 edges and a single stone pie-rule as an option.In contrast, 'Double-move Situ' starts with a single placement followed by double moves thereafter. Therefore centerless boards with an even number of nodes are used, and a Hex with edges N, N+2 assures this. However there is a changing parameter that determines which sites are controlled, and this parameter affects balance. So, the first player has the option of removing upto 2 nodes from the board, before the 2nd player starts with the single piece placement.Placement must be on empty nodes that are not controlled by the opponent, while removals are taken from nodes that the mover controls.Control is determined by the difference in count between the two player's pieces in line-of-sight of the given node. This difference is the  parameter for the game.  When the its value is met or exceeded, the player with the excess LoS pieces controls the site.In the original Situ this parameter is fixed at 2. In Double-move Situ it can be set from 1 to 4. The lower the number, the larger number of restricted nodes and possible captures, so the more tactical the game is. With higher numbers the game becomes more strategic. In any case, the game is finite, ending with one player running out of nodes to play upon.History:Situ is a descendant of my game Shaka that was designed as an exploration of line-of-sight. Shaka triggered the creation of Michał Zapała's 'Tore' and a flurry of LoS games on BGG Abstract Forum. While Situ may have helped stimulate Michał Zapała's 'Tumbleweed' As Alek Erikson tested Situ with me before assisting Michał with Tumbleweed's development.Steve Metzger and Luis Bolaños Mures 'Stigmergy' is a similar game, a simplification of 'Tumbleweed', that uses a majority of friendly LoS cells rather than a majority of the players pieces for control, and capture in that game is a flip whereas in 'Situ' it is a simple removal.A recent BGG thread proposing a game 'InSight' stimulated me to script my original game and create this new version. Structure of Play:
            There is no passing.
            Maroon chooses to remove up to two nodes of the board before passing to White. 
            Then White places an initial stone onto a remaining node on the board.
            
            After this play alternates, two turns per player, until one player cannot complete both turns. That player loses
            
            On each of the turns, the current player must either:
            - - place a stone on an empty node that the opponent does not control, or
            - - remove an opponent's stone that the current player controls.
            
            A player controls a node and any stone on it when the count of his stones in line-of-sight of the node, exceed those of his opponent by the node-control value chosen for the game, or more. (default is 3)
            
            ('in line-of-site of the node' refers to the first stone in each radial grid direction.) 
            
        There are options for the board size and type, and the number of surplus stones needed to control a node. Order 2 board Hex N/N+2 grid w/even nodes, no center Highly tactical. Control a site with a surplus of 1 on lines of sight.
(game "Double-Move Situ"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Counter" P1)
        (piece "Counter" P2)
        (piece "X" Neutral)
        (piece "Counter" Neutral)
    })
    (rules
        (meta (passEnd NoEnd))
        (play
            (if
                (and
                    (= -1 (var "DoubleTurnPhase"))
                    (= 1 (mover))
                )
                
                (or
                    (move Pass)
                    (move Add
                        (piece "X0") 
                        (to (sites Empty))
                        (then
                            (if
                                (> 2 (count Pieces in:(sites Occupied by:Neutral)))
                                (moveAgain)
                            )
                        )
                    )
                )
                
                (or {
                    (move Add
                        (to
                            (sites Empty)
                            if:(not ("IsControlledBy" Next (to)))
                        )
                        (then
                            (if
                                (= -1 (var "DoubleTurnPhase"))
                                (set Var "DoubleTurnPhase" 1)
                                ("MoveTwiceThenScore")
                            )
                        )
                    )
                    (move Remove 
                        (forEach
                            (sites Occupied by:Next)
                            if:("IsControlledBy" Mover (site)) 
                        )
                        (then ("MoveTwiceThenScore"))
                    )
                })
                (then
                    (if
                        (no Moves Next)
                        (and 
                            ("ScoreFor" Mover)
                            ("ScoreFor" Next) 
                        )
                    )
                )
            )
        )
        
        (end 
            (if 
                (no Moves Mover)
                (result Mover Loss) 
            )
        )
    )
)

Construct a Ludii game based on the following description
Variant of Hex that includes disc and rings.White starts by placing one disc or ring on any cell of the board. 
            
            Then, each player in turn must perform two actions: 
            
            1. add one of her discs to an empty cell or move one of her discs on the board into any ring located in a neighbor cell, and 
            
            2. add one of her rings to an empty cell or move one of her rings on the board to a neighbor cell occupied by a disc. 
            
        The disc-ring pair (a disc inside a ring) cannot be modified for the rest of the game. 
(game "DuploHex"
    (players 2)
    (equipment {
        (board (hex Diamond 7))
        (piece "DoubleCounter" Each)
        (piece "Disc" Each 
            (move Step 
                (to if:(or 
                        (= (what at:(to)) (id "Ring1"))
                        (= (what at:(to)) (id "Ring2"))
                    )
                )
                (then (promote (last To) (piece "DoubleCounter") Mover))
            )
        )
        (piece "Ring" Each
            (move Step 
                (to if:(or 
                        (= (what at:(to)) (id "Disc1"))
                        (= (what at:(to)) (id "Disc2"))
                    )
                )
                (then (promote (last To) (piece "DoubleCounter") Mover))
            )
        )
        (hand Each size:2)
        
        (regions P1 {(sites Side NE) (sites Side SW) })
        (regions P2 {(sites Side NW) (sites Side SE) })
    })
    (rules
        (start {
            (place "Disc1" (handSite P1 0) count:25)
            (place "Ring1" (handSite P1 1) count:25)
            (place "Disc2" (handSite P2 0) count:25)
            (place "Ring2" (handSite P2 1) count:25)
        })
        phases:{
        (phase "Placement" (play (move (from (sites Hand P1)) (to (sites Empty)) (then (moveAgain)))) (nextPhase "Game"))
        (phase "Game"
            (play 
                (if (is Odd (count Moves))
                    (or
                        (move 
                            (from (handSite Mover 0))
                            (to (sites Empty))
                            (then (moveAgain))
                        )
                        (forEach Piece "Disc")
                    )
                    (or
                        (move 
                            (from (handSite Mover 1)) 
                            (to (sites Empty))
                        )
                        (forEach Piece "Ring")
                    )
                )
            )
        )
        }
        (end (if (is Connected Mover) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Tugul Shodra is a blockade game played by Tuvinian children in Siberia. Three vertical lines, and two horizontal lines intersecting them along their top end points and their midpoints. Three pieces per player, arranged on the intersections of opposite vertical lines. Players alternate turns moving one of their pieces to an adjacent spot. The object of the game is to block the opponent's pieces from moving. 
(game "Tugul Shodra" 
    (players 2)
    (equipment {
        (board (remove (square 3) edges:{{0 1} {1 2}}) use:Vertex)
        (piece "Disc" Each "StepToEmpty")
    })
    (rules 
        (start {
            (place "Disc1" {2 5 8}) 
            (place "Disc2" {0 3 6})
        })
        (play (forEach Piece))
        (end ("NoMoves" Loss)) 
    )
)

Describe the mechanics of the following Ludii game
(game "Mewegae" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightMost" {(pair P1 5) (pair P2 6)})
    }) 
    (rules 
        
        (start {
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
            (set Count 4 to:(sites Track)) 
        })
        
        phases:{
        (phase "Sowing" 
            (play
                (or {
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))
                        )
                        (then
                            (sow
                                "TrackCCW"
                                apply:(if (and 
                                        (= 0 (state at:(to))) 
                                        (= 4 (count at:(to)))
                                    )
                                    (set State at:(to) (mover))
                                    (if (< 1 (count at:(to)))
                                        (if (= 0 (state at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                            (if (!= (mover) (state at:(to)))
                                                (if (is In (to) ("CanCaptureHoles"))
                                                    (and
                                                        (fromTo
                                                            (from (to))
                                                            (to (handSite Mover))
                                                            count:1
                                                        )
                                                        (set State at:(to) (state at:(to)))
                                                    )
                                                    ("RemmemberCanCaptureHoles" (to))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OnlyPiecesInMarked")
                            (and { 
                                (forEach Site ("SitesMarkedBy" 1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site ("SitesMarkedBy" 2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                                (forget Value "CanCaptureP1" All)
                                (forget Value "CanCaptureP2" All)
                                (set Var "Round" (+ 1 (var "Round")))
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (>= 1 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (>= 1 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("RightMostEmpty"))
                        count:4
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 4 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 3 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("RightMostEmpty"))
                                                count:3
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("RightMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("RightMostEmpty"))
                                        })
                                        (if (= 2 (count Cell at:(handSite Mover)))
                                            (and {
                                                (fromTo 
                                                    (from (handSite Mover))
                                                    (to ("RightMostEmpty"))
                                                    count:2
                                                )
                                                (fromTo 
                                                    (from (handSite Next))
                                                    (to ("RightMostEmpty"))
                                                    count:2
                                                )
                                                ("RememberOwnedHolesRandom" ("RightMostEmpty"))
                                            })
                                        )
                                    )
                                )
                            })
                        )
                    )
                    (then
                        (if (and (is Empty (handSite P1)) (is Empty (handSite P2))) 
                            (and
                                (if 
                                    (is Even (var "Round"))
                                    (set NextPlayer (player 2))
                                    (set NextPlayer (player 1))
                                )
                                (set Pending)
                            )
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        }
    )
)
Mewegae is a two-row mancala-style board game played in Eritrea. It contains a simultaneous opening move that is common in games from Eritrea and Ethiopia.2x6 board. Play begins with four counters in each hole. Players begin the game simultaneously, sowing according to the rules below, until one player drops their final counter into an empty hole. A player picks up the contents of any of their holes and sowing them in an anti-clockwise direction, picking up the contents of the last hole in which his counters fall, and continuing sowing. This continues until the last counter falls in an empty hole. Then it is the other player's turn. A hole is captured when the last ball is dropped into an opponent's hole containing three counters, making it four. A player cannot then take from one of these holes that they have captured. Therefore, the player cannot begin a turn from their own captured hole nor can they continue sowing from it. If the last counter of a sowing falls into an opponent's captured hole, nothing happens on the first instance, but every time after that, one of those counters are removed from the board and placed in the store, and the sowing continues with the contents of any of the player's holes. Ownership of a hole continues even if it becomes empty. When a player cannot move (i.e., there are no counters in their holes except any that are in captured holes), the opponent continues to move until the player is able to move. Play continues until all counters are either placed in the store or in captured holes and thus cannot be moved. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra the weaker player is given the two extra counters. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes. 

Construct a Ludii game based on the following description
Squadro is a strategy game for two players, conceptually very simple but extremely rich in depth. It was created by Adrián Jiménez Pascual in March 2015 and is published in 2018 by the company Gigamic.Each player starts with their five pieces in troughs on their side of the game board, with players sitting perpendicular to one another. When you move a piece, you move it a distance based on the strength indicated in the trough that you're leaving. Once the piece has made its way across the board, you move it back based on the strength on the other side. If you pass over an opposing piece while moving, then that opposing piece must return to its last departing base and your moving piece advances one cell further than where the opposing piece was.
            
        To win Squadro, you need to be the first player to make a return trip with four of your five pieces. 
(game "Squadro"
    (players {(player E) (player S)}) 
    (equipment {
        (board 
            (remove 
                (square 7) 
                vertices:{0 6 42 48}
            )
            use:Vertex
        )
        (piece "Minus" Each
            (if (= 3 (state at:(from)))
                "MoveThree"
                (if (= 2 (state at:(from)))
                    "MoveTwo"
                    "MoveOne"
                )
            )
        )
        (regions "Home" P1 (sites Left))
        (regions "Home" P2 (sites Top))
        (regions "OppositeHome" P1 (sites Right))
        (regions "OppositeHome" P2 (sites Bottom))
        (map {
            (pair 39 1) (pair 32 3) (pair 25 2) (pair 18 3) (pair 11 1)
            (pair 0 3) (pair 1 1) (pair 2 2) (pair 3 1) (pair 4 3)
        })
    })
    (rules 
        (start {
            (place "Minus1" coord:"A2" state:3 value:1)
            (place "Minus1" coord:"A3" state:1 value:1)
            (place "Minus1" coord:"A4" state:2 value:1)
            (place "Minus1" coord:"A5" state:1 value:1)
            (place "Minus1" coord:"A6" state:3 value:1)
            (place "Minus2" coord:"B7" state:1 value:1)
            (place "Minus2" coord:"C7" state:3 value:1)
            (place "Minus2" coord:"D7" state:2 value:1)
            (place "Minus2" coord:"E7" state:3 value:1)
            (place "Minus2" coord:"F7" state:1 value:1)
        })
        
        (play 
            (if ("SameTurn") 
                (move Hop
                    (from (last To))
                    (between 
                        (range 1 (count Columns)) 
                        if:("IsEnemyAt" (between))
                        (apply
                            (fromTo
                                (from (between))
                                (to 
                                    (if (is Mover P1)
                                        (coord row:(if (= (value Piece at:(between)) 1) (- (count Rows) 1) 0) column:(column of:(between)))
                                        (coord row:(row of:(between)) column:(if (= (value Piece at:(between)) 1) 0 (- (count Columns) 1)))
                                    )
                                )
                            )
                        )
                    )
                    (to if:(is Empty (to)))
                )
                (forEach Piece)
                (then 
                    (if (is In (last To) (sites Mover "OppositeHome"))
                        (and
                            (set Value at:(last To) 2)
                            (set State at:(last To) (mapEntry (last To)))
                        )
                        (if (and (!= (last From) (last To)) (is In (last To) (sites Mover "Home")))
                            (remove (last To))
                        )
                    )
                )
            )
        )
        
        (end (if (= (count Pieces Mover) 1) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Mulabalaba is an alignment game played in the Livingtone district of Zambia.Three concentric squares, with lines connecting the corners and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on the board. When a player makes a line of three of their pieces, they may remove one of the opponent's pieces. When all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece in the four outside corner spaces is allowed to move to any empty spot on the board. The player who captures all of the opponent's pieces wins. 
(game "Mulabalaba"
    (players 2)
    
    (equipment { 
        (board (concentric Square rings:3 joinCorners:True) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            (if (is In (from) (sites Corners))
                (move
                    (from (from))
                    (to (sites Empty))
                )
                ("StepToEmpty")
                (then ("ReplayIfLine3")) 
            )
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3")) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (forEach Piece)
                )
            )
        )
        }
        
        (end
            (forEach NonMover
                if:(no Pieces Player)
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Mu Torere is a game played by the Maori of New Zealand. It is unknown how old the game is. The board takes the form of a circle divided into eighths, with eight points on the circumference (kewai) and the central point (putahi) being playing spaces.Play begins with the pieces on the kewai, each player on half of the circle. Players move by moving one piece to an empty adjacent space. Players can only move to the putahi when the piece being moved is next to an opponent's piece. The player that blocks the other from moving is the winner. The game is played on a wheel board. The game is played with all the rules
(game "Mu Torere"
    (players 2) 
    (equipment { 
        <Board:type>
        
        (piece "Marker" Each <Play>) 
    }) 
    (rules 
        (start { 
            <Board:start>
        })
        (play (forEach Piece))
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
Notakto is a misere 3-in-a-row game for two players. It's played on the squares of a finite number of initially empty 3x3 boards. All pieces are exactly the same and are shared by both players.A board is dead if it contains at least one set of three stones in a straight orthogonal or diagonal line.
            
            A board that is not dead is alive.
            
            On their turn, a player must place a piece on an empty square of a living board.
            
        When all boards are dead, the player who made the last placement loses. 
(game "Notakto" 
    (players 2) 
    (equipment { 
        (board
            (union {
                (square 3) 
                (shift 0 4 (square 3))
                (shift 0 8 (square 3))
                (shift 0 12 (square 3))
                (shift 4 0 (square 3))
                (shift 4 4 (square 3))
                (shift 4 8 (square 3))
                (shift 4 12 (square 3))
                (shift 8 0 (square 3))
                (shift 8 4 (square 3))
                (shift 8 8 (square 3))
                (shift 8 12 (square 3))
                (shift 12 0 (square 3))
                (shift 12 4 (square 3))
                (shift 12 8 (square 3))
                (shift 12 12 (square 3))
            })		
        )
        (piece "Marker" Each) 
    }) 
    (rules 
        (play 
            (move Add 
                (to 
                    (sites Empty)
                    if:(= 0 (state at:(to)))
                )
                (then
                    (if (is Line 3) 
                        (forEach Site (expand origin:(last To) steps:2) (set State at:(site) 1))
                    )
                )
            )
        )
        (end (if (no Moves Next) (result Mover Loss)))
    )
)

Construct a Ludii game based on the following description
Aj Sina'anil, \Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, and then back to home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the team's home field, the piece may be re-entered. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured. Pieces are allowed to move forward or backward if the move captures a piece. The captures piece is placed on top of the piece that captured it, and the stack now moves toward the capturing player's home space. If the player successfully carries the captured piece to the team's home space, the piece is permanently captured and removed from play. If the opposing side lands on the same space as the stack, they are stacked with the opponent's piece, and the opponent begins carrying the stack to the opposing team's side. Any pieces captured belonging to the team which brings them back to their home are returned to their players. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces.
         The game has 6 players.
(game "Aj Sina'anil"
    (players <Player:num>)
    (equipment {
        (board
            (rectangle 1 <Player:size>)
            <Player:tracks> 
            use:Edge
        )
        (regions "AllSites" (sites Board Vertex))
        (piece "Stick" Each
            (forEach Value (values Remembered "Throws")
                (or
                    (if ("FreePiece" (state at:(from) level:(level)))
                        (or
                            (if ("IsOffBoard" ("NextSiteOnTrack" (value) from:(from) "Track"))
                                (move 
                                    (from (from) level:(level))
                                    (to 
                                        (handSite Mover)
                                        (apply (forget Value "Throws" (value)))		
                                    )
                                )
                                (move 
                                    (from (from) level:(level)
                                        if:(if (is In (from) (sites Hand Mover))
                                            ("NoPieceOnBoard")
                                            True
                                        )
                                    )
                                    (to 
                                        ("NextSiteOnTrack" (value) from:(from) "Track")
                                        (apply (forget Value "Throws" (value)))
                                    )
                                    (then 
                                        (if ("AtLeastAnEnemyPieceThere" (last To))
                                            ("CaptureMove")
                                        )
                                    )
                                )
                            )
                            (if (and (is In (from) (sites Board)) ("IsNotOffBoard" ("NextSiteOnTrack" (value) from:(from) "CaptureTrack")))
                                (if ("AtLeastAnEnemyPieceThere" ("NextSiteOnTrack" (value) from:(from) "CaptureTrack"))
                                    (move 
                                        (from (from) level:(level))
                                        (to 
                                            ("NextSiteOnTrack" (value) from:(from) "CaptureTrack")
                                            (apply (forget Value "Throws" (value)))
                                        )
                                        (then 
                                            ("CaptureMove")
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (if ("CapturingPiece" (state at:(from) level:(level)))
                        (if ("IsOffBoard" ("NextSiteOnTrack" (value) from:(from) "CaptureTrack"))
                            (do (forget Value "Throws" (value))
                                next:(move Remove (from) level:(level)
                                    (then
                                        (and {
                                            ("UnsetCapturingPieces")
                                            ("RemoveCapturedPieces")	
                                            ("RebirthCapturingPiece")
                                        })
                                    )
                                )
                            )
                            (move 
                                (from (from) level:(level))
                                (to 
                                    ("NextSiteOnTrack" (value) from:(from) "CaptureTrack")
                                    (apply (forget Value "Throws" (value)))
                                )
                                (then 
                                    (and
                                        ("CapturedPiecesFollowCapturingPiece")
                                        ("UnsetCapturingPieces")
                                    )
                                )
                            )
                        )
                    )
                )
            )		
        )
        ("StickDice" 4)
        (hand Each)
    })
    (rules 
        (start {
            <Player:team>
        })
        
        phases:{
        (phase "ThrowPhase" 
            (play 
                ("RollMove"
                    (move Pass
                        (then
                            (if (not (no Pieces Mover))
                                (and {
                                    (if (!= 0 ("ThrowValue"))
                                        (do
                                            (remember Value "Throws" ("ThrowValue"))
                                            ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece)))
                                        )
                                    )
                                    (moveAgain)
                                    (if ("SameTurn") (set Pending))
                                })
                            )
                        )
                    )
                )	
            )
            (nextPhase (is Pending) "MovePhase")
        )
        (phase "MovePhase" 
            (play 
                (or (forEach Piece) (forEach Piece container:(mover))
                    (then
                        (if (< 0 (size Array (values Remembered "Throws")))
                            (moveAgain)
                        )
                    )
                )
            )
            (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase")
        )
        }
        
        (end ("CaptureAllTeam"))
    )
)

Describe the mechanics of the following Ludii game
(game "Meurimueng-rimueng Peuet Ploh" 
    (players 2)
    (equipment { 
        ("AlquerqueBoard" 9 9)
        (piece "Marker" Each 
            (or 
                ("HopSequenceCapture")
                ("StepToEmpty")
            )
        )
    }) 
    
    (rules 
        ("BeforeAfterCentreSetup" "Marker1" "Marker2")
        
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("ForEachPlayerNoPiecesLoss"))
    )
)
Merimuëng-rimuëng Peuët Ploh is a capturing game played by the Acehnese people of Sumatra.9x9 intersecting lines, with diagonals drawn in every 4x4 square formed. Forty pieces per player, placed on the board with the central space unoccupied. Players alternate turns moving one piece to an empty adjacent spot. They may capture an opponent's piece by hopping over it. Multiple hops in one turn are allowed, but not required. The first person to capture all of the opponent's pieces wins. 

Construct a Ludii game based on the following description
Zuz Mel is a capturing game played by children in El Oued, Algeria. This version if played on a 5x5 board.5x5 board. Twelve pieces per player. Pieces begin in the rows closest to the player, and the two spaces to the right of the central space. Players alternate turns moving a piece orthogonally any distance. A player may capture an opponent's adjacent piece by hopping over it in an orthogonal direction to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of the opponent's pieces wins. 
(game "Zuz Mel (5x5)"
    (players 2)
    (equipment {
        (board (square 5))
        (piece "Marker" Each 
            (or 
                ("HopOrthogonalSequenceCapture")
                (move Slide Orthogonal)
            )
        )
    })
    (rules
        
        (start {
            (place "Marker1" (union (expand (sites Bottom)) (sites {"D3" "E3"})))
            (place "Marker2" (union (expand (sites Top)) (sites {"A3" "B3"})))
        })
        
        (play
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Renard et les Poules is a hunt game documented in nineteenth century France. Played on cross-shaped board, made of five squares, each divided into four squares and with the diagonals of the larger squares drawn. One player plays as seventeen hens, which begin on the points on one of the arms of the cross and along the line immediately perpendicular to that arm, and on the two outermost points on the left and right arms. The other player plays as one fox, which starts on the central point of the board. Players alternate turns moving to an empty adjacent spot along the lines of the board. The hens, however, can only move in a forward or horizontal direction. The fox hops over an adjacent hen to an empty spot immediately on the opposite side of the hen along the lines of the board. At the beginning of the game, the players choose whether to allow the fox the ability to make multiple captures in one turn. If the fox is able to capture but does not, the opponent adds another hen on an empty point in the bottom row. If there is no empty spot on the bottom row, the player waits until there is one to place the new hen. The fox wins by capturing all of the hens or by moving to the furthest line on the hens' side of the board. The hens win by blocking the fox from being able to move.
         The fox can capture one single piece.
(game "Renard et les Poules" 
    (players 2) 
    (equipment { 
        ("CrossBoard" 3 7 use:Vertex diagonals:Alternating)
        (hand P1)
        (piece "Fox" P1 S
            (or 
                <Fox:hopCapture> 
                <Fox:stepMove>
            ) 
        )
        (piece "Hen" P2 N ("StepToEmpty" (directions {Forwards Rightward Leftward}))) 
    }) 
    (rules 
        (start { 
            (place "Fox1" (centrePoint))
            (place "Hen2" (union {(expand (sites Bottom)) (sites Row 2) (sites {"A4" "G4" "A5" "G5"})}))
        })
        
        phases:{
        (phase "FoxPhase" P1 
            (play 
                <Fox:rememberHopCapture> 
            )
        )
        (phase "HenPhase" P2
            (play 
                (if (and ("DidNotCaptured") (!= 0 (count Sites in:("BottomEmptySites"))))
                    (move Add 
                        (to ("BottomEmptySites")) 
                        (then (and ("HenAdded") (moveAgain)))
                    )
                    (forEach Piece)
                )
            )
        )
        }
        
        (end {
            (if (no Moves P1) (result P1 Loss))
            (if (or (is In (where "Fox" P1) (sites Bottom)) (no Pieces P2)) (result P1 Win))
        }) 
    )
)

Construct a Ludii game based on the following description
Marelle Triple is a game of alignment played in France. Described in the nineteenth century, it is played on a board common worldwide, with slight variations in the rules.Three concentric squares, the corners and midpoints of the squares connected with lines. Nine pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, the players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row along the orthogonal lines (not along the diagonal lines), the player removes any one of the opponent's pieces. When a player is reduced to four pieces, they may move a piece to any open spot on the board. The player who reduces the opponent to two pieces wins.
         
(game "Marelle Triple"
    (players 2)
    
    (equipment { 
        (board (concentric Square rings:3 joinCorners:True) use:Vertex) 
        (hand Each)
        (piece "Marker" Each ("StepToEmpty" ~ "IfLine3MoveAgain")) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:9))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPiece")
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        "IfLine3MoveAgain" 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPiece")
                    (if (> (count Pieces Mover) 4)
                        (forEach Piece)
                        (move 
                            (from (sites Occupied by:Mover))
                            (to (sites Empty))
                        )
                    )
                )
            )
        )
        }
        (end ("HavingLessPiecesLoss" Next 2))
    )
)

Describe the mechanics of the following Ludii game
(game "Baralie" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" "BackgammonTracksSameDirectionWithBar") 
        (dice num:2)
        (map {(pair 1 19) (pair 2 6)}) 
        (piece "Disc" Each) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 12 count:15)
            (place Stack "Disc2" 11 count:14) 
            (place Stack "Disc2" 10)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (if (all DiceUsed)
                    ("MoveTo" ("NextSiteFromDist6" (site)))
                    (forEach Die
                        if:("DieNotUsed")
                        ("MoveTo" ("NextSiteFrom" (site)))
                        (then (moveAgain))
                    )
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (result Mover Win)
            )
        )
    )
)
Baralie is a European Tables game played in medieval England. 2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Both players begin on the same side of the board, one player with fifteen pieces on the rightmost point, the other player with fourteen pieces on the point behind it, and one on the point behind that. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. On each throw the player also plays a throw of 6 in addition to the throw presented by the dice. Pieces move in an anti-clockwise direction around the board. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging  to the opponent, the opponent's piece is removed from the board and must enter again from the leftmost point in the row where the pieces began. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins. 

Construct a Ludii game based on the following description
Pylos is a board game invented by David G. Royffe and published by Gigamic.Each player starts off with 15 balls. Players take turns taking pieces from their reserve pile, and placing them on a 4x4 game board made up of 16 indentations. When four pieces are placed next to each other in a square, one piece can be put on top of the square. That piece can also be one of the player pieces on the board with no other piece on top of it. If the square is completed with all the same color, the player of that color may take two of their own pieces from the board (one or two that are not supporting anything) and put it back into their reserve pile. At the end of the game, the game board should have 4 levels. The first level with 16 pieces, the second level with 9 pieces, the third level with 4 pieces, and the fourth level with 1 piece. A player wins if they put the last piece on the 4th level. 
(game "Pylos" 
    (players 2) 
    (equipment { 
        (board (square 4 pyramidal:True) use:Vertex) 
        (piece "Ball" Each) 
        (hand Each)
    }) 
    (rules 
        (start (place "Ball" "Hand" count:15))
        
        (play 
            (if "SameTurn"
                (move 
                    (from (sites Occupied by:Mover) if:("NothingOnTop"))
                    (to (handSite Mover))
                    (then (if (= (var) 1) (and (set Var 0) (moveAgain))))
                )
                (or
                    (do
                        (move 
                            (from
                                (sites Occupied by:Mover)
                                if:("NothingOnTop")
                            )
                            (to 
                                (sites Empty) 
                                if:(and 
                                    (is Flat)
                                    (< (layer of:(from)) (layer of:(to)))
                                )
                            )
                        )
                        ifAfterwards:(is Flat (last To))
                    )
                    (move 
                        (from (sites Occupied by:Mover container:(mover))) 
                        (to (sites Empty) 
                            if:(is Flat)
                        )
                    )
                    (then
                        (if (is Pattern {F R F R F} whats:{(id "Ball" Mover)}) 
                            (and (set Var 1) (moveAgain))
                        )
                    )
                )
            )
        )
        
        (end 
            (if 
                (= (layer of:(last To)) 3) 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Dodo is a dead simple game where the goal is to run out of moves.On your turn you move one of your pieces one step onto an empty cell in one of the three forwards directions. Black's pieces move towards the bottom of the board, while White's pieces move towards the top. If, at the beginning of your turn, none of your pieces can move, you win. 
(game "Dodo"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board (rotate 30 (hex 4)))
        (piece "Disc" Each ("StepToEmpty" Forwards))
    })
    (rules
        (start {
            (place "Disc1" {0 1 2 3 4 5 6 7 9 10 11 15 16})
            (place "Disc2" {20 21 25 26 27 29 30 31 32 33 34 35 36 })
        })
        (play (forEach Piece))
        (end ("MisereBlockWin"))
    )
)

Construct a Ludii game based on the following description
Off-shore is a territorial game where territory is based on 3 pillars:   -- Territory defined by the convex hulls of groups,   -- Group expansion limited to those groups that are not larger in size than the count of the current number of friendly groups.   -- The capture of enemy groups by expanding one's territory to encompass them.      A further minor point is that placement into enemy territory is restricted, thus preventing suicide placements, and indeed for standard play, preventing any expansion into the territory at all.      Some of the implications are:   -- groups can be captured from two sides, no need to surround.   -- to expand or merge groups, one must first have played enough isolated stones during the game. This rule prevents the game from being a simple race to cut off large corners.   -- capturing a group therefore also reduces the captured player's expansion potential due to loss of a group, in addition to the reduction in playble space.   -- merging groups is a powerful key type of move that creates strategic focus, but also reduces future growth potential by reducing the group count.   -- cells adjacent to stones along the edges of opponent's territory are likely to remain open for play, but care is needed to ensure that, when placing stones there, they are (or can be) connected to regions where the opponent is less able to expand his territory.      The game was inspired by investigating possible new ways of defining territory and capture.Definitions:
            -- Each of a player's stones belongs to exactly one group. 
            -- The group it belongs to contains all the stones that connect to it by virtue of being next to one another (across an edge).
            -- A player's territory is the union of all the cells that are within the convex grid-oriented hulls of the player's groups. 
            
            In simpler language:
            Imagine a line of cells that goes through just one stone of a group and leaves the rest of that group to one side. Surround the group with six of these lines and they will exactly contain all the territory of the stones of that group. A player's territory is then the combined territory of every group, counting cells only once where any of the group territories overlap.
            
            -- A player's score is the number of empty cells in their territory.
            
            Play:
            The mover places a stone onto an empty site, with the following two limitations:
        1) No placing in the opponent's territory.
    2) No placing next to a friendly group that has more stones than there are friendly groups.
    (Note that the resulting size of a group is irrelevant.)
    
    After the placement, every opponent's group that lies completely within the mover's territory is removed.
    
    Passing is voluntary. 
    When both players pass consecutively, the higher score wins. In case of a tie, the last to play wins.
    
    Various boards are optional. 
Weak Territory, allowing placement next to a friendly group in enemy territory is optional. 8 Square No placement within Enemy territory.
(game "OffShore"
    (players 2)
    (equipment {
        (board <Board:type> use:Cell)
        (hand Each size:1)
        (piece "Disc" Each)
    })
    (rules
        (start {
            (place "Disc1" (handSite P1 0) value:0) 
            (place "Disc2" (handSite P2 0) value:0) 
        })
        (play
            (or
                (move Pass)
                (move Add
                    (to
                        (difference
                            (union { 
                                (if
                                    (= 1 (mover)) 
                                    ("EmptySitesOutsideEnemyTerritoryFor" "P2")
                                    ("EmptySitesOutsideEnemyTerritoryFor" "P1")
                                )
                                (<RestrictionEasementFor:placement>)
                            })
                            ("SitesInOversizedGroups")
                        )
                    )
                    (then
                        (do 
                            ("UpdateGroupSizeValue4PiecesConnected2Placement")
                            next:("UpdateTotalMoverGroupCount")
                            (then
                                (if 
                                    ("IsNotAnIsolatedPlacement")
                                    ("RecordTerritoryOfRevisedGroup")
                                    (then
                                        (priority
                                            (if 
                                                (= (mover) 1)
                                                ("CaptureWithin" "P2" "P1")
                                                ("CaptureWithin" "P1" "P2")
                                                (then ("Scoring"))
                                            )
                                            ("Scoring")
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        (end 
            (if  (all Passed)
                {
                (if
                    (> (score Mover) (score Next))
                    (result Mover Win)
                )
                (if
                    (< (score Mover) (score Next))
                    (result Mover Loss)
                )
                } 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Trianon is a game played on a 5x5 board.TURN - On each turn, each player drops a stone on an empty cell
            
        GOAL - A player loses if he has 3 friendly stones on an orthogonal or diagonal line (they don't need to be adjacent to each other). 
(game "Trianon"
    (players 2)
    (equipment {
        (board (square 5) use:Vertex)
        (piece "Ball" Each)
    })
    (rules
        (play (move Add (to (sites Empty))))
        (end (if ("ThreeStones") (result Mover Loss)))
    )
)

Construct a Ludii game based on the following description
A square connection game where crosscuts are resolved by swapping stones. Resolve was designed by Alek Erickson in July 2020. The rules were finalized through critical playtesting session with Dale Walton and Luis Bolaños Mures. The game was partly inspired by the swap mechanic from Michael Zapala's Slyde. The original idea for swapping stones to resolve crosscuts can be traced to Phil Leduc's Thruway and Bill Taylor's Swapway as early as 2008, but the notion of a resolving stone where a single stone gets serially swapped to fix cuts in Resolve is novel.Resolve is a connection game for two players: a player with Black stones who wins by connecting the East/West sides, and a player with White stones who wins by connecting the North/South sides. Players take turns placing and swapping stones on the intersections of a square grid which is initially empty. Passing is forbidden. Same-colored stones with orthogonal adjacency are connected. The game is over when a player wins by connecting their designated sides of the board with a single group of connected stones of their color, at any time during their turn or their opponent's turn. Cutting stones are any four stones in a generic crosscut configuration.  
            
            OX
            XO
            
            On your turn you must select the following one of two actions. 
            1. Place a stone of your color on an empty point. If that stone creates a crosscut, swap it with different adjacent enemy stones that share a crosscut with it, until that stone is no longer part of a crosscut. 
        2. Choose a stone of your color that is part of a crosscut, and use it to resolve crosscuts as in 1. Then place a stone of your color on an empty point, if possible. Order 5 board
(game "Resolve"
    (players 2)
    (equipment {
        "SquareGrid"
        (regions P1 {(sites Side N) (sites Side S) }) 
        (regions P2 {(sites Side W) (sites Side E) })
        (piece "Ball" P1)
        (piece "Ball" P2)
    })
    (rules
        (play
            (if ("NewTurn")
                (or
                    ("Place")
                    ("Choose2Resolve")
                )
                (if 
                    (<= 0 (var "LT"))
                    ("ResolveTheValue" (var "LT"))
                    ("Place")
                ) 
            )
        ) 
        (end {
            (if 
                (is Connected Orthogonal Mover) 
                (result Mover Win)
            )
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Jeu Militaire" 
    (players 2) 
    (equipment { 
        (board 
            (rotate 90 ("ThreeMensMorrisGraphWithLeftAndRightTriangles"))
            use:Vertex
        )
        <Version:hand>
        
        (piece "Pawn" P1 ("StepToEmpty" <Army>))
        (piece "Pawn" P2 N ("StepToEmpty" <Tower>))
        (regions "Home" P2 (sites {"B1" "C2" "A2"}))
        (regions "Home" P1 (sites {"B2"}))
    }) 
    
    (rules 
        <Version:start>
        
        <Version:play> 
        
        (end {
            (if <EndCondP2> (result P2 Win))
            <Move:limit>
            (if (is In (where "Pawn" P1) (sites P2)) (result P1 Win))
            
                
                    
                    
                
                
            
        }) 
    )
)
The Jeu Militaire is a game documented since the nineteenth century in France. It was reported by several sources as being played in the French military.The board consists of three instersecting lines, with diagonals drawn in the square formed. On opposite ends of the square, the central line is extended beyond the square and lines drawn from the adjacent corners to the end of this line, forming two triangles at opposite ends. One player takes the part of three white towers, the other the part of a single black army piece. First the army moves their piece, then the towers move one of their pieces, play alternating thereafter until the game is ended. A tower piece may move one step along a marked line in any forward or sideways direction. Tower pieces cannot move backwards, diagonally or otherwise, towards the end of the board from which they started. The army may move one step in any direction along a marked line. The army wins by passing the towers and reaching the end of the board from which they started. The towers win by trapping the army so that it cannot move in its turn. The towers can move in sideway and forwards (including diagonal and orthogonal forward). The army can move in all the directions. The army can not move. The game is played according to the rules of Lucas with the pieces already on the board. 

Construct a Ludii game based on the following description
Six Men's Morris was popular in Medieval Europe until about 1600 CE. It is an alignment game based on Nine Men's Morris, with similar rules.Same rules as Murray, except a player cannot remove an opponent's piece that is in a three in a row formation unless there are no other options. The game starts with 5 pieces by player. Any Enemy piece can be captured.
(game "Six Men's Morris"
    (players 2) 
    
    (equipment { 
        (board (concentric Square rings:2) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3" Orthogonal exact:True)))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:<Num:piece>))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    <Remove:rule>
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True))
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    <Remove:rule>
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("HavingLessPiecesLoss" Next 2))
    )
)

Construct a Ludii game based on the following description
This game is played on a 7x7 square board.MOVE - Stones may move to an adjacent (orthogonal or diagonal) empty cell.
            
            CAPTURE - Stones capture by jumping over an enemy stone and landing in the immediate opposite empty cell.
            - Captures are mandatory.
            - Captures are multiple and the player must choose the jumping sequence that captures more enemy stones.
            
        GOAL - A player wins when it captures all enemy stones, or when he moves his last remaining stone to the center cell. 
(game "Jumping Beans"
    (players 2)
    (equipment {
        (board (square 7))
        (piece "Bean" Each ("StepToEmpty"))
    })
    (rules
        ("BeforeAfterCentreSetup" "Bean1" "Bean2")
        
        (play 
            (if ("SameTurn")
                (max Moves
                    ("HopCapture"
                        (from (last To))
                        ~
                        (then ("ReplayIfCanMove" ("HopCapture" (from (last To)))))
                    )
                )
                (priority {
                    (max Moves
                        (forEach Piece
                            ("HopCapture" ~ ~ (then ("ReplayIfCanMove" ("HopCapture" (from (last To))))))
                        )
                    )
                    (forEach Piece)
                })
            )
        )
        
        (end (if (or
                    (no Pieces Next) 
                    (and
                        (= 1 (count Pieces Mover))
                        (= (centrePoint) (where "Bean" Mover))
                    )
                )
                (result Mover Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Tic-Tac-Toe Misere" 
    (players 2) 
    (equipment { 
        (board (square 3)) 
        (piece "Disc" P1) 
        (piece "Cross" P2) 
    }) 
    (rules 
        (play (move Add (to (sites Empty))))
        (end (if (is Line 3) (result Next Win)))
    )
)
Tic-Tac-Toe Misere is played as per Tic-Tac-Toe, except that a player loses by making three-in-a-line of their colour.Play occurs on a 3x3 grid. One player places an X, the other places an O and players take turns placing their marks in the grid, losing is they make three in a row of their colour. 

Describe the mechanics of the following Ludii game
(game "Kharebga (7x7)"
    (players 2)
    (equipment {
        (board (square 7))
        (piece "Marker" Each 
            (move Slide Orthogonal
                (then ("CustodialCapture" Orthogonal (max 1)))
            )
        )
        (hand Each)
    })
    (rules
        (start (place "Marker" "Hand" count:24))
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover))
                    (to (difference (sites Board) (centrePoint)) if:(is Empty (to)))
                    (then
                        (if ("NewTurn") (moveAgain))
                    )
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Capture")
        )
        ("PhaseMovePiece" "Capture")
        }
        (end ("CaptureAll" Next))
    )	
)
Kharebga is a game with custodial captures played by children in El Oued, Algeria.7x7 board. 24 pieces per player. Players alternate turns placing two pieces on an empty space on the board, except in the central space. Captures cannot be made during the placement phase. When all of the pieces have been placed, players alternate turns moving a piece orthogonally any distance. When an opponent's piece is between two of a player's pieces, it is captured. If a player is unable to make a move, they pass their turn and the opponent plays again. The player who captures all of the opponent's pieces wins.
         

Construct a Ludii game based on the following description
Böxijn Barildaan (the struggle) is a capturing game played in Mongolia.  Four squares, arranged in a cross shape. The game is played along the lines. Four pieces per player, which begin on the corners of a square, opposite the square where the opponent's pieces are arranged. Players alternate turns moving their pieces. Pieces move three spaces along the lines on the board, capturing any piece on the third. The first two spaces in the move must be empty. Pieces may change direction in a turn, as long as the lines are followed and there is no backtracking. The player who captures all of the opponent's pieces wins. 
(game "Boxijn Barildaan"
    (players 2)
    (equipment {
        (board 
            (merge {
                (shift 1 0 (rectangle 4 2))
                (shift 0 1 (rectangle 2 4))
            })
            use:Vertex
        )
        (piece "Marker" Each ("StepMove"))
    })
    (rules
        (start {
            (place "Marker1" (expand (sites Bottom)))
            (place "Marker2" (expand (sites Top)))
        })
        (play 
            (if ("SameTurn")
                ("StepMove" (from (last To)))
                (forEach Piece)
            )
        )
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Plotto is a twist on 4-in-a-row played on a Hex board(less) with four colours of stones.MOVE - Players move in turn to place one stone of either color on an empty cell.
            - However, the dropped stone must be adjacent, at least, to two other stones.
            - A stone cannot be adjacent to another stone of the same color.
            
        GOAL - Wins the player that makes a 4 in-a-row, with stones of his color at both ends (one player has Black and Blue, the other has White and Red). 
(game "Plotto" 
    (players 2) 
    (equipment { 
        (boardless Hexagonal) 
        (tile "Hex" Each numSides:6) 
        (tile "SecondHex" Each numSides:6) 
        (hand Each size:2)
    }) 
    
    (rules 
        (start {
            (place "Hex1" (centrePoint)) 
            (place "Hex2" (ahead (centrePoint) E))
            (place "Hex1" (handSite P1 0))
            (place "Hex2" (handSite P2 0))
            (place "SecondHex1" (handSite P1 1))
            (place "SecondHex2" (handSite P2 1))
        })
        
        (play 
            (move 
                (from (sites Hand Mover))
                (to 
                    (sites Playable) 
                    if:(and
                        (<= 2 (count Sites in:(sites Around (to) NotEmpty)))
                        (not (is In (what at:(from)) (results from:(last From) to:(sites Around (to)) (what at:(to)))))
                    )
                )
                copy:True
            )
        )
        
        (end (if ("IsLine4WithEndSameColour") (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Hyvn ætter Hare is a blackade game played on Funen Island in Denmark. One player plays as the hare, and the other as three hounds, which attempt to trap the hare. Square board, divided into eight equal triangles, and a circle around the square, touching it at the corners, One player plays as the hare, the other player as three hounds. Players take turns placing one of their pieces on the board. When a player has placed all their pieces, they move to an adjacent empty spot. When the hounds block the hare from being able to move, the hounds win.  The First player moves only when all the pieces are placed.
(game "Hyvn aetter Hare"
    (players 2) 
    (equipment {
        (board 
            (splitCrossings
                (merge
                    (shift .5 .5 (scale 0.707 (concentric {1 8})))
                    (square 2)
                )
            )
            use:Vertex
        )
        (piece "Hare" P1 "StepToEmpty") 
        (piece "Dog" P2 "StepToEmpty") 
        (hand Each)
    }) 
    (rules 
        (start { 
            (place "Hare1" (handSite P1) count:1)
            (place "Dog2" (handSite P2) count:3)
        })
        <Play>
    )
)

Describe the mechanics of the following Ludii game
(game "Shah"
    (players 2)
    (equipment {
        ("NineMensMorrisBoard")
        (piece "Marker" Each ("StepToEmpty" ~ "IfLine3MoveAgain"))
        (hand Each)
    })
    (rules 
        (start (place "Marker" "Hand" count:12))
        phases:{
        (phase "Placement" 
            (play 
                (move 
                    (from (handSite Mover))
                    (to (sites Empty))
                    (then ("SetPlayerSecondPhase" (mover)))
                )
            )
            (nextPhase (and ("HandEmpty" P1) ("HandEmpty" P2)) "Remove")
        )
        (phase "Remove" 
            (play ("RemoveEnemyPiece"))
            (nextPhase Mover "Move")
        )
        (phase "Move" 
            (play 
                (if (and (not (is Pending)) "SameTurn")
                    ("RemoveEnemyPiece"
                        (then
                            (if (no Moves Next)
                                (and (moveAgain) (set Pending))
                            )	
                        )
                    )
                    (if (is Pending)
                        (do
                            (forEach Piece ("StepToEmpty")) 
                            ifAfterwards:(can Move (forEach Piece Next))
                        )
                        (forEach Piece)
                    )
                    (then
                        (if (= 2 (count Pieces P1))
                            (addScore P2 1 
                                (then 
                                    (if (!= (score P2) 5) 
                                        ("ResetGame")
                                    )
                                )
                            )
                            (if (= 2 (count Pieces P2))
                                (addScore P1 1 
                                    (then 
                                        (if (!= (score P1) 5) 
                                            ("ResetGame")
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (= 0 (count Sites in:(sites Occupied by:All container:"Board"))) "Placement")
        )
        }
        
        (end (if (= (score Mover) 5) (result Mover Win)))
    )
)
Shah is a game of alignment played in Somalia in the early twentieth century. It was one of the most popular games there, especially among men and children. Three concentric squares, with the midpoints of their sides connected with lines. Twelve pieces per player. Players take turns placing one of their pieces on an empty point on the board. The first player to make three in a row obtains the privilege of starting the next phase after all of the stones are placed; if no one makes three in a row the last player to place a stone begins the next phase. Ones all of the stones are placed, the player who has the right to begin the next phase removes any one of the opponent's stones, and the opponent does the same with one of the player's pieces. Then, players alternate turns moving one of their pieces to an empty adjacent space. When a player place three of their pieces in a row, they remove one of the opponent's pieces. If a player moves in such a way that the opponent cannot move, the player must make an extra move to allow the opponent a place to play. A player cannot capture an opponent's piece when this extra move is made. The player who captures all but two of the opponent's pieces wins. Games are usually played in sequence, starting with the winner of the previous game, with the first player to win five games in a row being the winner.
         

Construct a Ludii game based on the following description
Ultimately originates from Indian Chaturanga, arrived in Western Europe during the Middle Ages as Shatranj. Over several centuries, after seeming experimentation with movement, the adoption of the modern movement of the queen and bishop made chess what it is today. Modern Chess appeared sometimes during the fourteenth or fifteenth Century, when the vizier piece was replaced by the queen. It since has become perhaps the most popular game in the world, with massive international competitions.Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. Players capture pieces by moving onto a space occupied by an opponent's piece. Player wins when they checkmate the other player's king. 
(game "Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        ("Castling")
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Pahada Keliya is a race game played in Sri Lanka that is similar to other games played on a cross-shaped board in South Asia. The game is typically played on a cloth that is embroidered with the game pattern on it. It involves a complex set of moves in order to allow a player to begin to end the game, which causes great excitement in the course of play. It was considered by many in Sri Lanka to be the finest game in the world.Four 3x8 rectangles, arranged in a cross shape with a large square space in the center. The outer corners of each square are marked with a cross, as are the third and sixth space from the same corner. Four players, playing on two teams. Four pieces per player. The pieces are red, green, yellow, and black. Players start with one piece on the sixth and seventh space of the central row in their arm, and two pieces on the third space in the outer row of their arm, to the right. Two rectangular four-sided dice, with the following throws: 1, 3, 4, 6. Players use the throw of a die to move a piece; they may therefore may move two pieces each the value of one of the dice, or one piece twice, using the value of each dice. Play moves down the central track of the player's arm, around the outer perimeter of the board in an anti-clockwise direction, and back up the central row of the player's arm, proceeding into the large central square. When a player's piece moves into a space occupied by an opponent's piece, the opponent's piece is sent to the central square, from which it must begin again. A player cannot move into their central row, approaching the end of the track, unless two of their team member's pieces have moved past the player's own pieces. If two or more of the team member's pieces remain behind the player's own pieces, the player's pieces may not advance past the final three spaces in the left hand track of their home arm of the board. Neither they, nor any of the team's pieces, can proceed until two of the team member's pieces are placed, by exact throws, on the left inner corner of the arm of the player wishing to advance. These two pieces must then proceed together; i.e., only on double throws of the dice, with the exception that a double they cannot be used if it would cause them to land on a space occupied by a team member waiting to move. Once a double throw is successfully made and both pieces moved, the waiting pieces may proceed up the central row. When players cannot move the throws, they pass their turn. Players must move into the central square with an exact throw. The first team to place all of their pieces in the central square wins. 
(game "Pahada Keliya" 
    (players 4) 
    (equipment {
        ("PachisiBoard"
            {
            (track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True)
            (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True)
            (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True)
            (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)
            }
        )
        (dice d:4 faces:{1 3 4 6} num:2)
        (piece "Pawn" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) (pips)))
                    (move Remove (from) level:(level))
                    (move 
                        (from (from) level:(level))
                        (to
                            ("SiteToMoveOnTrack" from:(from) (pips))
                            if:(if (not (is In (to) (sites Mover "CentralRow")))
                                True
                                (if (or (is In (from) (sites Mover "CentralRow")) (= (from) ("Centre")))
                                    True
                                    (<= 1 (value Player Mover))
                                )
                            )
                            (apply
                                (if ("IsEnemyAt" (to))
                                    (forEach Level (to) FromTop
                                        (and {
                                            (if (= 1 (state at:(to) level:(level)))
                                                ("SetValueAlly" (- ("ValueAlly") 1))
                                            )
                                            (remove (to) level:(level))
                                            (add (piece ("PawnPiece" (who at:(to) level:(level)))) (to (centrePoint)))
                                        })
                                    )
                                )
                            )
                        )
                        (then
                            (if (and (= 0 (state at:(last To) level:(last LevelTo))) (is In (last To) ("RightCentralAlly")))
                                (and
                                    (set State at:(last To) 1)
                                    ("SetValueAlly" (+ 1 ("ValueAlly")))
                                )
                            )
                        )
                    )
                )	
                (then ("ReplayNotAllDiceUsed"))
            )
        )
        (regions "CentralRow" P1 (sites Direction from:55 N included:True distance:7))
        (regions "CentralRow" P2 (sites Direction from:19 E included:True distance:7))
        (regions "CentralRow" P3 (sites Direction from:94 S included:True distance:7))
        (regions "CentralRow" P4 (sites Direction from:34 W included:True distance:7))
        (regions "RightCentral" P1 (sites Direction from:56 N included:True distance:7))
        (regions "RightCentral" P2 (sites Direction from:0 E included:True distance:7))
        (regions "RightCentral" P3 (sites Direction from:93 S included:True distance:7))
        (regions "RightCentral" P4 (sites Direction from:50 W included:True distance:7))
    }) 
    (rules 
        (start {
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
            (place Stack "Pawn1" 61) (place Stack "Pawn1" 58)
            (place Stack "Pawn1" 62 count:2)
            (place Stack "Pawn2" 21) (place Stack "Pawn2" 20)
            (place Stack "Pawn2" 2 count:2)
            (place Stack "Pawn3" 88) (place Stack "Pawn3" 91)
            (place Stack "Pawn3" 87 count:2)
            (place Stack "Pawn4" 32) (place Stack "Pawn4" 33)
            (place Stack "Pawn4" 48 count:2)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (forEach Piece)
            )
        )
        
        (end ("EscapeTeamWin"))
    )
)

Construct a Ludii game based on the following description
Daldøsa is a capturing game that is played in the Jæren region of Norway. It is very similar to other games, like Daldøs and Sáhkku, played in the region, which are played in a similar way to games like Tab. The history of the game is unknown, but it appears to have once been popular.3x12 board, with the outer rows of holes slightly curved to form the appearance of an arc. Twelve pieces per player, which start on the board in each of the holes in the outer row belonging to a player. Two four-sided dice, marked 2-4 and \ 
(game "Daldosa"
    (players 2)
    (equipment {
        (board 
            (add 
                (merge {
                    (rectangle 1 8)
                    (shift -4 1.5 (rectangle 1 12))
                    (shift 0 3 (rectangle 1 8))
                })
                vertices:{{-1 0.1} {-2 0.3} {-2.9 0.5} {-3.6 0.8} {-1 2.9} {-2 2.7} {-2.9 2.5} {-3.6 2.2}}
            )
            {
            (track "Track1" {31..28 0..7 19..8 35..32 20..27 19..8} loop:True P1)
            (track "Track2" {35..32 20..27 19..8 31..28 0..7 19..8} loop:True P2)
            }
            use:Vertex
        )
        (regions "AllSites" (sites Board))
        (dice d:4 num:2)
        (piece "Minus" P1 ("MoveAPiece" "Track1"))
        (piece "Minus" P2 ("MoveAPiece" "Track2"))
    })
    (rules 
        (start {
            (place "Minus1" (sites {0..7 28..31}))
            (place "Minus2" (sites {20..27 32..35}))
        })
        (play 
            ("RollEachNewTurnMove"
                (forEach Die 
                    replayDouble:(and (= (face 36) 1) (= (face 37) 1))
                    (forEach Piece
                        (then 
                            (if (not (all DiceUsed))
                                ("ReplayIfCanMove" (forEach Die (forEach Piece)))
                            )
                        )
                    )
                )
            )
        )
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Alea Evangelii is a game that was discussed in Corpus Christi College Manuscript 122, dated to the twelfth century CE and probably written at Bangor Abbey, Ireland. The document illustrates the board with pieces on it and provides an ecclesiastical explanation for the board with reference to the Christian Gospels. It seems to be a Christian justification for an earlier game, which appears to have been similar to other known tafl games. Modern scholars have suggested that the author of the manuscript may have made several errors in reconstructing the board and the placement of the pieces.The game begins with the pieces set out as in the diagram. 2. The king's side takes the first move, play then alternating between players. 3. In his turn a player moves one of his pieces along a straight line, horizontally or vertically. 4. No piece may land on another, nor is there any jumping. 5. Only the king can land on the central space, though other pieces can pass through it. 6. Only the king may move to the spaces occupied by the fixed men: see rule 11. 7. The king is captured by surrounding him on all four sides by counts. If he is next to the central square or the edge of the board, he may be captured by surrounding him on the other three sides. 8. Dukes and counts are captured by surrounding them with enemies on two opposite sides, horizontally or vertically. Two or three men may be captured simultaneously if each falls between the moving piece and another enemy. 9. The fixed men in the corners may be used to capture pieces by either player. 10. A piece may come to rest voluntarily between two others, without being captured. 11. If the king moves to one of the squares occupied by the fixed men, he has escaped the board and wins the game. 12. If the king is captured by his opponents, then he has lost the game. The rules are describing with the Cyningstan ruleset.
(game "Alea Evangelii" 
    (players 2) 
    (equipment { 
        (board (square 19)) 
        (regions "Fortresses" (expand (sites Corners)))
        
        (piece "Thrall" P1 
            (move Slide
                Orthogonal 
                (between if:"EmptyButNotFortress") 
                (to (apply if:(!= (to) (centrePoint))))
                (then 
                    (or {
                        ("Custodial" "Thrall2")
                        (surround 
                            (from (last To)) 
                            Orthogonal
                            (between 
                                if:"JarlAndExpandedCentre" 
                                "CaptureJarl"
                            )
                            (to if:"AFriendOrTheCentre")
                        )
                        (custodial 
                            (from (last To)) 
                            Orthogonal
                            (between 
                                if:"JarlButNotTheExpandedCentre" 
                                "CaptureJarl"
                            )
                            (to if:("IsFriendAt" (to))) 
                        )
                    })
                )
            )
        )
        (piece "Thrall" P2 
            (move Slide
                Orthogonal 
                (between if:"EmptyButNotFortress") 
                (to (apply if:(!= (to) (centrePoint)))) 
                (then ("Custodial" "Thrall1")) 
            ) 
        )
        (piece "Jarl" P2 
            (move Slide
                Orthogonal 
                (to (apply if:(!= (to) (centrePoint))))
            )
        )
    }) 
    (rules 
        (start { 
            (place "Thrall1" {"C1" "F1" "N1" "Q1" "A3" "F3" "N3" "S3" "H4" "L4" "G5" "I5" "K5" "M5"
                "A6" "C6" "Q6" "S6" "E7" "O7" "D8" "P8" "E9" "O9" "E11" "O11" "D12"
                "P12" "E13" "O13" "A14" "C14" "Q14" "S14" "G15" "I15" "K15" "M15" "H16" "L16"
                "A17" "F17" "N17" "S17" "C19" "F19" "N19" "Q19"
            })
            (place "Thrall2" {"J4" "F6" "N6" "J7" "I8" "K8" "H9" "J9" "L9" "D10" "G10" "I10" "K10" "M10" "P10"
                "H11" "J11" "L11" "I12" "K12" "J13" "F14" "N14" "J16"
            })
            (place "Jarl2" (centrePoint))
        })
        
        (play (forEach Piece))
        
        (end {
            ("PieceTypeReachWin" "Jarl2" (sites "Fortresses") P2)
            (if "JarlWasCaptured" (result P1 Win))
        })
    )
)

Construct a Ludii game based on the following description
Quiela is a four-row mancala-style board game played by the Jinga people of Angola.4x7 board. Three counters in each hole in the outer row; before beginning each player rearranges these as they wish, with the following rules: The leftmost hole in the outer row must have the most counters; Each hole must have equal to or less than the number of the counters as the hole on its left; there can be a maximum of two holes with one counter in the inner row. Initial phase: Sowing occurs in an anti-clockwise direction, and when a counter lands in an occupied hole the sowing continues. When the final counter lands in an empty hole, the turn ends. If the empty hole is in the player's inner row, counters in the opponent's inner row opposite are captured, and if there are also counters in the opponent's outer row hole opposite, these are also taken. The initial phase ends for a player when they have one counter in each hole. After this, players can only move single counters into empty holes. The player who captures all of the opponent's counters wins. 
(game "Quiela" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "14,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1")) 
        (regions "Home" P2 (sites Track "TrackCCW2")) 
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom)))  
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top)))   
        (regions "Outer" P1 (sites Bottom))    
        (regions "Outer" P2 (sites Top))    
        (piece "Seed" Shared)
        (map "LeftMost" {(pair P1 0) (pair P2 27)})
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 3 to:(union (sites P1 "Outer") (sites P2 "Outer")))
        )
        
        phases:{
        (phase "Rearrangement"
            (play
                (or
                    (move 
                        (from (sites Mover "Home") if:(is Occupied (from)))
                        (to (difference (sites Mover) (from)))
                    )
                    (if (and {("LeftMostCounters") ("EqualOrLessThanLeftHole") ("MaximumOfTwoHolesInInner") })
                        (move Pass)
                    )
                )
            )
            (nextPhase (all Passed) "InitialPhase")
        )
        
        (phase "InitialPhase"
            (play
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover "Home") 
                        ) 
                        if:(is Occupied (from))
                    )
                    (then
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (is Occupied ("OppositePit" (to)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (handSite Mover))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            
            (nextPhase Mover ("OneCounterInEachHole") "MainPhase")
        )
        
        (phase "MainPhase"
            (play
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover "Home") 
                        ) 
                        if:(if (< 1 (count at:(from)))
                            True
                            (if (= 1 (count at:(from))) (is Empty ("NextHole" (from) 1)))
                        )
                    )
                    (then
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (is Occupied ("OppositePit" (to)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (handSite Mover))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Sig is a word used for many games throughout Saharan Africa. This board game is a race game played in the Tagant region of Mauritania. The game is played in the sand, with the central two rows elevated on an artificial dune. The board consists of four rows of any number of holes. Two to twelve players, who play on two equal teams. The number of pieces per team is equal to the number of holes in one row. One team plays as pieces of camel dung, the other as sticks. The pieces begin, one in each hole, in the outer rows of the board. Eight sticks, used as dice, with a marked side and a blank side. The values of the throws are equal to the number of marked sides which land face up. A throw of 4 grants the player another throw. Pieces can only be moved for the first time with a throw of 1 or 8. One piece may move one space on a throw of 1, or eight pieces may each move one space on a throw of 8. Once a piece has made its initial move, it may move according to the throws of the sticks. The bottom team's pieces move from right to left in the home row, left to right in the next row, right to left in the third row, and then into the opponent's home row. The top team moves left to right (from their perspective) in their home row, right to left in the next row, left to right in the next row, and into the bottom player's home row. When a team's piece lands on a space in the central two rows occupied by an opponent's piece, the opponent's piece is captured. Pieces cannot be captured in the home rows. When a piece moves into the opponent's home row, they move back into the central two rows, moving in the opposite direction as before. After moving into the home row a piece can no longer be captured, even when it is in the central two rows. Play continues until both team's pieces have moved out of their home row and can no longer be captured. Players then alternate turns throwing the sticks, removing one of the opponent's pieces every time a 4 is thrown. A team wins when only their pieces are left on the board. The game involves 2 players. Each row has 10 Holes.
(game "Sig (Mauritania)"
    (players <Players:num>)
    (equipment {
        (board 
            (rectangle 4 <Board:size>)
            <Board:track>
            use:Vertex
        )
        ("StickDice" 8)
        (piece "Marker" P1 ("Move"))
        (piece "Stick" P2 ("Move"))
    })
    (rules 
        (start {
            (place "Marker1" (sites Bottom))
            (place "Stick2" (sites Top))
            <Players:start>
        })
        phases:{
        (phase "MovingPhase"
            (play
                (do (if (<= (var) 0) (roll))
                    next:(if (is In (mover) (players Team1))
                        (forEach Piece P1)
                        (forEach Piece P2)
                    )
                    (then
                        (if ("IsSpecialThrow")
                            (moveAgain)
                        )
                    )
                )
            )	
            (nextPhase ("AllPiecesOutOfHomeAndCanNotBeCaptured") "RemovingPhase")
        )
        (phase "RemovingPhase"
            (play
                ("RollMove"
                    (if (= ("ThrowValue") 4) 
                        (move Remove
                            (sites Occupied by:Enemy)
                        )
                    )
                )
            )	
        )
        }
        (end ("CaptureAllTeam"))
    )
)

Construct a Ludii game based on the following description
Djara-Badakh is a simple game of alignment played by children in Somalia.3x3 intersecting lines. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot. The first player to place their three pieces along one of the lines wins. 
(game "Djara-Badakh"
    (players 2) 
    
    (equipment { 
        (board (square 3) use:Vertex) 
        (hand Each)
        (piece "Marker" Each ("StepToEmpty")) 
    })
    
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
Coyote is a game said to have been played in Mexico in the late nineteenth century. It is unknown if it is still played now. It is a hunt game similar to those played around the world, and particularly close to the Spanish game Cercar la Liebre.One player plays with one piece \ The coyote can jump to capture.
(game "Coyote" 
    (players 2) 
    (equipment { 
        (board (rectangle 5 5 diagonals:Radiating) use:Vertex)
        (piece "Sheep" P1 ("StepToEmpty")) 
        (piece "Coyote" P2 
            (or <Jump:coyote> 
                (if ("SameTurn") 
                    (move Pass) 
                    ("StepToEmpty")
                ) 
            ) 
        )
    })
    
    (rules 
        (start { 
            (place "Sheep1" (union (expand (sites Bottom)) (sites {"A3" "E3"})))
            (place "Coyote2" (centrePoint))
        })
        
        (play (forEach Piece)) 
        
        (end ("NoMovesLossAndLessNumPiecesPlayerLoss" P1 9))
    )
)

Construct a Ludii game based on the following description
Wari is an alignment game played by the Ashanti people in Ghana during the early twentieth century.6x6 board. Twelve pieces per player. Players alternate turns placing a piece on an empty space on the board. No captures may be made in the placement phase. When all of the pieces have been placed, players alternate turns moving a piece orthogonally to an empty adjacent space on the board. When a player places three of their pieces in an orthogonal row, they remove one of the opponent's pieces. Lines of four or more do not capture. Moving a piece out of a line  of four or more, making it now a line of three, does not capture. Lines of three made during the placement phase also do not result in capture. The player who captures all of the opponent's pieces wins. 
(game "Wari (Alignment)"
    (players 2)
    (equipment { 
        (board (square 6)) 
        (hand Each)
        (piece "Marker" Each
            (if (is Line 4 Orthogonal through:(from)) 
                ("StepToEmpty" Orthogonal)
                ("StepToEmpty" Orthogonal (then ("ReplayIfLine3" Orthogonal exact:True)))
            )
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPiece")
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Yaguarete Kora is a hunt game played by the Mbya Guaraní people of South America. One player plays as one jaguar, and the other plays as fifteen dogs.5x5 intersecting lines with diagonals in each quadrant. A triangle, the apex intersecting with the apex of one of the sides. A line is drawn from the apex to the midpoint of the base of the triangle. A line bisects this line, connecting the midpoints of the sides of the triangle,  One player plays as one jaguar, which begins on the center of the base of the large triangle's base. The other player plays as fifteen dogs, which begin on the points of the three ranks of the bottom half of the square portion of the board. The jaguar moves first. Pieces move to an empty adjacent space along the lines of the board. The jaguar may hop over an adjacent dog to an empty space immediately on the opposite side of it, capturing the dog. Dogs cannot capture. The dogs win by blocking the jaguar so it cannot move; the jaguar wins when only six dogs remain.  
(game "Yaguarete Kora"
    (players 2) 
    (equipment { 
        (board 
            (rotate 180 ("AlquerqueGraphWithBottomTriangle"))
            use:Vertex
        ) 
        (piece "Jaguar" P1
            (or 
                ("StepToEmpty")	
                ("HopCapture")
            )
        )
        (piece "Dog" P2 ("StepToEmpty"))
    }) 
    
    (rules 
        (start {
            (place "Jaguar1" coord:"C6")
            (place "Dog2" (expand (sites Bottom) steps:2))
        })
        (play (forEach Piece))
        (end {
            (if (no Moves P1) (result P1 Loss))
            (if (<= (count Pieces P2) 6) (result P1 Win))
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Cascades"
    (players 2)
    (equipment {
        (board (remove (hex Triangle 15) cells:{92..119} vertices:{223..285}))
        (piece "Ball" Each)
        (hand Each)
    })
    (rules
        (start {
            (place "Ball1" (forEach (sites Top) if:(is Even (site))))
            (place "Ball2" (forEach (sites Top) if:(is Odd (site))))
        })
        phases:{
        (phase "FirstMove" (play ("PlaceStone")) (nextPhase "Main"))
        (phase "Main"
            (play 
                (or 
                    ("PlaceStone" (then (if ("NewTurn") (moveAgain))))
                    (if ("SameTurn") (move Pass))
                )
            )
        )
        }
        (end 
            (if 
                (and (no Moves P1) (no Moves P2)) 
                (byScore {		
                    (score P1 (count Sites in:(forEach (sites Bottom) if:(= (who at:(site)) P1))))
                    (score P2 (count Sites in:(forEach (sites Bottom) if:(= (who at:(site)) P2))))
                })
            )
        )
    )
)
Cascades is an original game implying an original geometric pattern similar to cascades.DROP - Each stone is dropped on an empty cell, next to and below a stone of the same color
            
            MOVE - First player drops one stone at the first turn, then each player drops up to two stones (he may pass).
            
        GOAL - Wins the player with more stones on the bottom row. 

Describe the mechanics of the following Ludii game
(game "Cram" 
    (players 2) 
    (equipment { 
        (board (rectangle <Rows:num> <Columns:num>)) 
        (tile "Tile" P1 {F} numSides:4)
        (tile "Tile" P2 {F} numSides:4)
    }) 
    (rules 
        (play 
            (or 
                (move Add 
                    (piece (mover) state:0) 
                    (to (sites Empty))
                )
                (move Add 
                    (piece (mover) state:1) 
                    (to (sites Empty))
                )
            )
        )
        (end ("NoMoves" <End:result>))
    )
)
Cram is a mathematical game played on a sheet of graph paper. It is the impartial version of Domineering and the only difference in the rules is that each player may place their dominoes in either orientation, but it results in a very different game.The game is played on a sheet of graph paper, with any set of designs traced out. It is most commonly played on rectangular board like a 6×6 square.
            
            Two players have a collection of dominoes which they place on the grid in turn. A player can place a domino either horizontally or vertically. Contrary to the related game of Domineering, the possible moves are the same for the two players, and Cram is then an impartial game.
            
        As for all impartial games, there are two possible conventions for victory: in the normal game, the first player who cannot move loses, and on the contrary, in the misere version, the first player who cannot move wins. The board has 1 row. The board has 2 columns. The Last player to play wins.

Construct a Ludii game based on the following description
Game created by Ludii team as a test.Same rules as Six Men's Morris. 
(game "Symbol S.2" 
    (players 2) 
    
    (equipment { 
        (board 
            (graph
                vertices:{ {1 0} {2 0} {0 1} {1 1} {2 1} {3 1} {0 2} {1 2} {2 2} {3 2} {1 3} {2 3}}
                edges:{ {0 2} {0 3} {3 2} {3 4} {1 4} {4 5} {1 5} {3 7} {4 8} {6 7} {7 8} {8 9} {6 10} {11 9} {10 7} {11 8}}
            )
            use:Vertex
        )
        (hand Each) 
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3")))
        ) 
    }) 
    (rules 
        
        (start (place "Marker" "Hand" count:4))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3"))
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (forEach Piece)
                )
            )
        )
        }
        (end ("HavingLessPiecesLoss" Next 2))
    )
)

Describe the mechanics of the following Ludii game
(game "Nyout" 
    (players <Players:num>) 
    (equipment { 
        (board (concentric {1 -4 -4 20}) 
            {
            <Players:tracks>
            (track "HorizontalTrack" {13 5 1 0 3 7 23..28} directed:True)
            (track "VerticalTrack" {18 6 2 0 4 8 28} directed:True)
            }
            use:Vertex
        )
        (piece "Counter" Each
            (or {
                ("MoveOnTrack" "Track" Mover)
                ("MoveOnTrack" "HorizontalTrack")
                ("MoveOnTrack" "VerticalTrack")
            })
        )
        (dice d:2 from:0 num:4)
        (hand Each)
        (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 2) (pair 3 1) (pair 4 5)})
    }) 
    
    (rules 
        (start { 
            <Players:start>
        })
        phases:{
        (phase "Throwing" 
            (play 
                ("RollMove"
                    (move Pass (then (remember Value "Throws" ("ThrowValue"))))
                    (then (moveAgain))
                )
            )
            (nextPhase Mover (not ("SpecialThrows")) "Moving")
        )
        (phase "Moving"
            (play 
                (if (can Move ("Move"))
                    ("Move")
                    (move Pass (then (forget Value "Throws" All)))
                )
            )
            (nextPhase Mover (= 0 (size Array (values Remembered "Throws"))) "Throwing")
        )
        }
        
        (end ("EscapeTeamWin"))
    )
)
Nyout is a race game played in Korea in the nineteenth century. It was described as the most popular game in Korean at the time by Culin, and is played by two to four players.Twenty small circles arranged in a large circle, with a cross of nine more circles in the center of the large circle. The central circle and the circles where the crosses meet the larger circle are larger than the others.  Two players play with either one or four pieces each. Four stick dice with a white and a black side, with the following values for the throws: four white sides up = 4; four black sides up = 5; three white sides up = 3, two white sides up = 2, one white side up = 1. Throws of 4 and 5 allow the player another throw, pieces being moved after all of the player's throws. Pieces enter the board on the spot to the left of the topmost position of the circle, and proceed around the circle in an anti-clockwise direction. If a piece lands on one of the spaces where the central cross meets the circle, the piece may proceed along the cross to the opposite side on the next turn. A piece may not turn and move along a cross if it does not land on the end of the cross at the end of a throw. Pieces proceed to the topmost space, and move off the board by throwing one or more than required to land on this space. When a player lands on the same spot as one of their own pieces, these may be moved together as one piece. When a player lands on an opponent's piece, the opponent's piece is sent back to the start. The first player to remove all of their pieces from the board wins. 2 players involved with one piece per player.

Construct a Ludii game based on the following description
Lontu-Holo is a two-row mancala-style board game played by the Ndyuka people of Suriname. It is one of the only recorded games of this type where the goal is to capture the fewest number of counters.2x6 board, with a store hole on either end. Four counters in each hole. Each player owns the six holes, three holes in each row, to their right. Sowing occurs in an anti-clockwise direction, and only in the holes belonging to the player. Play begins with a stylized opening move. The first player takes the counters from the holes in each of the row of holes closest to them, and places them in the central row of their holes in the further row. The counters from the hole next in the direction of sowing are then sown. The counters from the central hole in the further of the player's rows are then sown. When this is completed, the player takes the counters from the holes in the row closest to them, and holds them until the opponent performs the same sequence of moves on their side of the board. At this point, each player places the counters they are holding into any hole on the opponent's side of the board which contains more than one counter. Players then alternate turns sowing pieces around their holes of the board. Sowing always skips the hole from which sowing began. When the final counter of a sowing causes a hole to contain four counters, these counters are placed on any hole on the opponent's side of the board that contains more than one counter. When a player has only single seeds in their holes, and the opponent is about to place counters in the player's holes, the opponent moves one of the player's counters into another hole containing one counter, thus making two, and places the counters from the opponent's side are placed there. The player who is able to place all of their counters on the opponent's side of the board wins. The opening rules of the variant Lontu Holo.
(game "Lontu-Holo" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6
            {
            (track "TrackCCW1" {1 2 3 9 8 7} loop:True P1) 
            (track "TrackCCW2" {4 5 6 12 11 10} loop:True P2) 
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))   
        (regions "Home" P2 (sites Track "TrackCCW2"))   
        (regions "TwoHolesClosestNotCentre" P1 (sites {1 3}))
        (regions "TwoHolesClosestNotCentre" P2 (sites {10 12}))
        (regions "TwoHolesFurtherNotCentre" P1 (sites {7 9}))
        (regions "TwoHolesFurtherNotCentre" P2 (sites {4 6}))
        (regions "LeftMostHoles" P1 (intersection (expand (sites Left)) (sites Track "TrackCCW1")))
        (regions "LeftMostHoles" P2 (intersection (expand (sites Right)) (sites Track "TrackCCW2")))
        (regions "RightMostHoles" P1 (intersection (sites Centre) (sites Track "TrackCCW1")))
        (regions "RightMostHoles" P2 (intersection (sites Centre) (sites Track "TrackCCW2")))
        (regions "ClosestRow" P1 (intersection (sites Bottom) (sites Track "TrackCCW1")))
        (regions "ClosestRow" P2 (intersection (sites Top) (sites Track "TrackCCW2")))
        (map "CentreFurtherRow" {(pair P1 8) (pair P2 5)})
        (map "CentreClosestRow" {(pair P1 2) (pair P2 11)})
        (map "RightFurtherRow" {(pair P1 9) (pair P2 4)})
        (map "RightClosestRow" {(pair P1 3) (pair P2 10)})
        (map "LeftFurtherRow" {(pair P1 7) (pair P2 6)})
        (map "LeftClosestRow" {(pair P1 1) (pair P2 12)})
        (piece "Seed" Shared)
        (map "Store" {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        (start (set Count 4 to:(union (sites Bottom) (sites Top))))
        
        phases:{
        <Variant:opening>
        
        (phase "Sowing"
            (play 
                (if ("SameTurn")
                    (if ("OneSeedInEachHole" Next)
                        (move 
                            (from 
                                (sites Next "Home")
                            )
                            (to (sites Next "Home") if:(!= (from) (to)))
                            count:1
                            (then
                                (moveAgain)
                            )
                        )
                        (move 
                            (from 
                                (var "Replay")
                            )
                            (to (sites Next "Home") if:(< 1 (count at:(to))))
                            count:1
                            (then
                                (if (is Occupied (last From))
                                    (moveAgain)
                                )
                            )
                        )
                    )
                    (move Select
                        (from 
                            (sites Mover "Home")
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                "TrackCCW"
                                owner:(mover)
                                apply:(if (= 4 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end
                (if ("NoSeedInHome" Mover) (result Mover Win))
            )
        )
        }
    )
)

Construct a Ludii game based on the following description
Main Chongkak is a two-row mancala-style board game that has been played since at least the nineteeenth century in Malaysia. It is typically played by women.2x6-9 holes with a store on either end. Play starts with same number of counters in each hole as number of holes in the row (6 counters if 6 holes in a row, etc). Store on either end. A player's store is the store to their left. Stores are included when sowing. Play begins from any hole belonging to the player. Counters are sowed clockwise: if the final counter lands in an empty hole, in player's own row, they take the counters in the opposite hole and place them in the store. If play ends in the store, they can then take counters from any of their holes and sow again. if play ends in an empty hole in the opponent's row, play ends. If play ends in a hole with counters, those are collected and sowing continues. A round ends when there are no counters left in a player's row. The opponent then takes all remaining counters and adds them to their store. Next round begins with each player taking the counters from their store and placing the same number of counters in the holes as when the game began, starting from right to left. Surplus counters are placed in the store. Unfilled holes are excluded from play in this round. Play continues as before. Play continues with as many rounds as needed until one player does not have enough counters to fill a single hole. Each player has 6 holes.
(game "Main Chongkak" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns"
            (track "Track" "0,ENE,E,ESE,WSW,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (map "RightMost" {(pair P1 ("Columns")) (pair P2 (+ ("Columns") 1))})
    }) 
    (rules 
        
        (start {
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
            (set Count "Columns" to:(union (sites Bottom) (sites Top)))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from
                            (if 
                                (and (not (is Pending)) ("SameTurn")) 
                                (sites {(var "Replay")}) 
                                (sites Mover) 
                            ) 
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then
                            (sow
                                apply:(if (and (is In (to) (sites Mover)) (= 1 (count at:(to))))
                                    (if (is Occupied ("OppositePit" (to)))
                                        (fromTo
                                            (from ("OppositePit" (to)))
                                            (to (mapEntry Mover))
                                            count:(count at:("OppositePit" (to)))
                                        )
                                    )
                                    (if (= (to) (mapEntry Mover))
                                        (and
                                            (set Pending)
                                            (moveAgain)
                                        )
                                        (if (and (< 1 (count at:(to))) (!= (to) (mapEntry Next)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                )
                                skipIf:(and {(not (is In (to) ("PlayableSites"))) (!= (to) (mapEntry P1)) (!= (to) (mapEntry P2))})
                            )
                        )
                    )
                    }
                    (then
                        (if ("OneRowIsEmpty")
                            (and { 
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (mapEntry P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (mapEntry P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "Playable" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> ("Columns") (count at:(mapEntry P1))) (result P2 Win))
                    (if (> ("Columns") (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                    (if (<= ("Columns") (count at:(mapEntry Mover)))
                        (move
                            (from (mapEntry Mover))
                            (to "RightMostEmpty")
                            count:("Columns")
                            (then (remember Value "Playable" (last To)))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Pentago is an abstract strategy game for two players with four 3×3 grids arranged into a larger 6×6 grid. After placing a marble, the player has to twist one of the grids by 90°, thus changing the board after every turn. The first player to get five marbles in a row wins. In case of both players having five in a row in the same time, the game is a draw. 
(game "Pentago"
    (players 2)
    (equipment { 
        (board (square 6) use:Vertex)
        (piece "Ball" Each)
        (regions "BottomLeft" (expand origin:(coord "B2") All))
        (regions "BottomRight" (expand origin:(coord "E2") All))
        (regions "TopLeft" (expand origin:(coord "B5") All))
        (regions "TopRight" (expand origin:(coord "E5") All))
    })
    (rules
        phases:{
        (phase "Place"
            (play (move Add (to (sites Empty)) (then (moveAgain))))
            (end (if (is Line 5 All) (result Mover Win)))
            (nextPhase Mover "Rotate")
        )
        
        (phase "Rotate"
            (play 
                (or
                    (move Select (from (sites {"B2" "B5" "E2" "E5"}))
                        (then 
                            (if (= (last To) (coord "E5"))
                                (do ("CreateVariables" "D6" "F6" "F4" "D4" "E4" "D5" "E6" "F5")
                                    next:(and {
                                        ("RemoveOccupiedSites" "D6" "F6" "F4" "D4" "E4" "D5" "E6" "F5")
                                        ("Rotation" "F6" "F4" "D4" "D6" "D5" "E6" "F5" "E4")
                                    })
                                )
                                (if (= (last To) (coord "B5"))
                                    (do ("CreateVariables" "A6" "C6" "C4" "A4" "B4" "A5" "B6" "C5")
                                        next:(and {
                                            ("RemoveOccupiedSites" "A6" "C6" "C4" "A4" "B4" "A5" "B6" "C5")
                                            ("Rotation" "C6" "C4" "A4" "A6" "A5" "B6" "C5" "B4")
                                        })
                                    )
                                    (if (= (last To) (coord "B2"))
                                        (do ("CreateVariables" "A3" "C3" "C1" "A1" "B1" "A2" "B3" "C2")
                                            next:(and {
                                                ("RemoveOccupiedSites" "A3" "C3" "C1" "A1" "B1" "A2" "B3" "C2")
                                                ("Rotation" "C3" "C1" "A1" "A3" "A2" "B3" "C2" "B1")
                                            })
                                        )
                                        (do ("CreateVariables" "D3" "F3" "F1" "D1" "E1" "D2" "E3" "F2")
                                            next:(and {
                                                ("RemoveOccupiedSites" "D3" "F3" "F1" "D1" "E1" "D2" "E3" "F2")
                                                ("Rotation" "F3" "F1" "D1" "D3" "D2" "E3" "F2" "E1")
                                            })
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (move Select (from (sites {"B2" "B5" "E2" "E5"}))
                        (then 
                            (if (= (last To) (coord "E5"))
                                (do
                                    ("CreateVariables" "D6" "F6" "F4" "D4" "E4" "D5" "E6" "F5")
                                    next:(and {
                                        ("RemoveOccupiedSites" "D6" "F6" "F4" "D4" "E4" "D5" "E6" "F5")
                                        ("Rotation" "D4" "D6" "F6" "F4" "F5" "E4" "D5" "E6")
                                    })
                                )
                                (if (= (last To) (coord "B5"))
                                    (do ("CreateVariables" "A6" "C6" "C4" "A4" "B4" "A5" "B6" "C5")
                                        next:(and {
                                            ("RemoveOccupiedSites" "A6" "C6" "C4" "A4" "B4" "A5" "B6" "C5")
                                            ("Rotation" "A4" "A6" "C6" "C4" "C5" "B4" "A5" "B6")
                                        })
                                    )
                                    (if (= (last To) (coord "B2"))
                                        (do ("CreateVariables" "A3" "C3" "C1" "A1" "B1" "A2" "B3" "C2")
                                            next:(and {
                                                ("RemoveOccupiedSites" "A3" "C3" "C1" "A1" "B1" "A2" "B3" "C2")
                                                ("Rotation" "A1" "A3" "C3" "C1" "C2" "B1" "A2" "B3")
                                            })
                                        )
                                        (do
                                            ("CreateVariables" "D3" "F3" "F1" "D1" "E1" "D2" "E3" "F2")
                                            next:(and {
                                                ("RemoveOccupiedSites" "D3" "F3" "F1" "D1" "E1" "D2" "E3" "F2")
                                                ("Rotation" "D1" "D3" "F3" "F1" "F2" "E1" "D2" "E3")
                                            })
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end {
                (if (and 
                        (is Line 5 All throughAny:("RegionToCheck" Mover))
                        (is Line 5 All throughAny:("RegionToCheck" Next))
                    )
                    (result Mover Draw)
                )
                (if (is Line 5 All throughAny:("RegionToCheck" Mover)) (result Mover Win))
                (if (is Line 5 All throughAny:("RegionToCheck" Next)) (result Next Win))
            })
            (nextPhase Mover "Place")
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Tsoro Yemutatu"
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 3 3)
        (hand Each)
        (piece "Marker" Each (move (from) (to (sites Empty))))
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win"))
    )
)
Tsoro Yemutatu is an alignment game from Zimbabwe. This version, played on a square board, is played by boys and young men, but sometimes adults and is usually scratched on the ground and played with stones.3x3 intersecting lines, with diagonals drawn in the large square. Three pieces per player. Players alternate turns placing a stone on an empty point on the board. When all of the pieces have been placed, players alternate turns moving one of their pieces to any empty point. The first player to place three of their pieces in a line wins.
         

Construct a Ludii game based on the following description
Picaria is a game played by the people of Isleta Pueblo in New Mexico in the early twentieth century, but likely to be older. This version is played on a smaller board.Played on a 3x3 board with diagonals in the squares. The board has 9 holes. The pieces can be placed to any empty site.
(game "Picaria" 
    (players 2) 
    (equipment { 
        <Board>
        (hand Each)
        (piece "Marker" Each ("StepToEmpty" All))
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to <To>)
                ) 
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win" All))
    )
)

Construct a Ludii game based on the following description
3D version of Tic-Tac-Toe on a 5 spaces board.White starts and, in turn, pieces are placed on any one of 5 spaces, including on other pieces. The object is to get 3 same color pieces in a row - horizontally, vertically or diagonally. 
(game "Agilidade"
    (players 2) 
    (equipment { 
        (board (skew .5 (scale 1 .5 
                    (merge {
                        (wedge 2 2)
                        (shift 0 1 (rotate 180 (wedge 2 2)))
                }))
            ) 
        use:Vertex) 
        (piece "discFlat" Each)
        (hand Each)
    }) 
    (rules
        (start {
            (place Stack "discFlat1" (handSite P1) count:7)
            (place Stack "discFlat2" (handSite P2) count:7)
        })
        (play 
            (move 
                (from (handSite Mover)) 
                (to (sites Board)) 
            )
        )
        (end (if (is Line 3 byLevel:True) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Yoté is a game with leaping captures played in Senegal. It is typically played in the sand with one side playing with stones or shells and the other with sticks. In it, a player making a capture is allowed to choose another of the opponent's pieces to remove from the board.5x5 board. Twelve pieces per player. Players alternate turns placing a piece on the board or moving a piece already on the board. Pieces move one space in any orthogonal direction. A player may capture an opponent's piece by hopping over it to an empty space on the other side of it. When a capture is made in this fashion, the player chooses another piece belonging to the opponent to capture in addition. The player who captures all of the opponent's pieces wins. 
(game "Yote"
    (players 2)
    (equipment {
        (board (square 5))
        (piece "Marker" Each 
            (or
                ("StepOrthogonalToEmpty")
                ("HopCapture" ~ ~ (then (moveAgain)))
            )
        )
        (hand Each)
    })
    (rules 
        (start (place "Marker" "Hand" count:12))
        (play 
            (if "SameTurn"
                "RemoveEnemyPiece"
                (or
                    (if ("HandOccupied" Mover)
                        (move 
                            (from (handSite Mover)) 
                            (to (sites Empty)) 
                        ) 
                    )
                    (forEach Piece)
                )
            )
        )
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Pagade Kayi Ata (Sixteen-handed)" 
    (players <Player:num>) 
    (equipment { 
        (board 
            (add
                (merge
                    {
                    (rectangle 3 8)
                    (shift 0.88 -4.45 (rotate 22.5 (rectangle 3 8)))
                    (shift 3.39 -8.21 (rotate 45 (rectangle 3 8)))
                    (shift 7.15 -10.71 (rotate 67.5 (rectangle 3 8)))
                    (shift 11.58 -11.59 (rotate 90 (rectangle 3 8)))
                    (shift 16.02 -10.71 (rotate 112.5 (rectangle 3 8)))
                    (shift 19.8 -8.21 (rotate 135 (rectangle 3 8)))
                    (shift 22.33 -4.45 (rotate 157.5 (rectangle 3 8)))
                    (shift 23.21 0 (rotate 180 (rectangle 3 8)))
                    (shift 22.33 4.45 (rotate 202.5 (rectangle 3 8)))
                    (shift 19.8 8.21 (rotate 225 (rectangle 3 8)))
                    (shift 16.02 10.71 (rotate 247.5 (rectangle 3 8)))
                    (shift 11.58 11.59 (rotate 270 (rectangle 3 8)))
                    (shift 7.15 10.71 (rotate 292.5 (rectangle 3 8)))
                    (shift 3.39 8.21 (rotate 315 (rectangle 3 8)))
                    (shift 0.88 4.45 (rotate 337.5 (rectangle 3 8)))
                    }
                )
                edges:{
                {8 71} {44 107} {80 143} {116 179} {152 215} {188 251}
                {224 287} {260 323} {296 359} {332 395} {368 431} {404 467}
                {440 503} {476 539} {512 575} {548 35}
                }
                cells:{ 
                { 35 26 17 8 71 62 53 44 107 98 89 80
                143 134 125 116 179 170 161 152 215 206 197 188
                251 242 233 224 287 278 269 260 323 314 305 296
                359 350 341 332 395 386 377 368 431 422 413 404
                467 458 449 440 503 494 485 476 539 530 521 512
                575 566 557 548
                } 
                }
            )
            {
            (track 
                "Track1" 
                "384,15,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S1,End" 
                P1 
                directed:True
            )
            (track 
                "Track2" 
                "384,39,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE1,End" 
                P2 
                directed:True
            )
            (track 
                "Track3" 
                "384,63,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE1,End" 
                P3 
                directed:True
            )
            (track 
                "Track4" 
                "384,87,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE1,End" 
                P4 
                directed:True
            )
            <Player:track58>
            <Player:track916>
            }
        )
        (map "Start" { 
            (pair 1 15) (pair 2 39) (pair 3 63) (pair 4 87)
            (pair 5 111) (pair 6 135) (pair 7 159) (pair 8 183)
            (pair 9 207) (pair 10 231) (pair 11 255) (pair 12 279)
            (pair 13 303) (pair 14 327) (pair 15 351) (pair 16 375)
        })
        (piece "Disc" Each
            (if (and 
                    (!= (pips) 0) 
                    ("IsNotOffBoard" ("SiteToMoveOnTrack" (from)))
                )
                (if ("IsEndTrack" ("SiteToMoveOnTrack" (from)))
                    ("RemoveAPiece" (from))
                    (move 
                        (from (from) level:(level)) 
                        (to 
                            ("SiteToMoveOnTrack" (from)) 
                            if:(and 
                                (or 
                                    (not (is In (to) (sites "Castle")))
                                    (and
                                        (is In (to) (sites "Castle"))
                                        (not ("IsEnemyAt" (to))) 
                                    )
                                )
                                (not 
                                    (and 
                                        ("IsEnemyAt" (to)) 
                                        (> (count at:(to)) 1)
                                    )
                                )
                            )
                            (apply 
                                if:(and 
                                    ("IsEnemyAt" (to)) 
                                    (= (count at:(to)) 1)
                                )
                                (and
                                    (fromTo 
                                        (from (to)) 
                                        (to ("Center"))
                                    )
                                    ("HasCapturedAnEnemy")
                                )
                            )
                        ) 
                    )
                )
            )	
        ) 
        
        (hand Each)
        (dice d:8 faces:{1 3 4 6 8 10 12 16} num:2)
        (regions "Castle" {
            22 19 16 0 3 6 13 10
            46 43 40 34 37 24 27 30
            70 54 61 67 51 58 64 48
            94 78 118 102 142 126 85 109 133
            91 75 115 99 139 123 82 106
            130 112 88 72 96 136 120
            166 150 190 174 214 198 238 222 157 181 205 229
            163 147 187 171 211 195 235 219 154 178 202 226 
            160 144 232 184 168 232 216 208 192
            262 246 253 286 270 277 310 294 301 334
            318 325 358 342 349 366 382 373 331 315 322 312 328
            363 379 370 259 243 250 256 240 376 283 267 274 280
            264 307 291 298 304 288 355 339 346 352 360 336
        })
        (regions "DiceHand" <Player:diceHand>)
    }) 
    (rules 
        <Player:start>
        (play
            (if ("CanThrowAgain")
                (move Select (from (sites "DiceHand")) (then (and (roll) (moveAgain))))
                ("RollEachNewTurnMove"
                    (forEach Die 
                        combined:True 
                        replayDouble:True 
                        (or
                            (if 
                                (and 
                                    ("HandOccupied" Mover)
                                    (= (pips) "ValueToEnter")
                                )
                                (move
                                    (from (handSite Mover)) 
                                    (to (mapEntry "Start" (mover)))
                                )
                            )
                            (or (forEach Piece) (forEach Piece container:(mover)))
                        )
                        (then (if (can Move 
                                    (forEach Die 
                                        combined:True 
                                        (or
                                            (if 
                                                (and 
                                                    ("HandOccupied" Mover)
                                                    (= (pips) "ValueToEnter")
                                                )
                                                (fromTo 
                                                    (from (handSite Mover)) 
                                                    (to (mapEntry "Start" (mover)))
                                                )
                                            )
                                            (or (forEach Piece) (forEach Piece container:(mover)))
                                        )
                                    )
                                )
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        (end ("EscapeWin"))
    )
)
Pagade Kayi Ata was a version of Pachisi invented by Maharaja Krishnaraja Wadiyar III of Mysore. This game can be played by up to sixteen players.Sixteen 3x8 rectangles are arranged in a circle, each rectangle touching the corner of another on its left and right. The second, fifth, and eighth squares (counting from the top) in the outer rows, and the third and sixth squares in the central row of each rectangle are marked. Can be played with sixteen, eight, or four players. It can be played individually, or on two teams. Each rectangle has one set of four pieces. They enter the board from the center, proceeding down the central row or their respective rectangles, proceeding in the outer rows of the rectangles in an anti-clockwise direction. When a complete circuit of the board has been made, the pieces must travel down the central row again and exit the board with an exact throw. The game is played with two eight-sided die, containing the following values: 1, 3, 4, 6, 8, 10, 12, 16 on one, 2, 5, 7, 9, 11, 13, 15, 16 on the other. It may also be played with four rectangular dice each with the values 1, 3, 4, 6. Pieces are entered on the throw of nine. Doubles allow a second roll.Spaces moved may be broken up between two pieces but each piece must move a number equal to that displayed on one of the dice. A player can pass, but only before the die is thrown. When two pieces of the same color occupy a space, no other pieces may pass them. These pieces may then move as a single pawn. If a piece lands on the same spot occupied by an opponent's piece, the opponent's piece is sent back to the start. Two pieces moving as a single pawn can only be sent to start by two other pieces moving as a single pawn. Pieces on a marked space cannot be sent to start. A  play which sends an opponent's piece to start allows another roll. A player may bypass the central row and circuit the board another time if they wish (i.e., in order to send another player back to start to prevent them from winning). The first player to remove all their pieces from the board wins, and the other platers continue playing until all but one player have moved their pieces into the center. The game involves 4 players.

Construct a Ludii game based on the following description
Parry is a game created on the same trip as Skirt, with a similar dynamic, but the sequence of placement and movement is opposite  (forced placement then optional move) and the restriction on movement is based on the strength of the placement rather than the groupings of the pieces, so the tactics are somewhat diffectent even if the overall strategies are similar.
            The movement based on placement is adapted from Throngs, but instead of being restricted to a single piece, the actions granted by the placement can be applied to any piece. Also there is no capture nor the possibility to jump over the opponent that exists in Throngs, thus, like in Skirt, the game consists of slipping in between pieces so as to retain the ability to grow in as many regions as possible.
            This system is more easily adapted to other board geometries than Skirt, and several additional board options have been included.
        The game can also be played with more than 2 players, but is less territorial and more chaotic in those modes.Goal: Most territory, counted when one player cannot make a required placement.
            
            Definitions:
            -- Site Power: For a given player, each site's power is equal to the amount by which the adjacent friendly pieces exceed the amount of all the rest of the adjacent pieces. If a site is occupied, the piece at the site is also counted as an adjacent piece.
            -- Territory: A player's 'Territory' is all the sites where he has positive power, plus all the sites he occupies where no other player has positive power.
            -- Uncontrolled site: An empty site which is not part of any player's territory is called an 'uncontrolled site'.
            
            Play:
            Turns alternate starting with White.
            To begin the turn, a player places a piece on an empty site.
            -- The piece must be placed on a site the mover controls, if possible.
            -- If this placement is not possible, the piece is placed onto an uncontrolled site.
            -- If placement is still not possible, the game ends.
            
            After the initial placement, the player is allowed to make bonus step moves using any combination of his pieces in any order, other than the one just placed. 
            -- The total number of steps must not exceed the power of the placement site before placement. 
            -- These step moves are all optional. 
            -- Unused bonus moves may not be saved for use in future turns.
            
            Jumping over other pieces is not allowed.
            ------------------------------------------
            The game can optionally be played with multiple players.
        This application shows the territories with player-coloured rings. Two Players Board & size: Equiversi Hexhex with edges alternating 2 and 4
(game "Parry"
    (players <PlayerCount:option>)
    (equipment
        {
        (board <Board:size> use:Vertex)
        (piece "Ball" Each)
        }
    )
    (rules 
(meta (no Repeat PositionalInTurn)) 
(start
    {
(set Score Each 1) 
}   
) 

(play
    (if "SameTurn"
        ("MoveUntilDone")
        ("MoveAddPriority"
            "PlacementSites" 
            "SitesUncontrolledEmpty" 
)))
(end 
    {
    (if
        (and
            {
            "EndCondition"
            (= 2 <PlayerCount:option>)
            (= (score P1) (score P2))
            (= (id P1) (what at:(var "PlacedPiece")))
            }
        )
        (result P1 Win)
    )
    
    (if
        (and
            {
            "EndCondition"
            (= 2 <PlayerCount:option>)
            (= (score P1) (score P2))
            (!= (id P1) (what at:(var "PlacedPiece")))
            }
        )
        (result P2 Win)
    )
    
    (if
        "EndCondition"
        (byScore)
    )
    
    }
    
)
)
)

Construct a Ludii game based on the following description
Fibonacci Nim is a mathematical subtraction game, a variant of the game of Nim.Fibonacci Nim is played by two players, who alternate removing coins or other counters from a pile. On the first move, a player is not allowed to take all of the coins, and on each subsequent move, the number of coins removed can be any number that is at most twice the previous move. According to the normal play convention, the player who takes the last coin wins. Or according to the Misère game, the player who takes the last coin loses. The last mover loses. The game involves a pile of 5 pieces.
(game "Fibonacci Nim" 
    (players 2) 
    (equipment { 
        (board (square 1)) 
        (piece "Marker" Neutral)
    }) 
    (rules
        (start (set Count <Size:pile> at:0)) 
        
        (play 
            (if "SameTurn"
                (or
                    (if (<= "NumRemove" "Max")
                        (move Select 
                            (from (last To))
                            (then 
                                (if (= (count at:(last To)) 1)
                                    (remove (last To))
                                    (and (set Count at:(last To) (- (count at:(last To)) 1)) (moveAgain)) 
                                )
                            ) 
                        )
                    )
                    (move Pass (then (set Value Mover (- ("NumRemove") 1))))
                )
                (move Select
                    (from (sites Occupied by:Neutral))
                    (then 
                        (if (= (count at:(last To)) 1)
                            (remove (last To))
                            (and 
                                (set Count at:(last To) (- (count at:(last To)) 1)) 
                                (moveAgain)
                            ) 
                        )
                    ) 
                )
            )
        ) 
        (end (if (no Moves Next) (result <Result> Win)))
    )
)

Construct a Ludii game based on the following description
Round Merels is a hypothesized game based on the frequent discovery of this pattern as graffiti on Roman and later monuments. It may be similar to a simple merels game but on a round board.Eight spots arranged in a circle around a central spot. Opposite spots are connected by a diameter through the central spot. The rules are describing with the Blumlein ruleset.
(game "Round Merels"
    (players 2) 
    (equipment { 
        (board (concentric {1 8}) use:Vertex)
        (hand Each)
        (piece "Marker" Each "StepToEmpty") 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                ) 
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end (if (is Line 3 through:(centrePoint) what:(mover)) (result Mover Win))) 
    )
)

Construct a Ludii game based on the following description
Mankala is a two-row mancala-style game, in which sowing is the primary movement mechanism in the game. It was documented in Egypt during the eighteenth century. 2x6 board. Six counters in each hole. Players take the contents of one of their holes and sow in an anti-clockwise direction. When the final counter of a sowing lands in a hole, making it contain two, four, or six counters,  these counters are taken. If the second to last hole also contains two, four, or six counters, these are also taken, continuing in an unbroken line until a hole with containing a number of counters other than two, four, or six. The game continues until all of the counters have been captured. The player who captured the most counters wins. 
(game "Mankala" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    
    (rules 
        (start (set Count 6 to:(sites Track)))		 
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(< 0 (count at:(from)))
                )
                (then 
                    (sow 
                        if:(or {
                            (= (count at:(to)) 2) 
                            (= (count at:(to)) 4)
                            (= (count at:(to)) 6)
                        })
                        apply:(fromTo 
                            (from (to)) 
                            (to (handSite Mover)) 
                            count:(count at:(to))
                        )
                        backtracking:True
                    )
                )
            )
        )
        (end ("MancalaByScoreWhen" (and (no Moves Next) (no Moves Mover))))
    )
)

Construct a Ludii game based on the following description
Tsoro is a term used for several two-row mancala-style board games played in Zimbabwe. In this version, players choose a special hole, \4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Each player's rightmost hole is the musoro. Two counters in each hole in the players' outer rows, except each musoro which has three. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. If this final hole is one of the musoro, the player may choose to end their turn instead of continuing to sow. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game.
         6 Holes per row.
(game "Musoro Tsoro" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))         
        (regions "Outer" P2 (sites Top))          
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start {
            (place "Seed" (intersection (sites Top) (sites Left)) counts:{3} state:2)
            (place "Seed" (intersection (sites Bottom) (sites Right)) counts:{3} state:1)
            (set Count 2 to:(union (difference (sites Top) (sites Left)) (difference (sites Bottom) (sites Right))))
        })
        
        (play 
            (or
                (if (and (!= 0 (state at:(var))) ("SameTurn"))
                    (move Pass)
                )
                (move Select
                    (from 
                        (if ("SameTurn")
                            "LastHoleSowed" 
                            (sites Mover "Home") 
                        ) 
                        if:(if "AHoleHasMoreThanOneCounter"
                            (> (count at:(from)) 1)
                            (and (= (count at:(from)) 1) (= 0 (count at:("NextHoleFrom" (from) Mover)))) 
                        )
                    )
                    (then 
                        (and
                            (sow
                                "Track"
                                owner:(mover)
                                apply:(if (= (count at:(to)) 1)
                                    (if (is In (to) (sites Mover "Inner"))
                                        (if (> (count at:("OppositePit" (to))) 0) 
                                            (and
                                                (remove ("OppositePit" (to))) 
                                                (if 
                                                    (> (count at:("OppositeOuterPit" (to))) 0) 
                                                    (remove ("OppositeOuterPit" (to))) 
                                                ) 
                                            ) 
                                        ) 
                                    )
                                    (and
                                        (moveAgain)
                                        (set Var (to))
                                    )
                                )
                            )
                            (forEach Site (sites Board)
                                (if (!= 0 (state at:(site))) (set State at:(site) (state at:(site))))
                            )
                        )
                    )
                )
            )
        )
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Viking Chess" 
    (players {(player N) (player N)}) 
    (equipment { 
        (board (rectangle 7 12)) 
        
        ("ChessPawn" "Pawn" ~
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        
        ("ChessRook" "Rook")
        ("ChessKing" "King")
        ("ChessBishop" "Bishop")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Queen")
        
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Top))
    }) 
    (rules 
        (start { 
            (place "Pawn1" {"B2" "B3" "C3" "D3" "E3" "E2" "F2" "F1"}) (place "Rook1" {"A1" "A2"}) (place "Knight1" {"C2" "D2"}) (place "Bishop1" {"B1" "E1"}) (place "Queen1" coord:"D1") (place "King1" coord:"C1") 
            (place "Pawn2" {"G1" "G2" "H2" "H3" "I3" "J3" "K3" "K2"}) (place "Rook2" {"L1" "L2"}) (place "Knight2" {"J2" "I2"}) (place "Bishop2" {"K1" "H1"}) (place "Queen2" coord:"I1") (place "King2" coord:"J1") 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King" Mover)))
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
        })
    )
)
Viking Chess was designed to enter the Chess Variant Pages' 84 Spaces Contest.Viking Chess is played on a board with 12 files and 7 ranks. The pieces are set up with both sides starting on the same side of board. Both sides' Pawns move in the same direction, and all Pawns promote normally upon reaching the (same) 7th rank. There is no Pawn double-move or en passant capture. There is no castling. 

Construct a Ludii game based on the following description
Ghingskoot is a game played by the Tohono O'odham people of Arizona. It is a race game similar to others known throughout the southwest United States and Mexico as Quince, and may be related to Mesoamerican Patolli.Played on a board with 36 holes arranged in a square, with a gap in the center of each side. There are arcs of five holes branching from opposite corners. Can be played with two to four players, who can also play on teams. One or two pieces per player.
            Four stick dice are used, with one marked side. Each die is marked differently for a different value: 4, 6, 14, 15. The throws are as follows: All marked sides up = 5; three marked sides up = 3; two marked sides up = 2, one marked side up = the value of the marked side; zero marked sides up = 10. 
            Players’ pieces enter on the branching arcs. The second piece cannot enter before the first one leaves the arc.
            Each player can choose which direction they wish to move around the board, but they must continue in this direction for the rest of the game. If a player lands on the same spot as the opponent, the opponent’s piece is removed from the board and must re-enter.
        Player must make an exact throw to get a piece off the board after reentering the arc from the spot where the player entered the board. The player to get both of their pieces off the board first wins. 2 players. Each player has 1 piece.
(game "Ghingskoot"
    (players <Players:num>)
    (equipment {
        ("KintsBoard"
            {
            (track "TrackCW1" "46,5,SSE,N,E,S,W,NNW,End" P1 directed:True)
            (track "TrackCCW1" "46,5,SSE,E,N,W,S,NNW,End" P1 directed:True)
            (track "TrackCW2" "47,41,NNW,S,W,N,E,SSE,End" P2 directed:True)
            (track "TrackCCW2" "47,41,NNW,W,S,E,N,SSE,End" P2 directed:True)
            <Players:track3>
            <Players:track4>
            }
        )
        (regions "AllSites" (sites Board))
        (regions "Arc" P1 (sites {1..5}))
        (regions "Arc" P2 (sites {41..45}))
        <Players:arc3>
        <Players:arc4>
        (regions "AllSitesDifferentThanArc" 
            (difference 
                (sites Board) 
                (union {(sites P1 "Arc") (sites P2 "Arc") (sites {0 32})})
            )
        )
        (dice d:2 facesByDie:{{0 4} {0 6} {0 14} {0 15}} num:4)
        (piece "Marker" Each
            (if (= (state at:(from)) 0)
                (if (or ("PieceAlreadyEntered")
                        ("PieceCanEnterOnlyIfNoPieceOnArc")
                    )
                    (or
                        ("MoveOn" "SiteToMoveOnTrackCW" ("RememberSelectedTrack" 1))
                        ("MoveOn" "SiteToMoveOnTrackCCW" ("RememberSelectedTrack" 2))
                    )
                )
                ("MoveOn" "SiteToMoveOnSelectedTrack")
            )
        )
        (hand Each)
        (map "Throw" {
            (pair 0 10) (pair 39 5) (pair 24 3) (pair 25 3) (pair 35 3) (pair 33 3)
            (pair 10 2) (pair 18 2) (pair 19 2) (pair 20 2) (pair 21 2) (pair 29 2)
        })
    })
    (rules 
        (start (place "Marker" "Hand" count:<Num:piece>))
        (play ("RollMove" (or (forEach Piece) (forEach Piece container:(mover)))))
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Nchuwa is a four-row mancala-style board game played by the Atonga people of central Africa during the early twentieth century.4x6, 9, 12, or 15. Two counters in each hole. Players begin by sowing from the rightmost hole in the inner row, placing one counter in each of the first two holes, then picking up the counters from the next hole and continuing to sow until the next hole after the sowing is empty (this should be the hole from which the sowing began). Each player then takes two counters from any of the holes in their inner row and places them in any empty hole in the outer row. The player then captures the counters in the opponent's opposite holes. The player then removes the contents of any one of the opponent's holes. Once both players have done this, the main phase begins. Players move by sowing from any of the holes on their side of the board in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When they fall into an empty hole, the sowing ends. If this hole is in the inner row, the contents of the opponent's opposite hole in the inner row are also taken. If there are also counters in the opponent's outer row opposite, these are also taken. The player may also capture the contents of any other hole in the inner or outer row. Single counters may be moved. The player who captures all of their opponent's counters wins. Each player has 6 holes by row.
(game "Nchuwa" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" <Board:CCW2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))      
        (regions "Home" P2 (sites Track "TrackCCW2"))      
        (regions "Inner" P1 (sites Row 1))         
        (regions "Inner" P2 (sites Row 2))         
        (regions "Outer" P1 (sites Row 0))         
        (regions "Outer" P2 (sites Row 3))         
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))
        )
        
        phases:{
        (phase "Opening1"
            (play
                (move Select
                    (from ("FirstSiteToSow"))
                    (then 
                        (sow 
                            "TrackCCW"
                            owner:(mover)
                            apply:(set Value Mover ("NextSite" from:(to)))
                        )
                    )
                )
            )
            (nextPhase Mover "Opening2")
        )
        (phase "Opening2"
            (play
                (move Select
                    (from (value Player Mover))
                    (then 
                        (sow 
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (= (count at:("NextSite" from:(to))) 0) 
                                (set Value Mover Off)
                                (set Value Mover ("NextSite" from:(to)))
                            )
                        )
                    )
                )
            )
            (nextPhase Mover ("IsOffBoard" (value Player Mover)) "Opening3")
        )
        (phase "Opening3"
            (play
                (move
                    (from (forEach (sites Mover "Inner") if:(!= 0 (count at:(site)))))
                    (to (forEach (sites Mover "Outer") if:(= 0 (count at:(site)))))
                    count:2
                )
            )
            (nextPhase Mover "Opening4")
        )
        (phase "Opening4"
            (play (move Remove (sites Next "Home")))
            (nextPhase Mover "Opening5")
        )
        (phase "Opening5"
            (play (move Remove (sites Next "Home")))
            (nextPhase Mover "Playing")
        )
        (phase "Playing"
            (play
                (move Select 
                    (from 
                        (if ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover "Home") 
                        ) 
                        if:(> (count at:(from)) 0)
                    )
                    (then 
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (= (count at:(to)) 1)
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (> (count at:("OppositePit" (to))) 0) 
                                        (and
                                            (remove ("OppositePit" (to))) 
                                            (if 
                                                (> (count at:("OppositeOuterPit" (to))) 0) 
                                                (remove ("OppositeOuterPit" (to))) 
                                            ) 
                                        ) 
                                    ) 
                                )
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end 
            (forEach Player
                if:(= 0 ("PiecesOwnedBy" Player))
                (result Player Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Mefuvha" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Board:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start { 
            (set Count 2 
                to:(difference 
                    (union (sites P1 "Home") (sites P2 "Home")) 
                    (union
                        (expand (intersection (sites Row 1) (sites Left)) steps:1 E) 
                        (expand (intersection (sites Row 2) (sites Right)) steps:1 W) 
                    )
                ) 
            ) 
            (set Count 1 
                to:(union
                    (difference (expand (intersection (sites Row 1) (sites Left)) steps:1 E) (sites Left)) 
                    (difference (expand (intersection (sites Row 2) (sites Right)) steps:1 W) (sites Right))
                )
            )
        })
        
        (play 
            (if "MoveAgainAfterCapture"
                (move Select
                    (from (sites Next "Home") if:(> (count at:(from)) 0))
                    (then 
                        (fromTo 
                            (from (last From)) 
                            (to (handSite Mover)) 
                            count:(count at:(last From)) 
                        )
                    )
                )
                (priority
                    (move Select 
                        (from 
                            (if ("SameTurn") 
                                "LastHoleSowed" 
                                (if 
                                    (< (count Turns) 3) 
                                    "StylizedMove" 
                                    (sites Mover "Home") 
                                ) 
                            ) 
                            if:(> (count at:(from)) 1)
                        )
                        "Sow"
                    )
                    (move Select 
                        (from 
                            (if ("SameTurn") 
                                "LastHoleSowed" 
                                (sites Mover "Home") 
                            )
                            if:(= (count at:(from)) 1)
                        )
                        "Sow"
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)
Mefuhva is a four-row mancala-style board game played by the Venda people in South Africa. It is played by men on large boards or in hollows dug into the ground.4x6-28 board; 16-20 is most common, only even numbers of holes. Two counters in each hole except the leftmost on the inner row, which is left empty, and the one to its right which contains one counter. Players sow by picking up the counters in any of their holes and sowing them in an anti-clockwise direction. Sowing continues when the last counter falls into an occupied hole by picking up the counters in that hole and continuing in the same direction. When the final counter lands in an empty hole in the inner row, the counters in the opponent's hole opposite in the inner row are captured; if there are also counters in the opponent's outer row opposite, these are also captured. The player is also entitled to capture counters in any other hole on the opponent's side. The turn ends with a capture and the opponent's turn begins. Play always begins with a stylized move, where the counters are taken from the third hole from the left in the inner row, sowing and making captures as described above. Players may not sow single counters unless there are no holes on their side containing multiple counters. Play ends when one player has captured all of their opponent's counters. Each player has 6 holes per row.

Describe the mechanics of the following Ludii game
(game "Tai Shogi"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 25))
        
        (piece "FreeBear" Each 
            (or
                ("SlideMove" (directions {Rightward Leftward FR FL BR BL}))
                ("ForwardKnightMove")
            )
        )
        
        (piece "FreeBoar" Each ("SlideMove" (directions {Rightward Leftward FR FL BR BL})))
        
        (piece "FuriousFiend" Each
            (or {
                ("SlideMove" Adjacent (between (max 3)))
                ("DoubleStep" Adjacent N)
                ("DoubleStep" Adjacent S)
                ("DoubleStep" Adjacent E)
                ("DoubleStep" Adjacent W)
                ("DoubleStep" Adjacent NE)
                ("DoubleStep" Adjacent NW)
                ("DoubleStep" Adjacent SW)
                ("DoubleStep" Adjacent SE)
                ("HopMove" Adjacent)
                (move Leap 
                    "KnightWalk" 
                    (to 
                        if:(not ("IsFriendAt" (to))) 
                        ("CaptureEnemyAndPromote")
                    ) 
                )
            })
        )
        
        (piece "WizardStork" Each
            (or 
                ("SlideMove" (directions {Forward BR BL FR FL}))
                ("StepMove" Backward)
            )			
        )
        
        (piece "GreatElephant" Each
            (or 
                ("SlideMove" (directions {Rightward Leftward BR BL}) (between (max 5)))
                ("SlideMove" (directions {FR FL Backward Forward}) (between (max 3)))
            )		
        )
        
        (piece "FragrantElephant" Each
            (or 
                ("SlideMove" (directions {FR FL}))
                ("SlideMove" (difference Adjacent (directions {FR FL})) (between (max 2)))
            )	
        )
        
        (piece "MountainWitch" Each
            (or 
                ("SlideMove" (directions {Backward BR BL FR FL}))
                ("StepMove" Forward)
            )		
        )
        
        (piece "TeachingKing" Each
            (or {
                ("SlideMove" Adjacent)
                (move Slide 
                    Adjacent 
                    (between 
                        (exact 3)	
                        if:(not ("IsFriendAt" (between)))
                        (apply (remove (between)))
                    )
                    (to 
                        (apply 
                            if:(not ("IsFriendAt" (to)))
                            (if 
                                ("IsEnemyAt" (to)) 
                                (and
                                    (remove (to))
                                    ("Promote")
                                )
                            )
                        )
                    )
                )
                ("StepMove" Adjacent) 
                (move Hop 
                    Adjacent
                    (between
                        (exact 2)
                        if:True
                    )
                    (to 
                        if:(not ("IsFriendAt" (to))) 
                        ("CaptureEnemyAndPromote")
                    ) 
                )
                (move Hop 
                    Adjacent
                    (between
                        (exact 1)
                        if:True
                    )
                    (to 
                        if:(not ("IsFriendAt" (to))) 
                        ("CaptureEnemyAndPromote")
                    ) 
                )
                (move Hop 
                    Adjacent
                    (between
                        (exact 1)
                        if:True
                    )
                    (to 
                        if:(and {
                            (not ("IsFriendAt" (to)))
                            (!= (to) (ahead (to) (directions Cell from:(from) to:(to))))
                            (not ("IsFriendAt" (ahead (to) (directions Cell from:(from) to:(to)))))
                        }) 
                        ("CaptureEnemyAndPromote")
                    )
                    (then 
                        (fromTo
                            (from (last To))
                            (to (ahead (last To) ("LastDirection" Cell)))
                        )
                    )
                )
                (move Hop 
                    Adjacent
                    (between
                        (exact 1)
                        if:True
                    )
                    (to 
                        if:(and {
                            (!= (to) (ahead (to) (directions Cell from:(to) to:(from))))
                            (not ("IsFriendAt" (ahead (to) (directions Cell from:(to) to:(from)))))
                            (not ("IsFriendAt" (to))) 
                        })
                        ("CaptureEnemyAndPromote")
                    )
                    (then 
                        (fromTo
                            (from (last To))
                            (to (ahead (last To) (directions Cell from:(last To) to:(last From))))
                        )
                    )
                )
            })	
        )
        
        (piece "SquareMover" Each
            (or 
                ("SlideMove" Orthogonal)
                ("StepMove" (directions {FR FL}))
            )
        )
        
        (piece "Bat" Each ("SlideMove" (directions {BR BL Forward})))
        
        (piece "BuddhistSpirit" Each
            (or 
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                ("StepMove" (directions {Backward Rightward Leftward}))
            )
        )
        
        (piece "Emperor" Each
            (and
                (do
                    (move 
                        (from)
                        (to (sites Occupied by:Enemy))
                    )
                    ifAfterwards:(not ("IsInCheck" "Emperor" Mover))
                )
                (move 
                    (from)
                    (to (sites Empty))
                )
            )		
        )
        
        (piece "Prince" Each ("StepMove" Adjacent))
        
        (piece "HookMover" Each
            ("SlideMove" Orthogonal ~
                (then (moveAgain))
            )
        )
        
        (piece "LongNosedGoblin" Each
            (or 
                ("SlideMove" Diagonal ~
                    (then (moveAgain))
                )
                ("StepMove" Orthogonal)
            )
        )
        
        (piece "Capricorn" Each
            ("SlideMove" Diagonal ~
                (then (moveAgain))
            )	
        )
        
        (piece "Peacock" Each
            (or 
                ("SlideMove" (directions {FR FL}) ~
                    (then (moveAgain))
                )
                ("SlideMove" (directions {BR BL}) (between (max 2)))
            )
        )
        
        (piece "SoaringEagle" Each
            (or {
                ("StepMove" (directions {FR FL}))
                (move 
                    Hop
                    (directions {FR FL})
                    (between
                        (exact 1)
                        if:True
                    )
                    (to 
                        if:(and {
                            (!= (to) (ahead (to) (directions Cell from:(to) to:(from))))
                            (not ("IsFriendAt" (ahead (to) (directions Cell from:(to) to:(from)))))
                            (not ("IsFriendAt" (to))) 
                        })
                        ("CaptureEnemyAndPromote")
                    )
                    (then 
                        (fromTo
                            (from (last To))
                            (to (ahead (last To) (directions Cell from:(last To) to:(last From))))
                        )
                    )
                )
                ("DoubleStep" (directions {FR FL}) ("LastDirection" Cell))
                ("DoubleStep" (directions {FR FL}) (directions Cell from:(last To) to:(last From)))
                ("HopMove" (directions {FR FL}))
                ("SlideMove" (difference Adjacent (directions {FR FL})))
            })
        )
        
        (piece "HornedFalcon" Each
            (or {
                ("StepMove" Forward)
                (move 
                    Hop
                    Forward
                    (between
                        (exact 1)
                        if:True
                    )
                    (to 
                        if:(and {
                            (!= (to) (ahead (to) (directions Cell from:(to) to:(from))))
                            (not ("IsFriendAt" (ahead (to) (directions Cell from:(to) to:(from)))))
                            (not ("IsFriendAt" (to))) 
                        })
                        ("CaptureEnemyAndPromote")
                    )
                    (then 
                        (fromTo
                            (from (last To))
                            (to (ahead (last To) (directions Cell from:(last To) to:(last From))))
                        )
                    )
                )
                ("DoubleStep" Forward ("LastDirection" Cell))
                ("DoubleStep" Forward (directions Cell from:(last To) to:(last From)))
                ("HopMove" Forward)
                ("SlideMove" (difference Adjacent Forward))
            })
        )
        
        (piece "Queen" Each ("SlideMove" Adjacent))
        
        (piece "RushingBird" Each ("SlideMove" (difference Adjacent Backward)))
        
        (piece "FreeDemon" Each
            (or 
                ("SlideMove" (directions {Rightward Leftward FR FL}))
                ("SlideMove" (directions {Forward Backward}) (between (max 5)))
            )
        )
        
        (piece "FreeDreamEater" Each
            (or 
                ("SlideMove" (directions {Forwards Backward}))
                ("SlideMove" (directions {Rightward Leftward}) (between (max 5)))
            )
        )
        
        (piece "WaterBuffalo" Each
            (or 
                ("SlideMove" (directions {FR FL BR BL Rightward Leftward}))
                ("SlideMove" (directions {Forward Backward}) (between (max 2)))
            )
        )
        
        (piece "FlyingOx" Each ("SlideMove" (directions {BL BR FR FL Forward Backward})))
        
        (piece "Soldier" Each ("SlideMove" (directions {Rightward Leftward Forward Backwards})))
        
        (piece "DragonKing" Each
            (or 
                ("StepMove" Diagonal)
                ("SlideMove" Orthogonal)
            )
        )
        
        (piece "DragonHorse" Each
            (or 
                ("StepMove" Orthogonal)
                ("SlideMove" Diagonal)
            )
        )
        
        (piece "SideChariot" Each 
            (or 
                ("SlideMove" Orthogonal)
                ("StepMove" (directions {BL BR}))
            )		
        )
        
        (piece "Rook" Each ("SlideMove" Orthogonal))
        
        (piece "Bishop" Each ("SlideMove" Diagonal))
        
        (piece "Lion" Each
            (or {
                ("DoubleStep" Adjacent N)
                ("DoubleStep" Adjacent S)
                ("DoubleStep" Adjacent E)
                ("DoubleStep" Adjacent W)
                ("DoubleStep" Adjacent NE)
                ("DoubleStep" Adjacent NW)
                ("DoubleStep" Adjacent SW)
                ("DoubleStep" Adjacent SE)
                ("HopMove" Adjacent)
                (move Leap
                    "KnightWalk" 
                    (to 
                        if:(not ("IsFriendAt" (to))) 
                        ("CaptureEnemyAndPromote")
                    ) 
                )
            })
        )
        
        (piece "WhiteHorse" Each ("SlideMove" (directions {Forwards Backward})))
        
        (piece "Whale" Each ("SlideMove" (directions {Forward Backwards})))
        
        (piece "StandardBearer" Each
            (or 
                ("SlideMove" Forwards)
                ("SlideMove" (difference Adjacent Forwards) (between (max 2)))
            )
        )
        
        (piece "VermillionSparrow" Each
            (or 
                ("StepMove" BL)
                ("SlideMove" (directions {FR BR}))
            )	
        )
        
        (piece "TurtleSnake" Each
            (or 
                ("StepMove" (difference Adjacent (directions {FR BR})))
                ("SlideMove" (directions {FR BR}))
            )	
        )
        
        (piece "BlueDragon" Each
            (or {
                ("StepMove" FL)
                ("SlideMove" (directions {Rightward FR Leftward}))
                ("SlideMove" (directions {Forward Backward}) (between (max 2)))
            })		
        )
        
        (piece "WhiteTiger" Each
            (or {
                ("StepMove" FR)
                ("SlideMove" (directions {Forward FL Backward}))
                ("SlideMove" (directions {Rightward Leftward}) (between (max 2)))
            })
        )
        
        (piece "RightChariot" Each
            (or 
                ("StepMove" Backward)
                ("SlideMove" (directions {Forward FR BR}))
            )	
        )
        
        (piece "LeftChariot" Each
            (or 
                ("StepMove" Backward)
                ("SlideMove" (directions {Forward FL BL}))
            )			
        )
        
        (piece "SideDragon" Each
            (or 
                ("StepMove" Backward)
                ("SlideMove" (directions {Forward Rightward Leftward}))
            )		
        )
        
        (piece "Dove" Each
            (or 
                ("SlideMove" Orthogonal (between (max 2)))
                ("SlideMove" Diagonal (between (max 5)))
            )	
        )
        
        (piece "SheDevil" Each
            (or 
                ("SlideMove" Diagonal (between (max 2)))
                ("SlideMove" Orthogonal (between (max 5)))
            )	
        )
        
        (piece "GoldenBird" Each
            (or {
                ("SlideMove" (directions {Rightward Leftward}) (between (max 2)))
                ("SlideMove" Diagonal (between (max 3)))
                ("SlideMove" (directions {Forward Backward}))
            })
        )
        
        (piece "GreatDragon" Each
            (or {
                ("SlideMove" (directions {Forward Backward}) (between (max 2)))
                ("SlideMove" (directions {BR BL}) (between (max 3)))
                ("SlideMove" (directions {Rightward Leftward}))
                (move Hop 
                    (directions {Rightward Leftward})
                    (between
                        (range 1 2)
                        if:True
                    )
                    (to 
                        if:(not ("IsFriendAt" (to))) 
                        ("CaptureEnemyAndPromote")
                    ) 
                )
            })	
        )
        
        (piece "WhiteElephant" Each
            (or 
                ("SlideMove" (difference Adjacent (directions {BR BL})) (between (max 2)))
                ("SlideMove" (directions {BR BL}))
            )	
        )
        
        (piece "LionDog" Each
            (or {
                (move Slide 
                    Adjacent 
                    (between 
                        (exact 3)	
                        if:(not ("IsFriendAt" (between)))
                        (apply (remove (between)))
                    )
                    (to 
                        (apply 
                            if:(not ("IsFriendAt" (to)))
                            (if 
                                ("IsEnemyAt" (to)) 
                                (and
                                    (remove (to))
                                    ("Promote")
                                )
                            )
                        )
                    )
                )
                ("StepMove" Adjacent) 
                (move Hop 
                    Adjacent
                    (between
                        (exact 2)
                        if:True
                    )
                    (to 
                        if:(not ("IsFriendAt" (to))) 
                        ("CaptureEnemyAndPromote")
                    ) 
                )
                (move Hop 
                    Adjacent
                    (between
                        (exact 1)
                        if:True
                    )
                    (to 
                        if:(not ("IsFriendAt" (to))) 
                        ("CaptureEnemyAndPromote")
                    ) 
                )
                (move Hop 
                    Adjacent
                    (between
                        (exact 1)
                        if:True
                    )
                    (to 
                        if:(and {
                            (not ("IsFriendAt" (to)))
                            (!= (to) (ahead (to) (directions Cell from:(from) to:(to))))
                            (not ("IsFriendAt" (ahead (to) (directions Cell from:(from) to:(to)))))
                        }) 
                        ("CaptureEnemyAndPromote")
                    )
                    (then 
                        (fromTo
                            (from (last To))
                            (to (ahead (last To) ("LastDirection" Cell)))
                        )
                    )
                )
                (move Hop 
                    Adjacent
                    (between
                        (exact 1)
                        if:True
                    )
                    (to 
                        if:(and {
                            (!= (to) (ahead (to) (directions Cell from:(to) to:(from))))
                            (not ("IsFriendAt" (ahead (to) (directions Cell from:(to) to:(from)))))
                            (not ("IsFriendAt" (to))) 
                        })
                        ("CaptureEnemyAndPromote")
                    )
                    (then 
                        (fromTo
                            (from (last To))
                            (to (ahead (last To) (directions Cell from:(last To) to:(last From))))
                        )
                    )
                )
            })
        )
        
        (piece "Wrestler" Each
            (or 
                ("StepMove" (directions {Rightward Leftward}))
                ("SlideMove" Diagonal (between (max 3)))
            )
        )
        
        (piece "GuardianOfTheGods" Each
            (or 
                ("StepMove" (directions {FR FL}))
                ("SlideMove" Orthogonal (between (max 3)))
            )	
        )
        
        (piece "BuddhistDevil" Each
            (or 
                ("StepMove" (directions {Backward Rightward Leftward}))
                ("SlideMove" (directions {FR FL}) (between (max 3)))
            )	
        )
        
        (piece "GoldenDeer" Each
            (or 
                ("SlideMove" (directions {FR FL}))
                ("SlideMove" (directions {BR BL}) (between (max 2)))
            )		
        )
        
        (piece "SilverHare" Each
            (or 
                ("SlideMove" (directions {BR BL}))
                ("SlideMove" (directions {FR FL}) (between (max 2)))
            )			
        )
        
        (piece "FierceEagle" Each
            (or 
                ("StepMove" Forwards)
                ("SlideMove" (directions {BR BL Rightward Leftward}) (between (max 2)))
            )		
        )
        
        (piece "OldKite" Each
            (or 
                ("StepMove" (directions {FR FL}))
                ("SlideMove" Orthogonal (between (max 2)))
            )			
        )
        
        (piece "ViolentOx" Each ("SlideMove" Orthogonal (between (max 2))))
        
        (piece "FlyingDragon" Each ("SlideMove" Diagonal (between (max 2))))
        
        (piece "OldRat" Each ("SlideMove" (directions {Backward FR FL}) (between (max 2))))
        
        (piece "EnchantedBadger" Each ("SlideMove" (directions {Forward Rightward Leftward}) (between (max 2))))
        
        (piece "FlyingHorse" Each
            (or 
                ("StepMove" Orthogonal)
                ("SlideMove" (directions {FR FL}) (between (max 2)))
            )		
        )
        
        (piece "PrancingStag" Each
            (or 
                ("StepMove" (directions {FR FL BR BL Forward}))
                ("SlideMove" (directions {Rightward Leftward}) (between (max 2)))
            )			
        )
        
        (piece "ViolentBear" Each
            (or 
                ("StepMove" (directions {Rightward Leftward}))
                ("SlideMove" (directions {FR FL}) (between (max 2)))
            )			
        )
        
        (piece "SideMover" Each
            (or 
                ("StepMove" (directions {Forward Backward}))
                ("SlideMove" (directions {Rightward Leftward}))
            )
        )
        
        (piece "VerticalMover" Each
            (or 
                ("StepMove" (directions {Rightward Leftward}))
                ("SlideMove" (directions {Forward Backward}))
            )			
        )
        
        (piece "Phoenix" Each
            (or 
                ("StepMove" Orthogonal)
                ("HopMove" Diagonal)
            )		
        )
        
        (piece "Kirin" Each 
            (or 
                ("StepMove" Diagonal)
                ("HopMove" Orthogonal)
            )		
        )
        
        (piece "ReverseChariot" Each ("SlideMove" (directions {Backward Forward})))
        
        (piece "PoisonSnake" Each
            (or 
                ("StepMove" (directions {Rightward Leftward}))
                ("HopMove" (directions {Forward BR BL}))
            )		
        )
        
        (piece "NorthernBarbarian" Each
            (or 
                ("StepMove" (directions {Rightward Leftward BR BL}))
                ("SlideMove" (directions {FR FL}) (between (max 2)))
            )		
        )
        
        (piece "SouthernBarbarian" Each
            (or 
                ("StepMove" (directions {Rightward Leftward FR FL}))
                ("SlideMove" (directions {BR BL}) (between (max 2)))
            )		
        )
        
        (piece "EasternBarbarian" Each
            (or 
                ("StepMove" (directions {Rightward Leftward FR FL}))
                ("SlideMove" (directions {Forward Backward}) (between (max 2)))
            )			
        )
        
        (piece "WesternBarbarian" Each
            (or 
                ("StepMove" (directions {Forwards Backward}))
                ("SlideMove" (directions {Rightward Leftward}) (between (max 2)))
            )			
        )
        
        (piece "BlindBear" Each
            (or 
                ("StepMove" Diagonal)
                ("SlideMove" Backward)
            )		
        )
        
        (piece "DrunkenElephant" Each ("StepMove" (difference Adjacent Backward)))
        
        (piece "NeighborKing" Each ("StepMove" (difference Adjacent Backward)))
        
        (piece "BlindTiger" Each ("StepMove" (difference Adjacent Forward)))
        
        (piece "FreeTiger" Each ("SlideMove" (difference Adjacent Forward)))
        
        (piece "BlindMonkey" Each ("StepMove" (directions {Rightwards Leftwards})))
        
        (piece "FerociousLeopard" Each ("StepMove" (directions {Backwards Forwards})))
        
        (piece "FreeLeopard" Each ("SlideMove" (directions {Backwards Forwards})))
        
        (piece "RecliningDragon" Each ("StepMove" (directions {Backwards Forward Rightward Leftward})))
        
        (piece "FreeDragon" Each ("SlideMove" (directions {Backwards Forward Rightward Leftward})))
        
        (piece "ChineseCock" Each ("StepMove" (directions {Backward FR FL Rightward Leftward})))
        
        (piece "OldMonkey" Each ("StepMove" (directions {Backwards FR FL})))
        
        (piece "EvilWolf" Each ("StepMove" (directions {Forwards Rightward Leftward})))
        
        (piece "FreeWolf" Each ("SlideMove" (directions {Forwards Rightward Leftward})))
        
        (piece "AngryBoar" Each ("StepMove" Orthogonal))
        
        (piece "CatSword" Each ("StepMove" Diagonal))
        
        (piece "FreeCat" Each ("SlideMove" Diagonal))
        
        (piece "CoiledSerpent" Each ("StepMove" (directions {Forward Backwards})))
        
        (piece "FreeSerpent" Each ("SlideMove" (directions {Forward Backwards})))
        
        (piece "DarkSpirit" Each ("StepMove" (directions {Rightward FR FL BR})))
        
        (piece "Deva" Each ("StepMove" (directions {Leftward FR FL BL})))
        
        (piece "RightGeneral" Each ("StepMove" (difference Adjacent Rightward)))
        
        (piece "LeftGeneral" Each ("StepMove" (difference Adjacent Leftward)))
        
        (piece "GoldGeneral" Each ("StepMove" (directions {Forwards Rightward Leftward Backward})))
        
        (piece "FreeGold" Each ("SlideMove" (directions {Forwards Rightward Leftward Backward}) ))
        
        (piece "SilverGeneral" Each ("StepMove" (directions {Forwards BR BL})))
        
        (piece "FreeSilver" Each ("SlideMove" (directions {Forwards BR BL})))
        
        (piece "CopperGeneral" Each ("StepMove" (directions {Forwards Backward})))
        
        (piece "FreeCopper" Each ("SlideMove" (directions {Forwards Backward}) ))
        
        (piece "TileGeneral" Each ("StepMove" (directions {FR FL Backward})))
        
        (piece "FreeTile" Each ("SlideMove" (directions {FR FL Backward}) ))
        
        (piece "IronGeneral" Each ("StepMove" Forwards))
        
        (piece "FreeIron" Each ("SlideMove" Forwards))
        
        (piece "WoodGeneral" Each ("SlideMove" (directions {FR FL}) (between (max 2))))
        
        (piece "StoneGeneral" Each ("StepMove" (directions {FR FL})))
        
        (piece "FreeStone" Each ("SlideMove" (directions {FR FL}) ))
        
        (piece "EarthGeneral" Each ("StepMove" (directions {Forward Backward})))
        
        (piece "GoBetween" Each ("StepMove" (directions {Forward Backward})))
        
        (piece "FreeEarth" Each ("SlideMove" (directions {Forward Backward})))
        
        (piece "FreeGoer" Each ("SlideMove" (directions {Forward Backward})))
        
        (piece "Knight" Each ("ForwardKnightMove"))
        
        (piece "HowlingDog" Each
            (or 
                ("StepMove" Backward)
                ("SlideMove" Forward)
            )		
        )
        
        (piece "Donkey" Each
            (or 
                ("StepMove" Orthogonal)
                ("HopMove" (directions {Forward Backward}))
            )
        )
        
        (piece "RamsHeadSoldier" Each ("SlideMove" (directions {FR FL})))
        
        (piece "Lance" Each ("SlideMove" Forward))
        
        (piece "Pawn" Each ("StepMove" Forward))
        
        (map "Promoted" { 
            (pair (id "Prince" P1) (id "Emperor" P1)) (pair (id "Prince" P2) (id "Emperor" P2))
            (pair (id "HookMover" P1) (id "GoldGeneral" P1)) (pair (id "HookMover" P2) (id "GoldGeneral" P2))
            (pair (id "LongNosedGoblin" P1) (id "GoldGeneral" P1)) (pair (id "LongNosedGoblin" P2) (id "GoldGeneral" P2))
            (pair (id "Capricorn" P1) (id "GoldGeneral" P1)) (pair (id "Capricorn" P2) (id "GoldGeneral" P2))
            (pair (id "Peacock" P1) (id "GoldGeneral" P1)) (pair (id "Peacock" P2) (id "GoldGeneral" P2))
            (pair (id "SoaringEagle" P1) (id "GoldGeneral" P1)) (pair (id "SoaringEagle" P2) (id "GoldGeneral" P2))
            (pair (id "HornedFalcon" P1) (id "GoldGeneral" P1)) (pair (id "HornedFalcon" P2) (id "GoldGeneral" P2))
            (pair (id "RushingBird" P1) (id "FreeDemon" P1)) (pair (id "RushingBird" P2) (id "FreeDemon" P2))
            (pair (id "FreeDemon" P1) (id "GoldGeneral" P1)) (pair (id "FreeDemon" P2) (id "GoldGeneral" P2))
            (pair (id "FreeDreamEater" P1) (id "GoldGeneral" P1)) (pair (id "FreeDreamEater" P2) (id "GoldGeneral" P2))
            (pair (id "WaterBuffalo" P1) (id "FreeDreamEater" P1)) (pair (id "WaterBuffalo" P2) (id "FreeDreamEater" P2))
            (pair (id "FlyingOx" P1) (id "GoldGeneral" P1)) (pair (id "FlyingOx" P2) (id "GoldGeneral" P2))
            (pair (id "Soldier" P1) (id "GoldGeneral" P1)) (pair (id "Soldier" P2) (id "GoldGeneral" P2))
            (pair (id "Lion" P1) (id "FuriousFiend" P1)) (pair (id "Lion" P2) (id "FuriousFiend" P2))
            (pair (id "SideChariot" P1) (id "GoldGeneral" P1)) (pair (id "SideChariot" P2) (id "GoldGeneral" P2))
            (pair (id "Rook" P1) (id "GoldGeneral" P1)) (pair (id "Rook" P2) (id "GoldGeneral" P2))
            (pair (id "Bishop" P1) (id "GoldGeneral" P1)) (pair (id "Bishop" P2) (id "GoldGeneral" P2))
            (pair (id "WhiteHorse" P1) (id "GoldGeneral" P1)) (pair (id "WhiteHorse" P2) (id "GoldGeneral" P2))
            (pair (id "Whale" P1) (id "GoldGeneral" P1)) (pair (id "Whale" P2) (id "GoldGeneral" P2))
            (pair (id "StandardBearer" P1) (id "GoldGeneral" P1)) (pair (id "StandardBearer" P2) (id "GoldGeneral" P2))
            (pair (id "VermillionSparrow" P1) (id "GoldGeneral" P1)) (pair (id "VermillionSparrow" P2) (id "GoldGeneral" P2))
            (pair (id "TurtleSnake" P1) (id "GoldGeneral" P1)) (pair (id "TurtleSnake" P2) (id "GoldGeneral" P2))
            (pair (id "BlueDragon" P1) (id "GoldGeneral" P1)) (pair (id "BlueDragon" P2) (id "GoldGeneral" P2))
            (pair (id "WhiteTiger" P1) (id "GoldGeneral" P1)) (pair (id "WhiteTiger" P2) (id "GoldGeneral" P2))
            (pair (id "RightChariot" P1) (id "GoldGeneral" P1)) (pair (id "RightChariot" P2) (id "GoldGeneral" P2))
            (pair (id "LeftChariot" P1) (id "GoldGeneral" P1)) (pair (id "LeftChariot" P2) (id "GoldGeneral" P2))
            (pair (id "SideDragon" P1) (id "GoldGeneral" P1)) (pair (id "SideDragon" P2) (id "GoldGeneral" P2))
            (pair (id "Dove" P1) (id "GoldGeneral" P1)) (pair (id "Dove" P2) (id "GoldGeneral" P2))
            (pair (id "SheDevil" P1) (id "GoldGeneral" P1)) (pair (id "SheDevil" P2) (id "GoldGeneral" P2))
            (pair (id "GoldenBird" P1) (id "GoldGeneral" P1)) (pair (id "GoldenBird" P2) (id "GoldGeneral" P2))
            (pair (id "GreatDragon" P1) (id "GoldGeneral" P1)) (pair (id "GreatDragon" P2) (id "GoldGeneral" P2))
            (pair (id "WhiteElephant" P1) (id "GoldGeneral" P1)) (pair (id "WhiteElephant" P2) (id "GoldGeneral" P2))
            (pair (id "LionDog" P1) (id "GreatElephant" P1)) (pair (id "LionDog" P2) (id "GreatElephant" P2))
            (pair (id "Wrestler" P1) (id "GoldGeneral" P1)) (pair (id "Wrestler" P2) (id "GoldGeneral" P2))
            (pair (id "GuardianOfTheGods" P1) (id "GoldGeneral" P1)) (pair (id "GuardianOfTheGods" P2) (id "GoldGeneral" P2))
            (pair (id "BuddhistDevil" P1) (id "GoldGeneral" P1)) (pair (id "BuddhistDevil" P2) (id "GoldGeneral" P2))
            (pair (id "GoldenDeer" P1) (id "GoldGeneral" P1)) (pair (id "GoldenDeer" P2) (id "GoldGeneral" P2))
            (pair (id "SilverHare" P1) (id "GoldGeneral" P1)) (pair (id "SilverHare" P2) (id "GoldGeneral" P2))
            (pair (id "FierceEagle" P1) (id "GoldGeneral" P1)) (pair (id "FierceEagle" P2) (id "GoldGeneral" P2))
            (pair (id "OldKite" P1) (id "LongNosedGoblin" P1)) (pair (id "OldKite" P2) (id "LongNosedGoblin" P2))
            (pair (id "ViolentOx" P1) (id "GoldGeneral" P1)) (pair (id "ViolentOx" P2) (id "GoldGeneral" P2))
            (pair (id "FlyingDragon" P1) (id "GoldGeneral" P1)) (pair (id "FlyingDragon" P2) (id "GoldGeneral" P2))
            (pair (id "OldRat" P1) (id "Bat" P1)) (pair (id "OldRat" P2) (id "Bat" P2))
            (pair (id "EnchantedBadger" P1) (id "Dove" P1)) (pair (id "EnchantedBadger" P2) (id "Dove" P2))
            (pair (id "FlyingHorse" P1) (id "Queen" P1)) (pair (id "FlyingHorse" P2) (id "Queen" P2))
            (pair (id "PrancingStag" P1) (id "SquareMover" P1)) (pair (id "PrancingStag" P2) (id "SquareMover" P2))
            (pair (id "ViolentBear" P1) (id "GoldGeneral" P1)) (pair (id "ViolentBear" P2) (id "GoldGeneral" P2))
            (pair (id "SideMover" P1) (id "GoldGeneral" P1)) (pair (id "SideMover" P2) (id "GoldGeneral" P2))
            (pair (id "VerticalMover" P1) (id "GoldGeneral" P1)) (pair (id "VerticalMover" P2) (id "GoldGeneral" P2))
            (pair (id "ReverseChariot" P1) (id "GoldGeneral" P1)) (pair (id "ReverseChariot" P2) (id "GoldGeneral" P2))
            (pair (id "Phoenix" P1) (id "GoldenBird" P1)) (pair (id "Phoenix" P2) (id "GoldenBird" P2))
            (pair (id "Kirin" P1) (id "GreatDragon" P1)) (pair (id "Kirin" P2) (id "GreatDragon" P2))
            (pair (id "PoisonousSnake" P1) (id "HookMover" P1)) (pair (id "PoisonousSnake" P2) (id "HookMover" P2))
            (pair (id "NorthernBarbarian" P1) (id "FragrantElephant" P1)) (pair (id "NorthernBarbarian" P2) (id "FragrantElephant" P2))
            (pair (id "SouthernBarbarian" P1) (id "WhiteElephant" P1)) (pair (id "SouthernBarbarian" P2) (id "WhiteElephant" P2))
            (pair (id "EasternBarbarian" P1) (id "Lion" P1)) (pair (id "EasternBarbarian" P2) (id "Lion" P2))
            (pair (id "WesternBarbarian" P1) (id "LionDog" P1)) (pair (id "WesternBarbarian" P2) (id "LionDog" P2))
            (pair (id "BlindBear" P1) (id "FreeBear" P1)) (pair (id "BlindBear" P2) (id "FreeBear" P2))
            (pair (id "DrunkenElephant" P1) (id "Prince" P1)) (pair (id "DrunkenElephant" P2) (id "Prince" P2))
            (pair (id "NeighborKing" P1) (id "StandardBearer" P1)) (pair (id "StandardBearer" P2) (id "StandardBearer" P2))
            (pair (id "BlindTiger" P1) (id "FreeTiger" P1)) (pair (id "BlindTiger" P2) (id "FreeTiger" P2))
            (pair (id "BlindMonkey" P1) (id "GoldGeneral" P1)) (pair (id "BlindMonkey" P2) (id "GoldGeneral" P2))
            (pair (id "FerociousLeopard" P1) (id "FreeLeopard" P1)) (pair (id "FerociousLeopard" P2) (id "FreeLeopard" P2))
            (pair (id "RecliningDragon" P1) (id "FreeDragon" P1)) (pair (id "RecliningDragon" P2) (id "FreeDragon" P2))
            (pair (id "ChineseCock" P1) (id "WizardStork" P1)) (pair (id "ChineseCock" P2) (id "WizardStork" P2))
            (pair (id "OldMonkey" P1) (id "MountainWitch" P1)) (pair (id "OldMonkey" P2) (id "MountainWitch" P2))
            (pair (id "EvilWolf" P1) (id "FreeWolf" P1)) (pair (id "EvilWolf" P2) (id "FreeWolf" P2))
            (pair (id "AngryBoar" P1) (id "FreeBoar" P1)) (pair (id "AngryBoar" P2) (id "FreeBoar" P2))
            (pair (id "CatSword" P1) (id "FreeCat" P1)) (pair (id "CatSword" P2) (id "FreeCat" P2))
            (pair (id "CoiledSerpent" P1) (id "FreeSerpent" P1)) (pair (id "CoiledSerpent" P2) (id "FreeSerpent" P2))
            (pair (id "Deva" P1) (id "TeachingKing" P1)) (pair (id "Deva" P2) (id "TeachingKing" P2))
            (pair (id "DarkSpirit" P1) (id "BuddhistSpirit" P1)) (pair (id "DarkSpirit" P2) (id "BuddhistSpirit" P2))
            (pair (id "RightGeneral" P1) (id "GoldGeneral" P1)) (pair (id "RightGeneral" P2) (id "GoldGeneral" P2))
            (pair (id "LeftGeneral" P1) (id "GoldGeneral" P1)) (pair (id "LeftGeneral" P2) (id "GoldGeneral" P2))
            (pair (id "GoldGeneral" P1) (id "FreeGold" P1)) (pair (id "GoldGeneral" P2) (id "FreeGold" P2))
            (pair (id "SilverGeneral" P1) (id "FreeSilver" P1)) (pair (id "SilverGeneral" P2) (id "FreeSilver" P2))
            (pair (id "CopperGeneral" P1) (id "FreeCopper" P1)) (pair (id "CopperGeneral" P2) (id "FreeCopper" P2))
            (pair (id "TileGeneral" P1) (id "FreeTile" P1)) (pair (id "TileGeneral" P2) (id "FreeTile" P2))
            (pair (id "IronGeneral" P1) (id "FreeIron" P1)) (pair (id "IronGeneral" P2) (id "FreeIron" P2))
            (pair (id "WoodGeneral" P1) (id "GoldGeneral" P1)) (pair (id "WoodGeneral" P2) (id "GoldGeneral" P2))
            (pair (id "StoneGeneral" P1) (id "FreeStone" P1)) (pair (id "StoneGeneral" P2) (id "FreeStone" P2))
            (pair (id "EarthGeneral" P1) (id "FreeEarth" P1)) (pair (id "EarthGeneral" P2) (id "FreeEarth" P2))
            (pair (id "GoBetween" P1) (id "GoldGeneral" P1)) (pair (id "GoBetween" P2) (id "GoldGeneral" P2))
            (pair (id "Knight" P1) (id "GoldGeneral" P1)) (pair (id "Knight" P2) (id "GoldGeneral" P2))
            (pair (id "HowlingDog" P1) (id "GoldGeneral" P1)) (pair (id "HowlingDog" P2) (id "GoldGeneral" P2))
            (pair (id "Donkey" P1) (id "GoldGeneral" P1)) (pair (id "Donkey" P2) (id "GoldGeneral" P2))
            (pair (id "RamsHeadSoldier" P1) (id "GoldGeneral" P1)) (pair (id "RamsHeadSoldier" P2) (id "GoldGeneral" P2))
            (pair (id "Lance" P1) (id "GoldGeneral" P1)) (pair (id "Lance" P2) (id "GoldGeneral" P2))
            (pair (id "Pawn" P1) (id "GoldGeneral" P1)) (pair (id "Pawn" P2) (id "GoldGeneral" P2))
        })
    })
    (rules
        (start {
            
            (place "Lance1" (sites {"A1" "Y1"})) (place "Lance2" (sites {"A25" "Y25"}))
            (place "TurtleSnake1" coord:"B1") (place "TurtleSnake2" coord:"X25")
            (place "WhiteTiger1" coord:"X1") (place "WhiteTiger2" coord:"B25")
            (place "Whale1" (sites {"C1" "W1"})) (place "Whale2" (sites {"C25" "W25"}))
            (place "FlyingDragon1" (sites {"D1" "V1"})) (place "FlyingDragon2" (sites {"D25" "V25"}))
            (place "LongNosedGoblin1" (sites {"E1" "U1"})) (place "LongNosedGoblin2" (sites {"E25" "U25"}))
            (place "Dove1" (sites {"F1" "T1"})) (place "Dove2" (sites {"F25" "T25"}))
            (place "Rook1" (sites {"G1" "S1"})) (place "Rook2" (sites {"G25" "S25"}))
            (place "DragonHorse1" (sites {"H1" "R1"})) (place "DragonHorse2" (sites {"H25" "R25"}))
            (place "DragonKing1" (sites {"I1" "Q1"})) (place "DragonKing2" (sites {"I25" "Q25"}))
            (place "Queen1" (sites {"J1" "P1"})) (place "Queen2" (sites {"J25" "P25"}))
            (place "GoldGeneral1" (sites {"K1" "O1"})) (place "GoldGeneral2" (sites {"K25" "O25"}))
            (place "Deva1" coord:"L1") (place "Deva2" coord:"N25")
            (place "DarkSpirit1" coord:"N1") (place "DarkSpirit2" coord:"L25")
            (place "Emperor1" coord:"M1") (place "Emperor2" coord:"M25")
            
            
            (place "ReverseChariot1" (sites {"A2" "Y2"})) (place "ReverseChariot2" (sites {"A24" "Y24"}))
            (place "SideDragon1" (sites {"B2" "X2"})) (place "SideDragon2" (sites {"B24" "X24"}))
            (place "SoaringEagle1" (sites {"C2" "W2"})) (place "SoaringEagle2" (sites {"C24" "W24"}))
            (place "Knight1" (sites {"D2" "V2"})) (place "Knight2" (sites {"D24" "V24"}))
            (place "PoisonSnake1" (sites {"E2" "U2"})) (place "PoisonSnake2" (sites {"E24" "U24"}))
            (place "FreeDreamEater1" (sites {"F2" "T2"})) (place "FreeDreamEater2" (sites {"F24" "T24"}))
            (place "Bishop1" (sites {"G2" "S2"})) (place "Bishop2" (sites {"G24" "S24"}))
            (place "FierceEagle1" (sites {"H2" "R2"})) (place "FierceEagle2" (sites {"H24" "R24"}))
            (place "WhiteElephant1" (sites {"I2" "Q2"})) (place "WhiteElephant2" (sites {"I24" "Q24"}))
            (place "FreeDemon1" (sites {"J2" "P2"})) (place "FreeDemon2" (sites {"J24" "P24"}))
            (place "SilverGeneral1" (sites {"K2" "O2"})) (place "SilverGeneral2" (sites {"K24" "O24"}))
            (place "LeftGeneral1" coord:"L2") (place "LeftGeneral2" coord:"N24")
            (place "RightGeneral1" coord:"N2") (place "RightGeneral2" coord:"L24")
            (place "Prince1" coord:"M2") (place "Prince2" coord:"M24")
            
            
            (place "SideChariot1" (sites {"A3" "Y3"})) (place "SideChariot2" (sites {"A23" "Y23"}))
            (place "WhiteHorse1" (sites {"B3" "X3"})) (place "WhiteHorse2" (sites {"B23" "X23"}))
            (place "RamsHeadSoldier1" (sites {"C3" "W3"})) (place "RamsHeadSoldier2" (sites {"C23" "W23"}))
            (place "ViolentOx1" (sites {"D3" "V3"})) (place "ViolentOx2" (sites {"D23" "V23"}))
            (place "CatSword1" (sites {"E3" "U3"})) (place "CatSword2" (sites {"E23" "U23"})) 
            (place "BlindBear1" (sites {"F3" "T3"})) (place "BlindBear2" (sites {"F23" "T23"}))
            (place "SilverHare1" (sites {"G3" "S3"})) (place "SilverHare2" (sites {"G23" "S23"}))
            (place "GoldenDeer1" (sites {"H3" "R3"})) (place "GoldenDeer2" (sites {"H23" "R23"}))
            (place "BlindMonkey1" (sites {"I3" "Q3"})) (place "BlindMonkey2" (sites {"I23" "Q23"}))
            (place "BlindTiger1" (sites {"J3" "P3"})) (place "BlindTiger2" (sites {"J23" "P23"}))
            (place "BuddhistDevil1" coord:"K3") (place "BuddhistDevil2" coord:"O23")
            (place "SheDevil1" coord:"O3") (place "SheDevil2" coord:"K23")
            (place "Wrestler1" coord:"L3") (place "Wrestler2" coord:"N23")
            (place "GuardianOfTheGods1" coord:"N3") (place "GuardianOfTheGods2" coord:"L23")
            (place "NeighborKing1" coord:"M3") (place "NeighborKing2" coord:"M23")
            
            
            (place "Soldier1" (sites {"A4" "Y4"})) (place "Soldier2" (sites {"A22" "Y22"}))
            (place "WaterBuffalo1" (sites {"B4" "X4"})) (place "WaterBuffalo2" (sites {"B22" "X22"}))
            (place "FerociousLeopard1" (sites {"C4" "W4"})) (place "FerociousLeopard2" (sites {"C22" "W22"}))
            (place "WesternBarbarian1" coord:"D4") (place "WesternBarbarian2" coord:"V22")
            (place "NorthernBarbarian1" coord:"V4") (place "NorthernBarbarian2" coord:"D22")
            (place "EasternBarbarian1" coord:"E4") (place "EasternBarbarian2" coord:"U22")
            (place "SouthernBarbarian1" coord:"U4") (place "SouthernBarbarian2" coord:"E22")
            (place "ChineseCock1" (sites {"F4" "T4"})) (place "ChineseCock2" (sites {"F22" "T22"}))
            (place "HornedFalcon1" (sites {"G4" "S4"})) (place "HornedFalcon2" (sites {"G22" "S22"}))
            (place "OldMonkey1" (sites {"H4" "R4"})) (place "OldMonkey2" (sites {"H22" "R22"}))
            (place "OldKite1" coord:"I4") (place "OldKite2" coord:"Q22")
            (place "RushingBird1" coord:"Q4") (place "RushingBird2" coord:"I22")
            (place "Peacock1" (sites {"J4" "P4"})) (place "Peacock2" (sites {"J22" "P22"}))
            (place "GreatDragon1" coord:"K4") (place "GreatDragon2" coord:"O22")
            (place "GoldenBird1" coord:"O4") (place "GoldenBird2" coord:"K22")
            (place "Kirin1" coord:"L4") (place "Kirin2" coord:"N22")
            (place "Phoenix1" coord:"N4") (place "Phoenix2" coord:"L22")
            (place "Lion1" coord:"M4") (place "Lion2" coord:"M22")
            
            
            (place "LeftChariot1" coord:"A5") (place "LeftChariot2" coord:"Y21")
            (place "RightChariot1" coord:"Y5") (place "RightChariot2" coord:"A21")
            (place "BlueDragon1" coord:"B5") (place "BlueDragon2" coord:"X21")
            (place "VermillionSparrow1" coord:"X5") (place "VermillionSparrow2" coord:"B21")
            (place "WoodGeneral1" (sites {"C5" "W5"})) (place "WoodGeneral2" (sites {"C21" "W21"}))
            (place "EarthGeneral1" (sites {"D5" "V5"})) (place "EarthGeneral2" (sites {"D21" "V21"}))
            (place "StoneGeneral1" (sites {"E5" "U5"})) (place "StoneGeneral2" (sites {"E21" "U21"})) 
            (place "TileGeneral1" (sites {"F5" "T5"})) (place "TileGeneral2" (sites {"F21" "T21"}))
            (place "IronGeneral1" (sites {"G5" "S5"})) (place "IronGeneral2" (sites {"G21" "S21"}))
            (place "CopperGeneral1" (sites {"H5" "R5"})) (place "CopperGeneral2" (sites {"H21" "R21"}))
            (place "OldRat1" (sites {"I5" "Q5"})) (place "OldRat2" (sites {"I21" "Q21"}))
            (place "CoiledSerpent1" (sites {"J5" "P5"})) (place "CoiledSerpent2" (sites {"J21" "P21"}))
            (place "RecliningDragon1" (sites {"K5" "O5"})) (place "RecliningDragon2" (sites {"K21" "O21"}))
            (place "Capricorn1" coord:"L5") (place "Capricorn2" coord:"N21")
            (place "HookMover1" coord:"N5") (place "HookMover2" coord:"L21")
            (place "DrunkenElephant1" coord:"M5") (place "DrunkenElephant2" coord:"M21")
            
            
            (place "HowlingDog1" (sites {"A6" "Y6"})) (place "HowlingDog2" (sites {"A20" "Y20"}))
            (place "FlyingHorse1" (sites {"B6" "X6"})) (place "FlyingHorse2" (sites {"B20" "X20"}))
            (place "EnchantedBadger1" (sites {"C6" "W6"})) (place "EnchantedBadger2" (sites {"C20" "W20"}))
            (place "Donkey1" (sites {"D6" "V6"})) (place "Donkey2" (sites {"D20" "V20"}))
            (place "FlyingOx1" (sites {"E6" "U6"})) (place "FlyingOx2" (sites {"E20" "U20"})) 
            (place "SideMover1" (sites {"F6" "T6"})) (place "SideMover2" (sites {"F20" "T20"}))
            (place "VerticalMover1" (sites {"G6" "S6"})) (place "VerticalMover2" (sites {"G20" "S20"}))
            (place "ViolentBear1" (sites {"H6" "R6"})) (place "ViolentBear2" (sites {"H20" "R20"}))
            (place "StandardBearer1" (sites {"I6" "Q6"})) (place "StandardBearer2" (sites {"I20" "Q20"}))
            (place "PrancingStag1" (sites {"J6" "P6"})) (place "PrancingStag2" (sites {"J20" "P20"}))
            (place "AngryBoar1" (sites {"K6" "O6"})) (place "AngryBoar2" (sites {"K20" "O20"}))
            (place "EvilWolf1" (sites {"L6" "N6"})) (place "EvilWolf2" (sites {"L20" "N20"}))
            (place "LionDog1" coord:"M6") (place "LionDog2" coord:"M20")
            
            
            (place "Pawn1" (sites Row 6)) (place "Pawn2" (sites Row 18))
            
            
            (place "GoBetween1" (sites {"H8" "R8"})) (place "GoBetween2" (sites {"H18" "R18"}))
        })
        
        (play 
            (if ("SameTurn")
                (if (is In (what at:(last To)) (sites {(id "Peacock" Mover) (id "Capricorn" Mover) (id "LongNosedGoblin" Mover) (id "HookMover" Mover)}))
                    (or
                        (move Pass)
                        ("SlideMove"
                            (from (last To))
                            (difference 
                                (difference (if ("IsPieceAt" "HookMover" Mover (last To)) Orthogonal Diagonal)
                                    ("LastDirection" Cell)
                                ) 
                                (directions Cell from:(last To) to:(last From))
                            )
                        )
                    )	
                )
                (forEach Piece)
            )
        )
        
        (end 
            (if 
                (and { 
                    (not (is Mover Next)) 
                    ("IsOffBoard" (where "Emperor" Next)) 
                    ("IsOffBoard" (where "Prince" Next)) 
                }) 
                (result Mover Win)
            )
        )
    )
)
Tai Shogi is a large Shogi variant known from the Edo Period in Japan.25x25 board. 354 pieces. The rules are describing from wikipedia.

Construct a Ludii game based on the following description
Phase Chess is a variant of Chess.Phase Chess is a variant of Chess played on standard Chess board and Chess set, with same rules as Chess except the next player must move from a cell of the same colour just moved to if they can. It they can not, they can move any piece. 
(game "Phase Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (priority {
                    (if (!= 0 (count Moves))
                        (do 
                            (or {
                                (forEach Piece "Queen" 
                                    (if (= (phase of:(from)) (phase of:(last To)))
                                        ("QueenMove") 
                                    )
                                )
                                (forEach Piece "Knight" 
                                    (if (= (phase of:(from)) (phase of:(last To)))
                                        ("KnightMove")
                                    )
                                )
                                (forEach Piece "Bishop" 
                                    (if (= (phase of:(from)) (phase of:(last To)))
                                        ("BishopMove")
                                    )
                                )
                                (forEach Piece "King" 
                                    (if (= (phase of:(from)) (phase of:(last To)))
                                        ("KingMove")
                                    )
                                )
                                (forEach Piece "Rook" 
                                    (if (= (phase of:(from)) (phase of:(last To)))
                                        ("RookMove")
                                    )
                                )
                                (forEach Piece "Pawn" 
                                    (if (= (phase of:(from)) (phase of:(last To)))
                                        ("PawnMove")
                                    )
                                )
                                (if ("IsPhaseZero" (last To))
                                    (if (and {
                                            "KingInTheInitialPlace" 
                                            ("HasNeverMoved" "King")
                                            (not ("IsInCheck" "King" Mover)) 
                                        })
                                        (or
                                            (if (and 
                                                    ("HasNeverMoved" "RookLeft")
                                                    (can Move ("DoCastle" "RookLeft" E 3 (is Empty (to))))
                                                )
                                                "BigCastling"
                                            )
                                            (if (and 
                                                    ("HasNeverMoved" "RookRight")
                                                    (can Move ("DoCastle" "RookRight" W 2 (is Empty (to))))
                                                )
                                                "SmallCastling"
                                            )
                                        )
                                    )
                                )
                            })
                            ifAfterwards:(not ("IsInCheck" "King" Mover (forEach Piece)))
                        )
                    )
                    (do 
                        (or 
                            (forEach Piece)
                            (if (and {
                                    "KingInTheInitialPlace" 
                                    ("HasNeverMoved" "King")
                                    (not ("IsInCheck" "King" Mover)) 
                                })
                                (or
                                    (if (and 
                                            ("HasNeverMoved" "RookLeft")
                                            (can Move ("DoCastle" "RookLeft" E 3 (is Empty (to))))
                                        )
                                        "BigCastling"
                                    )
                                    (if (and 
                                            ("HasNeverMoved" "RookRight")
                                            (can Move ("DoCastle" "RookRight" W 2 (is Empty (to))))
                                        )
                                        "SmallCastling"
                                    )
                                )
                            )
                        )
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                })
            )
        )
        
        (end {
            (if (and 
                    ("IsInCheck" "King" Next)
                    ("NextCanNotMove")
                ) 
                (result Mover Win)
            ) 
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Gabata (Shoa I)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 <Board:size> store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" <Board:trackCW> loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightMost" {(pair P1 5) (pair P2 6)})
    }) 
    (rules 
        
        (start {
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
            (set Count 4 to:(sites Track)) 
        })
        
        phases:{
        <Board:opening>
        
        (phase "Sowing" 
            (play
                (or {
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))
                        )
                        (then
                            (sow
                                "TrackCCW"
                                apply:(if (and 
                                        (= 0 (state at:(to))) 
                                        (= 4 (count at:(to)))
                                    )
                                    (set State at:(to) (mover))
                                    (if (< 1 (count at:(to)))
                                        (if (= 0 (state at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                            (if (!= (mover) (state at:(to)))
                                                (and
                                                    (fromTo
                                                        (from (to))
                                                        (to (handSite Mover))
                                                        count:(min 2 (count at:(to)))
                                                    )
                                                    (set State at:(to) (state at:(to)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OnlyPiecesInMarked")
                            (and { 
                                (forEach Site ("SitesMarkedBy" 1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site ("SitesMarkedBy" 2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                                (set Var "Round" (+ 1 (var "Round")))
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (>= 1 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (>= 1 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("RightMostEmpty"))
                        count:4
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 4 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 3 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("RightMostEmpty"))
                                                count:3
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("RightMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("RightMostEmpty"))
                                        })
                                        (if (= 2 (count Cell at:(handSite Mover)))
                                            (and {
                                                (fromTo 
                                                    (from (handSite Mover))
                                                    (to ("RightMostEmpty"))
                                                    count:2
                                                )
                                                (fromTo 
                                                    (from (handSite Next))
                                                    (to ("RightMostEmpty"))
                                                    count:2
                                                )
                                                ("RememberOwnedHolesRandom" ("RightMostEmpty"))
                                            })
                                        )
                                    )
                                )
                            })
                        )
                    )
                    (then
                        (if (and (is Empty (handSite P1)) (is Empty (handSite P2))) 
                            (and
                                (if 
                                    (is Even (var "Round"))
                                    (set NextPlayer (player 2))
                                    (set NextPlayer (player 1))
                                )
                                (set Pending)
                            )
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        
        }
    )
)
Gabata is a name applied to many two-or three-row mancala-style board games played in the Horn of Africa. This one is the most commonly played, and has been attested in Ethiopia since the early twentieth century, but is likely to be much older.2x6 board. Four counters in each hole. Players draw lots to see who goes first. Players pick up the counters in any of the holes in their row and sow them in an anti-clockwise direction. If the last counter falls into a hole that is occupied, the player picks up the contents of this hole and continues to sow. When the last counter falls into an empty hole, the play ends. Capturing occurs when the last counter falls into a hole on the opponent's side of the board containing three counters, increasing it to four. This hole then belongs to the player who captured it. A player cannot pick up counters from this hole, and the opponent can only do so if the last counter of their sowing falls there, in which case the opponent takes one counter from it, along with the final counter. The captured hole remains in the ownership of the person who captured it. If it remains empty and the opponent drops their last counter into this hole, the last counter is removed. If a player cannot move, they pass, but the opponent may continue to make moves. The player could then resume play if the opponent's moves create a possibility for a move. Play ends when there are no more counters available to move. Each player owns the counters in their captured holes or which they have removed from the board. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, but not if there are one or two extra. Play continues in several rounds like this until one player takes all the counters. Each row has 5 holes.

Construct a Ludii game based on the following description
This game is based on the discovery of a game board at the site of Poprad in Slovakia.17x17 or 17x18 board.  States can be repeated. Kharebga rules applied to a 17x17 board.
(game "Poprad Game"
    (players 2)
    <Version>
)

Construct a Ludii game based on the following description
Bizingo is a two-player strategy board game created sometime in the 1850s in the United States. Two opposing armies on a triangular grid face off against one another. A player can move a piece to any empty adjacent cell of the same color; so, on an open board, six moves are possible. Throughout the game, a player's pieces are restricted to cells of the same color.
            
            A captured piece is immediately removed from the game.
            
            A player captures a regular enemy piece by surrounding it on three sides.
            A player captures an enemy captain by surrounding it on three sides, with the caveat that one of the surrounding pieces must be a captain. (Three regular pieces are insufficient and the enemy captain would be unaffected.)
            An enemy piece on the edge of the board can be captured by surrounding it on two sides, with the caveat that one of the surrounding pieces must be a captain. (Two regular pieces are insufficient.)
            If a piece (regular or captain) is moved to a cell already surrounded by three enemy pieces, it is instantly captured, unless the move itself performed a capture.
            
        A player wins the game by reducing the opponent to two pieces. 
(game "Bizingo" 
    (players 2)
    (equipment {
        (board
            (remove
                (tri 13)
                cells:{ 0 1 13 25 11 12 24 36 165..168}
            )
        )
        (piece "Thrall" Each ("PieceMove"))
        (piece "Jarl" Each ("PieceMove"))
    }) 
    (rules 
        (start {
            (place "Thrall1" (sites {32..36 53..58 72 74..76 78}))
            (place "Jarl1" (sites {73 77}))
            (place "Thrall2" (sites {137..139 126..129 113..117 98 100 101 103}))
            (place "Jarl2" (sites {99 102}))
        })
        (play (forEach Piece)) 
        (end 
            (forEach Player 
                if:(<= (count Pieces Player) 2) 
                (result Player Loss)
            )
        ) 
    )
)

Construct a Ludii game based on the following description
Dörvön Cag (The four seasons) is a blockade game played in Mongolia. A circle, with four points equally spaced along the circumference, as well as a point in the center. A diameter is drawn between two of the outer points and through the center. Two players. Two pieces per player. Players alternate turns placing a piece on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent point along the lines. The player who blocks the other player from being able to move wins. 
(game "Dorvon Cag"
    (players 2)
    (equipment {
        (board 
            (remove (concentric {1 4}) edges:{{1 0} {0 3}})
            use:Vertex
        )
        (hand Each)
        (piece "Disc" Each "StepToEmpty")
    })
    (rules 
        (start (place "Disc" "Hand" count:2))
        phases:{
        (phase "Placement" 
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        ) 
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("BlockWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "Mughal Pathan" 
    (players 2) 
    (equipment { 
        (board
            (add
                (merge {
                    (square 7)
                    (shift 1 6 (rotate 180 (wedge 3)))
                    (shift 1 -2 (wedge 3))
                })
                edges:{
                {0 8} {8 16} {16 24} {24 32} {32 40} {40 48}
                {6 12} {12 18} {18 24} {24 30} {30 36} {36 42}
                {3 9} {9 15} {15 21} {21 29} {29 37} {37 45}
                {45 39} {39 33} {33 27} {27 19} {19 11} {11 3}
                }
            )
            use:Vertex
        )
        (piece "Marker" Each 
            (or 
                ("HopSequenceCapture")
                ("StepToEmpty")
            )
        )
    }) 
    (rules 
        (start {
            (place "Marker1" (union (sites Bottom) (expand (sites Row 2))))
            (place "Marker2" (union (sites Top) (expand (sites Row 8))))
        })
        (play 
            (if ("SameTurn")
                (or 
                    ("HopSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("CaptureAll" Next))
    )
)
Mughal Pathan is a game with leaping captures played outside of Kolkata, India by Muslim stonemasons in the early twentieth century. Its name and board suggest that it is closely related to Moghul Putt'han, played elsewhere in India.7x7 lines, intersecting to form a square. Diagonals are drawn in the four quadrants of the board. Two triangles, their apices intersecting the main board at opposite midpoints. The base of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. Twenty pieces per player, which begin on the points in the triangles and the first two rows of points in the square on the side closest to the player. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece may capture an opponent's piece by hopping over it to an empty point on the opposite side of the opponent's piece along the lies of the board. Multiple captures are allowed. The player who captures all of the opponent's peices wins. 

Construct a Ludii game based on the following description
Morra is a hand game of uncertain history from the Mediterranean region.Each player simultaneously bets on what the sum of all fingers shown will be. Each bet is added to a common pot. Then each player simultaneously reveals their hand, extending any number of fingers. Any player who successfully guesses the total number of fingers revealed by all players combined scores a point.
        The game is over when a player reaches a score of 3. The winning players share the pot. The game is played with 2 players.
(game "Morra" 
    (players <Players:num>) 
    
    (mode Simultaneous) 
    
    (equipment { 
        <Players:board>
        (hand Each size:6) 
        (hand Shared)
        (piece "Hand0" Each)
    }) 
    
    (rules 
        (start { 
            ("InitHand" "Hand01" P1)
            ("InitHand" "Hand02" P2)
            <Players:initP3>
        })
        
        phases:{
        (phase "Bet" 
            (play 
                (or {
                    (move Bet P1 (range 0 ("MaxFingers")) (then (set Pot (+ (pot) (amount P1)))))
                    (move Bet P2 (range 0 ("MaxFingers")) (then (set Pot (+ (pot) (amount P2)))))
                    <Players:betP3>
                })
            )
            (nextPhase "Hand")
        )
        
        (phase "Hand" 
            (play 
                (or {
                    ("ShowHand" P1)
                    ("ShowHand" P2)
                    <Players:showHandP3>
                })
            )
            (nextPhase "Observe")
        )
        
        (phase "Observe" 
            (play 
                (move 
                    Pass 
                    (then 
                        (and {
                            (remove 0) 
                            (remove 1)
                            <Players:removeP3>
                        })
                    )
                )
            )
            (nextPhase "Bet")
        )
        }
        
        (end 
            (if 
                (or {
                    (= (score P1) 3) 
                    (= (score P2) 3)
                    <Players:endP3>
                }) 
                (byScore)
            )
        ) 
    )
)

Construct a Ludii game based on the following description
The Concentration Game is a game that was played in Benin. The description of the rules are unclear, but it appears to have been the game that was played on a bronze gaming table looted from Benin City. The counters for this game were usually cowrie shells.Three rows of four holes; the central two holes in the middle row are stores. Each player owns the hole in the central row to their left. Ten counters in each hole. Players sow from one of their holes, sowing first into the hole from which the counters were lifted, in an anti-clockwise direction. When the final counter lands in a hole containing two counters, these counters are captured. The player captures like this seven times. The eighth captures happens when the final counter falls into a hole containing one counter; the next capture from a hole containing three; the next from a hole containing five; then repeating the pattern of one, three, five for the rest of the game. The player who captures the most counters wins. The number of counters to have in the hole to capture in the initial captures before the sequence is 2. The number of initial captures before the sequence is 3.
(game "The Concentration Game" 
    (players 2) 
    (equipment { 
        (mancalaBoard 3 "Columns" store:None
            (track "Track" "0,E,N,W,S2" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (union (sites {4}) (sites Bottom)))      
        (regions P2 (union (sites {7}) (sites Top)))      
        (map {(pair P1 5) (pair P2 6)}) 
    }) 
    (rules 
        
        (start {
            (set Count 10 to:(sites Outer))
            (set RememberValue "NumToCaptureP1" <ToCapture:num>)
            (set RememberValue "NumToCaptureP2" <ToCapture:num>)
            (set RememberValue "NumCaptureTwoP1" 0)
            (set RememberValue "NumCaptureTwoP2" 0)
        })
        
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(< 1 (count at:(from)))
                )
                (then 
                    (sow 
                        if:(= (count at:(to)) ("NumCountersToCapture")) 
                        apply:(and
                            (fromTo 
                                (from (to)) 
                                (to (mapEntry (mover))) 
                                count:(count at:(to))
                            )
                            (if	(< (value Player Mover) <Sequence:length>) 
                                ("UpdateNumCaptureTwo")
                                ("UpdateNumToCapture")
                            )
                        )
                        origin:True
                    )
                )
            )		
        )
        
        (end ("MancalaByScoreWhen" (no Moves Next)))
    )
)

Construct a Ludii game based on the following description
Obridje is a two-row mancala-style board game that was played in Ghana and among the Ijaw people of Nigeria in the early twentieth century.2x6 board with two stores. Four counters in each hole. Play may begin from any of the player's holes. Counters are sown anti-clockwise. If the last counter falls into an empty hole or a hole in either row, making that hole contain four counters, play ends, and the four counters are taken. Also, if at any time during the sowing a hole contains four counters, the player on whose row this occurs takes those counters. Otherwise, the player lifts the counters in the hole in which the final counter lands and continues sowing. Play ends when one player can no longer move. The player with the most counters wins. 
(game "Obridje" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (if ("SameTurn") 
                        (sites {(var "Replay")})
                        (sites Mover) 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then
                    (do
                        (set Var "NumSowed" (count at:(last To)))
                        next:(sow
                            apply:(if 
                                (and 
                                    (!= 4 (count at:(to))) 
                                    (< 1 (count at:(to)))
                                ) 
                                (and
                                    (moveAgain)
                                    (set Var "Replay" (to))
                                )
                            )
                        )
                        (then
                            (and
                                (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed")))
                                    (if (= 4 (count at:(site)))
                                        (fromTo
                                            (from (site))
                                            (to (if (is In (to) (sites P1)) (mapEntry P1) (mapEntry P2)))
                                            count:4
                                        )
                                    )
                                )
                                (set Var "NumSowed" 0)
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Next)))
    )
)

Construct a Ludii game based on the following description
Merimeueng-rimueng-do is a game from Sumatra that is similar to other hunt games in South and Southeast Asia. It has been played there at least since the beginning of the twentieth century, but is probably older.One player plays as the tigers (five in number), the other as the sheep (fifteen in number). They take turns placing the pieces on the intersections of the lines. When all of the player's pieces are on the board, the piece may move to any adjacent intersection along the connecting lines. The tiger hops over a sheep to capture it. The goal of the tiger is to capture all of the sheep; the sheep try to prevent all of the tigers from moving. 
(game "Merimueng-rimueng-do" 
    (players 2) 
    (equipment { 
        (board
            (scale 1.4 1 
                (remove
                    (scale 1 2 (wedge 5 6)) 
                    edges:{{0 1} {0 6}}
                    vertices:{24 19}
                )
            )
            use:Vertex
        )
        (hand Each) 
        (piece "Tiger" P1 
            (or {
                ("HopCapture") 
                ("StepToEmpty")
                ("BigHop" 3 (and (!= (row of:(between)) (row of:(from))) ("IsEnemyAt" (between))))
                ("BigHop" 4 ("IsEnemyAt" (between))) 
            })
        ) 
        (piece "Sheep" P2 "StepToEmpty") 
    }) 
    (rules 
        (start {
            (place "Tiger1" (handSite P1) count:5)
            (place "Sheep2" (handSite P2) count:15)
        })
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                ) 
            )
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        ("PhaseMovePiece" "Movement"
            (end ("NoMovesLossAndNoPiecesPlayerLoss" P2))
        )
        }
    )
)

Construct a Ludii game based on the following description
Shatranj is the name of a game played in West and South Asia for centuries. This version was played in the nineteenth and early twentieth century in Punjab, and was played on a board with 14x14 squares.14x14 board. 28 pieces per player. Pieces begin on the board in the following arrangement, and with the following movements: Outer row, from left corner: Rukh: moves orthogonally any distance; Ghora: moves orthogonally one space and then diagonally another space, jumping over the first space; Dahja: moves orthogonally any distance; Ratha: moves orthogonally any distance; Fil: moves diagonally any distance; Shahzada: moves diagonally or orthogonally any distance; Wazir: moves diagonally or orthogonally any distance; Raja: moves one space in any direction; Rani: moves one square in any direction; Fil, Ratha, Dahja, Ghora, Rukh. In the second row are fourteen Paidal: moves one square forward orthogonally or one diagonally to capture. Players alternate turns moving a piece to a space on the board. If one of the opponent's pieces is on the space to which a player moves their piece, the opponent's piece is captured. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot remain in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins.
         
(game "Shatranj (14x14)"
    (players 2) 
    (equipment { 
        (board (square 14)) 
        ("ChessPawn" "Pawn")
        ("ChessRook" "Rook")
        ("ChessRook" "Commoner")
        ("ChessRook" "Wazir")
        ("ChessKing" "King_noCross")
        ("ChessKing" "Mann")
        ("ChessBishop" "Bishop_noCross")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Queen")
        ("ChessQueen" "Amazon")
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 12))
            
            (place "Rook1" {"A1" "N1"}) (place "Knight1" {"B1" "M1"}) (place "Commoner1" {"C1" "L1"}) (place "Wazir1" {"D1" "K1"}) 
            (place "Bishop_noCross1" {"E1" "J1"}) (place "Amazon1" coord:"F1") (place "Queen1" coord:"G1") (place "King_noCross1" coord:"H1") (place "Mann1" coord:"I1") 
            
            (place "Rook2" {"A14" "N14"}) (place "Knight2" {"B14" "M14"}) (place "Commoner2" {"C14" "L14"}) (place "Wazir2" {"D14" "K14"}) 
            (place "Bishop_noCross2" {"E14" "J14"}) (place "Amazon2" coord:"I14") (place "Queen2" coord:"H14") (place "King_noCross2" coord:"G14") (place "Mann2" coord:"F14") 
        })
        
        (play 
            (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
        )
        
        (end ("Checkmate" "King_noCross"))
    )
)

Construct a Ludii game based on the following description
Quoted from the BGG entry: Bug ... is a 2 player combinatorial game where you build shapes on a hexagonal board, which then eat each other. The shapes that survive grow into different, larger shapes until one player runs out of space to grow (and thus wins).The game is played with white and black stones on any hexagonal tiling. The author strongly recommends playing at first on a 'hexhex3' board, and playing on larger boards only after accruing some skill.The game originated in the author's thinking about a cognitive phenomenon called 'perceptual binding', and how it may be used to make combinatorial games more easily understandable to the human mind, given its peculiarities. ...This implementation may differ slightly from the standard rules in exceptional cases, but is based on his confirmation of clarifying questions I asked the author in regards to the intent of the Eating rules.Definitions:
            -- A 'bug' is an entire group of connected, same-color stones on the board. A single stone is also a bug.
            -- The 'size' of a bug is the number of stones it contains.
            -- The 'type' of a bug is its size and shape. Rotating or reflecting the shape of a bug does not affect its type. 
            -- 'Growing' a bug is the creation of a new bug or the enlargement a single bug, using a single stone. (Merger is never allowed.)
            -- 'Eating' is the removal of an adjacent bug of the same type.
            
            Play:
            The board starts empty. 
            Black begins the game by placing one black stone on any empty space. 
            Then, starting with White, the players take turns.
            
            Each turn starts with a required growth, followed by eating and bonus growth in succession until no more bugs are available to eat.
            Bug mergers are never allowed.
            Note! A player who CANNOT move, WINS.
            
            Required growth:
            -- The moving player must place a stone to grow a bug.
            -- This first growth in a turn must not result in a bug that is larger than all the other bugs on the board.
            
            Successive cycles of eating and growth:
            If there are any bugs that can be eaten, a new Eat-and-Bonus-Growth cycle must be taken.
            
            Eating
            -- A bug is chosen to do the eating. 
            -- It must be able to grow after eating.
            -- It must then eat every bug that it can.
            (i.e. all the bugs of the same type that are next to it)
            
            Bonus Growth
            -- The same bug that ate must grow. 
            -- For this bonus growth there is no limit to the size of the bug that results.
            
            If there are still bugs that can be eaten on the board, the cycle repeats.
            If not, the next player's turn starts.
            
            Ending the game:
            If you CANNOT place a stone at the beginning of your turn, you have WON. 
            That is: you win if you’ve filled the ecosystem with your bugs so much you can no longer expand.
            
            The winner receives a point for each position where the other player could still place a stone.
        The more experienced player's score must exceed any handicap agreed at the begining of the game. 3 Hexagon
(game "Bug" 
    (players 2)
    (equipment {
        (board <Board:type> use:Cell)
        (piece "Hex" Each maxValue:1023) 
    })
    (rules
        (play
            (if ("NewTurn")
                (if
                    (> 1 ("SizeLargestBug"))
                    (move Add (to (sites Board)))
                    ("RequiredGrowth" (apply (set Var "Last2Grow" (mover))) (then ("FindWhatThereIsToEat")))
                )
                (if
                    (= 0 (size Array (values Remembered)))
                    ("PlayerChoosesAHungryBug")
                    ("BonusGrowth" (then ("FindWhatThereIsToEat")))
                )
                (then ("Score"))
            )
        )
        (end
            (if
                (and
                    (no Moves Mover)
                    ("NewTurn")
                ) 
                (if
                    (= (var "Last2Grow") (mover))
                    (result Mover Loss)
                )
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Tuz is a two-row mancala-style board game played in the Wallo region of Ethiopia. It is a type of Gabata, which is the name for a variety of this type of game played in the region.2x6 board. Four counters in each hole. Players draw lots to see who goes first. There is a choice of stylised opening move. One player takes a counter from their rightmost hole, then another from the opposite hole in the opponent's row, then proceeding in this fashion in an anti-clockwise direction until the holes alternate with five and three counters, until reaching the hole from which sowing began, which will hold four. The original counter is sown into the next hole in the opponent's row, making four, thus creating a tuz, which behaves as explained below. Alternatively, the player may rearrange the counters in a similar manner, but creating an alternating pattern of holes with three and five counters, and not creating a tuz. After this, players pick up the counters in any of the holes in their row and sow them in an anti-clockwise direction. If the last counter falls into a hole that is occupied, the player picks up the contents of this hole and continues to sow. When the last counter falls into an empty hole, the play ends. Capturing occurs when the last counter falls into a hole on the opponent's side of the board containing three counters, increasing it to four. This hole, a tuz, then belongs to the player who captured it. A player cannot pick up counters from this hole, and the opponent can only do so if the last counter of their sowing falls in the tuz, in which case the opponent takes one counter from it, along with the final counter. The tuz remains in the ownership of the person who captured it. If it remains empty and the opponent drops their last counter into the tuz, the last counter is removed. Play then continues by picking up the contents of another hole and continuing to sow. If a player cannot move, they pass, but the opponent may continue to make moves. The player could then resume play if the opponent's moves create a possibility for a move. Play ends when there are no more counters available to move. Each player owns the counters in their tuz or which they have removed from the board. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, and if each player has two remaining counters ownership is determined by chance. Play continues in several rounds like this until one player takes all the counters. 
(game "Tuz"
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightMost" {(pair P1 5) (pair P2 6)})
    }) 
    (rules 
        (start {
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
            (set Count 4 to:(sites Track)) 
        })
        
        phases:{
        (phase "Opening"
            (play
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {("NextHole" (last From) "TrackCCW" 2)})
                            (union (sites {10}) (intersection (sites Bottom) (sites Right)))
                        )
                    )
                    (then
                        (sow
                            count:1
                            "TrackCCW"
                            apply:(if (not (is In ("NextHole" (from) "TrackCCW" 2) (intersection (sites Bottom) (sites Right))))
                                (moveAgain)
                                (if (= 4 (count at:11)) (set State at:11 (mover)))
                            )
                        )
                    )
                )
            )
            (nextPhase (is In ("NextHole" (last From) "TrackCCW" 2) (intersection (sites Bottom) (sites Right))) "Sowing")
        )
        
        (phase "Sowing" 
            (play
                (or {
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))
                        )
                        (then
                            (sow
                                "TrackCCW"
                                apply:(if (and { 
                                        (= 0 (state at:(to))) 
                                        (= 4 (count at:(to)))
                                        (is In (to) ("OpponentOwnedHoles"))
                                    })
                                    (set State at:(to) (mover))
                                    (if (< 1 (count at:(to)))
                                        (if (= 0 (state at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                            (if (!= (mover) (state at:(to)))
                                                (and
                                                    (fromTo
                                                        (from (to))
                                                        (to (handSite Mover))
                                                        count:(min 2 (count at:(to)))
                                                    )
                                                    (set State at:(to) (state at:(to)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OnlyPiecesInMarked")
                            (and { 
                                (forEach Site ("SitesMarkedBy" 1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site ("SitesMarkedBy" 2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("RightMostEmpty"))
                        count:4
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 4 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 3 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("RightMostEmpty"))
                                                count:3
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("RightMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("RightMostEmpty"))
                                        })
                                        (if (= 2 (count Cell at:(handSite Mover)))
                                            (and {
                                                (fromTo 
                                                    (from (handSite Mover))
                                                    (to ("RightMostEmpty"))
                                                    count:2
                                                )
                                                (fromTo 
                                                    (from (handSite Next))
                                                    (to ("RightMostEmpty"))
                                                    count:2
                                                )
                                                ("RememberOwnedHolesRandom" ("RightMostEmpty"))
                                            })
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        
        }
    )
)

Construct a Ludii game based on the following description
Tsoro is a four-row mancala-style board game played in Zimbabwe. It was popular among men, and had many different regional variations.4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. 6 Holes per row.
(game "Tsoro" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites Top) (sites Bottom))))
        
        (play 
            (move Select
                (from 
                    (if 
                        ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover "Home") 
                    ) 
                    if:(if "AHoleHasMoreThanOneCounter"
                        (> (count at:(from)) 1)
                        (and (= (count at:(from)) 1) (= 0 (count at:("NextHoleFrom" (from) Mover)))) 
                    )
                )
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (= (count at:(to)) 1)
                            (if (is In (to) (sites Mover "Inner"))
                                (if (> (count at:("OppositePit" (to))) 0) 
                                    (and
                                        (remove ("OppositePit" (to))) 
                                        (if 
                                            (> (count at:("OppositeOuterPit" (to))) 0) 
                                            (remove ("OppositeOuterPit" (to))) 
                                        ) 
                                    ) 
                                ) 
                            )
                            (moveAgain)
                        )
                    )
                )
            )
        )
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Baqura is a two-row mancala-style board game reported in the seventeenth century by Thomas Hyde in his De Ludis Orientalibus. He describes the rules and states that it was played in Mesopotamia.2x6 board. Each player has 36 counters which they arrange however they like in their holes. Play begins from any hole in a player's row. Sowing occurs in an anti-clockwise direction. When the last counter falls makes an odd number of counters in the final hole of the sowing, these are picked up and sowing continues. If the last hole is made to be even, these are captured, as well as the contents of the opposite hole. If the previous hole is also even, those counters and those in the opposite hole are also taken, continuing until there is an odd or empty hole. If the final counter falls into an empty hole, play ends. The round ends when one player is unable to move. A new round begins. The player with the smaller number of counters distributes them as they like in their holes. The opponent then copies this arrangement, keeping the surplus of counters. Play continues as before. Rounds are played until one player has no remaining counters. 
(game "Baqura" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start {
            (set Count 36 at:(handSite P1)) 
            (set Count 36 at:(handSite P2)) 
        })
        
        phases:{
        (phase "Placement" 
            (play 
                (move 
                    (from (handSite Mover))
                    (to (sites Mover))
                )
            )
            (nextPhase Mover ("HandEmpty" Mover) "Sowing")
        )
        (phase "Sowing" 
            (play 
                (if (not (all Sites (sites Mover) if:(= 0 (count at:(site)))))
                    (move
                        Select 
                        (from 
                            (if 
                                "SameTurn" 
                                "LastHoleSowed" 
                                (sites Mover) 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then 
                            (sow
                                if:(> (count at:(to)) 1)
                                apply:(if (and (> (count at:(to)) 1) (is Odd (count at:(to))))
                                    (moveAgain)
                                    (and
                                        (if (> (count at:("OppositePitTwoRows" (to))) 0)
                                            (fromTo 
                                                (from ("OppositePitTwoRows" (to))) 
                                                (to (handSite Mover)) 
                                                count:(count at:("OppositePitTwoRows" (to)))
                                            ) 
                                        )
                                        (fromTo 
                                            (from (to)) 
                                            (to (handSite Mover)) 
                                            count:(count at:(to))
                                        ) 
                                    )
                                )
                                backtracking:(and {(is In (to) (sites Mover)) (> (count at:(to)) 1) (is Even (count at:(to))) })
                            )
                        )
                    )
                    (move Pass 
                        (then 
                            (and
                                (forEach Site (sites Next)
                                    (if (is Occupied (site))
                                        (fromTo 
                                            (from (site))
                                            (to (handSite Next))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (if (< ("PiecesOwnedBy" P1) ("PiecesOwnedBy" P2))
                                    (set NextPlayer (player 1))
                                    (set NextPlayer (player 2))
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (was Pass) "PlacementLosingPlayer")
        )
        (phase "PlacementLosingPlayer" 
            (play 
                (move 
                    (from (handSite Mover))
                    (to (sites Mover))
                    (then
                        (if ("HandEmpty" Mover)
                            (forEach Site (sites Mover)
                                (if (is Occupied (site))
                                    (fromTo 
                                        (from Cell (handSite Next))
                                        (to ("OppositePitTwoRows" (site)))
                                        count:(count at:(site))
                                    )
                                )
                            )
                            (moveAgain)
                        )
                    )
                )
            )
            (nextPhase ("HandEmpty" Mover) "Sowing")
        )
        }
        
        (end 
            (forEach Player
                if:(= 0 ("PiecesOwnedBy" Player))
                (result Player Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Backgammon" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" ("BackgammonTracksWithBar" End)) 
        (dice num:2)
        (regions P1 { 20..25 }) 
        (regions P2 { 7..12 }) 
        (map {(pair 1 6) (pair 2 19)}) 
        (piece "Disc" Each ("MoveAPieceIf" "DieNotUsedAndNoEscapeAndNotOffTheTrack" (from))) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) 
            (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5)
            (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) 
            (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (if "AllPieceInHome"
                    (forEach Die 
                        replayDouble:True 
                        if:("DieNotUsed")
                        (forEach Site 
                            (sites Occupied by:Mover)
                            (if ("NotEmptyAndNotOffTheBoard") 
                                (if ("CanEscape")
                                    ("RemoveAPiece")
                                    ("MoveAPiece" (site))
                                )
                            )
                            noMoveYet:(firstMoveOnTrack "Track" Mover
                                (if "HaveAPieceAndCanEscape"
                                    "RemoveAPiece"
                                )
                            )
                            (then ("ReplayNotAllDiceUsed"))
                        )
                    )
                    (max Distance "Track" Mover
                        (if "BarEmpty"
                            (forEach Piece top:True)
                            ("MoveAPieceIf" ("DieNotUsed") ("Bar"))
                            (then 
                                (if (not (all DiceUsed))
                                    (if (can Move 
                                            (if "BarEmpty"
                                                (forEach Piece top:True)
                                                ("MoveAPieceIf" ("DieNotUsed") ("Bar"))
                                            )
                                        )
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (result Mover Win)
            )
        )
    )
)
Backgammon as it is known today seems to have been invented around the seventeenth century, but the games from which it developed are much older. The origins of these games lie sometime in the early centuries CE, and it is related to the Persian game Nard. Other related games such as Tric-Trac and Tables were also been played on the same board in medieval and early modern Europe.The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, number the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces Play begins by each player rolling one die; the player with the highest roll plays first and plays the numbers on this first roll. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. 

Describe the mechanics of the following Ludii game
(game "Chinese Checkers"
    (players <Players:num>) 
    (equipment { 
        (board (hex Star ("Dim")))
        (piece "Marker" Each) 
        <Players:home>
    }) 
    (rules 
        <Players:start>
        
        phases:{
        (phase "Movement" 
            (play 
                (forEach Piece 
                    (or 
                        ("HopSequence" (from)) 
                        (move Step
                            (to 
                                if:(and
                                    (is Empty (to))
                                    (or
                                        (not ("FromIsOnTheRegionToFill" (from)))
                                        ("ToIsOnTheRegionToFill" (to))
                                    )
                                )
                            )
                        )
                    )
                )
            ) 
            (nextPhase (is Mover (next)) "MultiJump")
        ) 
        (phase "MultiJump" (play 
                (or 
                    ("HopSequence" (last To)) 
                    (move Pass)
                )
            ) 
            (nextPhase (not (is Mover (next))) "Movement")
        ) 
        }
        
        (end ("FillWin" (sites (player (mapEntry (mover))))))
    )
)
Chinese Checkers, originally known as \The game can be played by two, three, four, or six people. It is played on a board that is shaped like a six-pointed star with 121 holes for the pieces. Each point of the star has ten colored spheres and the goal of the game is to move all of one's pieces into the opposite point of the star. Players can move a piece to one adjacent hole, or can jump either their own or opponent's pieces. This does not result in capturing, and jumping is not mandatory. When fewer than six people play, players can play with only one color of pieces, but if two or three people play they can use more than one color, but each player must use an equal number of pieces. Two players occupy home regions on opposite sides, four home regions are empty. The game is played on a board of size 1.

Construct a Ludii game based on the following description
Dama is the name of a game with leaping captures played in several parts of the world. This version is played in Comoros.8x8 board. 16 pieces per player, lined up in the second and third rows (first row on each side is empty). Pieces move forward or horizontally one space, and capture opponents' pieces by jumping in these directions. When they reach the opposite side, they become a king and can jump opponents' pieces from any distance orthogonally. Multiple captures cannot be made by moving 180 degrees from the previous jump. Pieces can be promoted to king mid-jump. Winning is achieved by capturing all of the other player's pieces or by blocking them so they cannot move.
         
(game "Dama (Comoros)" 
    (players 2) 
    ("DraughtsEquipment" (square 8))
    (rules 
        (start { 
            (place "Counter1" (union (sites Row 1) (sites Row 2)))
            (place "Counter2" (union (sites Row 5) (sites Row 6)))
        })
        
        (play 
            (if "SameTurn"
                (or
                    (if "IsUnpromoted"
                        ("HopMan" (last To)
                            (then 
                                ("ReplayIfCanMove" ("HopMan" (last To)) 
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                        ("PromotedHopOrthogonalSequenceCapture" (from (last To)) (difference Orthogonal OppositeDirection))
                    )
                    (move Pass)
                )
                (or { 
                    (forEach Piece "Counter" 
                        ("HopMan" (from)
                            (then 
                                ("ReplayIfCanMove" ("HopMan" (last To))
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        ) 
                    )
                    (forEach Piece "DoubleCounter" ("PromotedHopOrthogonalSequenceCapture" (from) Orthogonal))
                    (forEach Piece "Counter" 
                        ("StepToEmpty" (directions {Forward Rightward Leftward}))
                        (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                    )
                    (forEach Piece "DoubleCounter" (move Slide Orthogonal))
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Demala Diviyan Keliya is a hunt game known by many names played throughout South Asia, and documented since the early twentieth century.Played with three \ Played on the normal board.
(game "Demala Diviyan Keliya" 
    (players 2) 
    (equipment { 
        (board <Board:type> use:Vertex)
        (hand P2) 
        (piece "Tiger" P1 (or "HopCapture" "StepToEmpty")) 
        (piece "Dog" P2 "StepToEmpty") 
    }) 
    (rules 
        (start {
            (place "Tiger1" <Board:initTiger>)
            (place "Dog2" (handSite P2) count:15)
        })
        
        phases:{ 
        (phase "Placement" P2 
            (play 
                (move 
                    (from (handSite P2)) 
                    (to (sites Empty))
                )
            ) 
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement"
            (end ("NoMovesLossAndLessNumPiecesPlayerLoss" P2 7))
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Abrobad" 
    (players 2)
    (equipment {
        (board (hex Limping <Board:size>))
        (piece "Hex" Each)
    })
    (rules 
        (play
            (priority 
                (move Add 
                    (to 
                        (sites Empty)
                        if:(= 0 (count Sites in:(sites Around (to) Own)))
                    ) 
                ) 
                (or
                    <Movement:type>
                    (move Propose "Conclude"
                        (then
                            (if 
                                (is Proposed "Conclude")
                                (add 
                                    (piece (next)) 
                                    (to (sites Empty)) 
                                    (then 
                                        (and 
                                            (set Score Mover (count Groups if:(= (who at:(to)) (mover)))) 
                                            (set Score Next (count Groups if:(= (who at:(to)) (next))))
                                        )
                                    )
                                )
                            )
                        )
                    )
                ) 
            )  
        ) 
        (end 
            (if 
                (is Proposed "Conclude") 
                (if 
                    (<= (score Mover) (score Next))
                    (result Mover Win)
                )
                (result Next Win)
            )
        )
    )
)
Abrobad is arabic, for \Goal: 
            You try to both reduce the number of your own groups as much as possible, and also to block your opponent's ability to reduce his groups down to fewer than yours. Whoever decides to end the game must fill the empty spaces with opponent's pieces, and only then, wins by having equal or fewer groups.
            
            Play:
            Starting with the board empty, player's take turns placing a piece of their color on an empty position that does not abut any friendly piece. If it is impossible to place a piece, the player, instead, moves a piece to the first empty position in any direction. But whenever a new opportunity for placement is available, the turn must be used for placement.
            
            Ending the Game:
            
            The game ends at the choice of the player about to move, but only at the beginning of a turn in which there is no forced placement. 
            
            Before scoring, the empty spaces are filled with the opponent's pieces. The player who ended the game wins unless the opponent has fewer groups. Because the empty spaces are filled with opponent's pieces, a player who ends the game too soon will lose. On the other hand, since ties go to the player who ends the game, it is important to end the game as soon as you can actually win.
            
            Variations: 
        Options are available to select the board size, and also to use other movement rules, instead of the standard one. Board & size: Hexhex with edges alternately 2 and 3 Movement: Pieces step or jump once, to the first empty position in that direction.

Construct a Ludii game based on the following description
Ngolo is a four-row mancala-style board game played in the Democratic Republic of Congo.4x9 board. Two counters in each hole. Players alternate turns sowing from one of the holes in their rows in an anti-clockwise direction. When a counter falls into a hole in their inner row, the player captures the counters from both of the opposite holes on the opponent's side of the board; if one of the two opposite holes is empty, no capture is made. Captures counters are sown on the player's side of the board. Play continues until one player captures all of the counters or one player forfeits. 
(game "Ngolo" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "18,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))
        )
        
        (play 
            (or 
                (move Pass) 
                (move Select
                    (from 
                        (sites Mover "Home") 
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (and {
                                    (!= (count at:("OppositeOuterPit" (to))) 0) 
                                    (!= (count at:("OppositePit" (to))) 0) 
                                    (is In (to) (sites Mover "Inner"))
                                })
                                (and {
                                    (fromTo 
                                        (from ("OppositeOuterPit" (to))) 
                                        (to (to)) 
                                        count:(count at:("OppositeOuterPit" (to)))
                                    )
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (to)) 
                                        count:(count at:("OppositePit" (to)))
                                    )
                                    (sow 
                                        (to)
                                        count:(+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))))
                                        "Track"
                                        owner:(mover)
                                    )
                                    }
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end {
            (if ("NoPieceNext")
                (result Mover Win)
            )
            (if (was Pass)
                (result Next Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Njombwa is a four-row mancala-style board game played by the Yao people in East Africa. In this version, the game starts with two counters in each hole.4x8 board, occasionally 4x9 or 10. Two counters in each hole, except the leftmost hole in the inner row, which has zero, and the hole to its right, which has one. Sowing occurs in an anti-clockwise direction. Players sow from any hole in their two rows. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opponent's opposite hole in their inner row are captured. If there are also counters in the opponent's opposite hole in the outer row, these are also captured, but only when a capture from the inner row was also made. Players cannot sow single counters, unless there are no holes with multiple counters left, in which case single counters may be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. Each row has 8 holes.
(game "Njombwa (Two Counters)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start {
            (set Count 2 to:(difference (sites Board) (sites {<Row:size> (+ 1 <Row:size>) (- (* <Row:size> 3) 1) (- (* <Row:size> 3) 2)}))) 
            (set Count 1 to:(sites {(+ <Row:size> 1) (- (* <Row:size> 3) 2)})) 
        })
        
        (play
            (if ("AllSitesNoMoreThanOne")
                (move Select
                    (from (sites Mover "Home") if:(and (is Occupied (from)) (is Empty ("NextHole" (from) 1))))
                    (then 
                        (sow
                            "Track"
                            owner:(mover)		
                        )
                    )
                )
                (move Select
                    (from 
                        (if ("SameTurn") 
                            "LastHoleSowed"
                            (sites Mover "Home") 
                        ) 
                        if:(> (count at:(from)) 1)
                    )
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                                (if (and 
                                        (is In (to) (sites Mover "Inner"))
                                        (is Occupied ("OppositePit" (to)))
                                    )
                                    (and
                                        (remove ("OppositePit" (to)))
                                        (if (is Occupied ("OppositeOuterPit" (to)))
                                            (remove ("OppositeOuterPit" (to)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )		
        )
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Ratti-Chitti-Bakri is a game with leaping captures played in India. Each player controls forty pieces on a 9x9 board. It is played in a similar way to several other games in South, Southeast, and West Asia.9x9 board played on the intersections, with diagonals for each 3x3 square. Forty pieces per player, one playing as white, the other as red, arranged on opposite sides of the board, each player's pieces taking up the first through fourth ranks of spaces, plus their right half of the fifth rank. The central spot remains empty. Players alternate turns by moving a piece to an adjacent empty spot along the lines on the board. A player may capture an opponent's piece by hopping over one adjacent piece if there is an empty spot behind it along a line on the board. The player who captures all of the opponent's pieces wins. 
(game "Ratti-Chitti-Bakri" 
    (players 2)
    (equipment { 
        ("AlquerqueBoard" 9 9)
        (piece "Marker" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    
    (rules 
        ("BeforeAfterCentreSetup" "Marker1" "Marker2")
        
        (play (forEach Piece))
        
        (end ("ForEachPlayerNoPiecesLoss"))
    )
)

Construct a Ludii game based on the following description
Es-Sîg is a race game played by women in Tunisia. It is one of a family of games where players attempt to reach Mecca, before the Ghoula, or witch, carries them back to start. The pieces are usually the women's wedding rings, and the Ghula is represented by a piece of coal.7x7 board, with an extra square above the top left square of the grid. One piece per player. Four sticks, with one green side and one white side, used as dice. The throws are as follows: one white and three green = sîg, valued at 1; two white and two green = 0; three white and one green = 3; four white = 4; four green=6. Pieces begin off the board, moving onto the bottom right square, and proceed in a boustrophedon direction, moving upward in the rightmost column, then down the next to the left, until reaching the extra space in the top left of the board. A player must first throw sîg to begin moving. Players move according to the values of the throws. If a player lands on the top right square, they must throw sîg five times to escape it. If a player lands on the central square, they must throw sîg ten times to escape it. A player must also throw one sîg to escape each of the final three spaces. Once a player has escaped the final space, they control the Ghula. The Ghula has different values for the throws: one white = 2; two white = 5; three white = 0; four white = 4; four green =6. The ghula moves in the opposite direction of the pieces, and when it overcomes one of the opponent's pieces it drags them in the direction it moves, with the goal of dragging them to the start. The Ghula may move forward or backward on its turn along the track. The Ghula does not have to throw a sîg to escape any spaces. Play continues until all of the players escape the final space. The game has 2 players.
(game "Es-Sig"
    (players <Player:num>)
    (equipment {
        (board 
            (merge {
                (rectangle 8 1)
                (square 7)
                (shift 8 0 (square 1))
            })
            {
            (track "Track" "50,19,W,N1,E,N1,W,N1,E,N1,W,N1,E,N1,W4" directed:True)
            (track "ExtensionTrack" "45,W,N" directed:True)
            (track "GhoulaTrack" "19,W,N1,E,N1,W,N1,E,N1,W,N1,E,N1,W" directed:True)
            (track "ReverseGhoulaTrack" "50,12,E,S1,W,S1,E,S1,W,S1,E,S1,W,S1,E" directed:True)
            }
        )
        (piece "Ghoula" Neutral)
        (piece "Stick" Each
            (if (= (from) ("TopRightSquare"))
                (if (= (state at:(from) level:(level)) 6)
                    (move 
                        (from (from) level:(level))
                        (to ("NextTopRightSquare"))
                        (then
                            (forEach Level (last To)
                                (set State at:(last To) level:(level) 0)
                            )
                        )
                    )
                    (if ("Sig")
                        (move Select
                            (from (from) level:(level))
                            (then 
                                (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo))))
                            )
                        )
                    )
                )
                (if (= (from) ("CentralSquare"))
                    (if (= (state at:(from) level:(level)) 11)
                        (move 
                            (from (from) level:(level))
                            (to ("NextCentralSquare"))
                            (then
                                (forEach Level (last To)
                                    (set State at:(last To) level:(level) 0)
                                )
                            )
                        )
                        (if ("Sig")
                            (move Select
                                (from (from) level:(level))
                                (then 
                                    (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo))))
                                )
                            )
                        )
                    )
                    (if (and (!= (from) ("BegginingFinalTrack")) (is In (from) (sites Track "Track")))
                        (move
                            (from (from) level:(level)
                                if:(if ("ActivatedPiece" (from) (level))
                                    True
                                    ("Sig")
                                )
                            )
                            (to
                                ("SiteToMoveOnTrack" "Track" ("ThrowValue"))
                                if:True
                            )
                            (then
                                (if (not ("ActivatedPiece" (last To) (topLevel at:(last To))))
                                    ("ActivePiece" (last To) (topLevel at:(last To)))
                                )
                            )
                        )
                        (if (is In (from) (sites Track "ExtensionTrack"))
                            (or {
                                (if (and (!= (from) ("FinalSite")) ("Sig"))
                                    (move
                                        (from (from) level:(level))
                                        (to ("SiteToMoveOnTrack" "ExtensionTrack" 1))
                                    )
                                )
                                (if (= (from) ("FinalSite"))
                                    (move Pass
                                        (then
                                            (if (!= 1 (count Pips))
                                                (and
                                                    (moveAgain)
                                                    (set Var 1)
                                                )
                                            )
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
                (then
                    (if (and (= (last To) ("FinalSite")) (!= (last From) ("FinalSite")))
                        (if (!= Undefined (var "ScoreToGet"))
                            (and
                                (set Score Mover (- (var "ScoreToGet") 1))
                                (set Var "ScoreToGet" (- (var "ScoreToGet") 1))
                            )
                            (and
                                (set Score Mover (count Players))
                                (set Var "ScoreToGet" (count Players))
                            )
                        )
                    )
                )
            )
            maxState:12
        )
        ("StickDice" 4)
        (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)})
        (map "ThrowGhoula" {(pair 0 4) (pair 1 6) (pair 2 4) (pair 3 2) (pair 4 6)})
    })
    (rules 
        (start <Player:start>)
        (play 
            ("RollMove"
                (if (> (var) 0)
                    ("MoveGhoula")
                    (if (or (= (where "Stick" Mover) ("FinalSite")) (!= 0 ("ThrowValue"))) (forEach Piece))
                )
            )
        )
        (end {
            (forEach Player
                if:(no Pieces Player) 
                (result Player Loss)
            )
            (if ("GhoulaPhaseDone")
                (byScore)
            )
        })
    )
)

Construct a Ludii game based on the following description
Tama is a game with leaping captures played in Armenia. It allows both orthogonal and diagonal movement, and was played on a checkered board. Played on an 8x8 board. 16 pieces per player, lined up in the second and third rows. A piece can move forwards, straight ahead or diagonally, or sideways to an orthogonally adjacent field if that field is empty, and capture opponents' pieces by jumping left, right, or forwards. When they reach the opposite side, they become a king, which may move in all directions (up, down, left, right, or diagonally), as long as the path is clear of pieces, and can jump opponents' pieces from any distance orthogonally. Captures must be taken if possible, and the maximum number of jumps must be made. Multiple captures cannot be made by moving 180 degrees from the previous jump. Pieces can be promoted to king mid-jump. Winning is achieved by capturing all of the other player's pieces or by blocking them so they cannot move. The rules come from Schmidt.
(game "Tama" 
    (players 2) 
    ("DraughtsEquipment" (square 8))
    (rules 
        (start { 
            (place "Counter1" (union (sites Row 1) (sites Row 2)))
            (place "Counter2" (union (sites Row 5) (sites Row 6)))
        })
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves
                        ("HopMan" (last To)
                            (then 
                                ("ReplayIfCanMove" ("HopMan" (last To))
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                    )
                    (max Moves ("PromotedHopOrthogonalSequenceCapture" (from (last To)) (difference Orthogonal OppositeDirection)))
                )
                (priority {
                    (max Moves
                        (or { 
                            (forEach Piece "Counter" 
                                ("HopMan" (from)
                                    (then 
                                        ("ReplayIfCanMove" ("HopMan" (last To))
                                            ("PromoteIfReach" (sites Next) "DoubleCounter")
                                        ) 
                                    ) 
                                ) 
                            )
                            (forEach Piece "DoubleCounter" ("PromotedHopOrthogonalSequenceCapture" (from) Orthogonal))
                        })
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {Forwards Rightward Leftward}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" <Variant:promotedMove>)
                    )
                })
            )
        ) 
        
        <Variant:endRule> 
    )
)

Construct a Ludii game based on the following description
Brood is a polyhex-matching game for two players – Black and White – played on an initially empty hexhex board. Michael Amundsen invented Brood in May 2022.Definitions:
            1 A group is a stone along with all stones one can reach from it through a series of steps onto adjacent stones of the same color.
            1.1 The size of a group is the number of stones in it.
            
            2 A brood is a group along with all other groups of identical color, size and shape. Shapes are considered identical across symmetries (just like in Bug).
            2.1 The size of a brood is the number of groups in it.
            2.2 The order of a brood is the size of the groups in it.
            2.3 The mass of a brood is the number of stones in it (its size times its order).
            
            Play:
            On the very first turn of the game, Black places one stone of their colour on any hex.
            After, that – starting with White – take turns doing one of the following:
            - Pass.
            - Place two stones of your colour on empty hexes.
            
            When the players pass consecutively, the winner is the player with the higher score.
            
            Scoring:
            For each of your broods, you score its mass multiplied by the lesser of its size and its order.
            
        For example, if a brood consists of 2 groups of size 3, it is worth 12 points. Its order is 3, its size is 2 and its mass is 6. Since 2 is smaller than 3, the brood is worth 6*2 = 12. A boad of size 4 is currently selected. Nothing is currently printed on the pieces. The 12* placement protocol is currently in effect. This is the protocol described in the rules above.
(game "Brood" 
    (players 2)
    (equipment {
        (board <Board:size> use:Cell)
        (piece "Hex" Each maxState:7 maxValue:1023) 
        (piece "Disc" Neutral)
        (hand Shared)
    })
    (rules
        <Protocol:pie>
        <Protocol:setup>
        (play
            <Protocol:protocol>
        )
        (end
            (if <Protocol:endCondition>
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
A chess variant invented by László Polgár. played on a board made of hexagons.Starchess is played on a star-shaped hexagonal board that can be thought of as a hexagon-shaped board with each side having length 6, but with four spaces removed from each corner. The board has 37 spaces.
            
            Starchess starts off with the non-Pawn pieces being placed behind the Pawns. This happens one piece at a time, in alternating turns, until all non-Pawn pieces have been placed. Then the 'movement phase' of the game begins as usual.
            
            Piece Movement:
            * Knights move as in Glinsky Chess.
            - They move two spaces in any adjacent direction, then one space in another direction.
            * Kings can move one space in any of those same six adjacent directions. There is no castling.
            * Queens can slide in any of the six adjacent directions from their current space---North, South, or 60 degrees off either of those.
            * Rooks can slide forward or backward only in their given column.
            * Bishops can slide in only four of the adjacent directions: they cannot slide North or South.
            * Pawns can advance one space forward without capturing. A Pawn on a Pawn start space can advance two spaces forward, even if it has previously moved (by capturing) to a different Pawn start space than it started the game on. Pawns capture by moving to one of the two adjacent spaces 60 degrees left or right of forward. On reaching the farthest rank in any of the innermost five columns, Pawns are promoted to a Queen, Rook, Bishop, or Knight, as the player chooses.
            
            The game ends on a checkmate or stalemate.
            
        Some terminology: a Pawn off to the side, in one of the two spaces at the extremes of the middle row is called a 'mummy', while a Pawn in one of the spaces adjacent to that is called a 'dead Pawn'. Mummies and dead Pawns cannot be promoted until they return to one of the innermost five columns. 
(game "Starchess"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board (rotate 30 (hex Star 2)))
        
        (piece "King" Each ("KingCaptureStep" Orthogonal ~))
        (piece "Queen" Each ("SlideCaptureMove" Orthogonal ~))
        (piece "Rook" Each ("SlideCaptureMove" (directions {N S}) ~))
        (piece "Bishop" Each
            ("SlideCaptureMove" (directions {WNW ENE WSW ESE}) ~)
        )
        ("ChessKnight" "Knight" (then (set Counter)))
        
        (piece "Pawn" Each
            (or {
                "StepForwardToEmpty"
                (if "IsFromInStartCell" "PawnStep_Double")
                "PawnCapture_Ortho"
                "EnPassant_Ortho"
                }
                (then
                    (and
                        (if (is In (last To) (sites Mover "PromotionZone"))
                            (moveAgain)
                        )
                        (set Counter)
                    )
                )
            )
        )
        
        (hand Each size:5)
        
        (regions "Home" P1 (sites {"A3" "B3" "C3" "C2" "C1"}))
        (regions "Home" P2 (sites {"G9" "G8" "G7" "H7" "I7"}))
        
        (regions "PromotionZone" P1 (sites P2 "Home"))
        (regions "PromotionZone" P2 (sites P1 "Home"))
        
        (regions "Region-Dark" (sites Phase 1))
        (regions "Region-Light" (sites Phase 2))
        (regions "Region-Medium" (sites Phase 0))
    })
    
    (rules
        (start {
            (place "King" "Hand" count:1)
            (place "Queen" "Hand" count:1)
            (place "Rook" "Hand" count:1)
            (place "Bishop" "Hand" count:1)
            (place "Knight" "Hand" count:1)
            
            (place "Pawn1" {"B4" "C4" "D4" "D3" "D2"})
            (place "Pawn2" {"F8" "F7" "F6" "G6" "H6"})
        })
        phases:{
        (phase "Placement"
            (play
                (move
                    (from (sites Occupied by:Mover container:(mover)))
                    (to (intersection (sites Mover "Home") (sites Empty)))
                )
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        (phase "Movement"
            (play
                (if ("SameTurn")
                    ("PromoteTo" (piece {"Queen" "Rook" "Bishop" "Knight"}))
                    (do (forEach Piece)
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
            )
            (end {
                ("Checkmate" "King")
                (if (or
                        (no Moves Mover)
                        (= (counter) 100)
                    )
                    (result Mover Draw)
                )
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Kaua Dorki (\Two isosceles triangles, which meet at the apices with the height of each triangle drawn and a line perpendicular to it in each triangle at its midpoint intersecting with the sides. Another line, bisected by the point where the spices of the triangles meet, with a shot line extending down on either end of the line, and a matching short line next to it at either end. Eight pieces per player, lined up with six on the two rows of the triangle closest to the player and two on the ends of the short lines to the left of the player. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece can capture an opponent's piece by hopping over it to an empty adjacent point immediately on the opposite side of the opponent's piece along the lines on the board. The player who captures all of the opponent's pieces wins. 
(game "Kaua Dorki" 
    (players 2) 
    (equipment { 
        (board
            (merge {
                (scale 1 2 (wedge 3))
                (shift 0 4 (rotate 180 (scale 1 2 (wedge 3))))
                (shift 0 4 (rectangle 1 5))
            })
            use:Vertex
        )
        (piece "Marker" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    (rules 
        (start {
            (place "Marker1" (expand (union (sites Bottom) (sites {"A3"}))))
            (place "Marker2" (expand (union (sites Top) (sites {"E3"}))))
        })
        
        (play (forEach Piece))
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Bis Gutiya is a game with leaping captures played in the Bihar region of India. 5x5 intersecting lines, with diagonals in each square formed by the lines. Twenty pieces per player, which each player places on the points on their side of the board, as well as the two points to the left of the central space. The central spot remains empty. Players alternate turns by moving a piece to an adjacent empty spot along the lines on the board. A player may capture an opponent's piece by hopping over one adjacent piece if there is an empty spot behind it along a line on the board. The player who captures all of the opponent's pieces wins. 
(game "Bis Gutiya" 
    (players 2)
    (equipment { 
        (board (square 5 diagonals:Solid) use:Vertex)
        (piece "Marker" Each 
            (or
                ("StepToEmpty") 
                ("HopCapture") 
            )
        )
    }) 
    
    (rules 
        ("BeforeAfterCentreSetup" "Marker1" "Marker2")
        (play (forEach Piece)) 
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
Hasami Shogi is a simplified version of Shogi, a Japanese game which is ultimately related to the Indian game Chaturanga. It is played only with the pawns on a 9x9 Shogi board.Play begins with the pieces arranged in the last row of squares on opposite sides of the board. Pieces move as rooks in Chess. An opponent's piece is captured by surrounding it on two opposite sides by a player's piece. Play continues until all but one player's pieces are captured. 
(game "Hasami Shogi" 
    (players 2) 
    
    (equipment { 
        (board (square 9))
        (piece "Fuhyo" P1 (move Slide Orthogonal (then (or ("CustodialCapture" Orthogonal (max 1)) "SurroundCaptures"))))
        (piece "Tokin" P2 (move Slide Orthogonal (then (or ("CustodialCapture" Orthogonal (max 1)) "SurroundCaptures"))))
    })
    
    (rules 
        (start { 
            (place "Fuhyo1" (sites Bottom))
            (place "Tokin2" (sites Top))
        })
        
        (play (forEach Piece))
        
        (end (if (= (count Pieces Next) 1) (result Mover Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Ja-Jeon-Geo-Gonu" 
    (players 2) 
    (equipment { 
        (board (square 4)
            {
            (track "Track1" {14 14 11 10 9 8 8 13 9 5 1 1 4 5 6 7 7 2 6 10} loop:True directed:True)
            (track "Track2" {11 11 14 10 6 2 2 7 6 5 4 4 1 5 9 13 13 8 9 10} loop:True directed:True)
            }	
            use:Vertex
        )
        (piece "Disc" Each  
            (or {
                ("StepToEmpty" Orthogonal)
                ("SlideToCapture") 
            }) 
        )
    }) 
    (rules 
        (start { <Start> })
        (play (forEach Piece)) 
        (end ("CaptureAll" Next))
    )
)
Ja-Jeon-Geo-Gonu is a Korean game of uncertain history.Played on a board similar to Surakarta, but smaller. Players begin with four pieces, arranged in the square of spaces in their bottom right corner. Players take turns moving a piece to one adjacent spot. To capture an opponent's piece, you must move along the curved loops. The spot at the immediate end of the loop must be empty, but the piece may continue as far as the player wishes, including moving along successive loops, or until they make a capture or are stopped by their own piece. The pieces are placed in the corners.

Construct a Ludii game based on the following description
Monkey Queen is a two player game, played on a 12x12 checkboard.The two players take turns moving stacks of their own color (including singletons - stacks of height one), one stack per turn.  Players will always have a move available and must make one.
            
            OBJECT OF THE GAME: Kill the enemy queen, or deprive your opponent of moves. 
            
            The pie rule is used in Monkey Queen. 
            
            Each player will always have exactly one queen monkey on the board which is a stack of two or more checkers all of the player's own color.  Additionally, each player may have one or more baby monkeys on the board which are singletons of his own color.
            
            CAPTURING QUEEN MOVES - A monkey queen captures exactly like a Chess queen.  Slide the entire stack in any direction (horizontally, vertically or diagonally) along a straight sequence of unoccupied squares terminated by an enemy occupied square, and capture the enemy queen or baby by replacement.
            
            NOTE: A queen may not give birth to its own baby and kill an enemy baby in the same move.
            
            NOTE: A queen of height two may not make a non-capturing move.
            
            NON-CAPTURING QUEEN MOVES - When not capturing, a queen moves any distance in any one direction, exactly like a Chess queen, except it leaves its bottom checker behind on the originating square, reducing the stack height by one.  The queen monkey has thus given birth to a baby monkey.
            
            CAPTURING BABY MOVES - A monkey baby, like a monkey queen, captures exactly like a Chess queen.  Slide the baby (singleton) in any direction along a straight sequence of unoccupied squares terminated by an enemy occupied square, and capture the enemy queen or baby by replacement.
            
            NON-CAPTURING BABY MOVES - When not capturing, a baby must move toward the enemy queen in the following sense:  The straight line distance between your baby and the enemy queen must be shortened by your move.
            
        NOTE: There's no requirement to make a kill in Monkey Queen.  
(game "Monkey Queen"
    (players 2)
    (equipment {
        (board (square 12))
        (piece "Marker"
            (or {
                (move Slide
                    (to 
                        if:("IsEnemyAt" (to)) 
                        (apply 
                            if:("IsEnemyAt" (to))
                            (remove (to) count:(size Stack at:(to)))
                        )
                    )
                    stack:True
                    (then
                        (if (< 1 (size Stack at:(last To)))
                            (set Value Mover (last To))
                        )
                    )
                )
                (if (< 2 (size Stack at:(from))) 
                    (move Slide
                        stack:True
                        (then
                            (and
                                (fromTo
                                    (from (last To) level:0)
                                    (to (last From))
                                )
                                (set Value Mover (last To))
                            )
                        )
                    )
                )
                (if (= 1 (size Stack at:(from))) 
                    (move Slide
                        (between 
                            if:(and
                                (< (count Steps (to) (value Player Next)) (count Steps (from) (value Player Next)))
                                (is Empty (between))
                            )
                        )
                    )
                )
            })
        )
    })
    (rules
        (meta (swap))
        (start {
            (place Stack "Marker1" 6 count:20)
            (place Stack "Marker2" 137 count:20)
        })
        (play (forEach Piece top:True))
        (end 
            (if 
                (or
                    (all Sites (sites Occupied by:Next) if:(= 1 (size Stack at:(site))))
                    (no Moves Next) 
                )
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Tic-Tac-Four is a Tic-Tac-Toe variant invented by Matthew Stephenson for Ludii.The same rules as Tic-Tac-Toe are used with four players in a 5x5 board. The third and fourth players play with \ 
(game "Tic-Tac-Four" 
    (players 4) 
    (equipment { 
        (board (square 5)) 
        (piece "Disc" P1) 
        (piece "Cross" P2) 
        (piece "Y" P3) 
        (piece "Z" P4) 
    }) 
    (rules 
        (play (move Add (to (sites Empty))))
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
A version of Chess for 4 players.A version with 8 players is also available as an option.Once a player is checkmated their king is removed, but all their other pieces remain on the board as neutral obstacles. Neutral pieces cannot help checkmate other players. If a player cannot make a move when there are more than two players remaining, they skip their turn rather than giving a stalemate. Four Players.
(game "Four-Player Chess" 
    (players <NumOfPlayers:NumPlayers>) 
    (equipment { 
        (board 
            <NumOfPlayers:BoardShape>
        ) 
        
        ("ChessPawn" "Pawn"
            (or 
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
                )
                "EnPassant"
            )
            (then
                (and
                    (if (is In (last To) (sites Mover "Promotion")) 
                        (moveAgain)
                    )
                    (set Counter)
                )
            )
        )
        
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        <NumOfPlayers:BoardRegions>
    }) 
    (rules 
        (start { 
            <NumOfPlayers:PieceSetup>
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        (if (and 
                                ("HasNeverMoved" "King")
                                (not ("IsInCheck" "King" Mover)) 
                            )
                            (or {
                                (if (and 
                                        ("HasNeverMoved" "RookLeft")
                                        (can Move ("CastleRook" "RookLeft" E 3 (is Empty (to))))
                                    )
                                    "BigCastlingHor"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookRight")
                                        (can Move ("CastleRook" "RookRight" W 2 (is Empty (to))))
                                    )
                                    "SmallCastlingHor"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookLeft")
                                        (can Move ("CastleRook" "RookLeft" S 3 (is Empty (to))))
                                    )
                                    "BigCastlingVer"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookRight")
                                        (can Move ("CastleRook" "RookRight" N 2 (is Empty (to))))
                                    )
                                    "SmallCastlingVer"
                                )
                            })
                        )
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
                (then
                    <NumOfPlayers:CheckMate>
                )
            )
        )
        
        (end {
            (forEach NonMover
                if:("IsOffBoard" (where "King" Player)) 
                (result Player Loss)
            )
            (if (and (<= (count Active) 2) (or (no Moves Mover) (= (counter) (* 50 (count Active))))) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
N-Mesh is a game on a square grid that evolved from Netted, an enclosure game on a hex grid.       The game is a race to deprive the opponent of liberties by surrounding the opponent's stones and or by destroying the liberties by placing stones on them.       If the players surround each other, the player with fewer captured stones wins, and where the result is still undetermined, the last to play loses. This latter rule prevents players from simply racing to cover up the liberties.  -------------   The main differences from Netted is that life in N-Mesh requires only a single liberty for a region, and the liberties are specific cells distributed across the board. (Netted liberties were the edge cells and each stone required its own exclusive liberty)    The difference in geometry also causes differences in connectivity:    Both feature 3 types of connectivity used strategically to separate the opponent's stones from liberties.    These include adjacency, as well as a short type of connection that can permanently cross the other player's connections and a longer type of connection that can be broken.    In N-Mesh the long connections are at knight's move distance, and are broken by a pair of stones placed in between, and the crossing connections are diagonals.-------------      Surrounding is done by nets. A net is made of adjacent stones as well as stones connected by diagonals and single empty spaces. Thus opponent's nets can cross each other and a portion of a net may be surrounded without surrounding the whole net. Having a connection to a living stone does not guarantee life to another stone: what provides life to a stone is having an empty liberty cell in the same region defined by the opponent's surrounding net.             Offensive tactics include:    - Threatening to capture over-extended pieces,     -- especially to pick off a single stone in diagonal-plus-double-knight's-move triangle,    -- covering liberties in uncontrolled areas to capture a larger group or to make group life harder to achieve,    -- or by creating forks.        - Using knight's moves to quickly fence off large territory.     -- enclosing more liberties and spaces to place on so that ones groups can survive longest    - Reinforcing threatened knight's connections by adding a stone there.        Defensive tactics include: Blocking threats by     - breaking a knight's move connection by extending a line of stones across it.     - placing on the site the opponent needs to complete the threat,    - encircling the threat location, or for edges sites,     - reducing the cut-off region to one empty edge site.        Notes:     -- Spacing of the liberties is arbitrary, but has been standardized to a regular spacing that can work on small and large boards, in order to allow the transfer of tactical knowledge from size to size.    -- The distribution is purposefully asymmetrical to allow the greatest variety of pie offerings.     -- If the game is to be played without a pie rule, a symmetrical arrangement is preferred for greater balance.    The pie rule means that the game is a proven 2nd-player win, and the quality of the AI can be judged accordingly.Goal: 
            Deprive any of your opponent's stones access to an empty shaded Liberty cell, by surrounding or 'Enmeshing' them.  
            
            Play:
            -- Black starts with an empty board.
            -- White has the option to convert Black's first stone to white instead of placing elsewhere. (pie move)
            -- Turns alternate.
            -- On your turn place one of your stones on an empty site.
            
            Ending the game:
            -- The game ends as soon as any stone is enmeshed. (see definitions below).
            
            -- If both player's stones are simultaneously 'enmeshed', the player with the most 'enmeshed' stones loses. 
            -- If this is still equal, the moving player loses.
            
            Definitions:
            A stone is 'Enmeshed' if it has no path in the play area to an empty shaded liberty cell without crossing a connection between the opponent's stones.
            
            There is a connection between stones of the same color if they: 
            -- 1. are on adjacent squares, 
            -- 2. are diagonally adjacent, (player's connections can cross each other)
            -- 3. are at knight's distance, with at least one empty space between. 
            
            Notes: 
            Knight's connections can cross each other, but cease to exist when 2 pieces are placed in between.
        When a stone is placed on a shaded cell, that cell no longer serves as a liberty for either player. Order 3 board
(game "N-Mesh"
    (players 2)
    (equipment {
        "SquareGrid"
        (regions "Marked" ("LibertyRegions")) 
        (piece "Ball" P1 maxState:1)
        (piece "Ball" P2 maxState:1)
        (piece "I" P1 maxState:5)
        (piece "I" P2 maxState:5)
    })
    (rules
        (play
            (or
                (if
                    (= 0 (counter))
                    (move Add
                        (to
                            (sites Occupied by:Next)
                            (apply (remove (to)))
                        )
                    )
                )
                ("Add2EmptyWithConsequenses")
            )
        )
        (end 
            (if 
                (or
                    (is Triggered "Enmeshed" Mover)
                    (is Triggered "Enmeshed" Next)
                )
                { 
                (if
                    (= (score Mover) (score Next))
                    (result Next Win)
                )
                (if
                    (!= (score Mover) (score Next))
                    (byScore)
                ) 
                }
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Lange Puff is a European Tables game played in Germany. Its rules have been documented since the nineteenth century, but it may be related to other games with similar names that are much older. 2x12 board, with spaces as points, divided in two. Fifteen pieces per player. Two six-sided die. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The lowest value of the dice must be played; if it cannot, the player does not move. When a player throws doubles, they play the values on each die, as well as the values on the opposite side of the dice (I.e., double 6 if double 1 is thrown, 5 if 2, 3 if 4). However, the values on the bottom can only be played if all of the top values are played. The first double throw is only played once, but every subsequent double throw is played twice, and the top values must be played twice before using the bottom values. Bottom values do not have to be played, or only some of the bottom values may be played if the player wishes. In addition, an extra throw is granted for the second and subsequent throws of doubles. Players enter their pieces onto the same section of the board, and proceed around the board to the point opposite the starting point, and then off the board. A player may not land on a point with two or more of the opponent's pieces. A player's piece may land on a point with a single opponent's piece. The opponent's piece is removed from the board and must enter again. The first player to remove all of their pieces from the board wins. 
(game "Lange Puff"
    (players 2)
    (equipment {
        ("BackgammonBoard" "BackgammonTracksSameDirectionWithHands") 
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die
                replayDouble:(= 1 (value Player Mover)) 
                if:("DieNotUsed")
                (if ("IsOffBoard" ("NextSiteFrom" (from) (pips)))
                    (move Remove (from))
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NoEnemyOrOnlyOne" (to))
                            ("HittingCapture" (handSite Next))
                        )
                    )
                )
                (then 
                    (if (not (all DiceUsed))
                        (moveAgain)
                        (if (= 1 (value Player Mover))
                            (if (and (all DiceEqual) (= 0 (size Array (values Remembered)))) 
                                (and 
                                    (moveAgain) 
                                    (set Var "PlayOpposite" 1)
                                )
                            )
                            (set Value Mover 1)
                        )
                    )
                )
            )			
        )
        (hand Each)
    })
    
    (rules 
        (start {
            (place Stack "Disc1" (handSite P1) count:15)
            (place Stack "Disc2" (handSite P2) count:15)
        })
        
        (play 
            (do (if (or (is Pending) ("NewTurn")) (roll))
                next:(if (= 1 (var "PlayOpposite"))
                    (or { 
                        (forEach Piece ("MoveOppositeDice") top:True) 
                        (forEach Piece container:(mover) ("MoveOppositeDice") top:True)
                        (move Pass 
                            (then 
                                (and { 
                                    (forget Value "Opposite" All) 
                                    (set Var "PlayOpposite" 0) 
                                    (set Pending) 
                                    (moveAgain)
                                })
                            )
                        )
                    })
                    
                        (do (if (and { 
                                    (= 0 (count MovesThisTurn)) 
                                    (all DiceEqual)
                                    (= 1 (value Player Mover))
                                })
                                (and 
                                    (remember Value "Opposite" (- 7 ("DoubleDieValue"))) 
                                    (remember Value "Opposite" (- 7 ("DoubleDieValue")))
                                )
                            )
                            next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True))
                        )
                    
                )
            )
        )
        
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
The prisoner's dilemma is a standard example of a game analyzed in game theory that shows why two completely rational individuals might not cooperate, even if it appears that it is in their best interests to do so. It was originally framed by Merrill Flood and Melvin Dresher while working at RAND in 1950. Albert W. Tucker formalized the game with prison sentence rewards and named it \The dilemma is repeated 10 times:
            - If the two players are cooperating (C), they get 6 points.
            - If the two players are defecting (D), they get 2 points.
            - If one player is cooperating (C) and the other is defecting (D), the first one gets 0 points and the second one gets 10 points.
         
(game "Iterated Prisoners Dilemma"
    (players 2)
    (mode Simultaneous) 
    (equipment {
        (board (square 2))
    })
    (rules
        (play 
            (or { 
                (move Select (from 0) P1 (then ("P1IsCooperating")))
                (move Select (from 1) P1 (then ("P1IsDefecting")))
                (move Select (from 2) P2 (then ("P2IsCooperating")))
                (move Select (from 3) P2 (then ("P2IsDefecting")))
                }
                (then
                    (if (and ("CooperateP1") ("CooperateP2")) 
                        (and (addScore P1 3) (addScore P2 3))
                        (if (and ("DefectP1") ("DefectP2")) 
                            (and (addScore P1 1) (addScore P2 1))
                            (if (and ("CooperateP1") ("DefectP2")) 
                                (and (addScore P1 0) (addScore P2 5))
                                (and (addScore P1 5) (addScore P2 0))
                            )
                        )
                    )
                    applyAfterAllMoves:True
                )
            )
        )
        (end (if (= (counter) 8) (byScore)))
    )
)

Construct a Ludii game based on the following description
Konane is an indigenous Hawaiian game played on a board that varies: it can range from 6x6 to more than 14x14, and does not have to be square. It is a game with leaping capture, and has been played at least since the eighteenth century, but probably for longer. Konane boards can be found on rock surfaces throughout Hawaii, but they are difficult to date.10x10 board. The black player starts by removing one black piece either from one of the central four spaces of the board or from one of the four corners. The white player then must remove a white piece that is orthogonally adjacent to the empty space. Play proceeds by orthogonally jumping an opposing piece and capturing it. All moves must be capturing moves. Multiple captures can be made only by continuing in the same direction. The first player unable to move loses. The game is played on a 6x6 board.
(game "Konane" 
    (players 2) 
    (equipment { 
        <Board>
        (piece "Marker" Each)
    }) 
    (rules 
        (start { 
            (place "Marker1" (sites Phase 1))
            (place "Marker2" (sites Phase 0))
        })
        
        phases:{ 
        (phase "OpeningP1" P1 
            (play 
                (move Remove
                    (intersection 
                        (union 
                            (sites Corners) 
                            (sites Centre)
                        ) 
                        (sites Phase 1)
                    ) 
                )
            ) 
            (nextPhase Mover "Movement")
        )
        (phase "OpeningP2" P2 
            (play (move Remove (sites Around (last To) Own))) 
            (nextPhase Mover "Movement")
        )
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    (or
                        ("HopSequence" (last To) SameDirection)
                        (move Pass)
                    )
                    (forEach Piece "Marker" ("HopSequence" (from) Orthogonal)) 
                )
            )
        )
        }
        
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
I Pere is a two-row mancala-style game board from played by the Dogon people of Mali. It is similar to other two-row games from the region, and was documented in the early twentieth century.2x5 board, the right-most hole is the store. Four counters in each hole. Sowing in an anti-clockwise direction, including the store. Play begins by each player placing the counters in their fourth hole into their store. Moves may begin from any of a player's holes except the store. If the last counter of a sowing drops into a hole making it contain two or three counters, these are taken and placed in the store. As soon as a player has at least thirteen counters in their store, they are picked up and sown, omitting each player's store and takes any counters in the opponent's holes which now contain two or three counters. Each player performs this move only once. The player who captures the most counters wins. 
(game "I Pere" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 5 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))  
        (regions P2 (sites Top))   
        (map {(pair P1 4) (pair P2 5)}) 
        (map "Fourth" {(pair P1 3) (pair P2 6)}) 
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        phases:{
        (phase "Opening"
            (play
                (move 
                    (from (mapEntry "Fourth" Mover))
                    (to (mapEntry Mover))
                    count:4
                )
            )
            (nextPhase Mover "Sowing")
        )
        (phase "Sowing"
            (play
                (if 
                    (and
                        (<= 13 (count at:(mapEntry Mover)))
                        (!= 1 (value Player Mover))
                    )
                    (or {
                        (move Select
                            (from (mapEntry Mover))
                            (then
                                (and
                                    (sow
                                        skipIf:(or
                                            (= (to) (mapEntry P1))
                                            (= (to) (mapEntry P2))
                                        )
                                    )
                                    (set Value Mover 1)
                                )
                            )
                        )
                        }
                        (then
                            (forEach Site (difference (sites Next) (mapEntry Next))
                                (if
                                    (or 
                                        (= 2 (count at:(site)))
                                        (= 3 (count at:(site)))
                                    )
                                    (fromTo 
                                        (from (site))
                                        (to (mapEntry Mover))
                                        count:(count at:(site))
                                    )
                                )
                            )
                        )
                    )
                    (move Select
                        (from
                            (difference (sites Mover) (mapEntry Mover))
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                apply:(if 
                                    (or
                                        (= 2 (count at:(to)))
                                        (= 3 (count at:(to)))
                                    )
                                    (fromTo
                                        (from (to))
                                        (to (mapEntry Mover))
                                        count:(count at:(to))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end ("MancalaByScoreWhen" (no Moves Next)))
    )
)

Construct a Ludii game based on the following description
Lisolo is a four-row mancala-style board game played by the Bemba people of central Africa.4x8 board. Two counters in each hole. Before play, players may arrange their counters as they see fit in their holes. Players alternate turns sowing the counters from one of their holes in an anticlockwise direction. When the final counter lands in an empty hole, their turn is over. If the final counter lands in an occupied hole, the contents of the two opposite hole in the opponent's rows are captured. If both do not have counters, then the player picks up the counters from the hole the last counter fell into and continues sowing. The player who captures all of the opponent's counters wins. 
(game "Lisolo" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 ("Columns") store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "16,E,N1,W" loop:True P2)
            }		
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Track "Track1")) 
        (regions "Home" P2 (sites Track "Track2")) 
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        phases:{
        (phase "Opening"
            (play
                (or
                    (forEach Site (sites Mover "Home")
                        (if (is Occupied (site))
                            (move 
                                (from (site))
                                (to 
                                    (forEach (sites Mover "Home")
                                        if:(!= (to) (site))
                                    )
                                )
                            )
                        )
                    )
                    (move Pass)
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        (phase "Sowing"
            (play
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover) 
                        ) 
                        if:(> (count at:(from)) 0)
                    )
                    (then 
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (> (count at:(to)) 1)
                                (if (not (is In (to) (sites Mover "Inner")))
                                    (moveAgain)
                                    (if (and 
                                            (= 0 (count at:("OppositePit" (to))))
                                            (= 0 (count at:("OppositeOuterPit" (to))))
                                        )
                                        (moveAgain)
                                        (and
                                            (if (!= 0 (count at:("OppositePit" (to))))
                                                (remove 
                                                    ("OppositePit" (to)) 
                                                    count:(count at:("OppositePit" (to)))
                                                ) 
                                            )
                                            (if (!= 0 (count at:("OppositeOuterPit" (to))))
                                                (remove 
                                                    ("OppositeOuterPit" (to)) 
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                ) 
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )	 
            )
        )
        }
        
        (end 
            (forEach Player
                if:(= 0 ("PiecesOwnedBy" Player))
                (result Player Loss)
            )		
        )
    )
)

Construct a Ludii game based on the following description
Dama is the name of a game with leaping captures played in several parts of the world. This version is played on the coast of Kenya.8x8 board. 16 pieces per player, lined up in the second and third rows (first row on each side is empty). Pieces move forward or horizontally one space, and capture opponents' pieces by jumping in these directions. When they reach the opposite side, they become a king and can jump opponents' pieces from any distance orthogonally. Captures must be taken if possible, and the maximum number of jumps must be made. In a situation where two pieces are able to make the maximum number of captures and one of them is a king, the king must make the captures. Multiple captures cannot be made by moving 180 degrees from the previous jump. Pieces can be promoted to king mid-jump. Winning is achieved by capturing all of the other player's pieces or by blocking them so they cannot move. 
(game "Dama (Kenya)" 
    (players 2) 
    ("DraughtsEquipment" (square 8))
    (rules 
        (start { 
            (place "Counter1" (union (sites Row 1) (sites Row 2)))
            (place "Counter2" (union (sites Row 5) (sites Row 6)))
        })
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves
                        ("HopMan" (last To)
                            (then 
                                ("ReplayIfCanMove" ("HopMan" (last To)) 
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                    )
                    (max Moves ("PromotedHopOrthogonalSequenceCapture" (from (last To)) (difference Orthogonal OppositeDirection)))
                )
                (priority {
                    (max Moves
                        (priority { 
                            (forEach Piece "DoubleCounter" ("PromotedHopOrthogonalSequenceCapture" (from) Orthogonal))
                            (forEach Piece "Counter" 
                                ("HopMan" (from)
                                    (then 
                                        ("ReplayIfCanMove" ("HopMan" (last To)) 
                                            ("PromoteIfReach" (sites Next) "DoubleCounter")
                                        ) 
                                    ) 
                                ) 
                            )
                        })
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {Forward Rightward Leftward}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Orthogonal))
                    )
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Emperador is a race game from medieval Spain that is related to other European Tables games. It is said, in the Libro de los Juegos of Alfonso X, to have been invented by \2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, toward the point where the opponent's pieces begin, and bearing off the board from there. A player cannot have two of their pieces on the same spot in the starting quadrant. When a piece lands on the same space as a single opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins. If players move their pieces such that they fill up all the points in a quadrant, and the other fills up all of the points in an adjacent quadrant such that neither player can move, the game is a draw. It is a prime win when one player has twelve pieces arranged on consecutive points so that the other player cannot pass them. When the player sends four pieces back to the beginning while preserving this state, it is a prime win. 
(game "Emperador"
    (players 2)
    (equipment {
        ("TableBoard" "TableTracksOppositeWithHands")
        (dice d:6 num:3)
        (hand Each)
        (regions "StartingQuadrant" P1 (sites {0..5}))
        (regions "StartingQuadrant" P2 (sites {12..17}))
        (piece "Disc" Each 
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" "SiteToMoveOnTrack")
                    "RemoveAPiece"
                    (if (or {
                            (is Empty ("SiteToMoveOnTrack"))
                            (and 
                                ("IsFriendAt" "SiteToMoveOnTrack")
                                (if (is In (to) (sites Mover "StartingQuadrant")) (not ("IsSingletonStack" "SiteToMoveOnTrack")) True)
                            )
                            (and 
                                ("IsEnemyAt" "SiteToMoveOnTrack")
                                ("IsSingletonStack" "SiteToMoveOnTrack")
                            )
                        })
                        (move 
                            (from) 
                            (to 
                                "SiteToMoveOnTrack" 
                                ("HittingCapture" (handSite (who at:(to))))
                            )
                        )
                    )
                )	
            )
        )
    })
    (rules 
        (start {
            (place Stack "Disc1" 0 count:15)
            (place Stack "Disc2" 12 count:15)
        })
        (play
            ("RollEachNewTurnMove"
                (or 
                    (forEach Piece top:True) 
                    (forEach Piece container:(mover) top:True)
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )  
        (end {
            ("EscapeWin")
            (if (and (no Moves P1) (no Moves P2)) (result Mover Draw))
        })
    )
)

Construct a Ludii game based on the following description
On  the  Isle  of  Lewis  (Outer  Hebrides,  Scotland)  are located   some   of   the   most   impressive   prehistoric megalithic  structures  in  Europe.  The  most  important sites  are  around  the  area  of Callanish,  and  include stone circles, cairns, and stone alignments.The  goal  of Callanish  is  to  create  an  alignment  of  a certain  number  of  stones  or  stacks  of  your  colour orthogonally along any file or rank of the board.The board is initially empty. Each player chooses a colour: White or Black. White starts by placing a stone on a vacant square. Black does the same.
            
        Players continue taking turns; however, your turn goes as follows: 1. Mark one of your exposed stones for removal from the board (i.e. it cannot be under an enemy stone). 2. Add one of your stones to the board. 3. Add another one of your stones to the board, at which point the marked stone is removed. The following rules constrain where you can add each stone: It must be a “knight’s move” away from the marked stone. That is to say, either 2 spaces vertically and 1 horizontally, or 2 spaces horizontally, and 1 vertically away from the marked stone. The space on which you place it must have none of your stones, and either: be vacant, or have an enemy stone, in which case you will place yours on top, creating a stack that you control. If, at the end of your opponent’s turn, you have at least 4 of your stones and/or stacks in the same rank, or in the same file, you win.
(game "Callanish" 
    (players 2) 
    (equipment { 
        (board <Board:BoardDef>) 
        (piece "Disc" Each ("MoveCondemnPiece")) 
    }) 
    (rules 
        phases: {
        (phase "Opening"
            (play (move Add (to (sites Empty))))
            (nextPhase (>= (count Turns) 2) "Playing")
        )
        (phase "Playing"
            (play 
                (if "SameTurn"
                    (if (is Pending)
                        ("MoveSecondKnight")
                        ("MoveFirstKnight")
                    )
                    (forEach Piece)
                )
            )
        )
        }
        (end {
            (if
                (and 
                    (= (% (- (count Moves) 2) 3) 0)
                    (or {
                        (<= <Board:MainWin0> ("OpponentCount" Row 0))
                        (<= <Board:MainWin1> ("OpponentCount" Row 1))
                        (<= <Board:MainWinC> ("OpponentCount" Row 2))
                        (<= <Board:MainWinC> ("OpponentCount" Row 3))
                        (<= <Board:MainWinC> ("OpponentCount" Row 4))
                        (<= <Board:MainWinC> ("OpponentCount" Row 5))
                        (<= <Board:MainWinC> ("OpponentCount" Row 6))
                        <Board:ExtraRows>
                        (<= <Board:MainWin0> ("OpponentCount" Column 0))
                        (<= <Board:MainWin1> ("OpponentCount" Column 1))
                        (<= <Board:MainWinC> ("OpponentCount" Column 2))
                        (<= <Board:MainWinC> ("OpponentCount" Column 3))
                        (<= <Board:MainWinC> ("OpponentCount" Column 4))
                        (<= <Board:MainWinC> ("OpponentCount" Column 5))
                        (<= <Board:MainWinC> ("OpponentCount" Column 6))
                        <Board:ExtraCols>
                    })
                )
                (result Mover Loss)
            )
            (if (no Moves Mover) (result Mover Loss))
        })
    )
)

Construct a Ludii game based on the following description
One of the most popular versions of Draughts, derived from the medieval game of Draughts but with the difference of the forced capture, hence its early name \Played on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them in a forward direction if they are adjacent. Capturing must happen if it is possible. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. The goal is to capture all of the opponent's pieces. 
(game "English Draughts" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 8))
    (rules 
        ("BlackCellsSetup" 3)
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    ("HopCapture" (from (last To)) (directions {FR FL})
                        (then 
                            ("PromoteIfReach" (sites Next) "DoubleCounter"
                                ("ReplayIfCanMove" ("HopCapture" (from (last To)) (directions {FR FL})))
                            ) 
                        ) 
                    )
                    ("HopDiagonalSequenceCaptureAgain")
                )
                (priority {
                    (or 
                        (forEach Piece "Counter" 
                            ("HopCapture" (from) (directions {FR FL}) 
                                (then 
                                    ("PromoteIfReach" (sites Next) "DoubleCounter"
                                        ("ReplayIfCanMove" ("HopCapture" (from (last To)) (directions {FR FL})))
                                    ) 
                                ) 
                            ) 
                        )
                        (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture"))
                    )
                    
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" "StepDiagonalToEmpty")
                    )
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Refugia is a modern experimental game with a goal of consolidating stones.    Stones enter unconnected, and can only move by fleeing from concentrations of enemy stones. Thus it is a movement game with a territorial aspect.      The game includes capture-by-hopping moves, which create mutual-enemy stones as an intermediate stage before possible reconversion back to player's stones. This mechanism keeps the game provably finite.     The pseudo-territories formed by the clumps of stones, have boundaries that can erode and shift; so the game is more tactical than strategic. Shifts in strategic concerns do occur, however, as the game evolves from first mainly claiming territory by placement density, to a race to agglomerate or capture, to fights to recapture vs blocking to retain lead in a tactical end game.     Because the effect of the mutual-enemy stones on movement is symmetrical but not the same for the two players, the game requires considerable mental concentration.2 players. Each plays Discs. - 
            
            --- Goal: Most friendly-stone adjacencies at the end of the game. Ties are broken by comparing piece counts. If it is still a tie, the last player to move loses. 
            
            --- Play.
            On your turn you may do one of the following:
            1. Pass
            
            2. Place one of your stones on an empty cell of the board is not adjacent to your existing stones.
            
            3. Move to a location with fewer adjacent enemies than the starting location.
            
            Moves are made in one of the following ways while keeping the above restriction:
            -- A. Step to an adjacent empty location.
            -- B. Hop your opponent's stone and replace it with a mutual enemy piece.
            -- C. Hop a mutual enemy piece and replace it with a stone from your supply.
            
        Note that the number of enemies is based on a count of both the opponent's stones and the mutual-enemy stones combined.   Board & size: Hexhex (12) with edges alternating 2 and 3 Green Background
(game "Refugia" 
    (players 2)
    (equipment {
        (board (hex <Board:size>))
        (piece "Disc" P1)
        (piece "Disc" P2)
        (piece "Fan" Neutral)
    })
    (rules 
        (start (set Score Each 0))
        (play
            (or {
                ("StepMove")
                ("HopEnemy")
                ("HopNeutral")
                ("Placement")
                (move Pass) 
            })
        )
        (end 
            (if 
                (all Passed) {
                (if 
                    (> (score Mover) (score Next))
                    (result Mover Win)
                )
                (if 
                    (< (score Mover) (score Next))
                    (result Next Win)
                )
                (if 
                    (> ("TieBreaker" Mover) ("TieBreaker" Next))
                    (result Mover Win)
                )
                (if 
                    (< ("TieBreaker" Mover) ("TieBreaker" Next))
                    (result Next Win)
                )
                }
                (result Next Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Ahtarah Guti" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (piece "Marker" Each 
            (or 
                ("HopSequenceCapture")
                ("StepToEmpty")
            )
        )
    }) 
    (rules 
        (start { 
            (place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3) (sites {13 14})}))
            (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8) (sites {10 11})}))
        })
        
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("CaptureAll" Next))
    )
)
Ahtarah Guti is a game with captures from central India. It was a very commonly-played game in the early twentieth century.5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. Eighteen pieces per player, each side arranged on one side of the board, with the central point empty and the player's pieces on the points to the right of it. Players alternate turns moving one of their pieces to an empty point. A piece may jump an opponent's piece to capture it. Multiple captures are allowed. The player who captures all of the opponent's pieces wins. 

Describe the mechanics of the following Ludii game
(game "At-Tab wa-d-Dukk"
    (players 2)
    (equipment {
        (board
            (rectangle 4 <Board:size>)
            {
            (track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True)
            (track "Track2" "51,W,S1,E,S1,W,S1,E" P2 directed:True)
            }
        )
        ("StickDice" 4)
        (map {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)})
        (piece "Marker" Each
            (if (or ("ActivatedPiece") (and (= 1 ("ThrowValue")) ("InactivePiece")))
                (if ("IsNotOffBoard" ("NextSiteOnTrack" ("ThrowValue")))
                    (if (or 
                            (not ("InOpponentHome")) 
                            (and
                                ("InOpponentHome")
                                ("OpponentPieceAtHome")
                            )
                        )
                        (if (or
                                (is In ("NextSiteOnTrack" ("ThrowValue")) (sites Empty))
                                ("IsEnemyAt" ("NextSiteOnTrack" ("ThrowValue")))
                            )
                            (or 
                                (if ("ThrowEqualSizeKingMinusOne")
                                    ("UncoupledKing")
                                )
                                ("KingMove")
                            )
                            (if (and 
                                    (is In ("NextSiteOnTrack" ("ThrowValue")) (sites "CentralRows"))
                                    ("IsFriendAt" ("NextSiteOnTrack" ("ThrowValue")))
                                )
                                ("CreateAKing")
                            )
                        )
                    )
                    (then ("ActivatePiece"))
                )
            )
        )
        (regions "AnotherThrow" (sites {1 4 6}))
        (regions "CentralRows" (union (sites Row 1) (sites Row 2)))
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    })
    (rules 
        (start { 
            (place "Marker1" (sites Bottom) state:1)
            (place "Marker2" (sites Top) state:1)
        })
        (play 
            ("RollMove"
                (if (can Move (forEach Piece))
                    (forEach Piece (then (if (is In ("ThrowValue") (sites "AnotherThrow")) (moveAgain))))
                    (move Pass (then (if (is In ("ThrowValue") (sites "AnotherThrow")) (moveAgain))))
                )
            )
        )
        (end 
            (if (or ("AllPieceInOpponentHome") (no Pieces Mover))
                (byScore)
            )
        )
    )
)
At-Tab wa-d-Dukk is a capturing game from Early Modern Southwest Asia. It is similar to the game of Tab still played today in the region, and may be the ancestor of several similar games.4x13, 19, 21, or 29 board. The number of pieces per player equals the number of spaces in a row, which begin the game arrayed in the outer rows of the board. Four sticks, each with a white side and a yellow side. Throws equal the number of white sides which fall up; when only yellow sides are up the throw equals 6. A throw of 1, 4, or 6 grants another throw to the player. Players  perform all of their throws first, and then move pieces according to the values of the throws without subdividing the value of a single throw. Players cannot move their pieces until the throw a 1. Pieces cannot move past one another in the home row. Each piece in the home row must individually be unlocked with a throw of 1 before it can move. In the central rows, when two of a player's pieces land on the same spot, they become a king and can be moved as one piece. There is no limit to the number of pieces in the king. They may be uncoupled with a throw of 1, or another throw which removes that number of pieces from the king. When a player's piece lands in a space occupied by an opponent's piece, the opponent's piece is removed from the board. Play progresses from left to right in the player's home row, and then from right to left in the second row, left to right in the third row, and then right to left in the opponent's row. When a piece enters the opponent's row, it cannot move if there are other pieces which can be moved. The player to capture the most of the opponent's pieces wins. The board has 13 columns.

Construct a Ludii game based on the following description
This game is played on the following 8x8 board and can be considered as a variant of Breakthrough.MOVE - On each turn, each player must do one of the following actions:
            - Move one friendly stone (the missiles) one cell forward (orthogonally or diagonally)
            - Explode one friendly stone, i.e., capture all stones of either color orthogonally and diagonally adjacent including itself.
            
        GOAL - Wins the player that move a stone into the last row, or is the only with stones in the board. 
(game "Bombardment"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (piece "NuclearBomb" Each
            (or
                ("StepForwardsToEmpty") 
                (move Select
                    (from (from))
                    (then
                        (forEach Site (sites Around (last To) includeSelf:True)
                            (if (is Occupied (site)) (remove (site)))
                        )
                    )
                )
            )
        )
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
    })
    (rules
        (start { 
            (place "NuclearBomb1" (expand (sites Bottom)))
            (place "NuclearBomb2" (expand (sites Top)))
        })
        
        (play (forEach Piece))
        
        (end (if (or ("ReachedTarget") (no Pieces Next)) (result Mover Win))) 
    )
)

Construct a Ludii game based on the following description
Bao Kiswahili is a four-row mancala-style board game played in the eastern part of the Democratic Republic of Congo. It was particularly popular among Banbubangu and Nonda people, as well as in some larger cities in surrounding regions.4x8 board. The fifth hole from the left in the inner row is rectangular, the rest are circular. 64 counters. Play begins with one counter in each hole in the inner row. Players take turns placing their remaining counters on the board in their inner rows. When they place a counter, they capture the hole facing it in the opponent's inner row, and sows the counters from either the leftmost or the rightmost hole of the player's inner row, sowing along the inner row. However, if the capture occurs from the rightmost, leftmost, or the next hole adjacent to each in the inner row, the captured pieces must be placed in the leftmost or rightmost hole, whichever is closer. The player may choose which hole to place captured counters in when captures are made from the central four holes in the inner row. The player must capture if possible, if not possible they place a counter into any of the holes in their inner row, pick up the contents of that hole, and sow in either direction. While sowing, if the final counter falls into an occupied hole and the opponent's hole opposite it has counters, the counters in the opponent's hole are captured. If the final counter falls into an occupied hole and the hole opposite it is empty, the counters are picked up and sowing continues in the same direction. If the final counter falls into an empty hole, the turn ends. If during this phase, the opponent's inner row is cleared of counters, the player wins. If all of the counters have been introduced and both players still have counters in their inner row, play proceeds to a second phase. Second Phase: Counters are picked up from any hole on the player's side and sown in either direction. The same capture, sowing, and victory rules apply as before. Captures, however, can only be made on subsequent sowings if there was a capture in the first round of a sowing. 
(game "Bao Kiswahili (DR Congo)" 
    (players 2) 
    (equipment { 
        (mancalaBoard 4 8 store:None
            {
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "23,W,N1,E" loop:True P2)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions "Home" P1 (expand (sites Bottom)))   
        (regions "Home" P2 (expand (sites Top)))    
        (regions "Inner" P1 (sites Row 1))      
        (regions "Inner" P2 (sites Row 2))      
        (map "LeftMostInner" {(pair P1 8) (pair P2 23)})
        (map "RightMostInner" {(pair P1 15) (pair P2 16)})
        (map "AdjacentLeftMostInner" {(pair P1 9) (pair P2 22)})
        (map "AdjacentRightMostInner" {(pair P1 14) (pair P2 17)})
    }) 
    (rules 
        (start {
            (set Count 24 at:(handSite P1))
            (set Count 24 at:(handSite P2))
            (set Count 1 to:(union (sites Row 1) (sites Row 2))) 
        })
        
        phases:{
        (phase "Placement"
            (play 
                (if ("SameTurn")
                    (if (is Pending) 
                        (or
                            (if (or (= 1 (value Player Mover)) (= 0 (value Player Mover))) 
                                (do 
                                    (fromTo
                                        (from ("OppositePit" (last To afterConsequence:True)))
                                        (to (mapEntry "LeftMostInner" Mover))
                                        count:(count at:("OppositePit" (last To afterConsequence:True)))
                                    )
                                    next:(move Select
                                        (from (mapEntry "LeftMostInner" Mover))
                                        (then ("Sowing" "TrackCW" 1))
                                    )
                                )
                            )
                            (if (or (= 2 (value Player Mover)) (= 0 (value Player Mover))) 
                                (do 
                                    (fromTo
                                        (from ("OppositePit" (last To afterConsequence:True)))
                                        (to (mapEntry "RightMostInner" Mover))
                                        count:(count at:("OppositePit" (last To afterConsequence:True)))
                                    )
                                    next:(move Select
                                        (from (mapEntry "RightMostInner" Mover))
                                        (then ("Sowing" "TrackCCW" 2))
                                    )
                                )
                            )
                        )
                        
                        
                        (or
                            (if (or (= (var "Direction") 1) (= (var "Direction") 3))
                                (move Select
                                    (from (var "Replay"))
                                    (then ("Sowing" "TrackCW" 1))
                                )
                            )
                            (if (or (= (var "Direction") 2) (= (var "Direction") 3))
                                (move Select
                                    (from (var "Replay"))
                                    (then ("Sowing" "TrackCCW" 2))
                                )
                            )
                        )
                    )
                    (if (is Occupied (handSite Mover)) 
                        (priority {
                            (move 
                                (from (handSite Mover))
                                (to (sites Mover "Inner") if:(is Occupied ("OppositePit" (to))))
                                count:1
                                (then
                                    (and {
                                        (moveAgain)
                                        (set Pending)
                                        (if (is In (last To) (expand (sites Right)))
                                            (set Value Mover 2) 
                                            (if (is In (last To) (expand (sites Left)))
                                                (set Value Mover 1) 
                                                (set Value Mover 0) 
                                            )
                                        )
                                    })
                                )
                            )
                            (move 
                                (from (handSite Mover))
                                (to (sites Mover "Inner"))
                                count:1
                                (then
                                    (and {
                                        (moveAgain)
                                        (set Var "Replay" (last To))
                                        (set Var "Direction" 3) 
                                    })
                                )
                            )
                        })
                        
                        (or 
                            ("SowingPhase2" "TrackCW" 1)
                            ("SowingPhase2" "TrackCCW" 2)
                        )
                    )
                )
            )
        )
        }
        
        (end 
            (forEach Player
                if:("NoPiecesInInner" Player)
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Bagh Guti is a hunt game from South Asia similar to others throughout the region. It is unique, though, because the goat pieces can be stacked on one another.5x5 board, played on intersections, with lines forming a diamond shape connecting the midpoints of the edges of the board. One player plays with two tiger pieces, placed on the midpoints of two opposite sides. The other player plays with twenty goats, divided into four stacks of five, placed on the next adjacent spot to the tigers on the diamond. The goats move first. Goats may move one at a time to any adjacent vacant spot. The tiger may move in the same manner, but also may capture a piece by hopping over it. Multiple captures can be made on the same turn with subsequent hops, but only the top goat in a stack is captured when a tiger leaps over it. The goal of the goats is to surround the tigers so they cannot move; the goal of the tigers is to capture all the goats. Initiallly, the tigers are placed at opposite sites of the top and the bottom of the board. Played on a board with the diagonals forming a diamond. The tiger can jump a sequence of pieces to capture.
(game "Bagh Guti" 
    (players 2) 
    (equipment { 
        <Board:type>
        (piece "Goat" P1 "StepToEmpty")
        (piece "Tiger" P2 <Tiger:move>)
    }) 
    
    (rules 
        (start { 
            (place Stack "Goat1" (sites {"B2" "D2" "B4" "D4"}) counts:{5 5 5 5})
            (place "Tiger2" <Start:tigerSites>)
        })
        
        (play <Tiger:playMove>)
        
        (end ("NoMovesP2NoPiecesP1"))
    )
)

Construct a Ludii game based on the following description
Otep is a four-row mancala-style board game played by the Bari people of South Sudan. The holes are scooped out of the ground, and the counters are pebbles or seeds which represent cows.4x8 board. Two counters in each hole. Sowing proceeds in an anti-clockwise direction. The first move must begin from the second hole from the right in the player's outer row, and proceed as follows, and is played simultaneously by both players: sow the two counters from that first hole, capture the counters in the opponent's two opposite holes and sow them, starting in the rightmost hole in the outer row, capture from the opposite two holes on the opponent's side and sow them again from the same hole. When the final counter falls in an occupied hole, those counters are picked up and sowing continues. The opening move ends when the final counter falls in an empty hole. The main phase then begins. When the final counter falls into an occupied hole in the player's inner row and both of the opposite holes on the opponent's side of the board are occupied, the counters in the opposite holes are captured and sown beginning in the first hole that was sown into to begin the sowing that caused the capture. When the final counter falls into an occupied hole and a capture is not possible, the contents of the hole are picked up and sowing continues. When the final counter lands in an empty hole, the turn ends. Players cannot sow from a hole containing a single counter. The player who captures all of their opponent's counters wins.
         
(game "Otep" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "16,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (map "SecondRightOuter" {(pair P1 14) (pair P2 17)})
        (map "RightOuter" {(pair P1 15) (pair P2 16)})
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(sites Board)) 
        )
        
        phases:{
        (phase "Opening1"
            (play
                (move Select
                    (from (mapEntry "SecondRightOuter" Mover))
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(and
                                (fromTo 
                                    (from ("OppositePit" (last From)))
                                    (to (mapEntry "RightOuter" Mover))
                                    count:2
                                )
                                (fromTo 
                                    (from ("OppositeOuterPit" (last From)))
                                    (to (mapEntry "RightOuter" Mover))
                                    count:2
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover "Opening2")
        )
        (phase "Opening2"
            (play
                (move Select
                    (from (mapEntry "RightOuter" Mover))
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(and
                                (fromTo 
                                    (from ("OppositePit" (last From)))
                                    (to (mapEntry "RightOuter" Mover))
                                    count:2
                                )
                                (fromTo 
                                    (from ("OppositeOuterPit" (last From)))
                                    (to (mapEntry "RightOuter" Mover))
                                    count:2
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover "Opening3")
        )
        (phase "Opening3"
            (play
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites {(mapEntry "RightOuter" Mover)}) 
                        ) 
                        
                    )
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (not (is Next Prev)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover) 
                        ) 
                        if:(> (count at:(from)) 1)
                    )
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if 
                                (and {
                                    (is In (to) (sites Mover "Inner"))
                                    (< 1 (count at:(to)))
                                    (is Occupied ("OppositeOuterPit" (to)))
                                    (is Occupied ("OppositePit" (to)))
                                })	
                                (and {
                                    (fromTo
                                        (from ("OppositeOuterPit" (to)))
                                        (to (last From))
                                        count:(count at:("OppositeOuterPit" (to)))
                                    )
                                    (fromTo
                                        (from ("OppositePit" (to)))
                                        (to (last From))
                                        count:(count at:("OppositePit" (to)))
                                    )
                                    (sow
                                        (last From)
                                        count:(+ (count at:("OppositePit" (to))) (count at:("OppositeOuterPit" (to))))
                                        "Track"
                                        owner:(mover)	
                                    )
                                })
                                (if (< 1 (count at:(to)))
                                    (moveAgain)
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end ("ForEachPlayerNoMovesLoss"))
    )
)

Construct a Ludii game based on the following description
Snopaque was creeted from the software AiAi. It is played on a hexagonal board.Player 1 marks a cell. Then Players take turns marking any unmarked cell with exactly one marked neighbour. Player who can't move loses. 
(game "Snowpaque" 
    (players 2) 
    (equipment { 
        (board (hex 5)) 
        (piece "Marker" Neutral) 
    }) 
    (rules 
        
        phases:{
        (phase "start" P1 
            (play (move Add (piece (id "Marker0")) (to (sites Empty)))) 
            (nextPhase "play")
        )
        (phase "play" 
            (play 
                (move Add 
                    (piece "Marker0") 
                    (to 
                        (sites Empty) 
                        if:(= "NumNeighbour" 1)
                    )
                )
            )
        )
        }
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
Nebäkuthana is a race game played by the Arapaho, Apache, Comanche, and Kiowa people of Oklahoma and Wyoming. It has many similarities to other race games with stick dice played in the Great Plains and Southwest United States.The board is rectangular, with six points on either side, with each side divided in half by two short parallel lines, which are the \ Each team has 2 scoring sticks.
(game "Nebakuthana"
    (players 4)
    (equipment {
        (board
            (graph 
                vertices:{
                {0 0} {2 0} {3 0.33} {4 0.33} {5 0.33} {6 0} {7 0} {8 0.33} {9 0.33} {10 0.33} {11 0} {13 0}
                {0 2} {6 2} {7 2} {13 2}
                {0.33 3} {12.66 3}
                {0.33 4} {12.66 4}
                {0.33 5} {12.66 5}
                {0 6} {2 6} {11 6} {13 6}
                {0 7} {2 7} {11 7} {13 7}
                {0.33 8} {12.66 8}
                {0.33 9} {12.66 9}
                {0.33 10} {12.66 10}
                {0 11} {6 11} {7 11} {13 11}
                {0 13} {2 13} {3 12.66} {4 12.66} {5 12.66} {6 13} {7 13} {8 12.66} {9 12.66} {10 12.66} {11 13} {13 13}
                }
                edges:{
                {0 1} {1 5} {5 13} {6 14} {5 6} {6 10} {10 11}
                {12 1} {0 12} {10 15} {15 11} 
                {12 22} {22 26} {22 23} {26 27} {26 36} {36 40}
                {15 25} {25 29} {24 25} {28 29} {29 39} {39 51}
                {40 41} {36 41} {39 50} {50 51} 
                {41 45} {45 46} {45 37} {46 38} {46 50} 
                }
            )
            {
            (track "Track1" "6,7,8,9,10,15,17,19,21,25,29,31,33,35,39,50,49,48,47,46,45,44,43,42,41,36,34,32,30,26,22,20,18,16,12,1,2,3,4,End" P1 directed:True)
            (track "Track2" "6,7,8,9,10,15,17,19,21,25,29,31,33,35,39,50,49,48,47,46,45,44,43,42,41,36,34,32,30,26,22,20,18,16,12,1,2,3,4,End" P2 directed:True)
            (track "Track3" "5,4,3,2,1,12,16,18,20,22,26,30,32,34,36,41,42,43,44,45,46,47,48,49,50,39,35,33,31,29,25,21,19,17,15,10,9,8,7,End" P3 directed:True)
            (track "Track4" "5,4,3,2,1,12,16,18,20,22,26,30,32,34,36,41,42,43,44,45,46,47,48,49,50,39,35,33,31,29,25,21,19,17,15,10,9,8,7,End" P4 directed:True)
            }
            use:Vertex
        )
        (piece "Stick" P1 ("Move"))
        (piece "Stick" P3 ("Move"))
        ("StickDice" 4)
        (hand P1)
        (hand P3)
        (map "Throw" {(pair 0 10) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 6)})
        (map "Start" {(pair P1 6) (pair P2 6) (pair P3 5) (pair P4 5)})
        (map "Opposite" {(pair P1 46) (pair P2 46) (pair P3 45) (pair P4 45)})
    })
    (rules 
        (start {
            (set Team 1 {P1 P2})
            (set Team 2 {P3 P4})
            (place "Stick1" 6)
            (place "Stick3" 5)
            (place "Stick1" (handSite P1) count:<Scoring:num>)
            (place "Stick3" (handSite P3) count:<Scoring:num>)
        })
        (play 
            ("RollMove"
                (if (or (is Mover P1) (is Mover P2))
                    (forEach Piece P1)
                    (forEach Piece P3)
                )
                (then
                    (if ("ReplayThrow")
                        (moveAgain)
                    )
                )
            )
        )
        (end ("EscapeTeamWin"))
    )
)

Construct a Ludii game based on the following description
HeXentafl is an asymmetric abstract strategy game based on the ancient viking game Hnefatafl. One side (white) plays the attackers, and one side (black) plays the defenders.HeXentafl can be played on a 4x4 or 5x5 hex grid.
            
            For the 4x4 version:
            The King sits on the central space, the throne, surrounded by three defenders. Six attackers sit on the outer corners of the grid.
            The attackers must capture the King in order to win. The defenders must escort the King to any of the six corners of the board in order to win.
            
            All pieces except the King move in a
            straight line, as many spaces as they like to an unoccupied space (like a rook in Chess). Only one piece at a time can occupy a space. A piece cannot jump over another piece.
            The King can move into any vacant adjacent space, moving one space at a time (similar to the king in Chess).
            
            Pieces are captured by surrounding them on two sides. Except for the corners, the pieces can be captured by surrounding them with two pieces which are not adjacents. You cannot \ The game is played on a 4x4 hex board.
(game "HeXentafl" 
    (players 2)
    (equipment {
        (board (rotate 90 (hex <Board:size>)))
        (piece "Thrall" P1 
            (move Slide 
                (between if:(and (!= (between) ("Throne")) (is Empty (between))))
                (then (and ("SurroundCorners") ("Custodial")))
            )
        )
        (piece "Thrall" P2 
            (move Slide 
                (between if:(and (!= (between) ("Throne")) (is Empty (between))))
                (then (and {("SurroundThrone") ("SurroundCorners") ("Custodial") }))
            )
        )
        (piece "Jarl" P1 
            (move 
                <Board:kingMove> 
                (then (and ("SurroundCorners") ("Custodial")))
            )
        )
        (regions "Fortresses" (sites Corners))
    })
    (rules 
        (start {
            (place "Jarl1" ("Throne"))
            <Board:start>
        })
        (play (forEach Piece))
        (end {
            ("PieceTypeReachWin" "Jarl1" (sites "Fortresses") P1)
            (if "JarlWasCaptured" (result P2 Win))
        })
    )
)

Construct a Ludii game based on the following description
Ataxx is an arcade game invented in 1990 by the Leland Corporation and was originally called Infection.Each player begins with two pieces on the four corners of the board, with each player's pieces in opposite corners. Players move one piece one or two spaces in any direction orthogonally or diagonally. If the piece is moved on space, another piece is added on the origin space. All of the opponent's pieces adjacent to the space to which the player moved now belong to the player who moved. Play ends when all spaces have been filled or one of the players has no remaining pieces. The player with the most pieces wins. 
(game "Ataxx" 
    (players 2) 
    (equipment { 
        (board (square 7)) 
        (piece "Marker" Each 
            (or 
                (move 
                    (from) 
                    (to (sites Around (from)) if:(is Empty (to))) 
                    copy:True
                )
                (move 
                    (from) 
                    (to 
                        (difference 
                            (expand origin:(from) steps:2) 
                            (expand origin:(from))
                        ) 
                        if:(is Empty (to))
                    )
                )
                (then
                    (forEach Site 
                        (intersection 
                            (sites Around (last To)) 
                            (sites Occupied by:Next)
                        )
                        (and 
                            (remove (site)) 
                            (add (piece (id "Marker" Mover)) (to (site))) 
                        )
                    )
                )
            )
        )
        }
    ) 
    (rules 
        (start {
            (set Score Each 2)
            (place "Marker1" {"A1" "G7"})
            (place "Marker2" {"A7" "G1"})
        })
        (play (forEach Piece
                (then 
                    (and 
                        (set Score P1 (count Sites in:(sites Occupied by:P1)))	 
                        (set Score P2 (count Sites in:(sites Occupied by:P2)))
                    )
                )	
            )
        )
        
        (end
            (if (or 
                    ("NoSites" (sites Occupied by:Next)) 
                    (is Full)
                )
                (byScore)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Nama"
    (players <Player:num>)
    (equipment {
        (board 
            (rectangle <Board:size> 1)
            (track "Track" <Board:track> directed:True)
        )
        (hand Each)
        (hand Shared)
        (piece "Marker" Each
            (if ("IsOffBoard" ("SiteToMove"))
                (move Remove (from) level:(level)
                    (then 
                        (if ("IsOffBoard" (where "Hyena" Shared))
                            ("SetHyenaPlayer")
                        )
                    )
                )
                (move
                    (from (from) level:(level))
                    (to ("SiteToMove"))
                    stack:True
                )
            )		
        )
        (piece "Hyena" Shared)
        ("StickDice" 4)
        (map "Throw" {(pair 0 0) (pair 1 0) (pair 2 2) (pair 3 0) (pair 4 20) })
    })
    (rules 
        (start 
            (place "Marker" "Hand")
        )
        (play 
            ("RollMove"
                (if (< 0 ("ThrowValue"))
                    (if (= ("HyenaPlayer") (id Mover))
                        (if ("IsOffBoard" ("SiteHyenaToMove"))
                            (move Remove (where "Hyena" Shared) 
                                (then
                                    (forEach Site (sites Board)
                                        (if (is Occupied (site))
                                            (remove (site) count:(size Stack at:(site)))
                                        )
                                    )
                                )
                            )
                            (move
                                (from (where "Hyena" Shared))
                                (to ("SiteHyenaToMove"))
                                (then 
                                    (forEach Value min:1 max:(- (* 2 ("ThrowValue")) 1)
                                        (if
                                            (is Occupied ("SiteToMoveOnTrack" from:(last From) (value)))
                                            (remove 
                                                ("SiteToMoveOnTrack" from:(last From) (value)) 
                                                count:(size Stack at:("SiteToMoveOnTrack" from:(last From) (value)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (or (forEach Piece) (forEach Piece container:(mover)))
                    )
                )
            )
        )
        (end {
            (forEach Player
                if:(and {
                    (> ("HyenaPlayer") 0) 
                    (!= (player) ("HyenaPlayer"))
                    ("IsOffBoard" (where "Hyena" Shared))
                }) 
                (result Player Loss)
            )
            
            (if 
                (and (= (id Mover) ("HyenaPlayer")) ("IsOffBoard" (where "Hyena" Shared))) 
                (result Mover Win)
            )
            (forEach Player
                if:(and (!= (player) ("HyenaPlayer")) (no Pieces of:(player)))
                (result Player Loss)
            )
        })
    )
)
Nama is a race game played in Ségou, Mali. The board is made in the sand, and nut shells are used as dice. The first player who reaches the end plays as the hyena, which eats up the remianing players' pieces.The board is a track of any number of spaces, made in the sand. Any number of players, playing with one piece. One piece is the hyena. Four nut shells are used as dice, with the following throws: four of all the same side = 20; two of the same side = 2; any other throw = 0. The first player to reach the end of the track then plays as the hyena. The hyena moves twice the value of the throw. When the hyena overtakes a player's piece, it is removed from the board and the player loses.  The game involves 2 players. The track is composed of 20 spaces

Construct a Ludii game based on the following description
Aqrad is an alignment game played by the Tuareg people in the Haggar region of Algeria. The game is usually played in the sand, and stones and camel droppings are used as pieces.7x6 board. Eighteen pieces per player. Players alternate turns placing a piece on the board. When all of the pieces have been placed, players alternate turns moving a piece to an adjacent empty square in an orthogonal direction. When a player places three of their pieces in an orthogonal line, they capture one of the opponent's pieces. The player who captures all of the opponent's pieces wins. 
(game "Aqrad"
    (players 2)
    
    (equipment { 
        (board (rectangle 7 6)) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" Orthogonal 
                (then ("ReplayIfLine3" Orthogonal exact:True))
            )
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:18))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True)) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Fivalath is a game invented by Néstor Romeral Andrés in 2020 that was inspired by Yavalath.  Players must make a line of five of their pieces to win, but will lose if they make a line of 4 first.Played on a square grid (8x8 or larger) with two players. Players alternate placing one stone of their colour on the board on any empty point.  If a player makes a line of five pieces, either orthogonally or diagonally, they win; but if they make a line of four pieces, they lose. Played on a size 8 board.
(game "Fivalath" 
    (players 2) 
    (equipment { 
        (board (square <Board:size>) use:Vertex) 
        (piece "Ball" Each) 
    }) 
    (rules 
        
        (play (move Add (to (sites Empty))))
        
        (end {
            (if (is Line 5 All) (result Mover Win))
            (if (is Line 4 All) (result Mover Loss))
        })
    )
)

Construct a Ludii game based on the following description
Kawade Kelia is a race game that was played in Sri Lanka in the late nineteenth century.One horizontal row of eleven squares, the central square marked with an X. From this central square, extending vertically, eleven more squares, making a row of twelve in total. The fifth square and the final square in this row are marked with an X. An arc of five squares extend left and down from the final square of the vertical row. From the fifth row of the vertical row, a square with twelve squares per side. The corner squares are marked with an X, the central two squares of the left, right, and top side are marked with one X across both squares. Two or four players; when there are four players they play on two teams of two. Three cowrie shells per player, used as pieces. Six cowrie shells used as dice; the throws = the number of mouths that land face up. Players move their pieces onto the board and around the circuit according to the throws of the cowries. Teams start on opposite ends of the bottom row of squares, up the vertical line to the square, in opposite directions around the square, then up the remaining part of the vertical row and down the arc, and off the board. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is sent back and must enter the board again. Pieces are safe from being sent back if they rest on a marked square. The first team to remove all of their pieces from the board wins.  The game involves 2 players.
(game "Kawade Kelia" 
    (players <Player:num>)
    (equipment {
        (board 
            (merge {
                (rectangle 1 12)
                (shift 3.5 3.25 (scale 1 1.5 (rotate 90 (rectangle 1 4))))
                (shift 0 7 (rectangle 1 12))
                (shift -5.5 12.5 (rotate 90 (rectangle 1 12)))
                (shift 2.5 10.5 (rotate 90 (rectangle 1 6)))
                (shift 5.5 12.5 (rotate 90 (rectangle 1 12)))
                (shift 0 18 (rectangle 1 11))
                (shift 1 11 (rotate 45 (rectangle 1 4)))
                (shift 5 13
                    (graph
                        vertices:{ { 0 0 } {0 1} {-0.94 0.26 } {-0.23 -0.44} } 
                        edges:{ {0 1} {1 2} {2 3} {3 0}} 
                    )
                )
            })
            {
            (track "Track1" "71,0,E5,N5,E,N,W,S,E5,N,WSW,SW,End" P1 directed:True)
            (track "Track2" "72,11,W6,N5,W,N,E,S,W6,N,WSW,SW,End" P2 directed:True)
            <Player:trackP3P4>
        })
        (piece "Paddle" Each
            (if ("IsEndTrack" "SiteToMoveOnTrack")
                "RemoveAPiece"
                (if ("IsNotOffBoard" "SiteToMoveOnTrack") 	 			
                    (if (or {
                            (is Empty "SiteToMoveOnTrack")
                            ("IsFriendAt" "SiteToMoveOnTrack")
                            (and 
                                ("IsEnemyAt" "SiteToMoveOnTrack")
                                (not (is In "SiteToMoveOnTrack" (sites "Protect")))
                            )
                        })
                        (move 
                            (from (from) level:(level))
                            (to 
                                "SiteToMoveOnTrack" 
                                "CaptureEnemyPiece"
                            )
                        )
                    )
                )
            )
        )
        ("StickDice" 6)
        (hand Each)
        (regions "Protect" (sites {5 17 19 27 41 57 46 62 63 34 35 51 52}))
    })
    (rules
        (start {
            (place Stack "Paddle1" (handSite P1) count:3)
            (place Stack "Paddle2" (handSite P2) count:3)
            <Player:startP3P4>
        })
        (play 
            ("RollMove"
                (or (forEach Piece) (forEach Piece container:(mover) top:True))
            )
        )
        (end {
            <Player:end>
        })
    )
)

Construct a Ludii game based on the following description
Gåsetavl is a hunt game played in Denmark since at least the nineteenth century. Twenty squares arranged in a cross shape, with diagonals in each square. The pieces are played on the intersections of the lines. Two foxes are placed on the outer corners of one of the arms of the cross, and twenty geese are placed on the points in the opposite arm, as well as the first two long lines in the perpendicular arms. Players alternate turns moving a piece to an empty spot along the lines on the board. The geese cannot move backward. The foxes may hop over a goose to an empty adjacent spot immediately on the opposite side of it along the lines on the board. The geese win by blocking the foxes from being able to move. The foxes win by capturing all the geese. 
(game "Gasetavl"
    (players 2)
    (equipment {
        ("CrossBoard" 3 7 use:Vertex diagonals:Solid)
        (piece "Fox" P1 (or ("HopCapture") ("StepToEmpty")))
        (piece "Geese" P2 N ("StepToEmpty" (directions {Rightward Forwards Leftward})))
    })
    (rules 
        (start {
            (place "Fox1" (sites {"G9" "I7"}))
            (place "Geese2" 
                (sites {"A3" "B2" "C1" "B4" "C3" "D2" "A7" "B6" "C5" "D4" 
                    "E3" "F2" "G1" "B8" "C7" "D6" "E5" "F4" "G3" "H2"
                    }
                )
            )
        })
        (play (forEach Piece))
        (end ("NoMovesP1NoPiecesP2")) 
    )
)

Construct a Ludii game based on the following description
Louis XVI is a tafl style game in which players must try to help King Louis XVI escape from an angry mob.The king player receives one king piece and an army of 18. The mob player gets 26 pieces. Play is set on a star shape board. Captures are done by jumping adjacent enemy pieces and are compulsory but not multiple. Only the King can move to one of the star point cells (the blue cells). If no possible capture, a player moves a pawn to an adjacent empty cell.
        The mob wins if the king is captured and the king player wins by getting the king piece to any of the points of the star. 
(game "Louis XVI"
    (players 2)
    (equipment {
        (board 
            (remove
                (hex 7)
                cells:{
                0 1 2 4 5 6 7 8 9 12 13 14 15 16 22 23
                57 45 70 34 58 82 46 71 69 81 56 44 68 92 55 80
                120 121 122 124 125 126 112 113 114 117 118 119 103 104 110 111
                }
            )
        )
        (piece "Pawn" Each)
        (piece "King" P2)
        (regions "GoalKing" (difference (sites Corners) (expand (sites Centre) steps:4)))
    })
    (rules
        (start {
            (place "Pawn1" (difference (expand (sites Centre) steps:4) (expand (sites Centre) steps:3)))
            (place "Pawn2" (difference (expand (sites Centre) steps:2) (sites Centre)))
            (place "Pawn1" (difference (expand (sites Centre) steps:4) (expand (sites Centre) steps:3)))
            (place "King2" (sites Centre))
        })
        (play
            (priority {
                (or
                    (forEach Piece "Pawn"
                        (move Hop
                            (between if:("IsEnemyAt" (between)))
                            (to if:(and (not (is In (to) (sites "GoalKing"))) (is Empty (to)))
                                (apply (remove (between)))
                            )
                        )
                    )
                    (forEach Piece "King"
                        (move Hop
                            (between if:("IsEnemyAt" (between)))
                            (to if:(is Empty (to)))
                        )
                    )
                )
                (or
                    (forEach Piece "Pawn"
                        (move Step
                            (to if:(and (not (is In (to) (sites "GoalKing"))) (is Empty (to)))
                                (apply (remove (between)))
                            )
                        )
                    )
                    (forEach Piece "King" ("StepToEmpty"))
                )	
            })
        )
        (end { 
            (if ("IsOffBoard" (where "King" P2)) (result P1 Win))
            ("PieceTypeReachWin" "King2" (sites "GoalKing") P2)
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Suffragetto" 
    (players 2)
    (equipment { 
        (board (square 17))
        (regions "House of Commons" Shared (sites {"H14" "I14" "J14" "H13" "I13" "J13"}))
        (regions "Albert Hall" Shared (sites {"H4" "I4" "J4" "H5" "I5" "J5"}))
        (regions "The Arena" Shared
            (difference
                (expand (expand (sites {"E17"}) steps:8 E) steps:16 S)
                (union (sites "House of Commons") (sites "Albert Hall"))
            )
        )
        (regions "The Free Zone" Shared
            (union {
                (expand (sites { "P5" })steps:6 N)
                (expand (sites { "B13" })steps:6 S)
                (expand (sites { "C17" "D17" "N17" "O17" })steps:16 S)
            })
        )	
        (regions "Hospital Grounds" Shared (expand (sites {"P17"}) steps:5 S))			
        (regions "Prison Yard" Shared (expand (sites {"B1"}) steps:5 N))			
        (regions "Prison" Shared 
            (union
                (expand (sites {"A1"}) steps:16 N)
                (expand (sites {"B17"}) steps:3 S)
            )
        )			
        (regions "Hospital" Shared 
            (union
                (expand (sites {"Q1"}) steps:16 N)
                (expand (sites {"P1"}) steps:3 N)
            )
        )
        ("PieceCore" "Suffragette" P1 "House of Commons" "Prison Yard" "Hospital")
        ("PieceCore" "Policeman" P2 "Albert Hall" "Hospital Grounds" "Prison")
        ("PieceCore" "Leader" P1 "House of Commons" "Prison Yard" "Hospital")
        ("PieceCore" "Inspector" P2 "Albert Hall" "Hospital Grounds" "Prison")
    }) 
    (rules 
        (start {
            (place "Suffragette1" {57 61 73 74 78 79 88 89 90 91 92 94 95 96 97 98} state:("MinorPiece"))
            (place "Policeman2" {227 231 209 210 214 215 196 197 198 199 200 194 193 192 191 190} state:("MinorPiece"))
            (place "Leader1" {87 93 99 72 80} state:("MajorPiece"))
            (place "Inspector2" {189 195 201 208 216} state:("MajorPiece"))
        })
        (play
            (priority {
                (if (< 0 (var "ReleaseCountdown")) 
                    (if (is Odd (var "ReleaseCountdown"))
                        (move (from ("ReleaseCandidatesByState" (var "LastState"))) (to ("ReleaseZone"))
                            (then
                                (and
                                    (set Var "LastState" -2)
                                    (set Var "ReleaseCountdown" (- (var "ReleaseCountdown") 1))
                                )
                            )
                        )
                        (or
                            (move (from ("ReleaseCandidates")) (to ("ReleaseZone"))
                                (then
                                    (and
                                        (set Var "LastState" (state at:(last To)))
                                        (set Var "ReleaseCountdown" (- (var "ReleaseCountdown") 1))
                                    )
                                )
                            )
                            (move Pass
                                (then
                                    (and
                                        (set Var "LastState" -2)
                                        (set Var "ReleaseCountdown" 0)
                                    )
                                )
                            )
                        )					
                        
                    )
                )
                (if (is Decided "Release")
                    (move (from ("ReleaseCandidates")) (to ("ReleaseZone"))
                        (then
                            (and
                                (set Var "LastState" (state at:(last To)))
                                (set Var "ReleaseCountdown" 11)
                            )
                        )
                    )
                )				
                (if (is Proposed "Release")
                    (or
                        (move Vote "Release")
                        (move Vote "No")
                    )
                )				
                (if "SameTurn"
                    (or
                        (if (= (id P1) (id Mover))
                            ("MoveHop"
                                ("MiddleOfBoardPlusExtra" "Prison Yard")
                                ("MiddleOfBoardPlusExtra" "House of Commons")
                                "Hospital"
                                (then (moveAgain))
                                (last To)
                            )
                            ("MoveHop"
                                ("MiddleOfBoardPlusExtra" "Hospital Grounds")
                                ("MiddleOfBoardPlusExtra" "Albert Hall")
                                "Prison"
                                (then (moveAgain))
                                (last To)
                            )
                        )
                        (move Pass)
                    )
                    (or
                        (if ("IsExchangePossible")
                            (move
                                Propose "Release"
                                (then
                                    (do
                                        (note "Release prisoners?" to:Next)
                                        next:(vote "Release")
                                    )
                                )
                            )
                        )
                        (forEach Piece)
                    )
                )
            })
        )
        (end {
            (if (= 6 (count Pieces P1 in:(sites "House of Commons"))) (result P1 Win))
            (if (= 6 (count Pieces P2 in:(sites "Albert Hall"))) (result P2 Win))
        })
    )
)
Suffragetto is a contest of occupation between two opposing factions, the Suffragettes and the Police. The goal of the Suffragettes is to break past Police lines and enter the House of Commons. At the same  time, The  Suffragettes  must  also  prevent  the  Police  from  entering  Albert  Hall, an  oft-used meeting space of the Women’s Social and Political Union. It is the Police’s duty to break up a meeting of the Suffragettes, currently being held in Albert Hall, all the while, preventing the Suffragettes from entering the House of Commons. The game is won by whoever first succeeds in introducing six members into the building guarded by its opponents. 

Describe the mechanics of the following Ludii game
(game "Onyx" 
    (players 2) 
    (equipment { 
        (board 
            (keep
                (rotate -45 (subdivide (tiling T33434 7 7) min:4))
                (poly {{-6.5 1.75} {-6.5 12.75} {4.5 12.75} {4.5 1.75}}) 
            ) 
            use:Vertex
        ) 
        (piece "Disc" Each) 
        (regions P1 {(sites Side W) (sites Side E) })
        (regions P2 {(sites Side N) (sites Side S) })
    }) 
    (rules
        (start {
            (place "Disc1" (sites {15 24 119 128}))
            (place "Disc2" (sites {20 27 116 123}))
        })
        (play 
            (move Add
                (to
                    (forEach (sites Empty) 
                        if:(if (is In (site) ("MidpointSquares")) ("AllCornersSquareEmpty") True)
                    )
                )
                (then
                    (forEach Site ("MidpointSquares")
                        (if (and { 
                                (is Empty (site))
                                (is In (last To) (sites Around (site))) 
                                ("AllCornersSquareOccupied")
                                (= 2 ("NumEnemyCorners"))
                                (= 2 ("NumEnemyOppositeCorners"))
                            })
                            (remove
                                (forEach 
                                    (sites Around (site)) 
                                    if:("IsEnemyAt" (site))
                                )
                            )
                        )
                    )
                )
            )
        )
        (end (if (is Connected Mover) (result Mover Win))) 
    )
)
Onyx is a two-player abstract strategy board game invented by Larry Back in 1995. The game features a rule for performing captures, making Onyx unique among connection games.The Onyx board is a grid of interlocking squares and triangles, with pieces played on the points of intersection (as in Go). Each side of the board comprises twelve points.The initial setup has four black pieces and four white pieces pre-placed. Black moves first by placing a black piece on any empty point of the board. White follows suit. Turns continue to alternate. A piece can be placed on the midpoint of a square only if all four corners of that square are currently unoccupied. Once placed, pieces do not move. Captured pieces are immediately removed from the game.
            
            The rule for capturing allows a player to capture two enemy pieces in a single turn. All of the following conditions must be met:
            - the two enemy pieces occupy opposite corners of a square;
            - a third corner of the square is already occupied by a piece owned by the capturing player;
            - the square's midpoint is unoccupied.
            
            The capture is executed by placing a piece on the remaining unoccupied corner of the square. If the capturing move also simultaneously completes a second square on the board where the same conditions prevail, then the move results in the capture of four enemy pieces instead of two.
            
        Black tries to connect the two horizontal (black) sides with an unbroken chain of black pieces, while White tries to connect the two vertical (white) sides with an unbroken chain of white pieces. The first to do so wins the game. 

Construct a Ludii game based on the following description
Al-Biruni, a tenth century Persian scholar, wrote about this four-player version of Chaturanga as played in India during the tenth century.Four players. Played with two six-sided dice. A throw of 5 is counted as 1, a throw of 6 is counted as 4.Throws move the pieces as follows: 1: Pawn or King, which move the same as in Shatranj; 2: Rook, which jumps to the second diagonal space; 3: Horse, which moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; 4: Elephant, which moves orthogonally any distance. Kings may be captured. Pieces are assigned values, which award the players stakes at the end of the game: King=5, Elephant=4, Horse=3, Rook=2, Pawn=1. If a player captures all of the other Kings and is still in possession of their own King, the score awarded is 54. The player with the most points wins. 
(game "Four-Player Chaturanga (al-Biruni)" 
    (players {(player N) (player W) (player S) (player E)}) 
    (equipment { 
        (board (square 8))
        (dice d:6 from:1 num:2)
        
        (piece "Pawn" Each
            (or 
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
            )
        )
        (piece "Rook" Each
            (move Hop 
                Diagonal 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndAddScore"
                )
            )
        )
        (piece "Knight" Each
            (move Leap 
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndAddScore"
                ) 
            )
        )
        (piece "Elephant" Each
            (move Slide 
                Orthogonal 
                (between if:(is Empty (between))) 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndAddScore" 
                )
            )
        ) 
        (piece "King_noCross" Each
            (move Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndAddScore" 
                )
            )
        )
        (map "Throw" {(pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 1) (pair 6 4)})
    }) 
    (rules 
        (start { 
            (place "Pawn1" {"A2" "B2" "C2" "D2"} value:1)
            (place "Pawn2" {"G1" "G2" "G3" "G4"} value:1)
            (place "Pawn3" {"H7" "G7" "E7" "F7"} value:1)
            (place "Pawn4" {"B5" "B6" "B7" "B8"} value:1)
            (place "Rook1" coord:"A1" value:2) (place "Rook2" coord:"H1" value:2) (place "Rook3" coord:"H8" value:2) (place "Rook4" coord:"A8" value:2) 
            (place "Knight1" coord:"B1" value:3) (place "Knight2" coord:"H2" value:3) (place "Knight3" coord:"G8" value:3) (place "Knight4" coord:"A7" value:3) 
            (place "Elephant1" coord:"C1" value:4) (place "Elephant2" coord:"H3" value:4) (place "Elephant3" coord:"F8" value:4) (place "Elephant4" coord:"A6" value:4) 
            (place "King_noCross1" coord:"D1" value:5) (place "King_noCross2" coord:"H4" value:5) (place "King_noCross3" coord:"E8" value:5) (place "King_noCross4" coord:"A5" value:5) 
        })
        
        (play 
            ("RollEachNewTurnMove" "PlayAPiece"
                (then 
                    (if 
                        (can Move "PlayAPiece")
                        (moveAgain)
                    )
                )
            )
        )
        
        (end
            (if (= 
                    (count Pieces Mover) 
                    (- (count Pieces All) 2) 
                )
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Brandub is a game from medieval Ireland that is mentioned in several Irish texts. These documents seem to outline an asymmetrical game with a special piece in the center, similar to other tafl games such as Tablut. It is uncertain what the size of the board was, or what form the pieces took.King piece. Four defenders with the king. King starts in the central space, with one defender on each side.  The rules are describing with the Nielsen ruleset.
(game "Brandub" 
    (players 2) 
    (equipment { 
        (board (square 7)) 
        (regions "Fortresses" (sites Corners))
        
        (piece "Thrall" P1 
            (move Slide
                Orthogonal 
                (to (apply if:(not "CentreOrFortress")))
                (then 
                    (or {
                        ("Custodial" "Thrall2")
                        (surround 
                            (from (last To))
                            Orthogonal
                            (between if:"JarlAndExpandedCentre" "JarlIsCaptured")
                            (to if:"FriendOrCentre")
                        )
                        (custodial 
                            (from (last To)) 
                            Orthogonal 
                            (between (max 1) if:"JarlButNotTheExpandedCentre" "JarlIsCaptured")
                            (to if:"FriendOrFortress")
                        )
                    })
                )
            )
        )
        (piece "Thrall" P2 
            (move Slide
                Orthogonal 
                (to (apply if:(not "CentreOrFortress"))) 
                (then ("Custodial" "Thrall1")) 
            ) 
        ) 
        (piece "Jarl" P2 
            (move Slide
                Orthogonal 
                (to (apply if:(not (= (to) (centrePoint))))) 
                (then ("Custodial" "Thrall1")) 
            )
        )
        }
    ) 
    (rules 
        (start { 
            (place "Thrall1" {"D1" "D2" "A4" "B4" "F4" "G4" "D6" "D7"})
            (place "Thrall2" {"D3" "C4" "E4" "D5"})
            (place "Jarl2" (centrePoint))
        })
        
        (play (forEach Piece)) 
        
        (end {
            ("PieceTypeReachWin" "Jarl2" (sites "Fortresses") P2)
            (if "JarlWasCaptured" (result P1 Win))
        })
    )
)

Construct a Ludii game based on the following description
This game, the name for which was not recorded, was played in the Orissa region of India. Four tigers play against twenty goats.5x5 board, played on intersections of the lines, with diagonals for each quadrant of the board. One player plays as four tigers, the other as twenty goats. The tigers begin, two on the top two corners of the board, and two in the centers of the two bottom quadrants. Four of the goats are placed on any available points. The tigers move first, to an empty adjacent spot along the lines on the board. The player playing as the goats places one of the remaining goats on any available point. The goats cannot move until all of the goats are placed. Once they are all placed, the goats move as the tigers do. The tigers alone may capture a goat by hopping over it to an empty spot immediately opposite a goat. The tigers win by capturing all the goats; the goats win by blocking the tigers from being able to move. 
(game "Orissa Tiger Game (Four Tigers)" 
    (players 2)
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Goat" P1 ("StepToEmpty"))
        (piece "Tiger" P2 (or ("StepToEmpty") ("HopCapture")))
        (hand P1)
    }) 
    
    (rules 
        (start { 
            (place "Goat1" (handSite P1) count:20)
            (place "Tiger2" (sites {"A5" "E5" "B2" "D2"}))
        })
        
        phases:{
        (phase "Placement" P1 
            (play (move (from (handSite P1)) (to (sites Empty)) (then (if (< 16 (count Cell at:(handSite P1))) (moveAgain))))) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement") 
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("NoMovesP2NoPiecesP1"))
    )
)

Construct a Ludii game based on the following description
A version of Shogi played on hexagonal cells.Piece movement has been updated to work on hexagonal cells, but all other rules remain the same. 
(game "Hexshogi" 
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        (board (rotate 90 (remove (hex Rectangle 9 11) cells:{0 10 21 31 42 52 63 73 84 94})))
        
        
        (piece "Osho" Each ("StepMove" All))
        
        
        (piece "Fuhyo" Each 
            ("StepMove" 
                Forward 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InLastRank" (last To)) 
                            ("Promote") 
                            (moveAgain) 
                        ) 
                    ) 
                )
            )
        )
        
        
        (piece "Ginsho" Each "SilverMove")
        
        
        (piece "Hisha" Each ("SlideMove" Orthogonal "CanPromote"))
        
        
        (piece "Kakugyo" Each ("SlideMove" Diagonal "CanPromote"))
        
        
        (piece "Keima" Each 
            (move Leap
                "KnightWalk"
                rotations:False
                (to 
                    if: (not ("IsFriendAt" (to))) 
                    (apply 
                        if:("IsEnemyAt" (to))
                        (add 
                            (piece (mapEntry "Captured" (what at:(to)))) 
                            (to (mapEntry "Where" (what at:(to))))
                        )
                    )
                )
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InTwoFurthestRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                ) 
            )
        )
        
        
        (piece "Kyosha" Each
            ("SlideMove" 
                Forward 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InLastRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                )
            ) 
        )
        
        
        (piece "Kinsho" Each "GoldMove")
        
        
        (piece "Tokin" Each "GoldMove")
        
        
        (piece "Narigin" Each "GoldMove")
        
        
        (piece "Ryuo" Each (or ("SlideMove" Orthogonal) ("StepMove" Diagonal)))
        
        
        (piece "Ryuma" Each (or ("SlideMove" Diagonal) ("StepMove" Orthogonal)))
        
        
        (piece "Narikei" Each "GoldMove")
        
        
        (piece "Narikyo" Each "GoldMove")
        
        (regions "LastRankP1" P1 (forEach (sites Board) if:(= (site) (ahead (site) N))))
        (regions "LastRankP2" P2 (forEach (sites Board) if:(= (site) (ahead (site) S))))
        (regions "TwoFurthestRankP1" P1 (forEach (sites Board) if:(= (site) (ahead (site) steps:2 N))))
        (regions "TwoFurthestRankP2" P2 (forEach (sites Board) if:(= (site) (ahead (site) steps:2 S))))
        (regions "Promotion" P1 (forEach (sites Board) if:(= (site) (ahead (site) steps:3 N))))
        (regions "Promotion" P2 (forEach (sites Board) if:(= (site) (ahead (site) steps:3 S))))
        (map "Where" {
            (pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) 
            (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) 
            (pair (id "Hisha" P1) (handSite P2 2)) (pair (id "Hisha" P2) (handSite P1 2)) 
            (pair (id "Kakugyo" P1) (handSite P2 3)) (pair (id "Kakugyo" P2) (handSite P1 3)) 
            (pair (id "Keima" P1) (handSite P2 4)) (pair (id "Keima" P2) (handSite P1 4)) 
            (pair (id "Kyosha" P1) (handSite P2 5)) (pair (id "Kyosha" P2) (handSite P1 5)) 
            (pair (id "Kinsho" P1) (handSite P2 6)) (pair (id "Kinsho" P2) (handSite P1 6)) 
            (pair (id "Tokin" P1) (handSite P2)) (pair (id "Tokin" P2) (handSite P1)) 
            (pair (id "Narigin" P1) (handSite P2 1)) (pair (id "Narigin" P2) (handSite P1 1)) 
            (pair (id "Ryuo" P1) (handSite P2 2)) (pair (id "Ryuo" P2) (handSite P1 2)) 
            (pair (id "Ryuma" P1) (handSite P2 3)) (pair (id "Ryuma" P2) (handSite P1 3)) 
            (pair (id "Narikei" P1) (handSite P2 4)) (pair (id "Narikei" P2) (handSite P1 4)) 
            (pair (id "Narikyo" P1) (handSite P2 5)) (pair (id "Narikyo" P2) (handSite P1 5)) 
        })
        (map "Captured" { 
            (pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) 
            (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) 
            (pair (id "Hisha" P1) (id "Hisha" P2)) (pair (id "Hisha" P2) (id "Hisha" P1)) 
            (pair (id "Kakugyo" P1) (id "Kakugyo" P2)) (pair (id "Kakugyo" P2) (id "Kakugyo" P1)) 
            (pair (id "Keima" P1) (id "Keima" P2)) (pair (id "Keima" P2) (id "Keima" P1)) 
            (pair (id "Kyosha" P1) (id "Kyosha" P2)) (pair (id "Kyosha" P2) (id "Kyosha" P1)) 
            (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) 
            (pair (id "Tokin" P1) (id "Fuhyo" P2)) (pair (id "Tokin" P2) (id "Fuhyo" P1)) 
            (pair (id "Narigin" P1) (id "Ginsho" P2)) (pair (id "Narigin" P2) (id "Ginsho" P1)) 
            (pair (id "Ryuo" P1) (id "Hisha" P2)) (pair (id "Ryuo" P2) (id "Hisha" P1)) 
            (pair (id "Ryuma" P1) (id "Kakugyo" P2)) (pair (id "Ryuma" P2) (id "Kakugyo" P1)) 
            (pair (id "Narikei" P1) (id "Keima" P2)) (pair (id "Narikei" P2) (id "Keima" P1)) 
            (pair (id "Narikyo" P1) (id "Kyosha" P2)) (pair (id "Narikyo" P2) (id "Kyosha" P1)) 
        })
        (map "Promoted" { 
            (pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) 
            (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) 
            (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) 
            (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2)) 
            (pair (id "Keima" P1) (id "Narikei" P1)) (pair (id "Keima" P2) (id "Narikei" P2)) 
            (pair (id "Kyosha" P1) (id "Narikyo" P1)) (pair (id "Kyosha" P2) (id "Narikyo" P2)) 
        })
        
        (hand Each size:7)
    })
    
    (rules 
        (start { 
            (place "Osho1" coord:"C3") (place "Kinsho1" {"B3" "C2"}) (place "Ginsho1" {"B4" "D2"}) (place "Keima1" {"A4" "D1"}) (place "Kyosha1" {"A5" "E1"}) (place "Kakugyo1" coord:"C5") (place "Hisha1" coord:"E3") (place "Fuhyo1" {"C7" "C6" "D6" "D5" "E5" "E4" "F4" "F3" "G3"})
            (place "Osho2" coord:"K11") (place "Kinsho2" {"K12" "L11"}) (place "Ginsho2" {"J12" "L10"}) (place "Keima2" {"J13" "M10"}) (place "Kyosha2" {"I13" "M9"}) (place "Kakugyo2" coord:"K9") (place "Hisha2" coord:"I11") (place "Fuhyo2" {"G11" "H11" "H10" "I10" "I9" "J9" "J8" "K8" "K7"})
        })
        
        (play
            (if ("SameTurn")
                (or
                    ("Promote")
                    (move Pass)
                )
                (do 
                    (or {
                        (move 
                            (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) 
                            (to (sites Empty))
                        ) 
                        ("PlacePawn" Mover Next)
                        ("PlaceLance" Mover)
                        ("PlaceKnight" Mover) 
                        (forEach Piece) 
                    })
                    ifAfterwards:(not ("IsInCheck" "Osho" Mover))
                )
            )
        )
        
        (end {
            (if (and 
                    ("IsInCheck" "Osho" Next)
                    ("NextCannotMove")
                ) 
                (result Mover Win)
            )
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
Adidada is a two-row mancala-style game board played by the Ewe people of Togo and Ghana.2x6 board with two stores. Four counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in a hole containing one or two counters, thus making it contain two or three counters, these are captured. When this capture is made, other holes with two or three counters in them, in an uninterrupted sequence behind the hole from which the first capture was made, are captured. The player who captures the most counters wins. 
(game "Adidada"
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))		 
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(< 0 (count at:(from)))
                )
                (then 
                    (sow 
                        if:(and 
                            (is In (to) (sites Next)) 
                            (or 
                                (= (count at:(to)) 2) 
                                (= (count at:(to)) 3)
                            )
                        ) 
                        apply:(fromTo 
                            (from (to)) 
                            (to (mapEntry (mover))) 
                            count:(count at:(to))
                        )
                        backtracking:True
                    )
                )
            )
        )
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )	
)

Describe the mechanics of the following Ludii game
(game "Coil" 
    (players 2) 
    (equipment { 
        (board (hex <Boundary:shape> <Board:size>)) 
        (piece "Disc" Each) 
    }) 
    (rules 
        <Boundary:cornerSetup>
        phases: {
        (phase "Opening"
            (play
                (or
                    (or
                        (move Add 
                            (piece (id "Disc" P2)) 
                            (to (sites Empty) if:"NonAdjacent")
                            (then (if (< (count MovesThisTurn) 2) (moveAgain)))
                        )
                        "Skip"
                    )
                    (if (= (count MovesThisTurn) 0)
                        (move Pass
                            (then
                                (if (is Mover P1)
                                    (swap Players P1 P2
                                        (then
                                            (note "Player 1 is now Black. Player 2 is now White." to:All)
                                        )
                                    )
                                    (note "Player 1 remains White. Player 2 remains Black." to:All)
                                    (then
                                        (do
                                            (set NextPlayer (player 1))
                                            next:(set Var 1) 
                                        )
                                    )
                                )
                            )
                    ))
                )
            )
            (nextPhase ("IsPlayingPhase") "Playing")
        )
        (phase "Playing" (play (move Add (to (sites Empty)))))
        }
        (end 
            (forEach Player
                if:(and {("IsPlayingPhase") (= (id Player) (mover)) ("BlackVC")})
                (result Player Win)
            )
        )
    )
)
Coil is an asymmetrical but balanced 2-player connection game on a hexhex7 (or larger) board, where one player tries to form a loop of stones in his color, and the other tries to stop him.  There's a chicken ballot at the start to ensure that the two sides are balanced. Because loops come in a wide range of sizes and shapes, and have many degrees of freedom, the game has rich tactics and strategy.  Small loops threats force players to focus on local battles while large loop threats force them to think globally, and to consider how the local battles fit into the global war. Wise stone placements can contribute to the creation of multiple loops or to defense against multiple loops, leading to layered, multi-dimensional consequences for each turn.This game is played on a hexagonal board made up of hexagonal cells, usually 7 cells per side, although bigger sizes may also be used. Initially the board is empty except for the six corner cells, upon which black stones are placed.  Then the players take it in turns to place 1-3 black stones each turn until one decides to pass; that player then becomes Black, and the other becomes White.  After that, players take it in turns to place one stone of their colour on the board on any empty hex.  If Black forms a continuous loop composed of their pieces, they win; if the board fills up with no loop of Black pieces being formed, White wins.
            
        During the initial chicken ballot phase, you may add stones by clicking on available spaces, or skip the rest of your placements (by choosing the Next Player action).  Alternatively, you may Pass at the start of your turn to take Black.  After that, you and your opponent will alternate playing one stone of your colour per turn, until the board is full or Black forms a loop. Played on a Hexagonal Board, pre-filled corners. The game is played on a board with 7 hexes per side.

Construct a Ludii game based on the following description
Kharbaga is a game played in North Africa, and is related to similar games played there that are similar to Alquerque. The board is a five by five grid.Players decide which colors to play, and who starts first. The board is filled in the beginning with all the players pieces. The only point vacant on the board is the middle point. Each player's pieces are placed on their half of the board, and lined up on the right-hand side of the fifth rank (the middle horizontal line of the grid board). Players alternate turns. Pieces move forward only (straight forward or diagonally forward) one space per turn following the pattern on the board until they are crowned Mullah by reaching the last rank. A non-Mullah piece may capture an enemy piece by hopping over it. The capture can be in any direction. When a piece reaches the other player's rank, it is promoted to Mullah. The Mullah can move and capture in any direction. It can also move any number of spaces. The Mullah can also capture an enemy piece from any distance, and land anywhere behind the captured piece provided there are no other pieces (friendly or not) within the spaces of the leap. If a piece piece reaches the other player's rank as an intermediate step of a capturing sequence, the piece does not get promoted to Mullah. The player to capture all of the opponent's pieces wins. 
(game "Kharbaga"
    (players {(player S) (player N)})
    (equipment {
        (board (square 5 diagonals:Solid) use:Vertex)
        (piece "Counter" Each 
            (or
                ("StepForwardsToEmpty")
                ("HopCapture")
                (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
            )
        )
        (piece "DoubleCounter" Each
            (or
                ("HopCaptureDistance")
                (move Slide)
            )
        )
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
    })
    
    (rules 
        ("BeforeAfterCentreSetup" "Counter2" "Counter1")
        (play (forEach Piece)) 
        (end (if (no Moves Mover) (result Next Win))) 
    )
)

Construct a Ludii game based on the following description
SNORT (Simon NORTon) is played on an 8 x 8 grid of squares.Two players, black and white, take turns dropping pieces onto empty squares (that are not orthogonally adjacent to another enemy's piece) until no more moves are available. The last player to make a move wins the game. 
(game "Snort"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Cat" P1)
        (piece "Dog" P2)
    })
    (rules
        (play
            (move Add
                (to 
                    (difference (sites Empty) (sites Around (sites Occupied by:Next) Orthogonal))
                )
            )
        )
        (end (if (no Moves Next) (result P1 Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Myles" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" ("BackgammonTracksSameDirectionWithBar")) 
        (dice num:2)
        (map {(pair 1 19) (pair 2 6)}) 
        (piece "Disc" Each) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 12 count:5)
            (place Stack "Disc1" 20 count:4)
            (place Stack "Disc1" 21 count:4)
            (place Stack "Disc1" 14 count:2)
            (place Stack "Disc2" 25 count:3) 
            (place Stack "Disc2" 24 count:3)
            (place Stack "Disc2" 23 count:3)
            (place Stack "Disc2" 22 count:3)
            (place Stack "Disc2" 21 count:3)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (if (all DiceUsed)
                    ("Move" ("NextSiteFromDist6" (site)))
                    (forEach Die
                        if:("DieNotUsed")
                        ("Move" ("NextSiteFrom" (site)))
                        (then (moveAgain))
                    )
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (result Mover Win)
            )
        )
    )
)
Myles is the name attributed to a fourteenth century English game. It is a European Tables game which is unnamed in the manuscript describing its rules. 2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Both players begin on the same side of the board, one player (who plays first) with five pieces on the rightmost point of the starting row, four on the fifth and sixth points and two in the eleventh point in the opposite row. The other player has three pieces each on the right five points in the second row. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. On each throw the player also plays a throw of 6 in addition to the throw presented by the dice. Pieces move in an anti-clockwise direction around the board. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the leftmost point in the row where the pieces began. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins. 

Construct a Ludii game based on the following description
Squava is a Yavalath variant on a 5x5 board.Players alternate turns placing one of their pieces on the board. The first person to make a line of four, but without first making a line of three, wins. 
(game "Squava" 
    (players 2) 
    (equipment { 
        (board (square 5)) 
        (piece "Marker" Each) 
    }) 
    (rules 
        (meta (swap))
        (play (move Add (to (sites Empty))))
        (end {
            (if (is Line 4) (result Mover Win))
            (if (is Line 3) (result Mover Loss)) 
        }) 
    )
)

Construct a Ludii game based on the following description
Issiren is a capturing game with dice played in the Illizi region of Algeria by the Kel Ajjer Tuareg people. 4x12 board. Twelve pieces per player, which begin one in each space in the row closest to the player. Six stick dice, green on one side and white on the other. The value of the throws equals the number of green faces, with the following exceptions: four green faces up allows a piece to be moved for the first time and a move of 1, plus another throw is granted; six white faces = 4 plus another throw; six green = 6 plus another throw; five white faces = move 5 plus another throw. Pieces move from right to left in the player's home row, then into the second row, moving left to right, then into the third row moving right to left, and then into the opponent's home row moving left to right, then back into the third row moving right to left, to the second row moving left to right, and then back into the player's home row moving right to left. If a player's piece lands on a space occupied by one of the opponent's pieces, the opponent's piece is captured. The player who captures all of the opponent's pieces wins. 
(game "Issiren"
    (players 2) 
    (equipment { 
        (board 
            (rectangle 4 12)
            {
            (track "Track1" "11,W,N1,E,N1,W,N1,E,S1,W,S1,E" loop:True P1)
            (track "Track2" "36,E,S1,W,S1,E,S1,W,N1,E,N1,W" loop:True P2)
            }
        )
        ("StickDice" 6)
        (piece "Marker" Each
            (move 
                (from
                    (from)
                    if:(if ("ActivatedPiece") 
                        True
                        ("AllowToActivate")
                    )
                )
                (to
                    ("NextSiteOnTrack" ("ThrowValue"))
                    if:(not ("IsFriendAt" (to)))
                    (apply
                        (if ("IsEnemyAt" (to))
                            (remove (to))
                        )
                    )
                )
                (then 
                    (if (= 1 (state at:(last To)))
                        ("ActivatePiece")
                    )
                )
            )
        )
        (map {(pair 0 4) (pair 1 5) (pair 2 2) (pair 3 3) (pair 4 1) (pair 5 5) (pair 6 6)})
    }) 
    
    (rules 
        (start { 
            (place "Marker1" (sites Bottom) state:1)
            (place "Marker2" (sites Top) state:1)
        })
        
        (play 
            ("RollMove" 
                (forEach Piece)
                (then
                    (if ("AllowToReplay") 
                        (moveAgain)
                    )
                )
            )
        )
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Main Tapak Empat is a hunt game played by the Minangkabau people of Malaysia. In it, One player plays as two tigers who try to capture 24 goats.5x5 intersecting lines, with diagonals in each 3x3 quadrant. One player plays with two tigers, which begin on the central spot. The other player plays as 24 goats. The goats play first, and may place a piece on any empty spot. The tigers move to an empty spot any distance along the lines on the board, or may hop over an adjacent goat to capture it, provided there is an empty spot immediately on the other side of the goat. Once all of the goats are placed, they may move along the lines to an empty adjacent spot. If the tigers cannot move, the goats win. The tigers win by capturing all the goats. 
(game "Main Tapak Empat"
    (players 2)
    (equipment {
        ("AlquerqueBoard" 5 5)
        (piece "Goat" P1 "StepToEmpty")
        (piece "Tiger" P2 (or "HopCapture" "StepToEmpty"))
        (hand P1)
    })
    (rules 
        (start {
            (place Stack "Tiger2" (centrePoint))
            (place Stack "Goat1" (handSite P1) count:24)
        })
        
        phases:{ 
        (phase "Placement" P1 
            (play 
                (move 
                    (from (handSite P1)) 
                    (to (sites Empty))
                )
            ) 
            (nextPhase ("HandEmpty" P1))
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("NoMovesP2NoPiecesP1"))
    )
)

Describe the mechanics of the following Ludii game
(game "Koro" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 <Row:size> store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (map "Hogon" {<Row:hogon>})
        (regions P1 (sites Bottom))     
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start (set Count <Start:numSeeds> to:(sites Track)))
        
        (play 
            (if (<= <Start:usingHogon> (count at:(mapEntry "Hogon" Mover)))
                (move Select
                    (from
                        (mapEntry "Hogon" Mover)
                    )
                    (then (sow))
                )
                (if ("NoOwnedHoleWithMoreThanOneSeedExceptHogon" Mover)
                    (if ("IsOlderPlayer")
                        (move Pass)
                        (do
                            (if ("NoOwnedHoleWithMoreThanOneSeedExceptHogon" Next)
                                (forEach Site (difference (sites Next) (mapEntry "Hogon" Next))
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry "Hogon" Mover))
                                        )
                                    )
                                )
                            )
                            next:(move Select
                                (from
                                    (mapEntry "Hogon" Mover)
                                    if:(< 1 (count at:(from)))
                                )
                                (then (sow))
                            )
                        )
                    )
                    (move Select
                        (from
                            (difference (sites Mover) (mapEntry "Hogon" Mover))
                            if:(< 1 (count at:(from)))
                        )
                        (then (sow))
                    )
                )
            )
        )
        
        (end 
            (forEach Player
                if:("NoOwnedHoleWithMoreThanOneSeed" Player)
                (result Player Loss)
            )
        )
    )
)
Koro is a two-row mancala-style board game played by the Dogon people of Mali. In it, the player's rightmost hole is a reserve, from which counters are redistributed periodically throughout the game.2x6 board. Four counters per hole. Each player's rightmost hole is their \ Each row has 5 holes. Each hole has initially 4 seeds.

Construct a Ludii game based on the following description
The game is played on a 8x8 square board. The game has similarities with Othello but the main goal is to create a line of 8 of either colour in a specific direction.DROP - On each turn, each player picks any stone of either color, and changes its color. Then, like in Othello, flips all stones of the other color that are between that stone and the next of same color, in any orthogonal or diagonal direction.
            
            GOAL - One player wins if it is able to make an horizontal 8 in-a-row of stones of any color. The other player wins by making a vertical 8 in-a-row.
            
        If, after a move, there are one horizontal and one vertical 8 in-a-row, the player that made the move losses. 
(game "Minefield" 
    (players 2) 
    (equipment { 
        (board (square 8))
        (piece "Disc" Neutral (flips 1 2))
    }) 
    (rules 
        
        (start {
            (place "Disc0" (sites Phase 0) state:1)
            (place "Disc0" (sites Phase 1) state:2)
        })
        
        (play 
            (move Select
                (from (sites Board))
                (then
                    (flip (last To)
                        (then ("ReverseBoundedPieces"))
                    )
                )
            )
        )
        
        (end {
            (if (and ("HorizontalLine") ("VerticalLine"))
                (result Mover Loss)
            )
            (if ("HorizontalLine")
                (result P1 Win)
            )
            (if ("VerticalLine")
                (result P2 Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Ring is a game played by the Warlpiri people of Australia in the mid-twentieth century. Old men described it has always having been played in the town. It was originally reported as a likely imported game, but the ubiquity of alignment games worldwide and the fact that alignment games on circular boards are rare elsewhere show that the game is probably an indigenous development.A circle with eight radii. Three pieces per player. Each player has three pieces, which must start on the outer ring adjacent to each other. Players alternate turns moving a piece to an empty point along the lines of the board. The player who makes a line of three through the center of the circle wins. 
(game "Ring"
    (players 2) 
    (equipment { 
        (board (concentric {1 8}) use:Vertex)
        (hand Each)
        (piece "Marker" Each "StepToEmpty") 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (difference (sites Empty) (sites Centre)))
                ) 
            )
            (nextPhase Mover "PlacementAdjacent")
        )
        
        (phase "PlacementAdjacent"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (difference (sites Empty) (sites Centre))
                        if:(is In (to) (sites Around (sites Occupied by:Mover)))
                    )
                ) 
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end (if (is Line 3 through:(centrePoint) what:(mover)) (result Mover Win))) 
    )
)

Construct a Ludii game based on the following description
Tsoro is a four-row mancala-style board game played in Zimbabwe with many regional variations. In this version, certain holes are designated in which a player may end their turn instead of continuing to sow.4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Two holes in each player's outer row are selected as misoro. Typically, the left two holes are chosen. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. If this final hole is one of the misoro, the player may choose to end their turn instead of continuing to sow. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game.
         Players choose the misoro holes. 6 Holes per row.
(game "Misoro Tsoro" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))         
        (regions "Outer" P2 (sites Top))          
        (piece "Seed" Shared)
    }) 
    (rules 
        
        <Start:rules>
        
        phases:{
        <Start:misoroPhase>
        (phase "Playing"
            (play 
                (or
                    (if (and (!= 0 (state at:(var))) ("SameTurn"))
                        (move Pass)
                    )
                    (move Select
                        (from 
                            (if ("SameTurn")
                                "LastHoleSowed" 
                                (sites Mover "Home") 
                            ) 
                            if:(if "AHoleHasMoreThanOneCounter"
                                (> (count at:(from)) 1)
                                (and (= (count at:(from)) 1) (= 0 (count at:("NextHoleFrom" (from) Mover)))) 
                            )
                        )
                        (then 
                            (and
                                (sow
                                    "Track"
                                    owner:(mover)
                                    apply:(if (= (count at:(to)) 1)
                                        (if (is In (to) (sites Mover "Inner"))
                                            (if (> (count at:("OppositePit" (to))) 0) 
                                                (and
                                                    (remove ("OppositePit" (to))) 
                                                    (if 
                                                        (> (count at:("OppositeOuterPit" (to))) 0) 
                                                        (remove ("OppositeOuterPit" (to))) 
                                                    ) 
                                                ) 
                                            ) 
                                        )
                                        (and
                                            (moveAgain)
                                            (set Var (to))
                                        )
                                    )
                                )
                                (forEach Site (sites Board)
                                    (if (!= 0 (state at:(site))) (set State at:(site) (state at:(site))))
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Sik"
    (players <Player:number>)
    (equipment {
        (board 
            (spiral turns:5 sites:86) 
            {
            (track "Track" {85..0} directed:True)
            }
            use:Vertex
        )
        ("StickDice" 4)
        (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)})
        (piece "Stick" Each
            (move
                (from (from) level:(level)
                    if:(or 
                        (= 1 (state at:(from) level:(level)))
                        ("Throw1")
                    )
                )
                (to
                    ("SiteToMoveOnTrack" "Track" ("ThrowValue"))
                    if:True
                )
                (then
                    (if (!= 1 (state at:(last To) level:(last LevelTo)))
                        (set State at:(last To) level:(last LevelTo) 1)
                    )
                )
            )
        )
        (piece "Bankor" Neutral)
    })
    (rules 
        (start {
            (place Stack items:<Player:init> 85)
            (place Stack "Bankor0" 85)
        })
        
        (play 
            ("RollMove"
                (if (= ("Center") (where "Stick" Mover))
                    (if (< (value Player Mover) 2)
                        (move Pass (then (set Value Mover (+ 1 (value Player Mover)))))
                        (if (or (= (mover) ("StateBankor")) (= 0 ("StateBankor")))
                            (if (!= 0 ("ThrowValue")) ("MoveBankor"))
                        )
                    )
                    (if (!= 0 ("ThrowValue")) (forEach Piece))
                )
            )
        )
        (end {
            (forEach Player
                if:(no Pieces Player) 
                (result Player Loss)
            )
            (forEach Player
                if:("BankorPhaseDone")
                (result Player Win)
            )
        })
    )
)
Sik is a race game played in the Tidikelt region of Algeria by women and children. Played on a spiral board made in the sand, players race to the center and try not to be captured by the \Spiral board of any number of spaces, rendered as holes in the sand. The first space is a mound. Any number of players. One piece per player, and one piece, the \ The game has 2 players.

Construct a Ludii game based on the following description
Steven Meyers' BoxOff has the feel of a classic solitaire abstract game. Brightly coloured pieces are distributed on a rectangular grid of squares and removed in pairs of like colour until the board is empty. Start: The game starts with a piece in each cell, which defines the challenge to be solved. 
            
            Play: The player then makes a series of moves, each involving the removal of a pair of same-coloured pieces that occupy a box (rectangle) that includes no other pieces of any colour.
            
        End: The player wins by removing all pieces from the board. Conversely, the player loses if there are no legal moves at any point while pieces remain on the board. 
(game "BoxOff"
    (players 1)
    (equipment {
        (board (rectangle 6 8))
        (piece "Disc1" P1)
        (piece "Disc2" P1)
        (piece "Disc3" P1)
    })
    (rules
        (start {
            (place Random {"Disc1"} count:16)
            (place Random {"Disc2"} count:16)
            (place Random {"Disc3"} count:16)
        })
        (play
            (move Select
                (from (sites Occupied by:All)) 
                (to 
                    (difference (sites Occupied by:All) (from))
                    if:(and {
                        (= (what at:(from)) (what at:(to)))
                        ("IsEmptyRectangle" (from) (to))
                    })
                )
                (then (and (remove (last From)) (remove (last To))))
            )
        )
        (end {
            (if (no Pieces Mover) (result Mover Win))
            (if (no Moves Mover) (result Mover Loss))
        })
    )
)

Construct a Ludii game based on the following description
Greater is a theoretical game designed to demonstrate Monte Carlo resistance. There is one optimal (non-losing) move per turn against a competent opponent.Players take turns removing a piece of their colour whose number is higher than the last piece they removed (free choice of first piece). A player with no legal moves passes. The game ends when neither player has any legal moves and is won by the player with the fewest remaining pieces (draw if equal). 
(game "Greater" 
    (players 2) 
    (equipment { 
        (board (square 4)) 
        (piece "Disc" Each) 
    }) 
    (rules 
        (start {
            (place "Disc1" {"A1"} state:1) 
            (place "Disc1" {"B1"} state:2) 
            (place "Disc1" {"C1"} state:3) 
            (place "Disc1" {"D1"} state:4) 
            (place "Disc1" {"A2"} state:5) 
            (place "Disc1" {"B2"} state:6) 
            (place "Disc1" {"C2"} state:7) 
            (place "Disc1" {"D2"} state:8) 
            (place "Disc2" {"A3"} state:5) 
            (place "Disc2" {"B3"} state:6) 
            (place "Disc2" {"C3"} state:7) 
            (place "Disc2" {"D3"} state:8) 
            (place "Disc2" {"A4"} state:1) 
            (place "Disc2" {"B4"} state:2) 
            (place "Disc2" {"C4"} state:3) 
            (place "Disc2" {"D4"} state:4) 
        })
        
        (play 
            (move Select 
                (from 
                    (forEach 
                        (sites Occupied by:Mover)
                        if:(> (state at:(site)) ("LastStateRemove"))
                    )
                )
                (then
                    (and
                        ("StoreStateRemoved")
                        (remove (last To))	
                    )
                )		
            )
        ) 
        
        (end 
            (if 
                (and (no Moves P1) (no Moves P2))
                (byScore { 
                    (score P1 (- (count Pieces P1))) 
                    (score P2 (- (count Pieces P2)))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Score Four is a 3D version of Connect Four on a 4x4x4 board.Place a piece of your colour each turn. Win with 4 in a row of your colour. 
(game "Score Four" 
    (players 2) 
    (equipment { 
        (board (skew .5 (scale 1 .5 (square 4))))
        (piece "discFlat" Each)
    }) 
    (rules
        (play 
            (move Add 
                (to 
                    (forEach 
                        (sites Board) 
                        if:(< (size Stack at:(site)) 4)
                    )
                ) 
                stack:True
            )
        )
        (end (if (is Line 4 byLevel:True) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Lombard Chess was a type of Chess game played in Lombardy. It shows some early attempts at speeding up the medieval game.8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. The King may leap to the second or third square on its first move, or move as a Knight, and does not hop over an opponent's piece. The King also cannot capture with this move. 1 x Queen: One square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. 2 x Rook: Any number of spaces orthogonally. 2 x Bishop: Two squares diagonally, jumping over the first. Cannot capture another Bishop. 2 x Knight: Moves one space orthogonally and then one space diagonally, jumping over any intervening pieces. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. May move two spaces on its first move. En passant is not allowed. Promoted to Queen when reaching the eighth rank, and may make the Queen's leap on its first move after being promoted. If this promotion is made with the opponent's King at the distance of the extended move, it does not give check on that turn. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a draw. 
         
(game "Lombard Chess"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        (piece "King" Each
            (or
                ("StepToNotFriend")
                (if (= 1 (state at:(from)))
                    (or
                        (move Hop 
                            (between 
                                (range 1 2)
                                if:(not ("IsEnemyAt" (between)))
                            ) 
                            (to  if:(is Empty (to)))
                        )
                        ("LeapToEmpty" "KnightWalk") 
                    )
                )
                ("RememberPieceHasMoved")
            )
        )
        ("ChessRook" "Rook")
        (piece "Bishop" Each
            (move Hop 
                Diagonal 
                (between if:True) 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    (apply 
                        (if ("IsEnemyAt" (to))
                            (remove 
                                (to)
                            )
                        )
                    ) 
                )
            )		
        )
        ("ChessKnight" "Knight")
        (piece "Queen" Each
            (or
                ("StepToNotFriend" Diagonal "RememberPieceHasMoved")	
                (if (= 1 (state at:(from)))
                    (move Hop 
                        Diagonal
                        (between if:True)
                        (to if:(is Empty (to)))
                    )
                )
                ("RememberPieceHasMoved")
            )
        )
        ("ChessPawn" "Pawn"
            (if (is In (from) (sites Start (piece (what at:(from)))))
                ("DoubleStepForwardToEmpty")
            )
            (then
                (if (is In (last To) (sites Mover "Promotion")) 
                    (and
                        (promote (last To) (piece (id "Queen" Mover)))
                        (set State at:(last To) 1)
                    )
                )
            )
        )
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (do (forEach Piece) 
                ifAfterwards:(not ("IsInCheck" "King" Mover))
                (then
                    (if (and (= 1 (state at:(where "King" Next))) ("IsInCheck" "King" Next))
                        ("PieceHasMoved" (where "King" Next))
                    )
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            ("DrawIfNoMoves" Next) 
        })
    )
)

Construct a Ludii game based on the following description
Lasca was invented by Emanuel Lasker in 1911. It is a combination of American checkers and a Russian game Bashni.Played on a 7x7 board. Each player has 11 pieces. they move diagonally one space or can capture opposing pieces by jumping. When captured, a piece is placed underneath the capturing piece, creating columns. When columns are captured, only the piece at the top of the column is taken. Columns are controlled by the player whose piece is on top of the column. When a piece or column reaches the opposite side of the board they become promoted to officer and can move backwards. A player wins by capturing all of the opponent's pieces. The game is played in a Chess board.
(game "Lasca" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        <Board:type> 
        (piece "Counter" Each)
        (piece "CounterStar" Each)
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    
    (rules 
        (start { 
            (place "Counter1" <Board:startP1>)
            (place "Counter2" <Board:startP2>)
        })
        
        (play
            (if "SameTurn"
                (if "IsUnpromoted" 
                    ("HopStackEnemyCaptureTop"
                        (from (last To)) 
                        (directions {FR FL}) 
                        (then 
                            ("PromoteIfReach" (sites Next) "CounterStar"
                                (if 
                                    (can Move
                                        ("HopStackEnemyCaptureTop" 
                                            (from (last To)) 
                                            (directions {FR FL}) 
                                        )
                                    ) 
                                    (moveAgain) 
                                )
                            ) 
                        )
                    ) 
                    ("HopStackEnemyCaptureTop"
                        (from (last To)) 
                        Diagonal 
                        (then 
                            (if 
                                (can Move 
                                    ("HopStackEnemyCaptureTop"
                                        (from (last To)) 
                                        Diagonal 
                                    )
                                ) 
                                (moveAgain) 
                            ) 
                        )
                    ) 
                )
                (priority {
                    (or { 
                        (forEach Piece "Counter" ("Hop" (directions {FR FL})) top:True (then ("PromoteIfReach" (sites Next) "CounterStar")))
                        (forEach Piece "CounterStar" ("Hop" Diagonal) top:True)
                    })
                    
                    (or { 
                        (forEach Piece "Counter" ("StepStackToEmpty" (directions {FR FL})) top:True (then ("PromoteIfReach" (sites Next) "CounterStar")))
                        (forEach Piece "CounterStar" ("StepStackToEmpty" Diagonal) top:True)
                    })
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Kharebga is a capturing game played by children in El Oued, Algeria.5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on an empty space on the board, except in the central space. Captures cannot be made during the placement phase. When all of the pieces have been placed, players alternate turns moving a piece orthogonally any distance. When an opponent's piece is between two of a player's pieces, it is captured. If a player is unable to make a move, they pass their turn and the opponent plays again. The player who captures all of the opponent's pieces wins. 
(game "Kharebga (5x5)"
    (players 2)
    (equipment {
        (board (square 5))
        (piece "Marker" Each 
            (move Slide Orthogonal
                (then ("CustodialCapture" Orthogonal (max 1)))
            )
        )
        (hand Each)
    })
    (rules
        (start (place "Marker" "Hand" count:12))
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover))
                    (to (difference (sites Board) (centrePoint)) if:(is Empty (to)))
                    (then
                        (if ("NewTurn") (moveAgain))
                    )
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Capture")
        )
        
        ("PhaseMovePiece" "Capture")
        }
        (end ("CaptureAll" Next))
    )	
)

Construct a Ludii game based on the following description
This game is presented in a group of manuscripts from the Maharaja Krishnaraja Wadiyar III of Mysore. 25 people attempt to trap two tigers, and the tigers attempt to eat the people.5x5 intersecting lines, with diagonals in each quadrant. At the midpoint of each side, the apex of a triangle. A line is drawn from the apex to the base of each triangle, and another line bisecting this one and the two opposite sides of the triangle. One player plays as two tigers, the other as 25 people. One tiger begins on the central point, and the other may be placed anywhere on the board. Players alternate turns, with the person playing as the people first placing a person on the board, and then one of the tigers moving to an empty adjacent spot along the lines of the board. When all of the people have been placed, the people move on the board in the same fashion. The tigers may capture one of the people by jumping over it to an empty adjacent spot immediately on the opposite side of one of the people along the lines of the board. The tigers win when they capture enough people so that the people cannot block the tiger, the people win when they can block the tiger from being able to move.
         
(game "Mysore Tiger Game (Two Tigers)" 
    (players 2) 
    (equipment {
        ("AlquerqueBoardWithFourTriangles")
        (hand Each) 
        (piece "Human" P2 ("StepToEmpty"))
        (piece "Tiger" P1
            (or 
                ("StepToEmpty")
                ("HopCapture")
            )
        )
    }) 
    (rules 
        (start {
            (place "Human2" (handSite P2) count:25)
            (place "Tiger1" (sites Centre))
            (place "Tiger1" (handSite P1))
        })
        
        phases:{
        (phase "Opening" 
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("NoMovesP1NoPiecesP2"))
    )
)

Construct a Ludii game based on the following description
Koti Keliya is a blocking game played in Sri Lanka. In contrast to many other hunt games in South Asia, it is played on a board of 12x12 squares.12x12 checkered board. One player plays with six \ 
(game "Koti Keliya"
    (players 2)
    (equipment
        {
        (board (square 12))
        (piece "Leopard" P1
            (move
                Slide Diagonal
                (between (max 2)) 
            ) 
        )
        (piece "Cow" P2 N ("StepToEmpty" (directions {FR FL}))) 
    })
    (rules
        (start {
            (place "Cow2" (difference (sites Bottom) (sites Phase 0)))
        })
        
        phases:{
        (phase "Placement"
            (play (move Add (to (intersection (sites Phase 1) (sites Empty)))))
            (nextPhase (not (no Pieces P1)) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end {
            (if (and (no Moves P1) (is Mover P1)) (result P2 Win))
            (if (= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(< (row of:(site)) (row of:(where "Leopard" P1)))))) (result P1 Win))
        }) 
    )	
)

Construct a Ludii game based on the following description
Dra is a game popular in West Africa, particularly in the areas of the Sahel and across several groups including the Touareg, Hausa, Bambara, Bozo, Sourai, and Fula. Typically, one player plays with twelve sticks, the other with twelve stones.5x6 board. Each player has twelve pieces. Players alternate placing their pieces until they are all placed on the board. Players cannot make a row of three pieces in the placement phase. Once the pieces are all on the board, they may be moved one space orthogonally. The goal is to make a line of three, which allows the player to capture one of the opponent's pieces. In the case that a move creates two lines of three, only one capture is made. The player who captures the most pieces wins. Matches are typically played to a score of ten, with a player scoring one point by winning a game, and two points for winning without any of their pieces being captured. 
(game "Dra"
    (players 2)
    
    (equipment { 
        (board (rectangle 5 6))
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" Orthogonal 
                (then ("ReplayIfLine3" Orthogonal exact:True))
            )
        )
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play 
                (do
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                    )
                    ifAfterwards:"NoLine3"
                )
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        (phase "Movement"
            (play   
                (if "SameTurn"
                    "RemoveAnyEnemyPiece" 
                    (forEach Piece) 
                )
            )
            
            (end ("HavingLessPiecesLoss" Next 2))
        )
        }
    )
)

Construct a Ludii game based on the following description
Mangala is a two-row mancala-style board game played in Turkey. It is similar to other two-row mancala games found throughout Southwest Asia and North Africa. The game is played with holes dug into the ground.Two rows of six holes. Each player has 6 holes.
(game "Mangala (Turkey)" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 <Column:size> store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        (start (set Count 5 to:(sites Track)))
        
        (play (move Select 
                (from 
                    (sites Mover) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        if:(or 
                            (= (count at:(to)) 1) 
                            (= (count at:(to)) 3)
                        )
                        apply:(fromTo 
                            (from (to)) 
                            (to (handSite Mover)) 
                            count:(count at:(to))
                        )
                        backtracking:True
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (= (count in:(sites Track)) 0)))
    )
)

Construct a Ludii game based on the following description
Refskak is a hunt game played in Iceland. One player, with twelve lambs, attempts to block the opponent, who plays as a fox, who tries to kill the lambs.Cross-shaped board, made of four 3x3 intersecting lines with diagonals. One player plays as the fox, which begins on the central space of the board. The other player plays as the lambs, who start in the spaces of one arm of the cross and the line of seven spots in front of that arm. Players alternate turns moving their pieces along the lines. The fox may capture one lamb by hopping over it in a straight line to an empty space on the opposite side of it. The fox wins by capturing seven lambs, the lambs win by blocking the fox so it cannot move. 
(game "Refskak"
    (players 2)
    (equipment {
        ("CrossBoard" 3 7 use:Vertex diagonals:Alternating)
        (piece "Lamb" P1 "StepToEmpty")
        (piece "Fox" P2 (or "HopCapture" "StepToEmpty"))
    })
    (rules 
        (start {
            (place "Fox2" (centrePoint))
            (place "Lamb1" (union (expand (sites Bottom) steps:2) (sites {"A3" "B3" "F3" "G3"})))
        })
        (play (forEach Piece))
        (end ("NoMovesLossAndLessNumPiecesPlayerLoss" P1 6))
    )
)

Construct a Ludii game based on the following description
Xarajlt (the jump) is a capturing game played in Mongolia. one player plays as lambs, the other as kids. 3x5 intersecting lines. Six pieces per player, arranged on the two short rows on opposite sides of the board. Players alternate turns moving a piece to an empty adjacent spot. Pieces move orthogonally in a horizontal or forward direction only. To capture, a piece may jump over an adjacent opponent's piece to an empty spot immediately on the opposite side of the piece along the lines of the board. Pieces may capture in a backwards direction. The player who captures all of the opponent's pieces wins. 
(game "Xarajlt"
    ("TwoPlayersNorthSouth") 
    
    (equipment {
        (board 
            (rectangle 5 3)
            use:Vertex
        )
        (piece "Marker" Each 
            (or
                ("StepToEmpty" (directions {Forward FR FL}))
                ("HopOrthogonalCapture")
            )
        )
    })
    
    (rules
        (start {
            (place "Marker1" (expand (sites Bottom)))
            (place "Marker2" (expand (sites Top)))
        })
        (play (forEach Piece))
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Awithlaknakwe is a game with custodial captures played by the Zuni people of the southwest United States from the late nineteenth century.12x12 board, with a line of six extra squares centered on each side. Diagonals in every square. Pieces are played on the intersections of lines. Played with two or four players; with four players, the top and left players play against the bottom and right players. Six pieces per player, with one larger piece. Each player's six pieces begin on the central intersection of the extra spaces. Pieces move one spot at a time diagonally. When a player surrounds an opponent's piece on two opposite sides, this piece is captured. The piece is then replaced by the larger piece, which may move diagonally or orthogonally. Pieces may not move backward. When all of the players' remaining pieces reach the starting squares of the opponent, the player with the most captured pieces wins. 
(game "Awithlaknakwe" 
    (players {(player N) (player E) (player S) (player W)}) 
    (equipment {
        (board 
            (merge
                (merge
                    (merge
                        (merge
                            (square 13 diagonals:Solid) 
                            (shift 3 -1 (rectangle 2 7 diagonals:Solid)) 
                        )
                        (shift 3 12 (rectangle 2 7 diagonals:Solid)) 
                    )
                    (shift -3.5 5.5 (rotate 90 (rectangle 2 7 diagonals:Solid))) 
                )
                (shift 9.5 5.5 (rotate 90 (rectangle 2 7 diagonals:Solid))) 
            )
            use:Vertex
        )
        (piece "Counter" Each ("StepToEmpty" (directions {FR FL})))
        (piece "DoubleCounter" Each ("StepToEmpty" (directions {Rightward Forwards Leftward})))
        (regions "Home" P1 (sites {"D9" "E8" "F7" "G6" "H5" "I4"}))
        (regions "Home" P2 (sites {"I22" "H21" "G20" "F19" "E18" "D17"}))
        (regions "Home" P3 (sites {"Q22" "R21" "S20" "T19" "U18" "V17"}))
        (regions "Home" P4 (sites {"V9" "U8" "T7" "S6" "R5" "Q4"}))
        (hand Each)
    })
    (rules
        (start {
            (set Team 1 {P1 P4})
            (set Team 2 {P2 P3})
            (place "Counter1" (sites P1))
            (place "Counter2" (sites P2))
            (place "Counter3" (sites P3))
            (place "Counter4" (sites P4))
            (place "DoubleCounter" "Hand")
        })
        (play 
            (forEach Piece
                (then  
                    (custodial 
                        (from (last To)) 
                        Orthogonal
                        (between 
                            (max 1) 
                            if:("IsEnemyAt" (between)) 
                            (apply 
                                (and {
                                    (remove (between))
                                    (if ("LargePieveAvailable")
                                        ("ReplaceByLargePiece")
                                    )
                                    (addScore Mover 1)
                                })
                            )
                        )
                        (to if:("IsFriendAt" (to))) 
                    )
                )
            )
        ) 
        
        (end 
            (if 
                (and 	
                    ("Team1OnlyOnStartSitesTeam2")
                    ("Team2OnlyOnStartSitesTeam1")
                ) {
                (if (> ("ScoreTeam1") ("ScoreTeam2")) (result Team1 Win))
                (if (< ("ScoreTeam1") ("ScoreTeam2")) (result Team2 Win))
                (if (= ("ScoreTeam1") ("ScoreTeam2")) (result Mover Draw))
            })
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Haretavl" 
    (players 2) 
    (equipment { 
        ("ThreeMensMorrisBoardWithLeftAndRightTriangles")
        (hand Each)
        (piece "Dog" P1 "StepToEmpty")
        (piece "Hare" P2 "StepToEmpty")
    }) 
    
    (rules 
        (start {
            (place "Dog1" (handSite P1) count:3)
            (place "Hare2" (handSite P2))
        })
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                ) 
            )
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        <End:rule>
    )
)
Haretavl is a blockade game from Scandinavia. It is documented from the nineteenth century, but older boards which have the same design are known from the Middle Ages, and thus the game may be much older.Square board, divided into eight equal triangles, with the central horizonal line extended past the square on either side and lines connecting the end point to the two nearby cornes of the square One player plays as the hare, the other player as three hounds. Players take turns placing one of their pieces on the board. When a player has placed all their pieces, they move to an adjacent empty spot. When the hounds block the hare from being able to move, the hounds win.
         The game has an ending condition only for P1.

Construct a Ludii game based on the following description
Jiu Zi Xian Qi is a puzzle game played on a star-shaped board that is played in western China. The board for the game has been documented in China since at least 1889. This version of the game way played in Qinghai, China in 2019 by an elderly man.The board begins initially with one stone on each playable site. First, according to the player's wish, one stone must be removed. Then, each piece jumps over another piece to an empty site to remove the piece that was jumped over. If the player has no move, they lose. If only one stone is left on the board, the player wins. A win is considered to be good luck and anything you pray for will come true. 
(game "Jiu Zi Xian Qi"
    (players 1) 
    (equipment { 
        ("StarBoard" 5)
        (piece "Marker" P1 ("HopFriendCapture"))
    }) 
    (rules 
        (start 
            (place "Marker" (sites Board))
        )
        
        phases:{
        (phase "Remove" 
            (play (move Remove (sites Board)))
            (nextPhase "Playing")
        )
        (phase "Playing"
            (play (forEach Piece))
            (end { 
                (if (= 1 (count Pieces P1)) (result Mover Win))
                ("NoMoves" Loss)
            })
        )
        }
    )		
)

Construct a Ludii game based on the following description
Jimafesosh is a two-row mancala-style board game played in the Wollo region of Ethiopia.2x6 board. Four counters in each hole. In the opening phase, the player takes all of the counters in their rightmost hole and places them in the opponent's opposite hole. The player  then takes the contents of the next hole, placing all of them into the hole following it, until the entire board has alternating holes with eight and zero counters. When the final hole is made with eight counters, these are picked up and the player sows as normal in an anti-clockwise direction. When the final counter falls into an occupied hole, the counters are picked up and sowing continues. When the final counter falls into an empty hole, the player captures the counters in the opposite hole. If a player cannot play, they must pass their turn until there are counters available for them to play. Play continues until there is one piece or fewer on the board, the player to whom the row in which the single piece is located captures it. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, and if each player has two remaining counters ownership is determined by chance. Play continues in several rounds like this until one player takes all the counters.
         
(game "Jimafesosh" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (map "RightMost" {(pair P1 5) (pair P2 6)})
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start {
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
            (set Count 4 to:(sites Track "TrackCCW")) 
        })
        
        phases:{
        (phase "Opening1"
            (play
                (move Select 
                    (from
                        (if ("SameTurn")
                            (var "Replay")
                            5
                        )
                    )
                    (then
                        (sow
                            numPerHole:4
                            "TrackCCW"
                            apply:(and
                                (moveAgain)
                                (if (is Occupied ("NextHole" (to) 1))
                                    (set Var "Replay" ("NextHole" (to) 1))
                                    (set Var "Replay" Undefined)
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (= Undefined (var "Replay")) "Opening2")
        )
        (phase "Opening2"
            (play
                (move Select 
                    (from
                        (if (and ("SameTurn") (!= Undefined (var "Replay")))
                            (var "Replay")
                            4
                        )
                    )
                    (then
                        (sow
                            "TrackCCW"
                            apply:(if (< 1 (count at:(to)))
                                (and
                                    (moveAgain)
                                    (set Var "Replay" (to))
                                )
                                (if (is Occupied ("OppositePitTwoRows" (to)))
                                    (fromTo
                                        (from ("OppositePitTwoRows" (to)))
                                        (to (handSite Mover))
                                        count:(count at:("OppositePitTwoRows" (to)))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            
            (nextPhase (not (is Next Prev)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (or {
                    (move Select 
                        (from
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                "TrackCCW"
                                apply:(if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                    (if (is Occupied ("OppositePitTwoRows" (to)))
                                        (fromTo
                                            (from ("OppositePitTwoRows" (to)))
                                            (to (handSite Mover))
                                            count:(count at:("OppositePitTwoRows" (to)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OneOrLessPieceOnBoard")
                            (and { 
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("RightMostEmpty"))
                        count:4
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (= 3 (count Cell at:(handSite Mover)))
                                    (and {
                                        (fromTo 
                                            (from (handSite Mover))
                                            (to ("RightMostEmpty"))
                                            count:3
                                        )
                                        (fromTo 
                                            (from (handSite Next))
                                            (to ("RightMostEmpty"))
                                            count:1
                                        )
                                        ("RemmemberOwnedHoles" ("RightMostEmpty"))
                                    })
                                    (if (= 2 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("RightMostEmpty"))
                                                count:2
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("RightMostEmpty"))
                                                count:2
                                            )
                                            ("RememberOwnedHolesRandom" ("RightMostEmpty"))
                                        })
                                    )
                                )
                            })
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
A chess variant played on a board made of hexagons invented by Isaak Grigorevich Shafran in 1939, and registered in 1956.Shafran Chess is played on a 'narrow' hexagonal board that can be thought of as a hexagonal board of size 6 with some outer spaces removed. The board has 70 spaces.
            
            Piece Movement:
            * Queens, Rooks, Bishops, and Knights move as in Glinski Chess.
            - Queens slide in any of the 12 directions.
            - Rooks slide in any of the 6 adjacent directions.
            - Bishops slide in any of the 6 'diagonal' directions.
            - Knights move two spaces in an adjacent direction, then one space in another direction.
            * Kings move as in Glinski Chess, but can also castle. In 'Long Castling', the King moves three spaces toward its queenside Rook and the Rook moves two spaces in the opposite direction. In 'Short Castling', the King moves two spaces toward its bishopside Rook (i.e., the one on the side of the board with two bishops), and the Rook moves three spaces. Castling can only take place when neither the King nor the Rook being moved have moved before.
        * Pawns can advance one space forward without capturing. A Pawn on a Pawn start space can advance any number of spaces, up to the middle row of the board. Thus the outermost Pawns on their first moves can only advance one space, while the Pawns in the three innermost columns can advance up to three spaces. Pawns capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). En passant capture works as in Glinski chess, except that if the opponent just advanced a Pawn three spaces, then the next player can perform en passant capture by landing a Pawn on either of the two spaces that the opponent Pawn just skipped over. On reaching the farthest rank in a given file, Pawns are promoted to a Queen, Rook, Bishop, or Knight, as the player chooses. 
(game "Shafran Chess"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board
            (remove
                (rotate 90 (hex 6))
                cells:{0..5 85..90 84 77 69 60 50 39 29 20 12}
            )
        )
        
        (piece "King" Each
            (or {
                ("KingCaptureStep" All "History_SaveMovementChange")
                (if "Castle_PreCheck"
                    (or {
                        "Castle_BishopSide_Long"
                        "Castle_BishopSide_Short"
                        "Castle_QueenSide_Long"
                        "Castle_QueenSide_Short"
                        }
                    )
                )
            })
        )
        (piece "Queen" Each ("SlideCaptureMove" All ~))
        (piece "Rook" Each ("SlideCaptureMove" Orthogonal "History_SaveMovementChange"))
        (piece "Bishop" Each ("SlideCaptureMove" Diagonal ~))
        ("ChessKnight" "Knight" (then (set Counter)))
        
        (piece "Pawn" Each
            (or {
                "StepForwardToEmpty"
                (if "IsFromInStartCell"
                    (or {
                        (if (is In (from) (sites Mover "Pawn_Step2Cells"))
                            ("PawnHop" 1)
                        )
                        (if (is In (from) (sites Mover "Pawn_Step3Cells"))
                            ("PawnHop" 2)
                        )
                    })
                )
                "PawnCapture_Diag"
                "EnPassant_Diag"
                }
                (then
                    (and
                        ("ReplayInMovingOn" (sites Mover "PromotionZone"))
                        (set Counter)
                    )
                )
            )
        )
        
        (map "King"  {(pair 1 "A1") (pair 2 "J10")})
        (map "RookLeft" {(pair 1 "A5") (pair 2 "F10")})
        (map "RookRight" {(pair 1 "E1") (pair 2 "J6")})
        
        (regions "Pawn_Step2Cells" P1 (sites {"B5" "B4" "B3" "B2" "C2" "D2" "E2"}))
        (regions "Pawn_Step2Cells" P2 (sites {"F9" "G9" "H9" "I9" "I8" "I7" "I6"}))
        
        (regions "Pawn_Step3Cells" P1 (sites    {"B3" "B2" "C2"}))
        (regions "Pawn_Step3Cells" P2 (sites    {"H9" "I9" "I8"}))
        
        (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE)))
        (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE)))
        
        (regions "Region-Dark" (sites Phase 2))
        (regions "Region-Light" (sites Phase 0))
        (regions "Region-Medium" (sites Phase 1))
    })
    
    (rules
        (start {
            (place "King1" coord:"A1" state:1)
            (place "Queen1" coord:"A2")
            (place "Rook1" {"A5" "E1"} state:1)
            (place "Bishop1" {"A3" "B1" "D1"})
            (place "Knight1" {"A4" "C1"})
            
            (place "King2" coord:"J10" state:1)
            (place "Queen2" coord:"J9")
            (place "Rook2" {"F10" "J6"} state:1)
            (place "Bishop2" {"G10" "I10" "J8"})
            (place "Knight2" {"H10" "J7"})
            
            (place "Pawn1" {"B6" "B5" "B4" "B3" "B2" "C2" "D2" "E2" "F2"})
            (place "Pawn2" {"E9" "F9" "G9" "H9" "I9" "I8" "I7" "I6" "I5"})
        })
        phases:{
        (phase "Movement"
            (play
                (if ("SameTurn")
                    ("PromoteTo" (piece {"Queen" "Rook" "Bishop" "Knight"}))
                    (do (forEach Piece)
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
            )
            (end {
                ("Checkmate" "King")
                (if (or
                        (no Moves Mover)
                        (= (counter) 100)
                    )
                    (result Mover Draw)
                )
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Buqruru is a two-row mancala-style board game played in the Tidikelt and Haggar regions of Algeria. It is typically made out of holes in the sand, and camel droppings are used as pieces.2x4 board. Six counters in each hole. At the beginning of the game, each player chooses one hole to be their sowing hole, from which each move on their turn must begin. The players agree on a direction of play, which is maintained throughout the game. Players alternate turns sowing from their sowing hole. The players may choose to sow one-by-one, two-by-two, three-by-three, four-by-four, and so forth, into the following holes. When the final counter lands in a hole causing it to contain two, four, six, or eight counters, the contents of that hole are captured. If the preceding hole also contains two, four, six, or eight counters, these are also captured, proceeding until there is a no longer a hole with two, four, six, or eight counters. If at the end of a turn a player sowed into the opponent's row and any of the opponent's holes contain two, four, six, or eight counters, providing the player sowed into them, the opponent captures these counters. In a players own row, if either player sows into a hole with an odd number of counters, making it an even number of counters, the player who owns that row captures the counters. If a player's sowing hole is empty at the beginning of their turn, they pass. Play continues until all of the counters are captured, or there is only one left on the board. The single counter is captured by the player in whose row it is located. 
            
        A new round begins. Players fill up as many holes as they can with six counters. If a player cannot, they fill as many as they can with six counters, and place the remainder in a hole, either between two with six counters or after them, and erases any empty holes. Play continues as before. When one player has erased all of their holes, the opponent wins. The game is played counter clockwise.
(game "Buqruru" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 4 store:None
            (track "Track" <Direction> loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start {
            (set Count 6 to:(sites Track)) 
            (set RememberValue "Playable" (sites Board))
        })
        
        phases:{
        (phase "SelectingHole"
            (play
                (move Select 
                    (from 
                        (sites Mover)
                        if:(is In (from) ("PlayableSites"))			
                    )
                    (then (set Value Mover (last To)))
                )
            )
            (nextPhase Mover "Sowing")
        )
        
        (phase "Sowing"
            (play
                (if (is Occupied (value Player Mover))
                    (or {
                        (move Select
                            (from 
                                (value Player Mover)
                                if:(is In (from) ("PlayableSites"))	
                            )
                            (then
                                (sow 
                                    numPerHole:1
                                    sowEffect:(if (and 
                                            (is In (to) (sites Next))
                                            (or { 
                                                (= 1 (count at:(to)))
                                                (= 3 (count at:(to)))
                                                (= 5 (count at:(to)))
                                                (= 7 (count at:(to)))
                                            })
                                        )
                                        (fromTo
                                            (from (to))
                                            (to (handSite Mover))
                                            count:(count at:(to))
                                        )
                                    )
                                    apply:(if (or { 
                                            (= 2 (count at:(to)))
                                            (= 4 (count at:(to)))
                                            (= 6 (count at:(to)))
                                            (= 8 (count at:(to)))
                                        })
                                        (fromTo
                                            (from (to))
                                            (to (handSite Mover))
                                            count:(count at:(to))
                                        )
                                    )
                                    skipIf:(not (is In (to) ("PlayableSites")))
                                    backtracking:True
                                )
                            )
                        )
                        (if (= 0 (% (count at:(value Player Mover)) 2))
                            (move Select
                                (from (value Player Mover))
                                (then
                                    (sow 
                                        numPerHole:2
                                        sowEffect:(if (and 
                                                (is In (to) (sites Next))
                                                (or { 
                                                    (= 0 (count at:(to)))
                                                    (= 2 (count at:(to)))
                                                    (= 4 (count at:(to)))
                                                    (= 6 (count at:(to)))
                                                })
                                            )
                                            (fromTo
                                                (from (to))
                                                (to (handSite Mover))
                                                count:(count at:(to))
                                            )
                                        )
                                        apply:(if (or { 
                                                (= 2 (count at:(to)))
                                                (= 4 (count at:(to)))
                                                (= 6 (count at:(to)))
                                                (= 8 (count at:(to)))
                                            })
                                            (fromTo
                                                (from (to))
                                                (to (handSite Mover))
                                                count:(count at:(to))
                                            )
                                        )
                                        skipIf:(not (is In (to) ("PlayableSites")))
                                        backtracking:True
                                    )
                                )
                            )
                        )
                        (if (= 0 (% (count at:(value Player Mover)) 3))
                            (move Select
                                (from (value Player Mover))
                                (then
                                    (sow 
                                        numPerHole:3
                                        sowEffect:(if (and 
                                                (is In (to) (sites Next))
                                                (or { 
                                                    (= 1 (count at:(to)))
                                                    (= 3 (count at:(to)))
                                                    (= 5 (count at:(to)))
                                                })
                                            )
                                            (fromTo
                                                (from (to))
                                                (to (handSite Mover))
                                                count:(count at:(to))
                                            )
                                        )
                                        apply:(if (or { 
                                                (= 2 (count at:(to)))
                                                (= 4 (count at:(to)))
                                                (= 6 (count at:(to)))
                                                (= 8 (count at:(to)))
                                            })
                                            (fromTo
                                                (from (to))
                                                (to (handSite Mover))
                                                count:(count at:(to))
                                            )
                                        )
                                        skipIf:(not (is In (to) ("PlayableSites")))
                                        backtracking:True
                                    )
                                )
                            )
                        )
                        (if (= 0 (% (count at:(value Player Mover)) 4))
                            (move Select
                                (from (value Player Mover))
                                (then
                                    (sow 
                                        numPerHole:4
                                        sowEffect:(if (and 
                                                (is In (to) (sites Next))
                                                (or { 
                                                    (= 0 (count at:(to)))
                                                    (= 2 (count at:(to)))
                                                    (= 4 (count at:(to)))
                                                })
                                            )
                                            (fromTo
                                                (from (to))
                                                (to (handSite Mover))
                                                count:(count at:(to))
                                            )
                                        )
                                        apply:(if (or { 
                                                (= 2 (count at:(to)))
                                                (= 4 (count at:(to)))
                                                (= 6 (count at:(to)))
                                                (= 8 (count at:(to)))
                                            })
                                            (fromTo
                                                (from (to))
                                                (to (handSite Mover))
                                                count:(count at:(to))
                                            )
                                        )
                                        skipIf:(not (is In (to) ("PlayableSites")))
                                        backtracking:True
                                    )
                                )
                            )
                        )
                    })
                    
                    (then
                        (if ("OneOrLessPieceOnBoard")
                            (and { 
                                (forEach Site (sites P1)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (handSite P1))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site (sites P2)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (handSite P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forget Value "Playable" All)
                            })
                        )	
                    )
                )
            )
            (end {
                (if (and (= 0 (count at:(value Player P1))) (= 0 (count at:(value Player P2)))) (result Mover Draw))
                (if ("OneOrLessPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            })
            
            (nextPhase ("OneOrLessPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                    (if (<= 6 (count at:(handSite Mover)))
                        (move
                            (from (handSite Mover))
                            (to (sites Mover))
                            count:6
                            (then (remember Value "Playable" (last To)))
                        )
                        (move
                            (from (handSite Mover))
                            (to (sites Mover))
                            count:(count at:(handSite Mover))
                            (then (remember Value "Playable" (last To)))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "SelectingHole")
        )
        }
        
    )
)

Construct a Ludii game based on the following description
Tablut is a game documented in Lapland during the 18th century. Judging from the form and rules, it is thought to be the latest surviving member of the tafl family. It is also currently the only tafl game to have a fully documented ruleset.The central square is the castle, which cannot be entered by pieces or by the king once it has left. There are two sides: one with the king and 8 pieces, another with 16 undifferentiated pieces. The king begins on the castle space, and his associated pieces are arranged with two pieces on each orthogonal side of the king. The opposing side is arranged on the sides of the board, one piece on each of the three central squares on each of the four sides, and one further piece on the next row in on the central square of the row. Pieces move orthogonally any number of squares. Pieces cannot jump. If a piece is caught between two opposing pieces, it is removed from play. A piece may also be captured by trapping it between an enemy piece and the castle. The king, when in the castle, can only be captured when surrounded on four sides. If it is in a space adjacent to one of the sides, it can be captured when the opponent surrounds it on the remaining three sides. Otherwise, it is captured like any other piece. If the king moves to the edge of the board, the player controlling the king wins. If the opposing side captures the king, they win. The king is captured if the enemy flanks him, except on the castle where he should be surrounded.
(game "Tablut" 
    (players 2) 
    (equipment { 
        (board (square 9)) 
        
        (piece "Thrall" P1 
            (move Slide
                Orthogonal 
                (between if:(and (!= (between) ("Castle")) (is Empty (between))))
                (then 
                    (or {
                        ("Custodial" "Thrall2")
                        <Jarl:captureType>
                    })
                )
            )
        )
        
        (piece "Thrall" P2 
            (move Slide
                Orthogonal 
                (between if:(and (!= (between) ("Castle")) (is Empty (between))))
                (then ("Custodial" "Thrall1")) 
            ) 
        ) 
        
        (piece "Jarl" P2 
            (move Slide
                Orthogonal 
                (between if:(and (!= (between) ("Castle")) (is Empty (between))))
                (then ("Custodial" "Thrall1")) 
            )
        )
        
        (regions "OrthogonalSitesCentre" 
            (difference
                (expand origin:("Castle") Orthogonal) 
                ("Castle")
            )
        )
    }) 
    (rules 
        (start { 
            (place "Thrall1" {"D1" "E1" "F1" "E2" "A4" "A5" "A6" "B5" "I4" "I5" "I6" "H5" "E8" "D9" "E9" "F9" "E8"})
            (place "Thrall2" {"E3" "E4" "E6" "E7" "C5" "D5" "F5" "G5"})
            (place "Jarl2" (centrePoint))
        })
        
        (play (forEach Piece)) 
        
        (end {
            ("PieceTypeReachWin" "Jarl2" (sites Outer) P2)
            (if "JarlWasCaptured" (result P1 Win))
        })
    )
)

Construct a Ludii game based on the following description
Khutka Boia is a two-row mancala-style board game played in the Mianwali district of Pakistan in the early twentieth century. It was played by all ages and genders, and generally played on holes made one a stone surface.2x5 board. Five counters in each hole. Players take turns sowing in an anti-clockwise direction. When the final counter lands in a hole, the player picks up the contents of the next hole following this one, and continues sowing. If the player cannot pick up any counters from this hole, the players captures any counters from the hole after the empty hole, and the turn ends. Whenever any holes in the player's row contain four counters, they are captured by the player. Play continues until all of the counters have been captured. A new round begins. The players count their captured counters. If the difference between the two players' captured counters is greater than five, for each multiple of five in the difference a hole on the player with fewer counters' side is eliminated from play, and the excess counters that equal a multiple of five are placed aside for use in further rounds if necessary. When the difference is less than five, and when dealing with the remaining pieces after the multiples of five are dealt with, The following scenarios apply. When one player has one counter and the other has four, the player with one will give their stone to the one with four, but the player who has one counter will receive one counter from the hole from which sowing begins at the beginning of each player's turn. When one player has two counters and the other has three, the player with two gives these counters to the other player. With these five, the player creates a \ 
(game "Khutka Boia" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 5 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (hand Each)
    }) 
    (rules 
        
        (start {
            (set Count 5 to:(sites Track)) 
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (or {
                        (move Select
                            (from
                                (if 
                                    ("SameTurn") 
                                    "PlayFromNextLastHole" 
                                    (sites Mover) 
                                ) 
                                if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                            )
                            (then
                                (do
                                    (if (= 1 (value Player Next))
                                        (fromTo
                                            (from (last From))
                                            (to (handSite Mover))
                                            count:1
                                        )
                                    )
                                    next:(sow
                                        (last From)
                                        apply:(if (is Occupied ("NextHoleFrom" (to) "Track" 1))
                                            (moveAgain)
                                            (if (is Occupied ("NextHoleFrom" (to) "Track" 2))
                                                (fromTo
                                                    (from ("NextHoleFrom" (to) "Track" 2))
                                                    (to (handSite Mover))
                                                    count:(count at:("NextHoleFrom" (to) "Track" 2))
                                                )
                                            )
                                        )
                                        skipIf:(not (is In (to) ("PlayableSites")))
                                    )
                                )
                            )
                        )
                        }
                        (then
                            (and {
                                (forEach Player
                                    (forEach Site (sites Player)
                                        (if (= 4 (count at:(site)))
                                            (fromTo
                                                (from (site))
                                                (to (handSite Player))
                                                count:4
                                            )
                                        )
                                    )
                                )
                                (forEach Site (sites P1)
                                    (if (and (is Occupied (site)) (= 1 (state at:(site))))
                                        (and
                                            (fromTo
                                                (from (site))
                                                (to (handSite Player))
                                                count:(count at:(site))
                                            )	
                                            (set State at:(site) 1)
                                        )
                                    )	
                                )
                                (forEach Site (sites P2)
                                    (if (and (is Occupied (site)) (= 2 (state at:(site))))
                                        (and
                                            (fromTo
                                                (from (site))
                                                (to (handSite Player))
                                                count:(count at:(site))
                                            )	
                                            (set State at:(site) 2)
                                        )
                                    )	
                                )
                            })
                        )
                    )
                    }
                    (then
                        (if ("OneSeedOnBoard")
                            (and { 
                                (forEach Site (sites P1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites P2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site (sites Board)
                                    (if (!= 0 (state at:(site)))
                                        (set State at:(site) 0)
                                    )
                                )
                                (set Value P1 0)
                                (set Value P2 0)
                                (forget Value "Playable" All)
                            })
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                    (if (<= 5 (count Cell at:(handSite Mover)))
                        (move
                            (from (handSite Mover))
                            (to (sites Mover) if:(is Empty (to)))
                            count:5
                            (then (remember Value "Playable" (last To)))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "DecisionForNextRound")
        )
        
        (phase "DecisionForNextRound"
            (play
                (if (> 5 ("DifferenceCapturedStone"))
                    (do
                        (if (= 1 (count Cell at:(handSite P1)))
                            (and
                                (set Value P1 1)
                                (fromTo
                                    (from (handSite P1))
                                    (to (handSite P2))
                                    count:1
                                )
                            )
                            (if (= 1 (count Cell at:(handSite P2)))
                                (and
                                    (set Value P2 1)
                                    (fromTo
                                        (from (handSite P2))
                                        (to (handSite P1))
                                        count:1
                                    )
                                )
                                (if (= 2 (count Cell at:(handSite P2)))
                                    (set Var "Bha" 1)
                                    (if (= 2 (count Cell at:(handSite P1)))
                                        (set Var "Bha" 2)
                                    )
                                )
                            )
                        )
                        next:(if (= (var "Bha") P1)
                            (move Select
                                (from (intersection (union (sites Left) (sites Right)) (sites P1)))
                                (then 
                                    (and
                                        (set State at:(last To) 1)
                                        (set Var "Bha" 0)
                                    )
                                )
                            )
                            (if (= (var "Bha") P2)
                                (move Select
                                    (from (intersection (union (sites Left) (sites Right)) (sites P2)))
                                    (then
                                        (and
                                            (set State at:(last To) 2)
                                            (set Var "Bha" 0)
                                        )
                                    )
                                )
                                (move Pass)
                            )
                        )
                    )
                    (move Pass)
                )
            )
            (nextPhase "Sowing")
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Pareia de Entrada"
    (players 2)
    (equipment {
        ("TableBoard" "TableTracksSameDirectionWithHands")
        (dice d:6 num:<Dice:num>)
        (hand Each)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" "SiteToMoveOnTrack")
                    "RemoveAPiece"
                    (if ("NoEnemyOrOnlyOne" "SiteToMoveOnTrack")
                        (move 
                            (from) 
                            (to 
                                "SiteToMoveOnTrack" 
                                ("HittingCapture" (handSite Next))
                            )
                        )
                    )
                )
            )
        )
    })
    (rules 
        (start {
            (place Stack "Disc1" (handSite P1) count:15)
            (place Stack "Disc2" (handSite P2) count:15)
        })
        (play 
            (do (if (or (is Pending) ("NewTurn")) (roll)) 
                next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True)
                    (then 
                        (and
                            ("ReplayNotAllDiceUsed")
                            (if (and (all DiceUsed) (all DiceEqual)) (and (set Pending) (moveAgain)))
                        )
                    )
                )
            )
        )
        (end ("EscapeWin"))
    )
)
Pareia de Entrada is a race game from medieval Spain that is related to other European Tables games. It is one of the earliest forms of Tables that employs a second turn when doubles are rolled on the dice.2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Two or three dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Both players enter their pieces into the same quadrant of the board, and move pieces along a horseshoe-shaped track around the board toward the quadrant on the opposite side of the board.  When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board and must enter again as before. When all of the dice present the same number, the player receives another turn. The player to bear off all of their pieces first wins.
         The game involves 2 dice

Describe the mechanics of the following Ludii game
(game "Dorvolz"
    (players 2)
    (equipment {
        (board (square 17) use:Vertex)
        (hand Each size:2)
        (piece "Bull" Each)
        (piece "Marker" Each)
        (regions "BullSites" P1 (sites {"C3" "K3" "O7" "C11" "G15" "O15"}))
        (regions "BullSites" P2 (sites {"G3" "O3" "C7" "O11" "C15" "K15"}))
    })
    (rules
        (start {
            (place "Bull1" (handSite P1) count:6)
            (place "Bull2" (handSite P2) count:6)
            (place "Marker1" (handSite P1 1) count:144)
            (place "Marker2" (handSite P2 1) count:144)
        })
        
        phases:{
        (phase "BullPlacement"
            (play 
                (move 
                    (from (handSite Mover))
                    (to (intersection (sites Empty) (sites Mover)))
                )
            )
            (nextPhase Mover (= 6 (count Sites in:(intersection (sites Board) (sites Occupied by:Mover)))) "MarkerPlacementAroundBull")
        )
        (phase "MarkerPlacementAroundBull"
            (play 
                (move 
                    (from (handSite Mover 1))
                    (to (intersection (sites Empty) (sites Around (sites Mover) All)))
                )	
            )
            (nextPhase Mover (= 54 (count Sites in:(intersection (sites Board) (sites Occupied by:Mover)))) "Playing")
        )
        (phase "Playing" 
            (play
                (move 
                    (from (handSite Mover 1))
                    (to (sites Empty))
                )
            )
            (end
                (if (and ("HandEmpty" P1) ("HandEmpty" P2))
                    (byScore {
                        (score P1 (size Territory P1 All))
                        (score P2 (size Territory P2 All))
                    })
                )
            )
        )
        }
    )
)
Dörvölz is a game played in Mongolia, in which players attempt to enclose the largest number of empty spaces.17x17 intersecting lines, with alternating black and white points, four equally spaced along the third and fifteenth rank and two along the seventh and eleventh rows, forming a large square. Each player has two kinds of piece, six bull-shaped pieces and 144 round pieces. To begin, players place their bull-shaped pieces on the opposite-color marked points on the board. Then, players alternate turns placing one of their pieces in an adjacent space next to one of their bull pieces. Once all of the bull pieces have been surrounded, the main phase of play begins. Players alternate turns placing one of their pieces on the board. The player who encloses the greatest number of empty spaces wins. 

Describe the mechanics of the following Ludii game
(game "Kharberg"
    (players 2)
    (equipment {
        ("AlquerqueBoard" 5 5)
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
        (piece "Counter" Each
            (or
                ("Hop") 
                ("StepToEmpty" ~ (then ("HasNotCaptured")))
                (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
            )
        )
        (piece "DoubleCounter" Each
            (or
                ("Hop") 
                (move Slide (then ("HasNotCaptured")))
            )
        )
    })
    (rules 
        (start { 
            (place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"}) }))
            (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top)) }))
        })
        (play 
            (or
                (if ("DidNotCaptured")
                    (or
                        (if ("ShouldCapturedButMoved") 
                            ("HuffOnePieceOf" (last To))
                        )
                        ("HuffOnePieceOf" ("SitesWithPossibleCaptureInPreviousTurn"))
                    )
                )
                (do 
                    ("RememberSiteWithPossibleCapture") 
                    next:(forEach Piece)
                )
            )
        )
        (end ("BlockWin"))
    )
)
Kharberg is a game with leaping captures played by people living in and around the Sahara. It is typically played by drawing the board in the sand.5x5 intersecting lines with diagonals in the four quadrants. Twelve pieces per player, arranged on the intersections of the lines, on the first two ranks in front of each player and the two to the right of the player in the central rank. Pieces move in any direction one space. A piece may capture an opponent's piece by hopping over it to an empty space in a straight line. Captures are obligatory. If a player does not capture when they are supposed to, the opponent may remove that piece immediately and then play as normal.  Once pieces reach the opposite side of the board from their starting position at the end of their turn, they are promoted and can move in any direction and over any distance. The player who captures all of their opponent's pieces or blocks them from being able to move wins. 

Construct a Ludii game based on the following description
Juroku Musashi is a hunt game from Japan. It has a rule where the soldiers may also win by confining the general to the triangular extension of the baord.5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a triangle, with the apex intesecting with the midpoint of that side. There is a line from the apex to the midpoint of the triangle's base, and another interior triangle, connecting the base of the larger triangle with the midpoints of the sides of the larger triangle. One player plays as the Taisho (\ 
(game "Juroku Musashi" 
    (players 2) 
    (equipment { 
        <Variant:board>
        (piece "Marker" P1 <Variant:p1Moves>)
        (piece "Marker" P2 
            (or 
                ("HopCapture") 
                ("StepToEmpty")
            ) 
        ) 
    }) 
    (rules 
        (start { 
            (place "Marker1" (difference (sites Outer) (expand (sites Bottom))))
            (place "Marker2" (ahead (centrePoint) N))
        })
        
        (play (forEach Piece)) 
        
        (end ("NoMovesP2NoPiecesP1"))
    )
)

Construct a Ludii game based on the following description
Pathway is a simple game made by Mark Steere. It was designed to be easy to program.Players take turns placing one of their stones on an empty square. It is not legal to place orthogonally adjacent to only enemy stones and it is not legal to place orthogonally adjacent to more than 1 friendly stone. All other placements onto empty squares are legal. Put differently: You may place adjacent to no stone or to exactly 1 friendly and any number of enemy stones.
        The first player unable to place a stone has won the game. A 6x6 board is currently selected
(game "Pathway"
    (players 2)
    (equipment {
        (board (square <Board>))
        (piece "Disc" Each)
    })
    (rules
        (play
            (move Add
                (to
                    (sites Empty)
                    if:(or 
                        (all Sites
                            (sites Around
                                (to)
                                Orthogonal
                            )
                            if:(is Empty (site))
                        )
                        (= 1
                            (count Sites
                                in:(sites Around
                                    (to)
                                    Own
                                    Orthogonal
                                )
                            )
                        )
                    )
                )
            )  
        )
        (end ("NoMoves" Win))
    )
)

Construct a Ludii game based on the following description
The Knossos Game is a speculated game based on an object found at the Palace of Knossos in Crete which looks like a game board, and which had four conical pieces found nearby. It is a unique object, though fragments with similar decoration could point to its existence elsewhere in the Aegean.Each player begins at the end of one of the \ Rules from Seleucid.
(game "Knossos Game" 
    (players 2)
    (equipment {
        (board 
            (merge {
                (rectangle 1 4) 
                (shift 1 1 (rectangle 1 2)) 
                (shift 0 -2 (rectangle 3 1))
                (shift 3 -2 (rectangle 3 1))
                
                (shift 1.5 4 (scale 2 (rectangle 2 1)))
                (shift 0 5 (scale 3 (rectangle 1 2)))
            })
            {
            (track "TrackBottom1" "14,6,7,0,1,4")
            (track "TrackBottom2" "15,8,9,3,2,5")
            (track "TrackOpposite1" "7,0,1,2,5")
            (track "TrackOpposite2" "9,3,2,1,4")
            (track "TrackCross1" "0,1,4,10,12,11")
            (track "TrackCross2" "3,2,5,10,13,11")
            (track "TrackTop1" "10,12,11,End")
            (track "TrackTop2" "10,13,11,End")
            }
            use:Vertex
        )
        ("StickDice" 2)
        (piece "RoundPawn" Each
            (or {
                ("MoveOnTrack" "TrackBottom1")	
                ("MoveOnTrack" "TrackBottom2")
                ("MoveOnTrack" "TrackOpposite1")	
                ("MoveOnTrack" "TrackOpposite2")
                (if (is Mover P1)
                    ("MoveOnTrack" "TrackTop1")
                    ("MoveOnTrack" "TrackTop2")
                )
                (if (and {
                        (not ("IsFriendAt" ("SiteAfterBridge")))
                        (= 3 ("ThrowValue"))
                        (not (is In (from) (sites "TopSites")))
                    }) 
                    (if (or 
                            (can Move ("MoveOnTrack" "TrackCross1")) 
                            (can Move ("MoveOnTrack" "TrackCross2"))
                        )
                        (move 
                            (from) 
                            (to 
                                ("SiteAfterBridge") 
                                "CaptureEnemyPiece"
                            )
                        )
                    )
                )
            })
        )
        (hand Each)
        (regions "TopSites" (sites {10..13}))
    })
    (rules 
        (start (place "RoundPawn" "Hand" count:2))
        (play 
            ("RollMove"
                (or 
                    (forEach Piece) 
                    (forEach Piece container:(mover))
                )
                (then 
                    (if (no Pieces Mover)
                        (and
                            (addScore Mover 1) 
                            (if (!= (score Mover) 2)
                                (and {
                                    (forEach Site 
                                        (sites Occupied by:All container:"Board")
                                        (remove (site))
                                    )
                                    (if (!= 0 (who at:(handSite P1)))
                                        (remove (handSite P1))
                                    )
                                    (if (!= 0 (who at:(handSite P2)))
                                        (remove (handSite P2))
                                    )
                                    (add (piece (id "RoundPawn" P1)) (to (handSite P1)) count:2)
                                    (add (piece (id "RoundPawn" P2)) (to (handSite P2)) count:2)
                                })
                            )
                        )
                        (if (= 3 ("ThrowValue")) (moveAgain))
                    )
                )
            )
        )
        (end (if (= (score Mover) 3) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Dabuda is a two-row mancala-style game that is particularly popular among the Afar who live in the Horn of Africa, and described by men from Asaita, Jibuti and Thio.Two rows of ten holes Four counters in each hole First play must be from the rightmost hole. The player has to open the game with the rightmost hole.
(game "Dabuda" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions "Home" P1 (sites Bottom)) 			
        (regions "Home" P2 (sites Top)) 				
        (regions "RightMost" P1 (sites <Rightmost:sitesP1>)) 
        (regions "RightMost" P2 (sites <Rightmost:sitesP2>)) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        phases:{
        (phase "Rightmost" 			 	
            (play ("Sow" "RightMost"))
            (nextPhase (= (count Turns) 2) "HomePhase")
        )
        (phase "HomePhase" 
            (play ("Sow" "Home")) 
        )
        }
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
        
    )
)

Construct a Ludii game based on the following description
A version of Shogi where all pieces start in reserve.Same as standard Shogi except:
            1. The board is initially empty and each player has the normal complement of 20 pieces in reserve.
            2. During a turn, a player must do one of three things:
            --- place a piece from the reserve on an empty square on the board
            --- move a previously placed piece to an empty square
            --- move a piece to a square occupied by an opposing piece, capturing it.
        3. A player may not make a capture until her/his own king is on the board. Your pieces have no real power of check on the opposing king until your own king is placed. Your opponent can legally place his or her king right next to your promoted Rook if your king is still in hand. There is no additional rule governing when you must enter your king. If a piece is checking the opposing king, but the friendly king has not been placed, that is called quasi-check. A player is under no compulsion to move out of quasi-check. 
(game "Unashogi" 
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        (board (square 9))
        
        
        (piece "Osho" Each ("StepMove"))
        
        
        (piece "Fuhyo" Each 
            ("StepMove" 
                Forward 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InLastRank" (last To)) 
                            ("Promote") 
                            (moveAgain) 
                        ) 
                    ) 
                )
            )
        )
        
        
        (piece "Ginsho" Each ("StepMove" (directions {Forward BL BR FL FR}) "CanPromote"))
        
        
        (piece "Hisha" Each ("SlideMove" Orthogonal "CanPromote"))
        
        
        (piece "Kakugyo" Each ("SlideMove" Diagonal "CanPromote"))
        
        
        (piece "Keima" Each 
            (forEach Direction 
                Forward 
                (to 
                    if:True 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL}) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (add 
                                                (piece (mapEntry "Captured" (what at:(to)))) 
                                                (to (mapEntry "Where" (what at:(to))))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                ) 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InTwoFurthestRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                ) 
            ) 
        )
        
        
        (piece "Kyosha" Each
            ("SlideMove" 
                Forward 
                (then 
                    (if ("InPromotionZone" (last To))
                        (if ("InLastRank" (last To)) 
                            "Promote" 
                            (moveAgain) 
                        ) 
                    ) 
                )
            ) 
        )
        
        
        ("ShogiGold" "Kinsho" "CapturePiece")
        
        
        ("ShogiGold" "Tokin" "CapturePiece")
        
        
        ("ShogiGold" "Narigin" "CapturePiece")
        
        
        (piece "Ryuo" Each (or ("SlideMove" Orthogonal) ("StepMove" Diagonal)))
        
        
        (piece "Ryuma" Each (or ("SlideMove" Diagonal) ("StepMove" Orthogonal)))
        
        
        ("ShogiGold" "Narikei" "CapturePiece")
        
        
        ("ShogiGold" "Narikyo" "CapturePiece")
        
        (regions "LastRankP1" P1 (sites Top))
        (regions "LastRankP2" P2 (sites Bottom))
        (regions "TwoFurthestRankP1" P1 (expand (sites Top)))
        (regions "TwoFurthestRankP2" P2 (expand (sites Bottom)))
        (regions "Promotion" P1 (expand (sites Top) steps:2))
        (regions "Promotion" P2 (expand (sites Bottom) steps:2))
        (map "Where" {
            (pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) 
            (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) 
            (pair (id "Hisha" P1) (handSite P2 2)) (pair (id "Hisha" P2) (handSite P1 2)) 
            (pair (id "Kakugyo" P1) (handSite P2 3)) (pair (id "Kakugyo" P2) (handSite P1 3)) 
            (pair (id "Keima" P1) (handSite P2 4)) (pair (id "Keima" P2) (handSite P1 4)) 
            (pair (id "Kyosha" P1) (handSite P2 5)) (pair (id "Kyosha" P2) (handSite P1 5)) 
            (pair (id "Kinsho" P1) (handSite P2 6)) (pair (id "Kinsho" P2) (handSite P1 6)) 
            (pair (id "Tokin" P1) (handSite P2)) (pair (id "Tokin" P2) (handSite P1)) 
            (pair (id "Narigin" P1) (handSite P2 1)) (pair (id "Narigin" P2) (handSite P1 1)) 
            (pair (id "Ryuo" P1) (handSite P2 2)) (pair (id "Ryuo" P2) (handSite P1 2)) 
            (pair (id "Ryuma" P1) (handSite P2 3)) (pair (id "Ryuma" P2) (handSite P1 3)) 
            (pair (id "Narikei" P1) (handSite P2 4)) (pair (id "Narikei" P2) (handSite P1 4)) 
            (pair (id "Narikyo" P1) (handSite P2 5)) (pair (id "Narikyo" P2) (handSite P1 5)) 
        })
        (map "Captured" { 
            (pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) 
            (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) 
            (pair (id "Hisha" P1) (id "Hisha" P2)) (pair (id "Hisha" P2) (id "Hisha" P1)) 
            (pair (id "Kakugyo" P1) (id "Kakugyo" P2)) (pair (id "Kakugyo" P2) (id "Kakugyo" P1)) 
            (pair (id "Keima" P1) (id "Keima" P2)) (pair (id "Keima" P2) (id "Keima" P1)) 
            (pair (id "Kyosha" P1) (id "Kyosha" P2)) (pair (id "Kyosha" P2) (id "Kyosha" P1)) 
            (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) 
            (pair (id "Tokin" P1) (id "Fuhyo" P2)) (pair (id "Tokin" P2) (id "Fuhyo" P1)) 
            (pair (id "Narigin" P1) (id "Ginsho" P2)) (pair (id "Narigin" P2) (id "Ginsho" P1)) 
            (pair (id "Ryuo" P1) (id "Hisha" P2)) (pair (id "Ryuo" P2) (id "Hisha" P1)) 
            (pair (id "Ryuma" P1) (id "Kakugyo" P2)) (pair (id "Ryuma" P2) (id "Kakugyo" P1)) 
            (pair (id "Narikei" P1) (id "Keima" P2)) (pair (id "Narikei" P2) (id "Keima" P1)) 
            (pair (id "Narikyo" P1) (id "Kyosha" P2)) (pair (id "Narikyo" P2) (id "Kyosha" P1)) 
        })
        (map "Promoted" { 
            (pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) 
            (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) 
            (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) 
            (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2)) 
            (pair (id "Keima" P1) (id "Narikei" P1)) (pair (id "Keima" P2) (id "Narikei" P2)) 
            (pair (id "Kyosha" P1) (id "Narikyo" P1)) (pair (id "Kyosha" P2) (id "Narikyo" P2)) 
        })
        
        (hand Each size:8)
    })
    
    (rules 
        (start { 
            (place "Osho1" (handSite P1 7)) (place "Kinsho1" (handSite P1 6) count:2) (place "Ginsho1" (handSite P1 1) count:2) (place "Keima1" (handSite P1 4) count:2) (place "Kyosha1" (handSite P1 5) count:2) (place "Kakugyo1" (handSite P1 3)) (place "Hisha1" (handSite P1 2)) (place "Fuhyo1" (handSite P1) count:9)
            (place "Osho2" (handSite P2 7)) (place "Kinsho2" (handSite P2 6) count:2) (place "Ginsho2" (handSite P2 1) count:2) (place "Keima2" (handSite P2 4) count:2) (place "Kyosha2" (handSite P2 5) count:2) (place "Kakugyo2" (handSite P2 3)) (place "Hisha2" (handSite P2 2)) (place "Fuhyo2" (handSite P2) count:9)
        })
        
        (play
            (if ("SameTurn")
                (or
                    ("Promote")
                    (move Pass)
                )
                (do 
                    (or {
                        (move 
                            (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho" "Osho"})) 
                            (to (sites Empty))
                        ) 
                        ("PlacePawn" Mover Next)
                        ("PlaceLance" Mover)
                        ("PlaceKnight" Mover) 
                        (forEach Piece) 
                    })
                    ifAfterwards:(or (not ("IsInCheck" "Osho" Mover)) (no Pieces Next "Osho" in:(sites Board)))
                )
            )
        )
        
        (end {
            (if (and {
                    ("IsInCheck" "Osho" Next)
                    ("NextCannotMove")
                    (= (count Pieces Mover "Osho" in:(sites Board)) 1)
                }) 
                (result Mover Win)
            ) 
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
The Long Assize was a version of Chess played in medieval France and England.8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. The King may leap to the second square on its first move if it has not yet been checked and does not hop over an opponent's piece. 1 x Queen: One square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. 2 x Rook: Any number of spaces orthogonally. 2 x Fil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. May move two spaces on its first move. En passant is allowed. Promoted to Queen when reaching the eighth rank, and may make the Queen's leap on its first move after being promoted. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a draw. Capturing all of an opponent's pieces except the King also results in a win. 
(game "Long Assize"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        (piece "King" Each
            (or
                ("StepToNotFriend")
                (if (= 1 (state at:(from)))
                    (move Hop 
                        (between if:(not ("IsEnemyAt" (between)))) 
                        (to 
                            if:(not ("IsFriendAt" (to))) 
                            "CaptureToPiece" 
                        )
                    )
                )
                ("RememberPieceHasMoved")
            )
        )
        ("ChessRook" "Rook")
        (piece "Bishop" Each
            (move Hop 
                Diagonal 
                (between if:True) 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece" 
                )
            )		
        )
        ("ChessKnight" "Knight")
        (piece "Queen" Each
            (or
                ("StepToNotFriend" Diagonal "RememberPieceHasMoved")
                (if (= 1 (state at:(from)))
                    (move Hop 
                        Diagonal
                        (between if:True)
                        (to if:(is Empty (to)))
                    )
                )
                ("RememberPieceHasMoved")
            )
        )
        ("ChessPawn" "Pawn"
            (or 
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
                )
                "EnPassant"
            )
            (then
                (if (is In (last To) (sites Mover "Promotion")) 
                    (and
                        (promote (last To) (piece (id "Queen" Mover)))
                        (set State at:(last To) 1)
                    )
                )
            )
        )
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (do (forEach Piece) 
                ifAfterwards:(not ("IsInCheck" "King" Mover))
                (then
                    (if (and (= 1 (state at:(where "King" Next))) ("IsInCheck" "King" Next))
                        ("PieceHasMoved" (where "King" Next))
                    )
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            ("DrawIfNoMoves" Next)
            (if (= (count Pieces Next) 1) (result Mover Win)) 
        })
    )
)

Construct a Ludii game based on the following description
In Buffalo Chess, a.k.a. Bison, one player represents a villager and their dogs, who are trying to keep the village from being overrun by buffalos, controlled by the other player.Buffalos move one step forward to a free space. Dogs move like a chess queen but cannot capture. The villager moves like a chess king, and can capture buffalos. Dogs and the villager cannot enter the top or bottom rows of the board. Buffalos start, and win by reaching the top row. They lose if they cannot move anymore. 
(game "Bison"
    (players 2)
    (equipment {
        (board (rectangle 7 11))
        (piece "Bull" P1 ("StepForwardToEmpty"))
        (piece "Colonel" P2
            (move Step Adjacent
                (to if:
                    (and
                        "ToCenter"
                        (not ("IsFriendAt" (to)))
                    )
                    (apply
                        (if ("IsEnemyAt" (to))
                            (remove (to))
                        )
                    )
                )
            )
        )
        (piece "Dog" P2
            (move Slide
                (between if:(and
                        "ToCenter"
                        (is Empty (to))
                    )
                )
            )
        )
    })
    (rules
        (start {
            (place "Bull1" (sites Bottom))
            (place "Colonel2" {"F6"})
            (place "Dog2" {"D6" "E6" "G6" "H6"})
        })
        (play (forEach Piece))
        (end {
            ("ReachWin" (sites Top) P1)
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
Designed in the early 2000s by Elliot Rudell and published by The Happy Puzzle Company and ThinkFun.Each player has 6 Chess queens. It is played on a 5x5 board. The starting position has the queens arranged on opposite sides, alternating white-black-white-black in each space. The pieces move as queens in Chess. The first player to line up four queens in a row wins. 
(game "All Queens Chess" 
    (players 2) 
    (equipment { 
        (board (square 5)) 
        (piece "Queen" Each (move Slide))
    }) 
    (rules 
        (start { 
            (place "Queen1" 
                (union { 
                    (difference (sites Bottom) (sites Phase 1)) 
                    (intersection (sites Left) (sites Row (/ (count Rows) 2)))
                    (difference (sites Top) (sites Phase 0)) 
                }) 
            )
            (place "Queen2" 
                (union { 
                    (difference (sites Bottom) (sites Phase 0)) 
                    (intersection (sites Right) (sites Row (/ (count Rows) 2)))
                    (difference (sites Top) (sites Phase 1)) 
                }) 
            )
        })
        
        (play (forEach Piece))
        (end (if (is Line 4) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
A highly tactical game of battling stacks growing into existence.Ex nihilo is a game for 2 players played with stackable pieces of two colors on the cells of a hexagonal arrangement of hexagons (a hexhex board). The board starts out empty. The game is over as soon as one player is unable to make a move. The other player is then the winner.
            
            Even though the goal is technically stalemate, out of the interlocking mechanics emerges a territorial goal with a constant threat of a clever check mate turning the tide or ending the game before territory is settled.
            
            The novelty of this game lies in its central gimmick: Every move consists in moving a stack. In this sense it is a pure movement game. Yet, the game features both placement and captures.
            
            Movement – overview:
            Stacks move along straight open lines and grow when they move away from the center cell. This game is unusual in allowing movement of stacks containing 0 pieces. It is by growing these that pieces get onto the board in the first place.
            
            Movement – details:
            On your turn, you must move a stack not topped by an enemy piece to an empty cell reachable through an unbroken line of empty cells. By convention, a single piece is considered a stack of size 1 and an empty cell is considered to contain a stack of size 0.
            
            If, after you have moved a stack, it is farther away from the center cell than before it was moved (measured in number of steps), its size is increased by 1 per step further away from the center it now is. This happens automatically in Ludii.
            
            You may move a proper part of a stack by splitting it. To move a part of a stack, drag the piece that will be the bottom piece of the new stack to its destination, or click it, then the destination.
            
            You may also move a whole stack, but only on the condition that you move it farther away from the center cell. A consequence is that moving a whole stack always results in its size increasing. Together with the convention that empty cells contain stacks of size 0, this also has the consequence that you can effectively place a new stack on the board by moving a stack of size 0. In Ludii a 0-stack is represented by a grey disc. You move it by dragging it to where you want to go, or click it, then the destination.
            
            Note that nothing special happens to the cell you moved the 0-stack from – it still contains a 0-stack.
            
            Capturing - overview:
            Flanked enemy stacks are captured by being taken hostage for a move. Capturing is obligatory: If a capturing move is available, a capturing move must be made.
            
            Capturing - details:
            If (and only if) the top piece of a stack is of your color, it is said to partake in flanking an enemy stack if (i) this enemy stack is exactly in the middle of a line of otherwise empty cells going from the flanking stack to another one of your stacks, and (ii) all three of these stacks are of the same size.
            
        If, after you have moved a stack, it partakes in flanking one or more enemy stacks, you must immediately move one of these enemy stacks. Except for the obvious difference that you are moving an enemy stack, all normal rules apply to this move. For example: If the captured stack grows (if you move it farther away from the center cell, that is), it grows by the addition of pieces of your color, so situations where this hostage move must itself be a capturing move are possible. Such chaining of captures must continue until you capture a stack that is not in a position to continue the chain. Growing captured stacks is the only way to take ownership of them more permanently. A base 4 board is currently selected
(game "Ex Nihilo"
    (players 2)
    (equipment {
        (board (hex <Board>))
        (piece "Disc" Each)
        (piece "Disc" Neutral)
    })
    (rules
        (start (place "Disc0" (sites Board)))
        (play
            (priority
                (do
                    (if
                        (= 1 (var))
                        (and
                            (set Var 0)
                            ("Capture")
                        )
                        ("MoveStack")
                    )
                    ifAfterwards:("CapturableInAnyDirection")
                )
                (if
                    (= 1 (var))
                    (do
                        (set Var 0)
                        next:("Capture")
                    )
                    ("MoveStack")
                )
                (then
                    (and
                        (forget Value All)
                        ("RememberAllCapturables")
                        (then
                            (if
                                ("CapturableInAnyDirection")
                                (and
                                    (set Var 1)
                                    (moveAgain)
                                )
                            )
                        )
                    )
                )
            )
        )
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
Svensk Brädspel is a European Tables game played in Sweden. It involves the possibility of winning by bringing the pieces to one of various winning positions. It was said to have been the most popular game in all parts of Sweden, in cities and in rural areas.2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A throw of doubles forces the player to play the throw twice. Each player's pieces begin in three stacks of five, on the leftmost point (with respect to the opponent) on the opponent's side of the board. Play proceeds (with respect to the player) from right to left on the opponent's side of the board, and then from left to right on the player's side of the board. A player cannot place two pieces on a single point on any of the first eleven points of the board, except for those pieces in the starting position, until one of the player's pieces has first landed on the twelfth point. However, a player may place two pieces on any point after the twelfth point, regardless of whether a piece has ever landed on the twelfth point. A player cannot move a piece onto a point containing two or more pieces belonging to the opponent. When a piece lands on a point occupied by a single piece belonging to the opponent, it is removed from the board and must be entered again, and can only do so using the value of one die, not both, with the starting point considered to be point 1, the next point 2, etc. Opponent's pieces can be removed from the board in this way when reentering the board. To win, a player must place their pieces in one of the following winning positions: five pieces on each of the final three points; three pieces on the final five points; seven on the final point, five on the penultimate point, and three on the antepenultimate point; fifteen on the final point. If none of these positions are possible, the player must bear off all of their pieces once all of their pieces have reached the final six points. The first player to reach a winning position or to bear off all of their pieces wins. 
(game "Svensk Bradspel"
    (players 2)
    (equipment {
        ("BackgammonBoard" ("BackgammonTracksSameDirectionOppositeCornersWithBars2" End)) 
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die
                replayDouble:True 
                if:("DieNotUsed")
                (if ("IsEndTrack" ("NextSiteFrom" (from) (pips)))
                    (if ("AllPiecesInFinalQuadrant")
                        (move Remove (from))
                    )
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:(and 
                                ("NoEnemyOrOnlyOne" (to))
                                (if (not (is In (to) (sites Mover "StartingSide")))
                                    True
                                    (if (= (value Player Mover) 1) True (is Empty (to)))
                                )
                            )
                            (apply 
                                (if ("IsEnemyAt" (to))
                                    (fromTo 
                                        (from (to))
                                        (to (mapEntry "Bar" Next))
                                    )
                                )
                            )
                        )
                    )
                )
                (then 
                    (and
                        ("ReplayNotAllDiceUsed")
                        (if (and
                                (= (last To) (mapEntry "12thPoint" Mover))
                                (!= 1 (value Player Mover))
                            )
                            (set Value Mover 1)
                        )
                    )
                )
            )		
        )
        (regions "FinalQuadrant" P1 (sites {7..12}))
        (regions "FinalQuadrant" P2 (sites {13..18}))
        (regions "StartingSide" P1 (sites {25..20 18..14}))
        (regions "StartingSide" P2 (sites {0..5 7..11}))
        (map "12thPoint" {(pair P1 13) (pair P2 12)})
        (map "Bar" {(pair P1 6) (pair P2 19)})
    })
    (rules 
        (start { 
            (place Stack "Disc1" 25 count:15)
            (place Stack "Disc2" 0 count:15) 
        })
        (play 
            ("RollEachNewTurnMove"
                (forEach Piece top:True)
            )		
        )
        
        (end { 
            ("EscapeWin")
            (if ("FiveOnThreeFinal" Mover) (result Mover Win))
            (if ("ThreeOnFiveFinal" Mover) (result Mover Win))
            (if ("SevenFiveThreeFinal" Mover) (result Mover Win))
            (if ("FifteenFinal" Mover) (result Mover Win))
        })
    )
)

Construct a Ludii game based on the following description
Mehen is a game dating to the late fourth millennium through the end of the third millennium in Egypt. It takes the form of a coiled snake that is segmented into spaces, and the board varies in the number of spaces that appear on it. It is only of the earliest multi-player games documented, with up to six players. Mehen was also played outside of Egypt, particularly in Cyprus and certain parts of the Levant, and was played in Cyprus for at least 1000 years after it became unpopular in Egypt.Spiral shaped board. Up to six players. Each player has six round pieces and two lions.  The rules are describing with the Kendall ruleset.
(game "Mehen"
    (players 2)
    (equipment { 
        (board 
            (spiral turns:5 sites:88) 
            {
            (track "NormalTrack" {"Entry".."EndInnerTrack" End} directed:True)
            (track "OppositeTrack" {"BeginOuterTrack".."Entry" End} directed:True)
            }
            use:Vertex
        ) 
        ("StickDice" 4)
        (hand Each size:2)
        
        (piece "Disc" Each 
            (if ("EmptyCentralSpaceReached") 
                (move Select
                    (from) 
                    ("PieceNowMoveToTheEntry") 
                )
                ("AdvanceOn" "NormalTrack")
            )
        )
        
        (piece "Marker" Each 
            (if ("EntryReachedFromInside")
                (move Select
                    (from) 
                    ("PromoteToLion")
                ) 
                ("AdvanceOn" "OppositeTrack")
            )
        )
        
        (piece "Lion" Each 
            (or
                ("LionMoveOn" "OppositeTrack")
                ("LionMoveOn" "NormalTrack")
            )
        )
    })
    (rules
        (start {
            (place "Disc1" (handSite P1) count:6)
            (place "Disc2" (handSite P2) count:6)
        })
        (play 
            ("RollMove" 
                (or {
                    (if
                        (and {
                            (= (count Pips) 1)
                            ("EntryEmpty")
                            ("HaveDiscToPlace")
                        }) 
                        ("LetInDisc")
                    )
                    (if
                        (and {
                            (= (count Pips) 1)
                            ("EntryEmptyOrOccupiedByEnemy")
                            ("HaveLionToPlace")
                        })
                        ("LetInLion")
                    )
                    (forEach Piece)
                })
            )
        )
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Buudal (the stop) is a capturing game played in Mongolia. One player plays as spotted dogs, the other as black dogs.3x3 intersecting lines, with diagonals in the four squares formed. Six pieces per player. Players alternate turns placing one of their pieces on the board. when all of the pieces have been placed, players alternate turns moving a piece by jumping over an adjacent spot to the next spot, along the lines of the board, which must be empty. If an opponent's piece is in the spot which was jumped, that piece is captured. The player who captures all of the opponent's pieces wins. 
(game "Buudal"
    (players 2) 
    (equipment {
        (board 
            (square 3 diagonals:Solid)
            use:Vertex
        )
        (hand Each)
        (piece "Marker" Each 
            (move Hop 
                (between 
                    if:True
                    (apply (if ("IsEnemyAt" (between)) (remove (between))))
                )
                (to if:(is Empty (to)))
            )
        )
    })
    (rules
        (start (place "Marker" "Hand" count:6))
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Claustro is a proximity restricted pure placement game in which a player loses as soon as one of there pieces is fully surrounded on their turn. The game is 'cold' and can work on multiple types of grids with the same principle.Board starts empty. 
            Place on an empty location, unless it is next to more of your own pieces. 
            Passing is not allowed.
        You lose if at the end of your turn, one of your stones is surrounded. Triangle-Square Grid Order 3 board
(game "Claustro"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Ball" P1)
        (piece "Ball" P2)
    })
    (rules
        (start (set Score Each 0))
        (play
            (move Add 
                (piece (mover))
                (to (sites Empty) 
                    if:(<= 0
                        (- 
                            (count Pieces Next in:(sites Around (to) <BoardShape:directionsUsed>))
                            (count Pieces Mover in:(sites Around (to) <BoardShape:directionsUsed>))
                )))
                (then 
                    (if 
                        (not
                            (all Sites 
                                (sites Occupied by:Mover) 
                                if:(can Move (step (from (site)) <BoardShape:directionsWin> (to if:(is Empty (to)))))
                        ))
                        (trigger "End" Mover)
                        (if 
                            (not
                                (all Sites 
                                    (sites Occupied by:Next) 
                                    if:(can Move (step (from (site)) <BoardShape:directionsWin> (to if:(is Empty (to)))))
                            ))
                            (trigger "End" Next)
                        )
                    )
                )
            )
        )
        (end 
            (if 
                (or (is Triggered "End" Mover) (is Triggered "End" Next))
                (if 
                    (is Triggered "End" Mover)
                    (result Mover Loss)
                )
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Zohn Ahl is a race game played by the Kiowa people of Oklahoma during the nineteenth century. It was typically played on a cloth with the board drawn on it. Players race around the circuit of the board, trying to \The board is roughly rectangular. There are six points on either side, with each side divided in half by two short parallel lines, the rivers. There are four arcs in the corners of the \ Each team has 2 scoring sticks.
(game "Zohn Ahl"
    (players 4)
    (equipment {
        (board
            (graph 
                vertices:{
                {0 0} {1 0.4} {2 0.4} {3 0.4} {4 0} {5 0} {6 0.4} {7 0.4} {8 0.4} {9 0} {4 1} {5 1} 
                {-6 3} {-5.6 4} {-5.6 5} {-5.6 6} {-6 7} {-6 8} {-5 7} {-5 8} {-5.6 9} {-5.6 10} {-5.6 11} {-6 12}
                {0 15} {1 14.6} {2 14.6} {3 14.6} {4 15} {5 15} {6 14.6} {7 14.6} {8 14.6} {9 15} {4 14} {5 14} 
                {15 3} {14.6 4} {14.6 5} {14.6 6} {15 7} {15 8} {14 7} {14 8} {14.6 9} {14.6 10} {14.6 11} {15 12}
                }
                edges:{
                {0 12} {23 24} {33 47} {36 9}
                {4 10} {5 11} {16 18} {17 19}
                {28 34} {35 29} {43 41} {42 40}
                }
            )
            {
            (track "Track1" "5,6,7,8,9,36,37,38,39,40,41,44,45,46,47,33,32,31,30,29,28,27,26,25,24,23,22,21,20,17,16,15,14,13,12,0,1,2,3,End" P1 directed:True)
            (track "Track2" "5,6,7,8,9,36,37,38,39,40,41,44,45,46,47,33,32,31,30,29,28,27,26,25,24,23,22,21,20,17,16,15,14,13,12,0,1,2,3,End" P2 directed:True)
            (track "Track3" "4,3,2,1,0,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,47,46,45,44,41,40,39,38,37,36,9,8,7,6,End" P3 directed:True)
            (track "Track4" "4,3,2,1,0,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,47,46,45,44,41,40,39,38,37,36,9,8,7,6,End" P4 directed:True)
            }
            use:Vertex
        )
        (piece "Stick" P1 ("Move"))
        (piece "Stick" P3 ("Move"))
        (piece "Stick" Neutral)
        ("StickDice" 4)
        (hand P1)
        (hand P3)
        (map "Throw" {(pair 0 10) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 5)})
        (map "Opposite" {(pair P1 29) (pair P2 29) (pair P3 28) (pair P4 28)})
        (map "Start" {(pair P1 5) (pair P2 5) (pair P3 4) (pair P4 4)})
    })
    (rules 
        (start {
            (set Team 1 {P1 P2})
            (set Team 2 {P3 P4})
            (place "Stick1" 5)
            (place "Stick3" 4)
            (place "Stick0" (handSite P1) count:<Scoring:num>)
            (place "Stick0" (handSite P3) count:<Scoring:num>)
        })
        (play 
            ("RollMove"
                (if (or (is Mover P1) (is Mover P2))
                    (forEach Piece P1)
                    (forEach Piece P3)
                )
                (then
                    (if ("ReplayThrow")
                        (moveAgain)
                    )
                )
            )
        )
        (end (if (is Empty (handSite ("HandOpponent"))) (result TeamMover Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Mysore Tiger Game" 
    (players 2) 
    (equipment { 
        (board
            (add
                (remove 
                    (scale 1 2 (wedge 3))
                    vertices:{5}
                )
                edges:{{4 5}}
            )
            use:Vertex
        )
        (hand P1) 
        (piece "Human" P1 ("StepToEmpty"))
        (piece "Tiger" P2
            (or 
                ("StepToEmpty")
                ("HopCapture")
            )
        )
    }) 
    (rules 
        (start {
            (place "Human1" (handSite P1) count:3)
            (place "Tiger2" (sites Top))
        })
        
        phases:{
        (phase "Opening" P1 
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        
        (end {
            (if (no Moves P2) (result P1 Win))
            (if (< (count Pieces P1) 3) (result P2 Win))
        })
    )
)
This game is presented in a group of manuscripts from the Maharaja Krishnaraja Wadiyar III of Mysore. Three people attempt to trap a tiger, and the tiger attempts to eat the people.A triangle, with a point in the center and lines connecting it to the apex and the midpoints of the two sides which meet at the apex. One person plays as the tiger, which begins on the apex. The other person plays as three people. Players alternate turns, with the person playing as the people first placing a person on the board, and then the tiger moving to an empty adjacent spot along the lines of the board. When all of the people have been placed, the people move on the board in the same fashion. The tiger may capture one of the people by jumping over it to an empty adjacent spot immediately on the opposite side of one of the people along the lines of the board. The tiger wins when it captures one person, the people win when they can block the tiger from being able to move. 

Construct a Ludii game based on the following description
The Ludus Anglicorum was a European Table game played in medieval England. It was described in a fourteenth century manuscript describing other similar games.2x12 board, divided in half. Spaces on each side take the form of points. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, toward the point where the opponent's pieces begin, and bearing off the board from there. A player cannot have two of their pieces on the same spot in the starting quadrant. When a piece lands on the same space as a single opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins.  
(game "Ludus Anglicorum" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" 
            {
            (track "Track1" {6 0..5 7..12 25..20 18..12} P1 directed:True)
            (track "Track2" {19 12..18 20..25 12..7 5..0} P2 directed:True)
            } 
        ) 
        (dice num:3)
        (map {(pair 1 19) (pair 2 6)}) 
        (piece "Disc" Each) 
        (regions P1 { 0..5 }) 
        (regions P2 { 13..18 }) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 0 count:15)
            (place Stack "Disc2" 13 count:15)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (forEach Die
                    if:("DieNotUsed")
                    (forEach Site
                        (sites Occupied by:Mover)
                        (if ("CanEscape" ("NextSiteFrom" (site))) 
                            ("RemoveAPiece")
                            (move 
                                (from (site))
                                (to ("NextSiteFrom" (site))
                                    if:("NotEnemyOrOnlyOne")
                                    ("HittingCapture" ("Bar"))
                                )
                            )
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (result Mover Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Gurgaldaj"
    (players 2) 
    (equipment {
        (board
            (concentric Triangle rings:3 joinCorners:True)
            use:Vertex
        )
        (hand Each)
        (piece "Marker" Each
            ("StepToEmpty" ~ 
                (then ("ReplayIfLine3" Orthogonal))
            )
        )
    }) 
    (rules 
        (start (place "Marker" "Hand" count:8))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal) 
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal))
                    ) 
                )
            )
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal) 
                    (forEach Piece)
                )
            )
        )
        }
        (end ("CaptureAll" Next))
    )
)
Gurgaldaj (Nightingale) is a game of alignment played on a triangular board in Mongolia. Three concentric triangles, with lines connecting their midpoints and corners. Eight pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot along the lines. When a player places three of their pieces in a row, they remove one of the opponent's pieces from the board. A piece that is in a three-in-a-row pattern cannot be removed. The player who removes all of the opponent's pieces wins. 

Construct a Ludii game based on the following description
Tsoro is a word used for several regional four-row mancala-style board games in Zimbabwe. In this version, captured counters are added to the player's own side of the board.4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Captured counters are then sown on the player's own side of the board, starting with the hole following the one from which the capture was triggered. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game.
         6 Holes per row.
(game "Tsoro (Reentered Captures)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites Top) (sites Bottom))))
        
        (play 
            (move Select
                (from 
                    (if 
                        ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover "Home") 
                    ) 
                    if:(if "AHoleHasMoreThanOneCounter"
                        (> (count at:(from)) 1)
                        (and (= (count at:(from)) 1) (= 0 (count at:("NextHoleFrom" (from) Mover)))) 
                    )
                )
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (= (count at:(to)) 1)
                            (if (is In (to) (sites Mover "Inner"))
                                (if (> (count at:("OppositePit" (to))) 0) 
                                    (and {
                                        (fromTo 
                                            (from ("OppositePit" (to))) 
                                            (to (to)) 
                                            count:(count at:("OppositePit" (to)))
                                        )
                                        (if 
                                            (> (count at:("OppositeOuterPit" (to))) 0) 
                                            (fromTo 
                                                (from ("OppositeOuterPit" (to))) 
                                                (to (to)) 
                                                count:(count at:("OppositeOuterPit" (to)))
                                            )
                                        ) 
                                        (sow 
                                            (to) 
                                            count:(+ (count at:("OppositeOuterPit" (to))) (count at:("OppositePit" (to)))) 
                                            "Track" 
                                            owner:(mover)
                                        )
                                    }) 
                                ) 
                            )
                            (moveAgain)
                        )
                    )
                )
            )
        )
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Thaayam is a race game played in southern India in the twentieth century.5x5 board, marked with an X in the central square and the midpoints of the outer circuit of spaces. Four players. Four pieces per player. Four seeds, with one white side and one dark side, used as dice. The values of the throws are equal to the number of white sides up, except when no white sides are up the throw equals 8. Throws of 1, 4, and 8 grant the player another throw. Players make all of the throws in their turn first, and then move the values of the throws individually. A player cannot subdivide the value of a single throw between pieces, but may move more than one piece in a turn if they have multiple throws, moving a piece the value of an entire throw. Pieces may only enter the board with a throw of 1. When a player has no pieces on the board, throws made before a throw of 1 do not count and cannot be played. Pieces enter on the marked square on the outer track of the square in front of the player. Pieces move anticlockwise around the outer squares of the board until they reach the square just before the square from which they started, then moving to the inner track and moving clockwise, and then onto the central square. Multiple pieces may occupy the same square. If a player's piece lands on a spot occupied by an opponent's piece, the opponent's piece is removed from the board and must be entered again. If the opponent has multiple pieces on this spot, they all are sent to the beginning. Sending an opponent's piece off the board grants the player another throw. Pieces on marked squares cannot be sent off the board. If a player has two pieces on the marked square on the opposite side of the board from the one in which they begin, the player may declare these as a twin which then play as one piece. Twins move half the value of a throw, rounding down. Twins may only be sent off the board by another twin. Twins may not send back to start a single piece belonging to an opponent. When sent off the board, the twins enter the board again as single pieces. When the twin reaches the central space, it becomes two single pieces again. When all of a player's pieces are in the central square, they may begin bearing them off. A throw of 1 is required to bear a piece off. The player who bears off all their pieces first wins. 
(game "Thaayam"
    (players 4)
    (equipment {
        (board (square 5)
            {
            (track "Track1" "2,E,N,W,S,E1,N3,E2,S2,W1,N1" P1 directed:True)
            (track "Track2" "14,N,W,S,E,N1,W3,N2,E2,S1,W1" P2 directed:True)
            (track "Track3" "22,W,S,E,N,W1,S3,W2,N2,E1,S1" P3 directed:True)
            (track "Track4" "10,S,E,N,W,S1,E3,S2,W2,N1,E1" P4 directed:True)
            }
        )
        (hand Each)
        (regions "MarkedCells" 
            (union {
                (sites Centre) 
                (intersection (sites Outer) (sites Row (row of:(centrePoint))))
                (intersection (sites Outer) (sites Column (column of:(centrePoint))))
            })
        )
        (piece "Counter" Each
            (or
                (if ("IsNotOffBoard" ("SiteToMoveOnTrack" (value)))
                    (move 
                        (from (from) level:(level))
                        (to ("SiteToMoveOnTrack" (value))
                            (apply 
                                if:True 
                                (and
                                    (if 
                                        (and {
                                            ("IsEnemyAt" (to))
                                            (= (value Piece at:(to)) 1) 
                                            (not (is In (to) (sites "MarkedCells")))
                                        })
                                        (fromTo 
                                            (from (to))
                                            (to 
                                                (handSite (who at:(to)))
                                                (apply
                                                    if:True 
                                                    (and
                                                        (set Pending)
                                                        (moveAgain)
                                                    )
                                                )
                                            )	
                                            count:(size Stack at:(to))
                                            stack:True
                                        )
                                    )
                                    (forget Value (value))
                                )
                            )
                        )
                    )
                )
                (if (and (= 1 (value)) ("AllPieceInCentre"))
                    (move 
                        (from (from) level:(level))
                        (to 
                            (handSite Mover)
                            (apply if:True
                                (forget Value (value))
                            )
                        )
                        (then 
                            (remove (last To))
                        )
                    )
                )
            )
        )
        (piece "DoubleCounter" Each 
            (if (and (> (/ (value) 2) 0) ("IsNotOffBoard" ("SiteToMoveOnTrack" (/ (value) 2))))
                (move 
                    (from (from) level:(level))
                    (to ("SiteToMoveOnTrack" (/ (value) 2))
                        (apply 
                            if:True 
                            (and
                                (if 
                                    (and {
                                        ("IsEnemyAt" (to))
                                        (= (value Piece at:(to)) 2) 
                                        (not (is In (to) (sites "MarkedCells")))
                                    })
                                    (and {
                                        (remove (to)) 
                                        (add 
                                            (piece ("CounterPlayer" (who at:(to)))) 
                                            (to (handSite (who at:(to)))) 
                                            count:2 
                                            stack:True
                                        )
                                        (set Pending)
                                        (moveAgain)
                                    })
                                )
                                (forget Value (value))
                            )
                        )
                    )
                    (then 
                        (if (= (centrePoint) (last To))
                            (and
                                (remove (last To))
                                (add 
                                    (piece ("CounterPlayer" (who at:(last To)))) 
                                    (to ((last To))) 
                                    count:2 
                                    stack:True
                                )
                            )
                        )
                    )
                )
            )
        ) 
        ("StickDice" 4)
        (map "Start" {(pair P1 2) (pair P2 14) (pair P3 22) (pair P4 10)})
        (map "OppositeStart" {(pair P1 22) (pair P2 10) (pair P3 2) (pair P4 14)})
    })
    (rules 
        (start {
            (place Stack "Counter1" (handSite P1) count:4 value:1)
            (place Stack "Counter2" (handSite P2) count:4 value:1)
            (place Stack "Counter3" (handSite P3) count:4 value:1)
            (place Stack "Counter4" (handSite P4) count:4 value:1)
        })
        (play 
            (if (can Move ("Move"))
                ("Move")
                (move Pass (then "ForgetAllUselessThrows"))
            )
        )
        
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Slitherlink is a pen and paper puzzle that is played on a rectangular grid of dots.Some of the squares created by the dots have numbers. The goal is to connect dots vertically or horizontally so that they form a continuous loop. The numbers indicate the number of sides in that box which are parts of the loop. 
(game "Slitherlink"
    (players 1) 
    (equipment 
        {
        (board (rectangle <Challenge:size>) (values Edge (range 0 1)) use:Edge)
        (hints { <Challenge:hints> } Cell)
        }
    )
    (rules
        (play
            (satisfy {
                (forAll Cell 
                    (or 
                        (= (hint Cell at:(from)) Off) 
                        (is Count Edge (sites Incident Edge of:Cell at:(from)) (hint Cell at:(from)))
                    )
                )
                (forAll Vertex 
                    (or 
                        (is Count Edge (sites Incident Edge of:Vertex at:(from)) 0)
                        (is Count Edge (sites Incident Edge of:Vertex at:(from)) 2)
                    )
                )
                (< (count Groups Edge) 2)
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
Co Chan Cho is a blocking game that was played by children in the Tonkin region of Vietnam  in the mid twentieth century.  The game was usually drawn on the ground, and broken  pieces of pottery, paper, or straw were used as pieces.The board is a square with diagonals drawn, with the bottom side of the square marked with an X. Two pieces per player, which begin on opposite corners of the square, one player on the side with the X and the other to the opposite side. Players alternate  turns moving  one of their pieces along the lines of the board to an empty adjacent point. Players cannot move along the line marked with an X. When one player  cannot move, the opponent wins. 
(game "Co Chan Cho" 
    (players 2) 
    (equipment { 
        (board 
            (square 2 diagonals:Solid)
            use:Vertex
        )
        (piece "Disc" Each
            (move Step 
                (to 
                    if:(and {
                        (or {
                            (and (!= (from) (coord "A1")) (!= (from) (coord "C1")))
                            (and (= (from) (coord "C1")) (!= (to) (coord "A1")))
                            (and (= (from) (coord "A1")) (!= (to) (coord "C1")))
                        }) 
                        (is Empty (to))
                    })
                )
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Disc1" (sites Top)) 
            (place "Disc2" (sites Bottom))
        })
        (play (forEach Piece))
        (end ("NoMoves" Loss)) 
    )
)

Construct a Ludii game based on the following description
Horde Chess is a Chess variant in which one player plays with a standard set of pieces and the other plays with 32 pawns.The rules are the same as for 
        Chess with these differences: White wins by capturing all black pieces. Black wins by checkmating the white king. If no black piece can make a valid move, the game is a draw (stalemate). Black pawns can be promoted to a black queen, rook, bishop or knight if they reach the last row. Black pawns cannot move two spaces forward from any position except the second rank. 
(game "Horde Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                (if (and 
                        (= (who at:(from)) P1) 
                        (is In (from) (sites Start (piece (what at:(from)))))
                    )
                    ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
                )
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (union {(sites Row 5) (sites Row 6) (sites Row 4) (difference (sites Row 7) (sites {"D8" "E8"})) (difference (sites Row 3) (sites {"A4" "B4" "C4" "F4" "G4" "H4"}))}))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (if (is Mover P1)
                    (do 
                        (or 
                            (forEach Piece)
                            (if (and {
                                    "KingInTheInitialPlace" 
                                    ("HasNeverMoved" "King")
                                    (not ("IsInCheck" "King" Mover)) 
                                })
                                (or
                                    (if (and 
                                            ("HasNeverMoved" "RookLeft")
                                            (can Move ("DoCastle" "RookLeft" E 3 (is Empty (to))))
                                        )
                                        "BigCastling"
                                    )
                                    (if (and 
                                            ("HasNeverMoved" "RookRight")
                                            (can Move ("DoCastle" "RookRight" W 2 (is Empty (to))))
                                        )
                                        "SmallCastling"
                                    )
                                )
                            )
                        )
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                    (forEach Piece)
                )
            )
        )
        
        (end {
            (if (and 
                    (is Mover P1)
                    (no Pieces P2)
                ) 
                (result P1 Win)
            ) 
            (if (and {
                    (is Mover P2)
                    ("IsInCheck" "King" Next)
                    (not (can Move (do (forEach Piece Next) ifAfterwards:(not ("IsInCheck" "King" Next)))))
                }) 
                (result P2 Win)
            ) 
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Lam Waladach is a two-row mancala-style board game played in central Ethiopia. It begins with a stylized move.2x6 board. Four counters in each hole. The first player takes three counters from each of their holes, and sows them beginning in the opponent's first hole. Sowing proceeds in an anti-clockwise direction, and when the final counter lands in an occupied hole, these are picked up and sowing continues. While sowing, if a hole is made to contain four counters, these are captured by the player. When the final counter falls into an empty hole, the turn ends, unless the player was able to make a capture during the sowing, in which case they may play again. A player with no counters on their side must pass, and may continue playing when there are counters in their holes again. Play continues until all the counters are captured, and the player with the most counters wins. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, but not if there are one or two extra. Play continues in several rounds like this until one player captures all the holes.
         
(game "Lam Waladach" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightMost" {(pair P1 5) (pair P2 6)})
    }) 
    (rules 
        
        (start { 
            (set Count 4 to:(sites Track))
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Opening"
            (play
                (move Select 
                    (from 11)
                    (then
                        (and
                            (forEach Site (sites Mover)
                                (fromTo
                                    (from (site))
                                    (to 11)
                                    count:3
                                )
                            )
                            (sow
                                count:18
                                "TrackCCW"
                                apply:(if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                )
                                origin:True
                            )
                        )
                    )
                )
            )
            (nextPhase "Sowing")
        )
        
        (phase "Sowing"
            (play
                (or {
                    (move Select 
                        (from 
                            (if 
                                (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then
                            (do
                                (set Var "NumSowed" (count at:(last To)))
                                next:(sow
                                    "TrackCCW"
                                    apply:(if (< 1 (count at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )	
                                )
                                (then
                                    (and
                                        (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed")))
                                            (if (= 4 (count at:(site)))
                                                (and
                                                    (fromTo
                                                        (from (site))
                                                        (to (handSite Mover))
                                                        count:4
                                                    )
                                                    (and
                                                        (moveAgain)
                                                        (set Pending)
                                                    )
                                                )
                                            )
                                        )
                                        (set Var "NumSowed" 0)
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("NoPieceOnBoard")
                            (and 
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            )
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 3 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
            
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 3 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("RightMostEmpty"))
                        count:(if (>= (count Cell at:(handSite Mover)) 4) 4 3)
                        (then
                            ("RemmemberOwnedHoles" (last To))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Sig is a game played in several parts of Morocco. This version is played by the Mzab people. It is a game of captures that is related to similar games, such as Tab, known in North Africa and Southwest Asia.Four rows of holes, of any number. Each player has as many pieces as are in one row. The pieces start in the outer row of the board for each player. Six sticks used as dice, with a green side and a white side. The throws are as follows: one white up = 0; two white up = 2; three white up = 1; four white up = 4; five white up = 0; zero white or six white up = 6. Each piece's first move must be with a throw of 1 or 6. This first throw moves the piece one space only. Play moves from left to right in the player's home row, from right to left in the second row, left to right in the third row, and right to left in the opponent's home row. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is removed from the board. The player who captures all of the opponent's pieces wins. Each row has 5 holes.
(game "Sig (Mzab)"
    (players 2)
    (equipment {
        (board 
            (rectangle 4 <Board:size>) 
            {
            (track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True)
            (track "Track2" <Board:trackP2> P2 directed:True)
            }
            use:Vertex
        )
        (piece "Stick" Each
            (if (or 
                    ("ActivatedPiece") 
                    (and (or (= 1 ("ThrowValue")) (= 6 ("ThrowValue"))) ("InactivePiece"))
                )
                (if ("IsNotOffBoard" ("NextSiteOnTrack" (if ("InactivePiece") 1 ("ThrowValue"))))
                    (if (or
                            (is In ("NextSiteOnTrack" (if ("InactivePiece") 1 ("ThrowValue"))) (sites Empty))
                            ("IsEnemyAt" ("NextSiteOnTrack" (if ("InactivePiece") 1 ("ThrowValue"))))
                        )
                        (move 
                            (from)
                            (to 
                                ("NextSiteOnTrack" (if ("InactivePiece") 1 ("ThrowValue"))) 
                                "CaptureEnemyPiece"
                            )
                        )
                    )
                    (then ("ActivatePiece"))
                )
            )
        )
        (regions "AllSites" (sites Board))
        ("StickDice" 6)
        (map {(pair 0 6) (pair 1 0) (pair 2 2) (pair 3 1) (pair 4 1) (pair 5 0) (pair 6 6)})
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    })
    (rules 
        (start { 
            (place "Stick1" (sites Bottom) state:1)
            (place "Stick2" (sites Top) state:1)
        })
        (play ("RollMove" (forEach Piece)))
        (end {
            ("CaptureAll" Next)
            (if ("AllPieceInOpponentHome")
                (result Mover Draw)
            )
        })
    )
)

Construct a Ludii game based on the following description
Shisen-Sho (四川省, Shisenshō; \Player choose a pair of identical tiles to connect. If the requirements are met, two tiles will be eliminated. The player’s task is to eliminate all the tiles on the board. The game is over if future moves are not possible and tiles are left on the board, or the player successfully removes all the tiles. Small Size No outer ring of spaces
(game "Shisen-Sho" 
    (players 1)
    (equipment { 
        (board (rectangle (+ <Size:boardHeight> <OuterRing:extraBoardSize>)(+ <Size:boardWidth> <OuterRing:extraBoardSize>))) 
        
        (piece "BambooOne" P1) 
        (piece "BambooTwo" P1) 
        (piece "BambooThree" P1) 
        (piece "BambooFour" P1) 
        (piece "BambooFive" P1) 
        (piece "BambooSix" P1)
        (piece "BambooSeven" P1) 
        (piece "BambooEight" P1) 
        (piece "BambooNine" P1)
        
        (piece "CharacterOne" P1) 
        (piece "CharacterTwo" P1) 
        (piece "CharacterThree" P1) 
        (piece "CharacterFour" P1) 
        (piece "CharacterFive" P1) 
        (piece "CharacterSix" P1)
        (piece "CharacterSeven" P1) 
        (piece "CharacterEight" P1) 
        (piece "CharacterNine" P1)
        
        (piece "CircleOne" P1) 
        (piece "CircleTwo" P1) 
        (piece "CircleThree" P1) 
        (piece "CircleFour" P1) 
        (piece "CircleFive" P1) 
        (piece "CircleSix" P1)
        (piece "CircleSeven" P1) 
        (piece "CircleEight" P1) 
        (piece "CircleNine" P1)
        
        (piece "DragonGreen" P1)
        (piece "DragonRed" P1) 
        (piece "DragonWhite" P1) 
        
        (piece "FlowerBamboo" P1)
        (piece "FlowerChrysanthemum" P1)
        (piece "FlowerOrchid" P1)
        (piece "FlowerPlum" P1)
        
        (piece "SeasonSpring" P1)
        (piece "SeasonSummer" P1)
        (piece "SeasonAutumn" P1)
        (piece "SeasonWinter" P1)
        
        (piece "WindNorth" P1)
        (piece "WindEast" P1)
        (piece "WindWest" P1)
        (piece "WindSouth" P1)
        
        <OuterRing:tilePlacementRegion>
    }) 
    (rules 
        (start { 
            (place Random (sites "TilePlacementRegion") {"BambooOne" "BambooTwo" "BambooThree" "BambooFour" "BambooFive" "BambooSix" "BambooSeven" "BambooEight" "BambooNine"
                "CharacterOne" "CharacterTwo" "CharacterThree" "CharacterFour" "CharacterFive" "CharacterSix" "CharacterSeven" "CharacterEight" "CharacterNine"
                "CircleOne" "CircleTwo" "CircleThree" "CircleFour" "CircleFive" "CircleSix" "CircleSeven" "CircleEight" "CircleNine"
                "DragonGreen" "DragonRed" "DragonWhite"
                "FlowerBamboo" "FlowerChrysanthemum" "FlowerOrchid" "FlowerPlum"
                "SeasonSpring" "SeasonSummer" "SeasonAutumn" "SeasonWinter"
                "WindNorth" "WindEast" "WindWest" "WindSouth"
            } count:<Size:numTiles>) 
        })
        (play "Move")
        (end (if (no Pieces All) (result P1 Win))) 
    )
)

Construct a Ludii game based on the following description
El Zorro is a hunt game played on the island of La Palma in the Canary Islands since at least the early twentieth century. It was typically played on lines etched in stone or on the ground, and the pieces were pebbles or corn kernels.Five squares which are each divided with lines connecting the midpoints of their sides and diagonals. The five squares are arranged in a cross-shaped board. One player plays as two foxes the other as twenty hens. The hens begin on the twenty spaces on one half of the board, the foxes on the bottom two corners of the square on the opposite arm of the cross. The foxes may move in any direction, and hop over a hen to an empty space immediately adjacent on the opposite side of the hen along the lines of the board to capture. The hens may not move backward. The foxes win by capturing all the hens, the hens win by occupying all of the spaces in the square of the arm of the cross opposite from where they began. 
(game "El Zorro" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        ("CrossBoard" 3 7 use:Vertex diagonals:Alternating)
        (piece "Fox" P1 (or ("HopCapture") "StepToEmpty"))
        (piece "Hen" P2 ("StepToEmpty" (directions {Rightward Leftward Forwards}))) 
    }) 
    (rules 
        (start { 
            (place "Hen2" (union (sites Top) (expand (sites Row 4))))
            (place "Fox1" (intersection (union (sites Column 4) (sites Column 2)) (sites Bottom)))
        })
        
        (play (forEach Piece))
        
        (end {
            (if
                (all Sites (expand (sites Bottom) steps:2) if:(= (who at:(site)) P2))
                (result P2 Win)
            )
            (if (no Pieces P2) (result P1 Win))
        }) 
    )
)

Construct a Ludii game based on the following description
Plakoto is a game related to Backgammon that is typically played as part of Tavli, along with Fevga and Portes, in the eastern Mediterranean.Played on a standard Backgammon board. Each player starts with fifteen pieces on the starting point of their track. Two six-sided dice. The pieces move around the board in opposite directions in a horseshoe-shaped track.
            
            Each player rolls one die. The player who rolls highest goes first. The player then rolls two die to begin play.  The numbers on the two dice constitute separate moves; i.e. a piece must move the full value of an individual die. One piece may move the combined total of the two die. Doubles are played twice. A player must use both numbers of a roll if possible, or all four numbers in the case of doubles. 
            
            If a player lands on a point occupied by a single opposing piece, the opponent’s piece is trapped until the trapping player removes their piece.
            
            A piece may not be moved to a point occupied by two or more of the opponent's pieces. The player cannot move a piece to a point where the opponent has trapped another of the player's pieces. 
            
            Once a player has moved all fifteen of their pieces into the their home section of the board (that is, the six points at the end of the player's track), the player may begin bearing off. A player cannot bear off when the player has one or more pieces trapped inside the their home section. A player bears off by rolling a number equal to the number of points left in the track of a piece, plus one. If there is no piece on the point indicated by the roll, then the player must make a legal move using a piece that will not remove it from the board. If there are no pieces available to fulfill this condition, the player must remove a piece that is furthest from the goal. The first player to bear off all fifteen pieces wins the game.
            
            If the last piece belonging to player remains in the starting position is trapped by the opponent before it has left the starting position, the player loses. The only exception is if the opponent still has pieces on their starting position. A game in which both players' respective pieces in the starting position are trapped is a draw.
            
            In Tavli, in subsequent rounds, the winner of the previous round plays first.
            
        The game is also typically played with a point system, where points are lost based on the winning conditions. Players lose two points by losing if they haven't yet borne off any of their pieces, or one point if they have borne off at least one piece. A player who loses because their final piece in the starting position was trapped loses two points. 
(game "Plakoto" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" "BackgammonTracks")
        (dice num:2)
        (regions P1 { 20..25 }) 
        (regions P2 { 7..12 }) 
        (piece "Disc" Each ("MoveAPieceIf" "DieNotUsedAndNoEscapeAndNotOffTheTrack" (from))) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 12 count:15)
            (place Stack "Disc2" 25 count:15)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (if "AllPieceInHome"
                    (forEach Die 
                        replayDouble:True 
                        if:("DieNotUsed")
                        (forEach Site 
                            (sites Occupied by:Mover)
                            (if ("NotEmptyAndNotOffTheBoard") 
                                (if ("CanEscape")
                                    ("RemoveAPiece")
                                    ("MoveAPiece" (site))
                                )
                            )
                            noMoveYet:(firstMoveOnTrack "Track" Mover
                                (if "HaveAPieceAndCanEscape"
                                    "RemoveAPiece"
                                )
                            )
                            (then ("ReplayNotAllDiceUsed"))
                        )
                    )
                    (max Distance "Track" Mover
                        (forEach Piece top:True 
                            (then ("ReplayNotAllDiceUsed"))
                        )
                    )
                )
            )
        )
        
        (end {
            (if ("AllPieceEscaped")
                (byScore { 
                    ("SetScoreOf" P1 P2)
                    ("SetScoreOf" P2 P1)
                })
            )
            (if ("MotherCheckerP1Pinned")
                (byScore { 
                    (score P1 0)
                    (score P2 2)
                })
            )
            (if ("MotherCheckerP2Pinned")
                (byScore { 
                    (score P1 2)
                    (score P2 0)
                })
            )
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Bechi" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 ("Column") store:None
            <Board:tracks>
        )
        (regions "Home" P1 (sites Bottom))      
        (regions "Home" P2 (sites Top))      
        <Board:regions>
        (piece "Seed" Shared) 
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 6 to:(sites Track)))
        
        phases:{
        (phase "Sowing"
            (play 
                (if (can Move ("Move"))
                    ("Move")
                    (move Pass
                        (then 
                            (if (all Passed)
                                (and {
                                    (forEach Site (sites P1 "Home")
                                        (if (is Occupied (site))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P1))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                    (forEach Site (sites P2 "Home")
                                        (if (is Occupied (site))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P2))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                    (forget Value "HolesSowed" All)
                                })
                            )
                        )
                    )
                )
            )
            (end (if (all Passed)
                    {
                    (if (> 6 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 6 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase (all Passed) "BetweenRounds")
        )
        (phase "BetweenRounds"
            (play
                (if (<= 6 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to (intersection (sites Empty) (sites Mover "Home")))
                        count:6
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
        
    )
)
Béchi is a two-row mancala-style board game played by the Kunama people of Eritrea, particularly by boys and adolescent young men. It involves trickery, in which eliminated holes can be deceptively filled with counters to fool the other player into thinking they can play there.2x4 board. Six counters per hole. Sowing occurs in a clockwise direction from the left half of a player's row, and anti-clockwise when played from the player's right half of the row. The first seed of sowing is placed in the hole from which the sowing began. When the final counter of a sowing falls into an occupied hole, and it now contains an even number of counters, these are captured, provided the contents of that hole have already been moved. Should the following hole also contain an even number of counters, these are also captured, as well as the next one, until there is a hole with an odd number of counters. If a player cannot move, they must pass until the opponent plays in such a way that they may play. If neither player is able to move, they both capture the counters in their rows. Players then count their counters by placing them six per hole. The player who has more counters than necessary to fill their holes places them aside for use in successive rounds. The player who is unable to fill a hole with six counters leaves it empty, also placing the extra counters aside for later use. This hole is not to be sown into. The player chooses which hole to leave empty. Subsequent rounds continue until one player cannot fill a hole with six counters.  The board has 4 columns.

Describe the mechanics of the following Ludii game
(game "Coc-Inbert" 
    (players 2) 
    ("DraughtsEquipment" (square 8)) 
    (rules 
        ("BlackCellsSetup" 3)
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves 
                        ("HopOnlyCounters" (from (last To)) (directions {FR FL})
                            (then 
                                ("PromoteIfReach" (sites Next) "DoubleCounter"
                                    ("ReplayIfCanMove" ("HopOnlyCounters" (from (last To)) (directions {FR FL})))
                                ) 
                            ) 
                        )
                    )
                    (max Moves ("HopDiagonalSequenceCaptureAgain"))
                )
                (priority {
                    (max Moves
                        (priority {
                            (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture"))
                            (forEach Piece "Counter" 
                                ("HopOnlyCounters" (from) (directions {FR FL})
                                    (then 
                                        ("PromoteIfReach" (sites Next) "DoubleCounter"
                                            ("ReplayIfCanMove" ("HopOnlyCounters" (from (last To)) (directions {FR FL})))
                                        ) 
                                    ) 
                                ) 
                            )
                        })
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter")) 
                        )
                        (forEach Piece "DoubleCounter" "StepDiagonalToEmpty")
                    )
                })
            )
        ) 
        
        (end 
            (forEach Player
                if:(no Pieces Player) 
                (result Player Win)
            )
        ) 
    )
)
Coc-Inbert is a Draughts game from early modern France. In it, the goal is reversed: The player who wins is the one who successfully forces the opponent to take all of the player's pieces.8x8 Draughts board. Twelve pieces per player, arranged on the three rows closest to the players. Players alternate turns moving a piece forward diagonally to an adjacent empty space. Pieces capture an opponent's piece by hopping over it to an empty space on the opposite side of it, in a forward direction only. Captures are mandatory, and the maximum number of captures is required. Kings are made when a piece reaches the opposite edge of the board from where it started. Kings may move one space diagonally in either direction, and capture rules are the same as for pieces, except when different capturing routes are available with the same number of captures, the one which takes the most kings must be taken. In addition, if a sequence of captures can be made by a king or a regular piece, it must be made with the king. Kings cannot be captured by regular pieces. The first player to force the opponent to capture all of their pieces wins. 

Construct a Ludii game based on the following description
Kiust Oyun is a capturing game played in Macedonia. Rectangular board, divided into three sections lengthwise. Ten lines divide the outer two sections widthwide. Twelve pieces per player, which begin on the outer intersections closest to the player. Four stick dice, with front and back sides distinguished one from the other. Throws are as follows: Four backs up = kiust. Three backs up = 6; two backs up = 3; one back up = 2; four fronts up = four throws of 6.  A throw of kiust is required to enter the opponent's inner row. The pieces of the left hand player move from left to right and then right to left in the next row, then left to right in the following row, then proceeding to circulate in the central two rows in a clockwise direction. The right hand player's pieces move from right to left in their home row, then left to  right in  the next row, then right to left in the third row, circulating in an anti-clockwise direction. Pieces landing on an opponent's piece with a throw of 2 in the central rows capture the opponent's piece. A player may only pass an opponent's piece without capture with a throw of 3. The player who captures all of the opponent's pieces wins. 
(game "Kiust Oyun"
    (players 2) 
    (equipment { 
        (board 
            (merge {
                (scale 2 1 (rectangle 12 2))
                (shift 2 0 (scale 4 1 (rectangle 12 2)))
                (shift 6 0 (scale 2 1 (rectangle 12 2)))
            })
            {
            (track "Track1" "22,S,E1,N,E1,S" P1 directed:True)
            (track "Track2" "47,S,W1,N,W1,S" P2 directed:True)
            (track "LoopTrack1" "1,N,E1,S" loop:True P1)
            (track "LoopTrack2" "24,N,W1,S" loop:True P2)
            }
            use:Vertex
        )
        ("StickDice" 4)
        (piece "Marker" Each ("Move"))
        (map "Throw" {(pair 0 0) (pair 3 6) (pair 2 3) (pair 1 2) (pair 4 6)})
        (regions "Home" P1 (expand (sites Left)))
        (regions "Home" P2 (expand (sites Right)))
    }) 
    
    (rules 
        (start {
            (place "Marker1" (sites Left))
            (place "Marker2" (sites Right))
        })
        (play
            (do 
                (if (or (= (var "Kiust") 1) ("NewTurn")) (roll))
                next:(if (= 0 ("ThrowValue"))
                    (move Pass (then (and (moveAgain) (set Var "Kiust" 1))))
                    (forEach Piece)
                )
            )
        )
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Conträre Puff is a European Tables game played in Germany. The rules for the game were documented in the nineteenth century, but it could be much older, as other games with similar names are known from earlier periods in Europe.2x12 board, with spaces as points, divided in two. Fifteen pieces per player. Two six-sided die. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The lowest value of the dice must be played; if it cannot, the player does not move. When a player throws doubles, they play the values on each die, as well as the values on the opposite side of the dice (I.e., double 6 if double 1 is thrown, 5 if 2, 3 if 4). However, the values on the bottom can only be played if all of the top values are played. The first double throw is only played once, but every subsequent double throw is played twice, and the top values must be played twice before using the bottom values. Bottom values do not have to be played, or only some of the bottom values may be played if the player wishes. In addition, an extra throw is granted for the second and subsequent throws of doubles. Players enter their pieces onto opposite sections of the board, and proceed around the board toward the section where the opponent enters the board, and then bearing pieces off the board. A player may not land on a point with two or more of the opponent's pieces. A player's piece may land on a point with a single opponent's piece. The opponent's piece is removed from the board and must enter again. The first player to remove all of their pieces from the board wins.
         
(game "Contrare Puff"
    (players 2)
    (equipment {
        ("BackgammonBoard" "BackgammonTracksWithHands") 
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die
                replayDouble:(= 1 (value Player Mover)) 
                if:("DieNotUsed")
                (if ("IsOffBoard" ("NextSiteFrom" (from) (pips)))
                    (move Remove (from))
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NoEnemyOrOnlyOne" (to))
                            ("HittingCapture" (handSite (who at:(to))))
                        )
                    )
                )
                (then 
                    (if (not (all DiceUsed))
                        (moveAgain)
                        (if (= 1 (value Player Mover))
                            (if (and (all DiceEqual) (= 0 (size Array (values Remembered)))) 
                                (and 
                                    (moveAgain) 
                                    (set Var "PlayOpposite" 1)
                                )
                            )
                            (set Value Mover 1)
                        )
                    )
                )
            )			
        )
        (hand Each)
    })
    
    (rules 
        (start {
            (place Stack "Disc1" (handSite P1) count:15)
            (place Stack "Disc2" (handSite P2) count:15)
        })
        
        (play 
            (do (if (or (is Pending) ("NewTurn")) (roll))
                next:(if (= 1 (var "PlayOpposite"))
                    (or { 
                        (forEach Piece ("MoveOppositeDice") top:True) 
                        (forEach Piece container:(mover) ("MoveOppositeDice") top:True)
                        (move Pass 
                            (then 
                                (and { 
                                    (forget Value "Opposite" All) 
                                    (set Var "PlayOpposite" 0) 
                                    (set Pending) 
                                    (moveAgain)
                                })
                            )
                        )
                    })
                    
                        (do (if (and { 
                                    (= 0 (count MovesThisTurn)) 
                                    (all DiceEqual)
                                    (= 1 (value Player Mover))
                                })
                                (and 
                                    (remember Value "Opposite" (- 7 ("DoubleDieValue"))) 
                                    (remember Value "Opposite" (- 7 ("DoubleDieValue")))
                                )
                            )
                            next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True))
                        )
                    
                )
            )
        )
        
        (end ("EscapeWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "2048"
    (players 1)
    (equipment {
        (board (square 4))
        (piece "Square2" Shared)
        (piece "Square4" Shared)
        (piece "Square8" Shared)
        (piece "Square16" Shared)
        (piece "Square32" Shared)
        (piece "Square64" Shared)
        (piece "Square128" Shared)
        (piece "Square256" Shared)
        (piece "Square512" Shared)
        (piece "Square1024" Shared)
        (piece "Square2048" Shared) 
        (map "Promotion" {
            (pair (id "Square2" Shared) (id "Square4" Shared))
            (pair (id "Square4" Shared) (id "Square8" Shared))
            (pair (id "Square8" Shared) (id "Square16" Shared))
            (pair (id "Square16" Shared) (id "Square32" Shared))
            (pair (id "Square32" Shared) (id "Square64" Shared))
            (pair (id "Square64" Shared) (id "Square128" Shared))
            (pair (id "Square128" Shared) (id "Square256" Shared))
            (pair (id "Square256" Shared) (id "Square512" Shared))
            (pair (id "Square512" Shared) (id "Square1024" Shared))
            (pair (id "Square1024" Shared) (id "Square2048" Shared))
        })
        (map "Score" {
            (pair (id "Square2" Shared) 2)
            (pair (id "Square4" Shared) 4)
            (pair (id "Square8" Shared) 8)
            (pair (id "Square16" Shared) 16)
            (pair (id "Square32" Shared) 32)
            (pair (id "Square64" Shared) 64)
            (pair (id "Square128" Shared) 128)
            (pair (id "Square256" Shared) 256)
            (pair (id "Square512" Shared) 512)
            (pair (id "Square1024" Shared) 1024)
            (pair (id "Square2048" Shared) 2048)
        })
    })
    (rules
        (start (place Random {"Square2"} count:2))
        (play 
            (or {
                (if ("CanSlideW")
                    ("SlideW"
                        ("ApplySlideW")
                    )
                )
                (if ("CanSlideE")
                    ("SlideE"
                        ("ApplySlideE")
                    )
                )
                (if ("CanSlideN")
                    ("SlideN"
                        ("ApplySlideN")
                    )
                )
                (if ("CanSlideS")
                    ("SlideS"
                        ("ApplySlideS")
                    )
                )
                }
                (then
                    (if (< (value Random (range 1 8)) 2)
                        (add (piece "Square4") (to (sites Random (sites Empty) num:1)))
                        (add (piece "Square2") (to (sites Random (sites Empty) num:1)))
                    )		
                )
            )
        )
        (end {
            (if ("IsNotOffBoard" (where "Square2048" Shared)) (result Mover Win))
            (if (no Moves Next) (result Mover Loss))
        })
    )
)
2048 is a single-player sliding tile puzzle video game written by Italian web developer Gabriele Cirulli and published on GitHub.2048 is played on a plain 4×4 grid, with numbered tiles that slide when a player moves them. Every turn, a new tile randomly appears in an empty spot on the board with a value of either 2 or 4. Tiles slide as far as possible in the chosen direction until they are stopped by either another tile or the edge of the grid. If two tiles of the same number collide while moving, they will merge into a tile with the total value of the two tiles that collided. The resulting tile cannot merge with another tile again in the same move. The game is won when a tile with a value of 2048 appears on the board. 

Construct a Ludii game based on the following description
Life and Death are in a constant struggle to gain the upper hand in the cycle of life. A game is played in two rounds. In each round, players strive to achieve a particular goal, unique to them. But at the same time, they pursue a general objective. The player who first achieves one of his two objectives wins the round.
            
            The purpose of Life: Life wants to expand. To achieve this objective, there must be at least one Life pawn in each segment and in each ring of the Circle of Life.
            
            Death's Goal: Death wants to rule. To achieve this goal, at least one complete segment or ring of the Circle of Life must be filled with Death pawns.
            
            Overall Goal: Both players are equally striving to fulfill their destiny. To achieve this objective, you must have all of your 14 pawns on the Circle of Life.
            
            A game is played in two rounds. In each round, one of the players assumes the role of Life, the other that of Death. After the first round, the players switch roles.
            
            The player who assumes the role of Life begins. When it is their turn, the player performs one of two actions:
            
            Place a pawn in a free space on the Circle of Life. This location must be vertically or horizontally adjacent to a Life token (same for Death). During the very first turn, the player can place his pawn wherever he wants.
            
            Or turn a ring one segment (45 degrees) clockwise.
            
            Special power of Life: birth.
            If, by placing his pawn, the player has finished filling a segment with Life pawns, the player who took on the role of Life has the right to place another Life pawn in any empty space. . In doing so, he must comply with the investment rules.
            
            Special power of Death: disintegration.
            If, after a Death token has been placed, a Life token is completely surrounded by Death tokens (either vertically or horizontally), the Life token must be replaced by a Death token. the death
            
        A round ends when a player has achieved one of their two objectives. The winner of this round counts his pawns that are on the Circle of Life. After two rounds, when each of the players has taken on the role of Life and Death once, the game ends. Now it's a matter of determining who the final winner is: If a player wins both rounds, they've won the whole game! If each player wins a round, they compare the number of checkers it took each to win a round. Whoever needed the fewest pawns is the final winner. In the event of a tie, the game ends as in real life: with a draw. 
(game "Azteka"
    (players 2)
    (equipment {
        (board
            (remove
                (concentric {0 0 8 8 8 8})
                cells:{1}
            )
        )
        (piece "Pawn" Each)
        (hand Each)
        (regions "RingOne" {24..31})
        (regions "RingTwo" {16..23})
        (regions "RingThree" {8..15})
        (regions "RingFour" {0..7})
        (regions "SegmentOne" {0 8 16 24})
        (regions "SegmentTwo" {2 10 18 26})
        (regions "SegmentThree" {3 11 19 27})
        (regions "SegmentFour" {4 12 20 28})
        (regions "SegmentFive" {5 13 21 29})
        (regions "SegmentSix" {6 14 22 30})
        (regions "SegmentSeven" {7 15 23 31})
        (regions "SegmentEight" {1 9 17 25})
    })
    (rules
        (start (place "Pawn" "Hand" count:14))
        phases:{
        (phase "FirstPhase"
            (play
                (if ("SameTurn")
                    (move
                        (from (handSite Mover))
                        (to (sites Around (sites Occupied by:Mover) Orthogonal if:(is Empty (to))))
                        (then
                            (if (and ("HandOccupied" Mover) ("SpecialLifePower" P1)) (moveAgain))
                        )
                    )
                    (or
                        (if ("HandOccupied" Mover)
                            (move
                                (from (handSite Mover))
                                (to (if (< (count Moves) 2) (sites Empty) (sites Around (sites Occupied by:Mover) Orthogonal if:(is Empty (to)))))
                            )
                        )
                        (if (>= (count Moves) 2)
                            ("Rotate")
                        )
                        (then
                            (if (is Mover P1)
                                (if (and ("HandOccupied" Mover) ("SpecialLifePower" P1)) (moveAgain))
                                ("SpecialDeathPower" P2)
                            )
                        )
                    )
                    (then
                        (if (is Mover P1)
                            (if (or ("DestinGoal" P1) ("LifeGoal" P1))
                                (and {
                                    (set Score P1 (count Pieces Mover in:(sites Board)))
                                    (remove (sites Board))
                                    (remove (sites Hand P1))
                                    (remove (sites Hand P2))
                                    (add (piece (id "Pawn" P1)) (to (handSite P1)) count:14)
                                    (add (piece (id "Pawn" P2)) (to (handSite P2)) count:14)
                                    (set NextPlayer (player 2))
                                    (set Pending)
                                })
                            )
                            (if (or ("DestinGoal" P2) ("DeathGoal" P2))
                                (and {
                                    (set Score P2 (count Pieces Mover in:(sites Board)))
                                    (remove (sites Board))
                                    (remove (sites Hand P1))
                                    (remove (sites Hand P2))
                                    (add (piece (id "Pawn" P1)) (to (handSite P1)) count:14)
                                    (add (piece (id "Pawn" P2)) (to (handSite P2)) count:14)
                                    (set NextPlayer (player 2))
                                    (set Pending)
                                })
                            )
                        )
                    )
                )
            )
            (nextPhase (or (!= 0 (score P1)) (!= 0 (score P2))) "SecondPhase")
        )
        (phase "SecondPhase"
            (play
                (if (and (not (is Pending)) ("SameTurn"))
                    (move
                        (from (handSite Mover))
                        (to (sites Around (sites Occupied by:Mover) Orthogonal if:(is Empty (to))))
                        (then
                            (if (and ("HandOccupied" Mover) ("SpecialLifePower" P2)) (moveAgain))
                        )
                    )
                    (or
                        (if ("HandOccupied" Mover)
                            (move
                                (from (handSite Mover))
                                (to (if (< (count Sites in:(sites Occupied by:All container:"Board")) 2) (sites Empty) (sites Around (sites Occupied by:Mover) Orthogonal if:(is Empty (to)))))
                            )
                        )
                        (if (>= (count Sites in:(sites Occupied by:All container:"Board")) 2)
                            ("Rotate")
                        )
                        (then
                            (if (is Mover P2)
                                (if (and ("HandOccupied" Mover) ("SpecialLifePower" P2)) (moveAgain))
                                ("SpecialDeathPower" P1)
                            )
                        )
                    )
                    (then
                        (if (is Mover P2)
                            (if (or ("DestinGoal" P2) ("LifeGoal" P2))
                                (if (> (score P2) 0)
                                    (set Var "End" 2)
                                    (if (> (count Pieces Mover in:(sites Board)) (score P1))
                                        (and
                                            (set Var "End" 1)
                                            (set Score P2 (count Pieces Mover in:(sites Board)))
                                        )
                                        (if (< (count Pieces Mover in:(sites Board)) (score P1))
                                            (and
                                                (set Var "End" 2)
                                                (set Score P2 (count Pieces Mover in:(sites Board)))
                                            )
                                            (set Var "End" 3)
                                        )
                                    )
                                )
                            )
                            (if (or ("DestinGoal" P1) ("DeathGoal" P1))
                                (if (> (score P1) 0)
                                    (set Var "End" 1)
                                    (if (> (count Pieces Mover in:(sites Board)) (score P2))
                                        (and
                                            (set Var "End" 2)
                                            (set Score P1 (count Pieces Mover in:(sites Board)))
                                        )
                                        (if (< (count Pieces Mover in:(sites Board)) (score P2))
                                            (and
                                                (set Var "End" 1)
                                                (set Score P1 (count Pieces Mover in:(sites Board)))
                                            )
                                            (set Var "End" 3)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end {
                (if (= (var "End") 3) (result Mover Draw))
                (if (= (var "End") 2) (result P2 Win))
                (if (= (var "End") 1) (result P1 Win))
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Kpo is a two-row mancala-style board game played by the Vei people in the late nineteenth century. It was described by Prince Momolu Massaquoi to Stewart Culin. It can be played by two, three, or four players.Two rows of six holes with stores on either end. Four counters in each hole. Players sow in an anti-clockwise direction. When the last counter falls into a hole, and it now contains two or three counters, these are captured. The game is played with 2 players.
(game "Kpo" 
    (players <Players:num>) 
    
    (equipment { 
        (mancalaBoard 2 6
            <Players:track>
        )
        (piece "Seed" Shared)
        <Players:homes>
        <Players:store> 
    }) 
    (rules 
        
        (start (set Count <Players:init> to:(sites Track)))
        
        <Players:Play>
        
        <Players:end>
    )
)

Construct a Ludii game based on the following description
Abalala'e is a three-row mancala-style game from the central highlands of Eritrea. It was taught to R. Pankhurst by Abba Pawlos Tzadua, Abba Zacharias, Michael Yaqob, and Gabra Sellasé Gabra Amlak, who were all from towns in that region. It is also known in the eastern lowlands of Eritrea as Gabata.3x6 board. Each player owns the row closest to them and the half of the central row to their right. Play begins with three counters in each hole. During the first phase of the game, the players race each other (i.e., do not take turns) to be the first person to drop the last counter into an empty hole. Play moves from left to right in the row closest to the player, right to left in the central row, and left to right in the furthest row. Upon reaching the final hole in the opponent's row, play continues with the first hole in the player's own row. In the first phase, Players take counters from the leftmost hole in their row and sow them in the appropriate direction. When the final counter lands in a hole with counters, they are picked up and sowing continues until the last counter is dropped into an empty hole. Play continues in phase two in the same manner as before, but the players take turns and the player who \ 
(game "Abalala'e" 
    
    (players 2) 
    (equipment { 
        (mancalaBoard 3 "Columns" store:None
            {
            (track "Track" "0,E,N1,W5,N1,E" loop:True P1)
            (track "Track" "17,W,S1,E5,S1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (union (sites Bottom) (sites {"D2" "E2" "F2"}))) 
        (regions "Home" P2 (union (sites Top) (sites {"A2" "B2" "C2"})))  
        (regions "LeftPart" P1 (sites {"A1" "B1" "C1"}))      
        (regions "LeftPart" P2 (sites {"D3" "E3" "F3"}))      
        (regions "MiddleRow" (sites {"A2" "B2" "C2" "D2" "E2" "F2"}))   
        (map "LeftHole" {(pair P1 0) (pair P2 17)})       
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 3 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        (play 
            (move Select 
                (from 
                    (if ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover "Home") 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        count:(if ("HasCaptured") 1 (count at:(last To))) 
                        "Track"
                        owner:(mover)
                        apply:(if (> (count at:(to)) 1)
                            (moveAgain)
                            (if (is In (to) (sites Mover "Home"))
                                (if (is In (to) (sites "MiddleRow")) 
                                    (if (> (count at:"NextRowPit") 0) 
                                        (and { 
                                            (fromTo 
                                                (from "NextRowPit") 
                                                (to (handSite Mover)) 
                                                count:(count at:"NextRowPit")
                                            ) 
                                            (moveAgain) 
                                            ("StoreLastPitSowed")
                                        })
                                    )
                                    (if (is In (to) (sites Mover "LeftPart"))
                                        (and {
                                            (if (> (count at:"NextRowPit") 0) 
                                                (and {
                                                    (fromTo 
                                                        (from "NextRowPit") 
                                                        (to (handSite Mover)) 
                                                        count:(count at:"NextRowPit")
                                                    )
                                                    (moveAgain) 
                                                    ("StoreLastPitSowed")
                                                })
                                            )
                                            (if (> (count at:"OppositePit") 0) 
                                                (and {
                                                    (fromTo 
                                                        (from "OppositePit") 
                                                        (to (handSite Mover)) 
                                                        count:(count at:"OppositePit")
                                                    )
                                                    (moveAgain) 
                                                    ("StoreLastPitSowed")
                                                })
                                            )
                                        })
                                        (if (> (count at:"OppositePit") 0) 
                                            (and {
                                                (fromTo 
                                                    (from "OppositePit") 
                                                    (to (handSite Mover)) 
                                                    count:(count at:"OppositePit")
                                                )
                                                (moveAgain) 
                                                ("StoreLastPitSowed")
                                            })
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen"
                (or {
                    (all Sites (sites P1 "Home") if:(= 0 (count at:(site)))) 
                    (all Sites (sites P2 "Home") if:(= 0 (count at:(site)))) 
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
A simple, drawless, and finite annihilation game where groups only grow by capturing.Oust is a game for two players, played on a hexagonally patterned board which is initially empty. The two players, Black and White, take turns placing stones of their color onto unoccupied cells on the board. A group is a set of interconnected, like-colored stones. A group can be a singleton, a single stone which is not connected to any other stones of its color. A group includes all the stones of its own color connected to it. There are two types of moves - non-capturing placements and capturing placements. Non-capturing placements either forms no connections (adjacencies) with any stones, or forms one or more connections with only enemy stones. A non-capturing placement does not form any connection with stones of its own color. Making a non-capturing placement concludes your turn. When you place a stone which forms one or more connections with your own groups, you will create a new, larger group of your own stones. You can only make such a placement if said new group will have one or more connections with enemy groups upon its creation and if all said enemy groups are smaller than said new group. Upon making such a placement, all said enemy groups are removed from the board. After capturing one or more enemy groups and while it is still your turn, you must continue to add stones until you make a non-capturing placement, at which time your turn is concluded. If you have a placement available on your turn you must make one. If you don't have any placements available, you must pass your turn. There will always be a placement available for at least one player. You win by making a placement which captures all of the enemy stones on the board. The game is played on a size 5 board
(game "Oust"
    (players 2)
    (equipment {
        (board <Board>)
        (piece "Disc" Each)
    })
    (rules
        (play
            (or
                (move Add
                    (to (sites Empty)
                        if:"NoFriendlyAdjacent"
                    )
                )
                (do
                    (move Add
                        (to (sites Empty)
                            if:"FriendlyAdjacent"
                        )
                    )
                    ifAfterwards:"Captures"
                    (then
                        (and
                            ("RemoveGroups")
                            (moveAgain)
                        )
                    )
                )
            )
        )
        (end
            (if
                (and 
                    (< 2 (count Moves))
                    (=
                        0
                        (count Sites
                            in:(sites Occupied by:Enemy)
                        )
                    )
                )
                (result Mover Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Claim Jumpers"
    (players 2)
    (equipment
        {
        (board <Board:size> use:Vertex)
        (piece "Disc" Each)
        }
    )
    (rules 
        (start (set Score Each 0)) 
        (play
            (if
                ("SameTurn")
                ("ForcedHop")
                ("Placement")
                (then
                    (and
                        (set Score Mover (count Pieces Mover))
                        (set Score Next (count Pieces Next))
        )))) 
        (end 
            {
            (if
                (and
                    "EndCondition"
                    (= (score Mover) (score Next))
                )
                (result Mover Win)
            )
            
            (if
                (and
                    "EndCondition"
                    (!= (score Mover) (score Next))
                )
                (byScore)
            )
            }  
)))
Claim Jumpers was part of a series of games created while travelling, that sought to simplify some of my earlier games to there barest essentials.
            A new element is placement before movement, but movement excludes the placed piece. 
            This is similar to placement after the movement with restriction against placement to the movement origin site; but it also allows for placement that precludes the forced movement in certain cases.
            The essence of the game is to force the opponent to capture your pieces in ways that allow greater capture-backs, and then hold onto that lead or increase it.
            The game seems to be very interesting tactically, open to global strategies, but not forcing global play, due to the complexity and balance of local play.  Other than board edges, defensive resources include thick, rounded blocks of pieces - which does involve mid-range placements.
        The A/B AI is strong on small tactical boards.Claim Jumpers is a 2-player strategy game
            It may be played: 
            -- on a hex grid
            -- on a square grid
            -- on a square plus diagonal grid
            
            The goal is to maximize your pieces when the board is full. 
            A new piece is placed at the beginning of each turn. Followed, if possible, by a chain of forced jumps made by a different piece, that capture by 'flipping' the jumped opponent to your own color.
            
            The board starts empty. Turns alternate starting with White.
            Game ends when the board is full. No passing.
            
        Maximum captures are not required, but the piece choen to capture must capture at least one, and maynot stop capturing as long as it is able to capture the next adjacent opponent's piece. Board & size: Orthogonal 3

Construct a Ludii game based on the following description
This version of Shatranj is described in the seventeenth century Italian manuscript Libro che insegna giocar a scachi, as a version of Shatranj played by Turkish people. 8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): One square diagonally or, one the first turn, may jump two squares diagonally or orthogonally, over any pieces on the first square. There can be no capture with this move. 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Two squares diagonally, jumping over the first. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the eighth rank. On its first move, this promoted piece may also use the jumping move of the Fers. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it.
         
(game "Shatranj (Turkey)" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        ("ChessKing" "King_noCross")
        (piece "Ferz_noCross"
            (or
                ("StepToNotFriend" Diagonal)
                (if (not ("MovedBefore" (from)))
                    (move Hop 
                        (between if:True)
                        (to if:(is Empty (to)))
                    )
                )
                (then 
                    (if (not ("MovedBefore" (last To)))
                        ("RememberMoved" (last To))
                    )
                )
            )
        )
        (piece "Elephant"
            (move Hop 
                Diagonal
                (between if:True)
                (to if:(not ("IsFriendAt" (to)))
                    (apply 
                        (if ("IsEnemyAt" (to))
                            (remove (to))
                        )
                    ) 
                )
            )	
        )
        ("ChessKnight" "Knight")
        ("ChessRook" "Rook")
        ("ChessPawn" "Pawn" ~ (then ("PromoteIfReach" (sites Mover "Promotion") "Ferz_noCross")))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        (play 
            (do (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            (if (no Moves Mover) (result Mover Loss))
        })
    )
)

Construct a Ludii game based on the following description
Sétichch is a race game that was played by White Mountain Apache people in Fort Apache, Arizona in the early twentieth century.Forty stones arranged in a circle, with a larger gap after every tenth stone, the spaces between the stones are the playing spaces. Four or six players, played on two teams, with two sticks per team, starting in one of the gaps. Three sticks, round on one side and flat on the other, used as dice. The throws are as follows: three round sides = 10; two round sides = 2; one round side = 3; three flat sides = 5. A throw of 10 grants the player another throw. Pieces move according to the throws in opposite directions around the board. The team to get their pieces to the starting gap wins. The game has 4 players.
(game "Setichch"
    (players <Player:num>)
    (equipment {
        ("FortyStonesWithFourGapsBoard"
            {
            (track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True)
            (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)
            }
        )
        (regions "AllSites" (sites Board))
        (piece "Stick" P1)
        (piece "Stick" P2)
        ("StickDice" 3)
        (hand Each)
        (map "Throw" {(pair 0 5) (pair 1 3) (pair 2 2) (pair 3 10)})
    })
    (rules 
        (start {
            (place Stack "Stick1" Edge 36 count:2)
            (place Stack "Stick2" Edge 38 count:2)
            <Player:teams>
        })
        (play 
            ("RollMove"
                (if (is In (mover) (players Team1))
                    ("Move" Team1 "TrackCW")
                    ("Move" Team2 "TrackCCW")
                )
                (then (if (= 10 ("ThrowValue")) (moveAgain)))
            )
        )
        (end {
            (if 
                (and {
                    (is In (mover) (players Team1)) 
                    (= 1 (count Sites in:(sites Occupied by:Team1))) 
                    (= 36 (where "Stick" Team1))
                })
                (result Team1 Win)
            )
            (if 
                (and {
                    (is In (mover) (players Team2)) 
                    (= 1 (count Sites in:(sites Occupied by:Team2))) 
                    (= 38 (where "Stick" Team2))
                })
                (result Team2 Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Place pieces to connect all three board sides.Players take turns placing a piece of their colour on an empty cell. A player wins by connecting all three board sides with a connected group of their pieces. Played on a size 3 board. The first player to connect all three sides wins.
(game "Y" 
    (players 2) 
    (equipment { 
        (board (hex Triangle <Board>)) 
        (piece "Disc")
    }) 
    (rules 
        (play (move Add (to (sites Empty))))
        (end 
            (if (is Connected 3 Sides) 
                (result Mover <Result>) 
            ) 
        )
    )
)

Construct a Ludii game based on the following description
Rock-paper-scissors is a hand game with its origins in East Asia. The names and actual gestures vary over time and place. Jan-Ken, a Japanese version, uses the hand gestures for rock, paper, and scissors, from the late nineteenth century. This version came to North America and Europe in the early twentieth century through contact with Japan.Two players make one of three signs with their hands at the same time, with one hand sign bating another (Rock beats Scissors, Scissors beats Paper, Paper beats Rock). 
(game "Rock-Paper-Scissors" 
    (players 2) 
    (mode Simultaneous) 
    (equipment { 
        (board 
            (union 
                (square 1) 
                (shift 0 2 (square 1))
            )
        )
        (hand Each size:3) 
        (piece "Rock" Each)
        (piece "Paper" Each)
        (piece "Scissors" Each)
    }) 
    (rules 
        
        (start { 
            (place "Rock1" (handSite P1)) (place "Rock2" (handSite P2)) 
            (place "Paper1" (handSite P1 1)) (place "Paper2" (handSite P2 1)) 
            (place "Scissors1" (handSite P1 2)) (place "Scissors2" (handSite P2 2)) 
        })
        
        (play 
            (or 
                (move 
                    (from (sites Occupied by:P1)) 
                    (to 0) 
                    P1
                ) 
                (move 
                    (from (sites Occupied by:P2)) 
                    (to 1) 
                    P2
                )
            )
        )
        
        (end {
            (if
                (or {
                    (and (= (what at:0) (id "Rock1")) (= (what at:1) (id "Rock2")))
                    (and (= (what at:0) (id "Paper1")) (= (what at:1) (id "Paper2")))
                    (and (= (what at:0) (id "Scissors1")) (= (what at:1) (id "Scissors2")))
                })
                (result Mover Draw) 
            ) 
            (if 
                (or {
                    (and (= (what at:0) (id "Rock1")) (= (what at:1) (id "Scissors2")))
                    (and (= (what at:0) (id "Paper1")) (= (what at:1) (id "Rock2")))
                    (and (= (what at:0) (id "Scissors1")) (= (what at:1) (id "Paper2")))
                })
                (result P1 Win) 
            ) 
            (if 
                (or {
                    (and (= (what at:0) (id "Paper1")) (= (what at:1) (id "Scissors2")))
                    (and (= (what at:0) (id "Scissors1")) (= (what at:1) (id "Rock2")))
                    (and (= (what at:0) (id "Rock1")) (= (what at:1) (id "Paper2")))
                })
                (result P2 Win) 
            ) 
        }) 
    )
)

Construct a Ludii game based on the following description
Ako Okwe is a mancala-type board game documented in Nigeria during the twentieth century. The game is sometimes compared to marketing, and captures said to be placed in the nkuru (bank). The full name, in Umuahia, is Ezu Ahia Ako Okwe, which translates to \The first capture must be of one counter. The first capture must be of one counter.
(game "Ako Okwe" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 5
            { 
            (track "TrackCCW" "1,E,N,W" loop:True)
            (track "TrackCW" "6,E,S,W" loop:True)
            }
        )
        (regions P1 (sites Bottom))     
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 10 to:(sites Track)))
        
        (play (or ("Sow" "TrackCW") ("Sow" "TrackCCW")))
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Describe the mechanics of the following Ludii game
(game "Um el Banat"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions "Home" P1 (sites Bottom)) 
        (regions "Home" P2 (sites Top)) 
        (piece "Seed" Shared)
        (hand Each)
        (map "LeftMost" {(pair P1 0) (pair P2 11)})
    }) 
    (rules 
        (start { 
            (set Count 4 to:(sites Track)) 
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Sowing"
            (play 
                (or {
                    (move Select
                        (from 
                            (if (and ("SameTurn") (= 1 (var "ContinueSowing")))
                                ("LastHoleSowed") 
                                ("OwnedHoles") 
                            )
                            if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))
                        )
                        (then
                            (sow
                                apply:
                                (if (= (next) (state at:(to)))
                                    (and {
                                        (move
                                            (from (to))
                                            (to (handSite Mover))
                                            count:(min 2 (count at:(to)))
                                        )
                                        (moveAgain)
                                        (set Var "ContinueSowing" 0)
                                    })
                                    (if (= (mover) (state at:(to)))
                                        (set Var "ContinueSowing" 0)
                                        (if (and (< 1 (count at:(to))) (!= 4 (count at:(to))))
                                            (and
                                                (moveAgain)
                                                (set Var "ContinueSowing" 1)
                                            )
                                            (if (and (= 4 (count at:(to))) (not (is In (sites Mover "Home"))))
                                                (and
                                                    (set State at:(to) (mover))
                                                    (set Var "ContinueSowing" 0)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OnlyPiecesInMarked")
                            (and { 
                                (forEach Site ("SitesMarkedBy" 1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site ("SitesMarkedBy" 2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                                (if (>= ("NumCapturedPieces" 1) ("NumCapturedPieces" 2))
                                    (set NextPlayer (player 1))
                                    (set NextPlayer (player 2))
                                )
                            })
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:4
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 4 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 3 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("LeftMostEmpty"))
                                                count:3
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("LeftMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("LeftMostEmpty"))
                                        })
                                        (fromTo 
                                            (from (handSite Mover))
                                            (to (handSite Next))
                                            count:(count Cell at:(handSite Mover))
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        }
    )
)
Um el Banât is a two-row mancala-style board game played among the Kababish of people of Sudan.2x6 board. Four counters in each hole. Players sow from any of the holes in their row in an anti-clockwise direction. When the final counter of a sowing falls into an occupied hole (except in the scenario below), these are picked up and sowing continues. If the final counter falls into either an empty hole or one of the opponent's holes with three counters, making that hole now have four counters, the sowing ends. When the final counter falls into a hole in the opponent's row containing four counters after sowing concludes, this hole is marked. If a player sows their final counter into their opponent's marked hole, the final counter and one of the counters in the hole are captured. The player then gets another turn. If the final counter falls into a player's own marked hole, the turn ends. The contents of marked holes cannot be sown. The game ends when only marked holes contain counters. These are then captured by the players who marked them. A new game begins. The player with the most counters places four in each hole beginning from the left hole in their row. Each hole that contains four counters is owned by that player for the new round. If the player has three counters remaining after filling as many holes with four as possible, they borrow one counter from the opponent to make four and own the corresponding hole. If there are two or one remaining, the opponent borrows these to fill and own the last hole. Play continues until one player owns no more holes. 

Construct a Ludii game based on the following description
Mity is a simple territory game of pure placement invented by Michael Amundsen in 2021.Players place one token of their color each turn and the first player unable to do so has lost. You may place on any empty cell unless your opponent has a token closer to that cell than you have along at least 2 of the 3 lines (axes) the cell is on. 
            
        The game uses the pie rule: One player chooses the first move and the other player chooses whose move it is. A size 4 board is currently selected
(game "Mity"
    (players 2)
    (equipment {
        (board (hex <Board>))
        (piece "Disc" Each)
    })
    (rules
        (meta (swap))
        (play
            (move Add
                (to
                    (sites Empty)
                    if:("Placeable")
                )
            )
        )
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Invented in 1988 by Walter Zamkauskas and first published in the Argentine magzine El Acertijo in December 1992.Played on a 10x10 board. Each player has four Amazons (chess queens), with other pieces used as arrows. Two things happen on a turn: an amazon moves like a Chess queen, but cannot cross or enter a space occupied by another amazon or arrow. Then, it shoots an arrow to any space on the board that is along the path of a queen's move from that place. The last player able to make a move wins. 
(game "Amazons" 
    (players 2) 
    (equipment { 
        (board (square 10)) 
        (piece "Queen" Each (move Slide (then (moveAgain))))
        (piece "Dot" Neutral)
    }) 
    (rules 
        (start { 
            (place "Queen1" {"A4" "D1" "G1" "J4"})
            (place "Queen2" {"A7" "D10" "G10" "J7"})
        })
        
        (play 
            (if (is Even (count Moves))
                (forEach Piece)
                (move Shoot (piece "Dot0"))
            )
        )
        
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Bao is a four-row mancala-style board game played in Zanzibar and Swahili-speaking areas of coastal East Africa.4x8 board. One hole, the Nyumba, is square, and is the hole immediately to the right of center in the player's inner row. The holes on both ends of both players' inner rows are Kichwa, and the next holes in from those are the Kimbi. Players sow from one of their holes in either direction on the board. When the final counter lands in an occupied hole, these counters are picked up and sowing continues, when a capture is not possible. When the final counter lands in an empty hole, the turn ends.  Play begins with six counters in the Nyumba, two in each of the holes to its right, and 22 counters to be entered on the board.
            
            Namua is the stage of the game where there are still counters to be placed on the board. During Namua, the Nyumba is the house, as long as it has at least six counters in it and it has not been emptied. Players place counters into an occupied hole in their front row. If this hole is opposite one of the opponent's occupied holes, the opponent's counters in that hole are captured. Captures must be made if possible. If a capture is not possible, the counter is placed into a hole and the contents of that hole are sown. The house cannot be emptied, but if it is the only occupied hole, the counter placed into it, and only that one counter, can be sown to one of the adjacent holes.  Sowing from a Kichwa in the direction of the back row is not allowed unless it is the only occupied hole in the front row. Players cannot place a counter in holes with single counters  unless only holes in the front row with single counters exist or the house is still present. If the final counter of a sowing lands in the house, the turn ends. Once all of the counters are placed on the board for both players, Namua ends.
            
            The next stage begins. The rules for the house mentioned above during the Namua stage no longer apply, but the rules below remain in effect until the first capture in this phase of the game has been made.  Players alternate turns taking the counters from one of their holes that has more than one and less than sixteen counters and sowing them. When the final counter lands in an occupied hole in the front row opposite one of the opponent's occupied holes, the opponent's counters are captured, unless the hole from which sowing began contained sixteen or more counters. Captures must be made if possible. Single counters cannot be sown. Sowing must occur from an inner row hole when possible. A Kichwa cannot be sown toward the back row if it is the only occupied hole in the front row. 
            
            Capturing rules:  The counters captured from the opponent's hole are captured and sown on the player's front row. If they were captured from a Kimbi or Kichwa, they must be sown from the nearest Kichwa. If they were not captured from one of these holes, they must be sown from the Kichwa in the direction toward which the sowing was proceeding when the capture was made. If the capture was not made from a Kimbi or Kichwa and it was not made while sowing, the player can choose which Kichwa to sow from. Further captures in the same turn must be made with this sowing if possible, and are made if the final counter lands in an occupied hole in the inner row which is opposite an occupied hole in the opponent's inner row. If a capture is not possible, the sowing must end in the house. When the final counter lands in the house, the player may choose to continue sowing from the house or to end their turn. If the player cannot capture and cannot drop the final counter in the house, they must sow into an occupied hole, and continue sowing from that hole. The player may sow such that the final counter lands in an empty hole only when none of the other options are possible.
            
            When a player sows in such a way that they do not capture and the opponent is unable to capture on their next turn but the player will be able to capture on their own following move, the opponent cannot sow from this hole. The opponent is able to sow from such a hole if they can capture from this hole; if the hole in question is the house (this remains true for all phases of the game); if it is the only occupied hole in the front row; or if it is the only hole in the front row with greater than one counter. This rule does not apply during the Namua phase.
            
        A player wins when their opponent's inner row holes are empty. This includes in the middle of sowing (e.g., sowing into the outer row directly from a Kichwa when it is the only occupied hole in the front row). A player may also lose if they only  have single counters in their holes.  
(game "Bao" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 8 store:None
            {
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "23,W,N1,E" loop:True P2)
            }		
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions "Home" P1 (expand (sites Bottom)))    
        (regions "Home" P2 (expand (sites Top)))     
        (regions "Inner" P1 (sites Row 1))      
        (regions "Inner" P2 (sites Row 2))      
        (regions "SquaresHoles" (sites {19 12}))      
        (regions "RightSquare" (sites {18 13}))     
        (map "LeftMostInner" {(pair P1 8) (pair P2 23)})
        (map "RightMostInner" {(pair P1 15) (pair P2 16)})
        (map "AdjacentLeftMostInner" {(pair P1 9) (pair P2 22)})
        (map "AdjacentRightMostInner" {(pair P1 14) (pair P2 17)})
    }) 
    (rules 
        (start {
            (set Count 22 at:(handSite P1))
            (set Count 22 at:(handSite P2))
            (set Count 6 to:(sites "SquaresHoles"))
            (set Count 2 to:(sites "RightSquare"))
        })
        
        (play 
            (if ("SameTurn")
                (if (is Pending) 
                    (or
                        (if (or (= 1 (var "Side")) (= 0 (var "Side"))) 
                            (do 
                                (fromTo
                                    (from ("OppositePit" (last To afterConsequence:True)))
                                    (to (mapEntry "LeftMostInner" Mover))
                                    count:(count at:("OppositePit" (last To afterConsequence:True)))
                                )
                                next:(move Select
                                    (from (mapEntry "LeftMostInner" Mover))
                                    (then ("Sowing" "TrackCW" 1))
                                )
                            )
                        )
                        (if (or (= 2 (var "Side")) (= 0 (var "Side"))) 
                            (do 
                                (fromTo
                                    (from ("OppositePit" (last To afterConsequence:True)))
                                    (to (mapEntry "RightMostInner" Mover))
                                    count:(count at:("OppositePit" (last To afterConsequence:True)))
                                )
                                next:(move Select
                                    (from (mapEntry "RightMostInner" Mover))
                                    (then ("Sowing" "TrackCCW" 2))
                                )
                            )
                        )
                    )
                    
                    
                    (or
                        (if 
                            (and
                                (if (!= (var "Replay") (mapEntry "RightMostInner" Mover))
                                    True
                                    ("AllHolesEmptyExceptRightMost")
                                )
                                (or (= (var "Direction") 1) (= (var "Direction") 3))
                            )
                            (move Select
                                (from (var "Replay"))
                                (then ("Sowing" "TrackCW" 1))
                            )
                        )
                        (if 
                            (and
                                (if (!= (var "Replay") (mapEntry "LeftMostInner" Mover))
                                    True
                                    ("AllHolesEmptyExceptLeftMost")
                                )
                                (or (= (var "Direction") 2) (= (var "Direction") 3))
                            )
                            (move Select
                                (from (var "Replay"))
                                (then ("Sowing" "TrackCCW" 2))
                            )
                        )
                    )
                )
                (if (is Occupied (handSite Mover)) 
                    (priority {
                        (move 
                            (from (handSite Mover))
                            (to (sites Mover "Inner") if:(and (is Occupied (to)) (is Occupied ("OppositePit" (to)))))
                            count:1
                            (then
                                (and {
                                    (moveAgain)
                                    (set Pending)
                                    (if (is In (last To) (expand (sites Right)))
                                        (set Var "Side" 2) 
                                        (if (is In (last To) (expand (sites Left)))
                                            (set Var "Side" 1) 
                                            (set Var "Side" 0) 
                                        )
                                    )
                                })
                            )
                        )
                        (if (!= (value Player Mover) 1) 
                            (move 
                                (from (handSite Mover))
                                (to (difference (sites Mover "Inner") (sites "SquaresHoles")) if:(is Occupied (to)))
                                count:1
                                (then
                                    (and {
                                        (moveAgain)
                                        (set Var "Replay" (last To))
                                        (set Var "Direction" 3) 
                                    })
                                )
                            )
                            (move 
                                (from (handSite Mover))
                                (to (sites Mover "Inner") if:(is Occupied (to)))
                                count:1
                                (then
                                    (and {
                                        (moveAgain)
                                        (set Var "Replay" (last To))
                                        (set Var "Direction" 3) 
                                    })
                                )
                            )
                        )
                        
                        (if (!= (value Player Mover) 1)
                            (move 
                                (from (handSite Mover))
                                (to (intersection (sites "SquaresHoles") (sites Mover "Inner")) if:(is Occupied (to)))
                                count:1
                                (then
                                    (and {
                                        (moveAgain)
                                        (set Var "Replay" (last To))
                                        (set Var "Direction" 3) 
                                    })
                                )
                            )
                        )
                    })
                    
                    (priority {
                        (or 
                            (move Select
                                (from 
                                    (sites Mover)
                                    if:(and
                                        (or (< 1 (count at:(from))) (> 16 (count at:(from))))
                                        (is Occupied ("OppositePit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                                    )
                                )
                                (then
                                    (sow
                                        "TrackCW"
                                        owner:(mover)
                                        apply:(if (is In (to) (sites Mover "Inner"))
                                            (if (is Occupied ("OppositePit" (to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Pending)
                                                    (if (is In (to) (expand (sites Right)))
                                                        (set Var "Side" 2) 
                                                        (if (is In (to) (expand (sites Left)))
                                                            (set Var "Side" 1) 
                                                            (set Var "Side" 0) 
                                                        )
                                                    )
                                                })
                                                (if (< 1 (count at:(to)))
                                                    (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                        (and {
                                                            (moveAgain)
                                                            (set Var "Replay" (to))
                                                            (set Var "Direction" 1) 
                                                        })
                                                        (set Var "Direction" 0) 
                                                    )
                                                )
                                            )
                                            (if (< 1 (count at:(to)))
                                                (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "Direction" 1) 
                                                    })
                                                    (set Var "Direction" 0) 
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (move Select
                                (from 
                                    (sites Mover)
                                    if:(and 
                                        (or (< 1 (count at:(from))) (> 16 (count at:(from))))
                                        (is Occupied ("OppositePit" ("NextHole" (from) "TrackCCW" (count at:(from)))))
                                    )
                                )
                                (then
                                    (sow
                                        "TrackCCW"
                                        owner:(mover)
                                        apply:(if (is In (to) (sites Mover "Inner"))
                                            (if (is Occupied ("OppositePit" (to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Pending)
                                                    (if (is In (to) (expand (sites Right)))
                                                        (set Var "Side" 2) 
                                                        (if (is In (to) (expand (sites Left)))
                                                            (set Var "Side" 1) 
                                                            (set Var "Side" 0) 
                                                        )
                                                    )
                                                })
                                                (if (< 1 (count at:(to)))
                                                    (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                        (and {
                                                            (moveAgain)
                                                            (set Var "Replay" (to))
                                                            (set Var "Direction" 2) 
                                                        })
                                                        (set Var "Direction" 0) 
                                                    )
                                                )
                                            )
                                            (if (< 1 (count at:(to)))
                                                (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "Direction" 2) 
                                                    })
                                                    (set Var "Direction" 0) 
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (or 
                            (move Select
                                (from 
                                    (if (!= (value Player Mover) 1)
                                        (sites Mover)
                                        (difference (sites Mover) (sites "SquaresHoles"))
                                    )
                                    if:(or (< 1 (count at:(from))) (> 16 (count at:(from))))
                                )
                                (then
                                    (sow
                                        "TrackCW"
                                        owner:(mover)
                                        apply:(if (is In (to) (sites Mover "Inner"))
                                            (if (is Occupied ("OppositePit" (to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Pending)
                                                    (if (is In (to) (expand (sites Right)))
                                                        (set Var "Side" 2) 
                                                        (if (is In (to) (expand (sites Left)))
                                                            (set Var "Side" 1) 
                                                            (set Var "Side" 0) 
                                                        )
                                                    )
                                                })
                                                (if (< 1 (count at:(to)))
                                                    (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                        (and {
                                                            (moveAgain)
                                                            (set Var "Replay" (to))
                                                            (set Var "Direction" 1) 
                                                        })
                                                        (set Var "Direction" 0) 
                                                    )
                                                )
                                            )
                                            (if (< 1 (count at:(to)))
                                                (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "Direction" 1) 
                                                    })
                                                    (set Var "Direction" 0) 
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (move Select
                                (from 
                                    (if (!= (value Player Mover) 1)
                                        (sites Mover)
                                        (difference (sites Mover) (sites "SquaresHoles"))
                                    )
                                    if:(or (< 1 (count at:(from))) (> 16 (count at:(from))))
                                )
                                (then
                                    (sow
                                        "TrackCCW"
                                        owner:(mover)
                                        apply:(if (is In (to) (sites Mover "Inner"))
                                            (if (is Occupied ("OppositePit" (to)))
                                                (and {
                                                    (moveAgain)
                                                    (set Pending)
                                                    (if (is In (to) (expand (sites Right)))
                                                        (set Var "Side" 2) 
                                                        (if (is In (to) (expand (sites Left)))
                                                            (set Var "Side" 1) 
                                                            (set Var "Side" 0) 
                                                        )
                                                    )
                                                })
                                                (if (< 1 (count at:(to)))
                                                    (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                        (and {
                                                            (moveAgain)
                                                            (set Var "Replay" (to))
                                                            (set Var "Direction" 2) 
                                                        })
                                                        (set Var "Direction" 0) 
                                                    )
                                                )
                                            )
                                            (if (< 1 (count at:(to)))
                                                (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles")))))
                                                    (and {
                                                        (moveAgain)
                                                        (set Var "Replay" (to))
                                                        (set Var "Direction" 2) 
                                                    })
                                                    (set Var "Direction" 0) 
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    })
                )
            )
        )
        
        (end ("ForEachPlayerNoMovesLoss"))
    )
)

Construct a Ludii game based on the following description
Boolik is a capturing game played by the Qeqchi people of Guatemala. It is typically played on the floor of a house at night, with two teams of people. Fifteen corn kernels are placed in a line; the playing spaces are the empty spaces between the kernels. Four corn kernels used as dice, marked on one side. The value of a throw is equal to the number of marked sides that land up, except when no marked sides are up, when the value is 5. Any number of players, who play on two teams, each starting from one side of the board. Five pieces per player. Players take turns moving pieces according to the throws of the corn, with two throws per turn. When a player reaches the opposite end of the board, they move to the start and continue moving in the same direction. If a piece lands on a space occupied by an opponent's piece, the player then moves in the reverse direction, carrying the opponent's piece with it in an attempt to move past the starting point and off the board. When the player moves past the starting point and then moves off the board, the opponent's piece is captured. The player who made the capture enters their piece again on their next turn. However, if the opponent lands on a piece carrying one of their pieces away, they then start carrying both of those pieces back to their starting point, freeing the captured piece and capturing the other player's piece. Players belonging to the same team may land on the same spot, but both are taken back to start if the opponent lands on them. Players cannot enter more than one of their pieces on the board at one time. The first team to capture all of the opposing team's pieces wins. The game has 2 players.
(game "Boolik"
    (players <Player:num>)
    (equipment {
        (board 
            (rectangle 1 15) 
            <Player:tracks> 
            use:Edge
        )
        (piece "Stick" Each
            (or
                (if ("FreePiece" (state at:(from) level:(level)))
                    (move 
                        (from (from) level:(level))
                        (to 
                            ("NextSiteOnTrack" ("ThrowValue") from:(from) "Track")
                        )
                        (then 
                            (if ("AtLeastAnEnemyPieceThere" (last To))
                                ("CaptureMove")
                            )
                        )
                    )
                )
                (if ("CapturingPiece" (state at:(from) level:(level)))
                    (if ("IsNotOffBoard" ("NextSiteOnTrack" ("ThrowValue") from:(from) "CaptureTrack"))
                        (move 
                            (from (from) level:(level))
                            (to 
                                ("NextSiteOnTrack" ("ThrowValue") from:(from) "CaptureTrack")
                            )
                            (then 
                                (and
                                    ("CapturedPiecesFollowCapturingPiece")
                                    ("UnsetCapturingPieces")
                                )
                            )
                        )
                        (move Remove (from) level:(level)
                            (then
                                (and {
                                    ("UnsetCapturingPieces")
                                    ("RemoveCapturedPieces")	
                                    ("RebirthCapturingPiece")
                                })
                            )
                        )
                    )
                )
            )
        )
        (regions "AllSites" (sites Board Vertex))
        (map "Throw" {(pair 0 5) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)})
        (map "Entry" {
            (pair 1 0) (pair 2 13) (pair 3 0) (pair 4 13) 
            (pair 5 0) (pair 6 13) (pair 7 0) (pair 8 13) 
            (pair 9 0) (pair 10 13) (pair 11 0) (pair 12 13) 
            (pair 13 0) (pair 14 13) (pair 15 0) (pair 16 13)
        })
        ("StickDice" 4)
        (hand Each)
    })
    (rules
        (start {
            <Player:teams>
        })
        (play 
            ("RollMove"
                (or {
                    (if (and ("NoPieceOnBoard") (is Occupied (handSite Mover)))
                        ("EnterAPiece")
                    )
                    (forEach Piece)
                })
                (then
                    (if (and (not (no Pieces Mover)) ("NewTurn"))
                        (moveAgain)
                    )
                )
            )
        )
        
        (end ("CaptureAllTeam"))
    )
)

Construct a Ludii game based on the following description
Fevga is a game similar to Backgammon that is played in Greece and the eastern Mediterranean. It is typically played along with Portes and Plakoto as Tavli.Played on a standard Backgammon board. Each player has fifteen pieces, which all begin on the leftmost point on each player's side of the board. Both players move anti-clockwise around the board. Both players roll one die, and the player with the higher number plays first. If it is played after another game, the winner of the previous game goes first. The player rolls two die and begins play with that roll. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When doubles are thrown, they are played twice. If a player can only play one number but not both, they must play the higher number, if possible. To begin, each player may only move one piece, until it passes the opponent's starting point, after which any pieces can be moved. Pieces may only be moved to an empty point or one occupied by another piece belonging to the player. Players may not block all six points in either player's starting quadrant. If a player has blocked six points in a row, and the opponent has moved all of their pieces to the point adjacent to the blocked points, the player must move to unblock one of the points. Once a player has moved all of their pieces into the final six points of their track, they may begin bearing off. They do so by rolling a number equal to the number of points left in the track, plus one. If they cannot bear off, they must make a legal move with a piece that cannot bear off. If no such move is available, then they must bear off the piece which is furthest from the goal. The first player to bear off all their pieces wins the game and gets one point. If the winner bears off all their pieces before the opponent bears off any, they get two points.  
(game "Fevga" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" ("BackgammonTracksSameDirectionOppositeCorners" End)) 
        (dice num:2)
        (regions "Home" P1 { 20..25 }) 
        (regions "Home" P2 { 7..12 }) 
        (regions "Side" P1 { 0..12 }) 
        (regions "Side" P2 { 13..25 }) 
        (map {(pair 1 0) (pair 2 25)}) 
        (piece "Disc" Each ("MoveAPieceIf" "DieNotUsedAndNoEscapeAndNotOffTheTrack" (from))) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 0 count:15)
            (place Stack "Disc2" 25 count:15)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (if "AllPieceInHome"
                    (forEach Die 
                        replayDouble:True 
                        if:("DieNotUsed")
                        (forEach Site 
                            (sites Occupied by:Mover)
                            (if ("NotEmptyAndNotOffTheBoard") 
                                (if ("CanEscape")
                                    ("RemoveAPiece")
                                    ("MoveAPiece" (site))
                                )
                            )
                            noMoveYet:(firstMoveOnTrack "Track" Mover
                                (if "HaveAPieceAndCanEscape"
                                    "RemoveAPiece"
                                )
                            )
                            (then "ReplayNotAllDiceUsed")
                        )
                    )
                    (max Distance "Track" Mover
                        (forEach Piece top:True
                            (then "ReplayNotAllDiceUsed")
                        )
                    )
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped") 
                (byScore { 
                    ("SetScoreOf" P1 P2)
                    ("SetScoreOf" P2 P1)
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Tsoro is a word used for several different board games in Zimbabwe. This game is a four-row mancala-style game with a series of graduated Baia, or captures, on players' subsequent turns.4x13-19 board. Two counters in every hole, except the leftmost in both of a player's rows, which are empty, and the second from the left in the inner row, which has one. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. Captures are made when the final counters lands in an empty hole in the inner row, capturing the contents of the opponent's opposite inner row hole, as well as the contents of the outer row hole only if there was a capture from the inner row hole. Captures from extra holes are also made, which are graduated based on the number of captures the player has made. On their first turn, players sow from the third hole from the left in the front row. This triggers a capture of the counters in the opposite holes in the opponent's inner and outer rows, plus the contents of any other five holes on the opponent's side of the board. In subsequent turns, sowing must occur from a hole which follows an empty hole according to the circuit of the holes. On their second capture, the player captures three extra holes. All other subsequent captures capture from two extra holes. Sowing a single counter cannot result in a capture. The player who captures all of their opponent's counters wins. Each row has 13 holes.
(game "Tsoro (Baia)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" <Row:trackCCW2> loop:True P2)
            (track "TrackCW1" <Row:trackCW1> loop:True P1)
            (track "TrackCW2" <Row:trackCW2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))          
        (regions "Outer" P2 (sites Top))           
        (regions "FirstMove" P1 (difference (expand (intersection (difference (sites Track "TrackCCW1") (sites Bottom)) (sites Left)) steps:2 E) (expand (intersection (difference (sites Track "TrackCCW1") (sites Bottom)) (sites Left)) E))) 
        (regions "FirstMove" P2 (difference (expand (intersection (difference (sites Track "TrackCCW2") (sites Top)) (sites Right)) steps:2 W) (expand (intersection (difference (sites Track "TrackCCW2") (sites Top)) (sites Right)) W)))  
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start {
            (set Count 2 to:(difference (sites P1 "Outer") (sites Left)))
            (set Count 2 to:(difference (sites P2 "Outer") (sites Right)))
            (set Count 2 to:(difference (sites P1 "Inner") (expand (sites Left))))
            (set Count 2 to:(difference (sites P2 "Inner") (expand (sites Right))))
            (set Count 1 to:(difference (sites P1 "Inner") (union (sites Left) (difference (sites P1 "Inner") (expand (sites Left))))))
            (set Count 1 to:(difference (sites P2 "Inner") (union (sites Right) (difference (sites P2 "Inner") (expand (sites Right))))))
        })
        
        phases:{
        (phase "FirstTurn"
            (play 
                (if (>= 0 (var "FreeCapture"))
                    (move Select
                        (from (sites Mover "FirstMove"))
                        (then
                            (sow
                                "TrackCCW"
                                owner:(mover)
                                apply:(if (is In (to) (sites Mover "Inner"))
                                    (if 
                                        (is Occupied ("OppositePit" (to)))
                                        (and {
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (handSite Mover))
                                                count: (count at:("OppositePit" (to)))
                                            )
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (handSite Mover))
                                                    count: (count at:("OppositeOuterPit" (to)))
                                                )
                                            )
                                            (set Value Mover (+ 1 (value Player Mover)))
                                            (set Var "FreeCapture" 5)
                                            (moveAgain)
                                        })
                                    )
                                )
                            )
                        )
                    )
                    (move
                        (from
                            (sites Next "Home")
                            if:(and (is Occupied (from)) (not (is In (from) (sites Next "FirstMove"))))
                        )
                        (to (handSite Mover))
                        count:(count at:(from))
                        (then
                            (and
                                (set Var "FreeCapture" (- (var "FreeCapture") 1))
                                (if (< 1 (var "FreeCapture"))
                                    (moveAgain)
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (not (is Next Mover)) "Main")
        )
        
        (phase "Main"
            (play 
                (if (>= 0 (var "FreeCapture"))
                    (or
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    (sites Mover "Home") 
                                )
                                if:(and 
                                    (< 1 (count at:(from)))
                                    (if ("SameTurn")
                                        True
                                        (is Empty ("PreviousHole"))	
                                    )
                                )
                            )
                            (then
                                (sow
                                    "TrackCCW"
                                    owner:(mover)
                                    apply:(if (< 1 (count at:(to)))
                                        (and {
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        })
                                        (if (is In (to) (sites Mover "Inner"))
                                            (if 
                                                (is Occupied ("OppositePit" (to)))
                                                (and {
                                                    (fromTo
                                                        (from ("OppositePit" (to)))
                                                        (to (handSite Mover))
                                                        count: (count at:("OppositePit" (to)))
                                                    )
                                                    (if (is Occupied ("OppositeOuterPit" (to)))
                                                        (fromTo
                                                            (from ("OppositeOuterPit" (to)))
                                                            (to (handSite Mover))
                                                            count: (count at:("OppositeOuterPit" (to)))
                                                        )
                                                    )
                                                    (set Value Mover (+ 1 (value Player Mover)))
                                                    (if (= 0 (value Player Mover)) 
                                                        (set Var "FreeCapture" 3)
                                                        (set Var "FreeCapture" 2)
                                                    )
                                                    (moveAgain)
                                                })
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (move Select
                            (from 
                                (if ("SameTurn")
                                    (sites {(var "Replay")})
                                    (sites Mover "Home") 
                                )
                                if:(and 
                                    (= 1 (count at:(from)))
                                    (if ("SameTurn")
                                        True
                                        (is Empty ("PreviousHole"))	
                                    )
                                )
                            )
                            (then
                                (sow
                                    "TrackCCW"
                                    owner:(mover)
                                    apply:(if (< 1 (count at:(to)))
                                        (and {
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        })
                                    )
                                )
                            )
                        )
                    )
                    (move
                        (from
                            (sites Next "Home")
                            if:(and (is Occupied (from)) (not (is In (from) (sites Next "FirstMove"))))
                        )
                        (to (handSite Mover))
                        count:(count at:(from))
                        (then
                            (and
                                (set Var "FreeCapture" (- (var "FreeCapture") 1))
                                (if (< 1 (var "FreeCapture"))
                                    (moveAgain)
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Gomoku (\Played on a Go board, using 15x15 of the intersecting lines. The first player places 2 black and 1 white piece on the board. The second player can then choose to: play as black, play as white and place another white piece, or place two more stones and let the other player choose which color to play. Players take turns placing pieces in an attempt to make 5 in a row. In the Standard version, rows of more than five do not count. Played on a 9x9 board. Open anywhere. Win with a line of exactly five stones.
(game "Gomoku" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each) 
    }) 
    (rules 
        <Play> 
        (end (if (is Line 5 All <Exact>) (result Mover Win))) 
    )
)

Describe the mechanics of the following Ludii game
(game "Papan Dakon" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "Track1" "0,8,E,S,W" loop:True P1)
            (track "Track2" "15,7,W,N,E" loop:True P2)
            }
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (map "RightMost" {(pair P1 7) (pair P2 8)})
    }) 
    (rules 
        (start {
            (set Count 7 to:(union (sites P1) (sites P2)))
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or
                    (move Select
                        (from 
                            (if ("SameTurn") 
                                "LastHoleSowed" 
                                (sites Mover) 
                            ) 
                            if:(and (> (count at:(from)) 0) (is In (from) ("PlayableSites")))
                        )
                        (then
                            (sow
                                "Track"
                                owner:(mover)
                                apply:(if (and (!= (to) (mapEntry Mover)) (< 1 (count at:(to))))
                                    (moveAgain)
                                )
                                skipIf:(if (!= (to) (mapEntry Mover)) (not (is In (to) ("PlayableSites"))))
                            )
                        )
                    )
                    (if (and (is In (last To afterConsequence:True) (sites Mover)) ("SameTurn"))
                        (if (is In (last To afterConsequence:True) ("PlayableSites"))
                            (move
                                (from (last To afterConsequence:True))
                                (to ("OppositePit" (last To afterConsequence:True)))
                                count:1
                                (then
                                    (fromTo
                                        (from (last To))
                                        (to (mapEntry Mover))
                                        count:(count at:(last To))
                                    )
                                )
                            )
                        )
                    )
                    (then (if ("NoPieceOnBoard") (forget Value "Playable" All)))
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 7 (count at:(mapEntry P1))) (result P2 Win))
                    (if (> 7 (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                    (if (<= 7 (count at:(mapEntry Mover)))
                        (move
                            (from (mapEntry Mover))
                            (to "RightMostEmpty")
                            count:7
                            (then (remember Value "Playable" (last To)))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)
Papan Dakon is a two-row mancala-style board game from Borneo. It is one of many games that are similar throughout southeast Asia.2x7 board, with one store at either end. Each player owns the store to their left. Seven counters in each hole. The first turn is played simultaneously by both players; at the point which one player's sowing lasts longer than the others, the player whose turn was shorter plays next and turns alternate from this point. Players sow in a clockwise direction from one of the holes in their row, also sowing into their store, but not in their opponent's store. When the final counter lands in an empty hole or in the store, the turn ends. When the final counter falls into an occupied hole, the player picks up the contents of this hole and continues to sow. If this occupied hole is in the player's row, they have the option to instead place the final counter in the opposite hole in the opponent's row, and to place this last counter as well as the contents of that hole into the store. When all of the counters are in the stores, a new game begins. The players take the counters from their stores and place seven in each hole, beginning from their right. Any player which cannot fill a hole with seven counters places the remaining counters in their store. Any holes which are left empty are out of play for this game. Play continues as before. Multiple games are played like this until all of the holes on one side are left empty. This player loses. 

Describe the mechanics of the following Ludii game
(game "Main Pacheh"
    (players <Player:num>)
    (equipment {
        (board 
            (square 5)
            {
            (track "Track1" "2,E,N,W,S,E1,N3,E2,S2,W1,12" P1 directed:True)
            (track "Track2" "22,W,S,E,N,W1,S3,W2,N2,E1,12" P2 directed:True)
            <Player:trackP3>
            <Player:trackP4>
            }
        )
        (piece "Marker" Each
            (if ("IsNotOffBoard" "SiteToMoveOnTrack")
                (if (or
                        (is Empty "SiteToMoveOnTrack")
                        ("IsEnemyAt" "SiteToMoveOnTrack")
                    )
                    (move 
                        (from (from) level:(level))
                        (to 
                            "SiteToMoveOnTrack" 
                            ("HittingCapture" (mapEntry "StartingPoint" (who at:(to))))
                        )
                    )
                )
                (then 
                    (if (= "Goal" (last To))
                        (remove (last To))
                    )
                )
            )
        )
        (map "ThrowDiceValue" {(pair 0 8) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)})
        (map "StartingPoint" {(pair 1 2) (pair 2 22) (pair 3 14) (pair 4 10)})
        ("StickDice" 4)
    })
    (rules 
        (start {
            (place Stack "Marker1" 2 count:4)
            (place Stack "Marker2" 22 count:4)
            <Player:startP3>
            <Player:startP4>
        })
        (play 
            ("RollMove"
                (if (can Move (forEach Piece))
                    (forEach Piece (then (if (= ("ThrowValue") 8) (moveAgain))))
                    (move Pass (then (if (= ("ThrowValue") 8) (moveAgain))))
                )
            )
        )
        (end ("EscapeWin"))
    )
)
Main Pacheh is  race game played on a square board from the Penang region in Malaysia. Curiously, the name of the game is similar to the name for many cross-shaped games known throughout South, Southwest, and Southeast Asia.5x5 board, with the central square on each side and the central square of the board marked with an X. Two to four players, each with four pieces, which start on one of the marked squares on the edge of the board. Four cowrie shells used as dice. The throws are as  follows, with the value of the throws equaling the number of mouths which land up, all mouths down = 8, and grants the player another throw. Pieces moves in a spiral track around the board in an anti-clockwise direction until they reach the space before the starting point, at which point they proceed around the inner circles in a clockwise direction, and then to the central space. When a player lands on a space occupied by an opponent's piece, the opponent's piece is sent back to their starting position. When a player reaches the central square by an exact throw, it is removed from the board. The first player to remove all four of their pieces from the board wins. The game involves 2 players.

Describe the mechanics of the following Ludii game
(game "Shisima"
    (players 2) 
    (equipment { 
        (board (concentric {1 8}) use:Vertex)
        (piece "Marker" Each "StepToEmpty")
    }) 
    (rules 
        (start { 
            (place "Marker1" {1 8 7})
            (place "Marker2" {3 4 5})
        })
        
        (play (forEach Piece))
        (end 
            (if 
                (and 
                    (= (what at:(centrePoint)) (mover)) 
                    (is Line 3)
                ) 
                (result Mover Win)
            )
        ) 
    )
)
Shisima is played by the Tiriki people in Kenya on an octagonal board. The board represents a source of water (\Each player has three pieces. Pieces are initially placed three-in a row on side nearest the player. Pieces can move to an adjacent space connected to it by a line. The goal is to create three in a row through the central space. 

Describe the mechanics of the following Ludii game
(game "Chiana wa Kunja"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            (track "Track" <Board:track> loop:True)
        )
        (piece "Seed" Each)
        (hand Shared)
    }) 
    
    (rules 
        (start {
            (place "Seed1" (sites Bottom) counts:{4})
            (place "Seed2" (sites Top) counts:{4})
        })
        
        (play 
            (or
                (move Select 
                    (from ("LeftMost"))
                    (then
                        (do
                            (and
                                (forEach Site
                                    (sites Track "Track" from:(last From) to:(trackSite Move from:(last From) steps:(count at:(last From))))
                                    (if (!= (mover) (who at:(site)))
                                        (and 
                                            (remove (site) count:(count at:(site)))
                                            (add (piece (id "Seed" Mover)) (to Cell (handSite Shared)) count:(count at:(site)))
                                        )
                                    )
                                )
                                (set Var "NumSowed" (count at:(last From)))
                            )
                            next:(sow)
                            (then
                                (and {
                                    (if (< 1 (var "NumSowed"))
                                        (if (and
                                                (= 1 (count at:("NextHoleFrom" (last From) "Track" (var "NumSowed"))))
                                                (= 2 (count at:("NextHoleFrom" (last From) "Track" (- (var "NumSowed") 1))))
                                            )
                                            (moveAgain)
                                        )
                                    )
                                    (if (!= 0 (what Cell at:(handSite Shared)))
                                        (fromTo
                                            (from Cell (handSite Shared))
                                            (to (last From))
                                            count:(count Cell at:(handSite Shared))
                                        )
                                    )
                                    (set Var "NumSowed" 0)
                                })
                            )
                        )
                    )
                )
                (if (and (= 1 (count Pieces Mover)) (is Empty ("NextHoleFrom" (from) "Track" 1)))
                    (move
                        (from ("LeftMost"))
                        (to 
                            ("NextHoleFrom" (from) "Track" 2)
                            (apply
                                (and
                                    (remove (to) count:(count at:(to)))
                                    (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to)))
                                )	
                            )	
                        )
                    )
                )
            )		
        )
        
        (end ("BlockWin"))
    )
)
Chiana wa Kunja is a four-row mancala-style board game played by the Nyanja people of East Africa. Typically, it is played by children.4-row board, of any number of holes. Only the outer rows are used. Four counters in each hole in the outer row. Sowing occurs in an anti-clockwise direction. Players do not own rows, instead, over the course of their sowing, their counters are always grouped together, and sowing must occur from the rearmost counter in the player's series. If, after sowing, a player's series has one counter in the foremost hole and two in the next hole behind it, the player sows again from the rearmost hole. If the player overtakes the opponent's series, the player captures any counters in the opponent's series and places all of them in the hole immediately behind the player's series, now becoming the rearmost hole. If the rearmost hole contains a single counter, it is moved into the next hole which then becomes the rearmost hole for the next turn. If a player is reduced to a single counter, it can be moved two holes on the player's turn. The player who successfully captures all of the opponent's counters wins.  Each row has 6 holes.

Construct a Ludii game based on the following description
French Wari is a two-row mancala-style board game from Barbados. It was documented in the early twentieth century, but likely was played on the island by enslaved African people who brought the game from West Africa. It is similar to other mancala games found throughout the Caribbean and West Africa.2x6 board. Play begins with four counters in each hole. Moves begin from any hole in the player's row and sowing proceeds in an anti-clockwise direction. If the final counter of a sowing lands in an occupied hole, these counters are lifted and sowing continues. If the final counter lands in an empty hole, any counters in the opposite hole are taken and the turn ends. Play continues until one player cannot move. When this happens, the other player captures the remaining counters and the game ends. The player with the most counters wins. 
(game "French Wari" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (if 
                        ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover) 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        apply:(if (> (count at:(to)) 1)
                            (moveAgain)
                            (if (> (count at:("OppositePitTwoRows" (to))) 0)
                                (fromTo 
                                    (from ("OppositePitTwoRows" (to))) 
                                    (to (handSite Mover)) 
                                    count:(count at:("OppositePitTwoRows" (to)))
                                ) 
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Fang is a game played by the Uighur people of the Xinjiang Uighur Autonomous Region of China. It incorporates principles of alignment and territory games. 7x7 board, with diagonals in the square formed by the central 3x3 lines. 24 pieces per player. Black plays first. Players alternate turns placing a piece on one of the empty spots on the board. The first stone must be placed in the central spot. They attempt to orthogonally surround an empty point with four of their pieces, making a square. When all of the pieces are placed, players alternate turns removing one of their opponent's pieces from the board. They then move one of their pieces along the lines of the board to the place left vacant by the piece they removed. When a player makes a new square, they may remove another of the opponent's pieces from the board. Pieces that are in a square around an empty point may not be captured, and captures are not made in the placement phase. The player who captures all of the opponent's pieces wins. 
(game "Fang"
    (players 2)
    (equipment {
        (board 
            (add
                (square 7)
                edges:{{16 24} {24 32} {30 24} {24 18}}
            )
            use:Vertex
        )
        (piece "Marker" Each
            ("StepToEmpty" ~
                (then 
                    (if (> ("HowManySquareSurroundedEmptyPoint") 0)
                        (and
                            (set Value Mover "HowManySquareSurroundedEmptyPoint")
                            (moveAgain)
                        )
                    )
                )
            )
        )
        (hand Each)
    })
    
    (rules
        (start (place "Marker" "Hand" count:24))
        
        phases:{
        (phase "FirstPlacement" P1
            (play (move (from (handSite Mover)) (to (sites Centre))))
            (nextPhase "Placement")	
        )
        (phase "Placement" 
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" Mover) "Playing")	
        )
        (phase "Playing" 
            (play
                (if ("SameTurn")
                    (move Remove 
                        (sites Occupied by:Next) 
                        (then 
                            (if (> (value Player Mover) 1)
                                (and 
                                    (moveAgain)
                                    (set Value Mover (- (value Player Mover) 1))
                                )
                                (set Value Mover 0)
                            )
                        )
                    )
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Jekab is a Draughts game played in the Marshall Islands. It appears to be a derivative of American Pool Checkers, which is identical except for the promotion of the king.8x8 board, twelve pieces per player. Pieces placed on the dark squares of the first three rows of each side, with the empty corner to the right of each player. Pieces move one space forward diagonally. They may capture pieces of the opponent by hopping over them. Captures may happen in any direction. Multiple captures are allowed in the same turn, but they may not hop over the same piece or a player's own piece. Captures are compulsory, but if more than one option exists the player may choose which capture to make. When a piece reaches the opposite edge of the board, it becomes a king, even if this is in the middle of a turn. Kings may move any number of spaces forward or backwards, and may capture by flying leap. Kings must take all possible pieces in a sequence. The player to capture all of the other player's pieces wins. 
(game "Jekab"
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 8))
    (rules 
        ("BlackCellsSetup" 3)
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    ("HopInternationalDraughtsStyle" (from (last To))
                        (then 
                            (if "JumpToPromotionZone" 
                                (and 
                                    ("ReplayIfCanMove" ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn))
                                    (promote (last To) (piece "DoubleCounter") Mover)
                                )
                                ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To))))
                            )
                        ) 
                    )
                    (max Moves ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn))
                )
                (priority {
                    (or 
                        (forEach Piece "Counter"
                            ("HopInternationalDraughtsStyle" (from)
                                (then 
                                    (if "JumpToPromotionZone" 
                                        (and 
                                            ("ReplayIfCanMove" ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn))
                                            (promote (last To) (piece "DoubleCounter") Mover)
                                        )
                                        ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To)))) 
                                    )
                                ) 
                            ) 
                        )
                        (max Moves (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture" before:(count Rows) after:(count Rows) at:EndOfTurn)))
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal))
                    )
                })
            )
        )
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Infuse is a game of entering the most pieces. They can only enter out of sight of your own pieces, but you make move your pieces that lie near to enemy pieces, in order to make new entry sites for yourself, or block entry sites for your opponent. The game may be played on either hex or square grids.Start on an empty board. 
            
            On a turn either enter a piece not in line of sight of your own pieces, or move a piece a number of independant single steps not to exceed the count of that piece's enemy neighbors. 
            
            If one player passes, to avoid ending the game with a 2nd pass, the opponent must place a piece if possible, or if unable to place, he may move in a way that enables his future placement. Otherwise, he must pass and the game ends.
            
        The winner is the player with the most pieces in play. If equal, the last to pass loses. Order 2 board Square Grid
(game "Infuse"
    (players 2)
    (equipment {
        (board "BoardUsed" use:Cell)
        (piece "Disc" Each)
    })
    (rules
        (start (set Score Each 0))
        (play
            (if (was Pass)
                (or
                    (move Pass)
                    (priority 
                        ("PlaceOutOfSight")
                        (forEach Piece
                            (do ("StepMoves") 
                                ifAfterwards:(can Move 
                                    (add
                                        (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to)))))
                                    )
                                )
                            )
                        )
                    )
                )
                (or {
                    ("PlaceOutOfSight")
                    (forEach Piece ("StepMoves"))
                    (move Pass)
                })
            )
        )
        (end {
            (if 
                (and
                    (all Passed)
                    (> (score Mover) (score Next))
                )
                (result Mover Win)
            )
            (if 
                (and
                    (all Passed)
                    (<= (score Mover) (score Next))
                )
                (result Next Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Bolotudu is a game of alignment that was played by the Bambara people of West Africa. It is a game in which the goal is to get two pieces in a row, but this is forbidden during the placement phase of the game.6x6 grid. Twelve pieces per player. In the first phase, players alternate turns placing their pieces on an empty space on the board. They are forbidden from placing two of their own pieces orthogonally adjacent to one another. Once all of the pieces are placed, players alternate turns moving the pieces in an orthogonal direction to an empty adjacent spot. When they place a piece so that two are in a row, they capture one of the opponent's pieces. The player who captures all of the opponent's pieces wins. 
(game "Bolotudu"
    (players 2)
    (equipment {
        (board (square 6))
        (hand Each)
        (piece "Marker" Each ("StepToEmpty" Orthogonal "IfLine2OrthogonalMoveAgain"))
    })
    (rules
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (difference (sites Empty) (sites Around (sites Occupied by:Mover) Orthogonal)))
                ) 
            )
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        (phase "Movement"
            (play 
                (if "SameTurn"
                    (move Remove
                        (sites Occupied by:Next)
                    )
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )	
)

Describe the mechanics of the following Ludii game
(game "Hermit" 
    (players 2) 
    (equipment { 
        (board <Board:type> use:Vertex) 
        (piece "Marker" Each) 
        (piece "Marker" Neutral)
    }) 
    (rules
        (start {
            <Board:seed>
            (set Score P1 0)
            (set Score P2 0)
        }) 
        
        (play
            (do
                (move Add (to (sites Empty)))
                ifAfterwards:
                (or {
                    (= 1 (size Group at:(last To) Orthogonal))
                    (= 3 (size Group at:(last To) Orthogonal))
                    (= 5 (size Group at:(last To) Orthogonal))
                    }
                )
                (then
                    (addScore Mover (- ("CombinedGroupCounts" if:(= (who at:(to)) (mover))) (score Mover)))
                )   
            )
        )
        (end
            (if (all Passed) 
                {
                (if (> ("CombinedGroupCounts" if:(= (who at:(to)) P1))
                        ("CombinedGroupCounts" if:(= (who at:(to)) P2))
                ) (result P1 Win))
                (if (< ("CombinedGroupCounts" if:(= (who at:(to)) P1))
                        ("CombinedGroupCounts" if:(= (who at:(to)) P2))
                ) (result P2 Win))
                }
                (result Mover Win)
            ) 
        )
    )
)
Hermit is a game in which players place stones on empty vertices to create connected groups of sizes 1, 3 and 5.                            It is easy to learn but challenging to master. Although the game is static (pieces do not move),  there is still a dynamic effect because legal placements turn on and off!                            Hermit can be played on the nodes of any graph, even on a four-dimensional tesseract! Twelve 2-dimensional graphs are included. Some graph require a neutral token to prevent symmetric play by the second player.Hermit is a two player abstract game in which players drop stones to create edgewise connected, owned groups of odd sizes 1, 3 and 5 exclusively. 
            The game ends when neither player can legally place a stone. 
            The player with the most groups on the board at game's end wins. 
            Ties are broken by the most groups of size 1 (hermits), then by the most groups of size 3, and finally, the last player to place a stone wins.
            
            Scores are formatted 'aa1133', where aa = count of all groups, 11 = count of size 1 groups, and 33 = count of size 3 groups.
            
        It is helpful to turn on 'Show Legal Moves' (Alt-M). Base 3 hexagonal board of triangles

Construct a Ludii game based on the following description
Invented in 1995 by David L. Smith, Andantino is a tile-placing game using hexagonal tiles published by Nestor Games.The game starts with a tile of each color touching one another. Players take turns placing tiles which must touch at least two other tiles. A player wins by either completely surrounding one or more of the opponent's tiles, or by creating a straight line of five tiles. The game uses hexagonal tiles.
(game "Andantino" 
    (players 2) 
    (equipment { 
        (boardless <Tiling:type>) 
        (tile <Tiling:tile> Each <Tiling:numSides>) 
    }) 
    
    (rules 
        (start {
            (place <Tiling:piece1> (centrePoint)) 
            (place <Tiling:piece2> (ahead (centrePoint) E))
        })
        
        (play 
            (move Add
                (to 
                    (sites Playable) 
                    if:(<= 2 
                        (count Sites in:(sites Around (to) NotEmpty)) 
                    )
                )
            )
        )
        
        (end {
            (if (or (is Loop surround:Next) (is Line 5)) (result Mover Win))
            (if (= (count Moves) (* (count Players) "NumTiles")) (result Mover Draw))
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Khamousiyya"
    (players 2)
    (equipment {
        (board (square 7))
        (piece "Marker" Each 
            ("StepToEmpty" Orthogonal
                (then 
                    ("CustodialCapture" Orthogonal (max 1)
                        (then
                            (if ("CanCaptureAgain")	
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        (hand Each)
    })
    (rules
        (start (place "Marker" "Hand" count:24))
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover))
                    (to 
                        (if (no Pieces Mover in:(sites Board))
                            (forEach
                                (sites Around (centrePoint) Orthogonal)
                                if:(is Empty (site))
                            )
                            (difference (sites Board) (centrePoint)) 
                        )
                        if:(is Empty (to))
                    )
                    (then
                        (if ("NewTurn") (moveAgain))
                    )
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Capture")
        )
        (phase "Capture"
            (play 
                (if ("SameTurn")
                    (or
                        (move Step
                            (from (last To))
                            Orthogonal 
                            (to if:("IsConfigurationToCustodialAgain"))	
                            (then 
                                ("CustodialCapture" Orthogonal (max 1)
                                    (then
                                        (if ("CanCaptureAgain")	
                                            (moveAgain)
                                        )
                                    )
                                )
                            )
                        )
                        (move Pass)
                    )
                    (forEach Piece) 
                )
            )	
        )
        }
        (end ("BlockWin"))
    )	
)
Khamousiyya is the larger form of Kharbga played in the northern part of Tunisia. It is typically played in the sand, with date pits, shells, pebbles, or camel droppings as pieces. Normally it is played in several rounds, with the winner playing first in subsequent rounds.7x7 board. 24 pieces per player. Players alternate turns placing two pieces on the board. The first piece of each player must be placed on a spot adjacent to the central spot. The central spot cannot be filled. When both players have placed their pieces, they move their pieces orthogonally to an empty adjacent space. When an opponent's piece is surrounded on two opposite sides by pieces belonging to the player, the opponent's piece is captured. The player who made the capture may move the same piece they moved to make a capture another time if another capture is possible by doing so. 
            
            The player who captures all of their opponent's pieces, or which blocks the opponent from being able to move, wins. 
            
        In a case where the second player has created a blockade of their pieces containing one or more of only their own pieces which can move infinitely without possibility of being taken, the second player player may declare H'ajeb in order to regain the possibility of winning. The second player declares H'ajeb on their turn, and then the first player gains the ability to move any distance orthogonally or diagonally. The first player may also make multiple captures not just with the same piece, but with more than one. The second player may rescind the H'ajeb declaration at any time and the captures must stop. If the second player allows the first player to continue until the first player cannot capture, the second player captures any two of the first player's pieces, and the first player captures one of the second player's pieces that is able to move infinitely.  

Construct a Ludii game based on the following description
Had is a race game played in the Bordj Bou Arreridj region of Algeria in the early twentieth century. It resembles other games such as Tab which are popular in North Africa and Southwest Asia.3x14 board. Fourteen pieces per player, placed in the outer rows of the board. Two knucklebones used as dice. Players move their pieces according to the throws of the knucklebones. Pieces move in a boustrophedon path along the board. The first player to remove their pieces from the board wins. 
(game "Had"
    (players 2) 
    (equipment { 
        (board (rectangle 3 14) 
            { 
            (track "Track1" "0,E,N1,W,N1,E" P1 directed:True)
            (track "Track2" "41,W,S1,E,S1,W" P2 directed:True)
            }
        )
        (dice d:4 num:2)
        (piece "Marker" Each 
            (if ("IsOffBoard" ("SiteToMoveOnTrack"))
                (move Remove (from))
                (move 
                    (from) 
                    (to 
                        ("SiteToMoveOnTrack") 
                        if:(is Empty (to)) 
                    )
                )
            )
        ) 
    }) 
    
    (rules 
        (start { 	
            (place "Marker1" (sites Bottom))
            (place "Marker2" (sites Top))
        })	
        
        (play ("RollMove" (forEach Piece)))
        
        (end 
            (if 
                (no Pieces Mover) 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Jostle is a two player game. The 10x10 board is initially set up with 16 red and 16 blue checkers. Red andBlue, take turns moving checkers of their own color, one move per turn, starting with Red.OBJECT OF THE GAME The last player to make a move wins.
            
            FRIENDLY AND ENEMY CONNECTIONS A connection, i.e. an orthogonal
            adjacency between two checkers, is friendly if the two checkers are the same color and enemy if the two checkers are oppositely colored. 
            
            CHECKER VALUE A checker’s value is its number of friendly connections minus
            its number of enemy connections.
            
            MOVES A checker’s value must increase when it‘s moved. Move a checker to an
            unoccupied, orthogonally adjacent square.
            
        There is no capturing in Jostle, only jostling. The game is played on a 10x10 square board.
(game "Jostle"
    (players 2)
    (equipment {
        <Board:board>
        (piece "Marker" Each
            (move Step Orthogonal
                (to if:(and 
                        (is Empty (to))
                        (< ("Score" (from)) ("Score" (to)))
                    )
                )
            )
        )
    })
    (rules
        <Board:start>
        (play (forEach Piece))
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Gabata is a word that applies to many mancala-style games throughout the Horn of Africa. This game is a two-row version played in the Adegrat area of Ethiopia.2x6 board. Three counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter falls into an occupied hole, the player picks up the counters in the next hole and continues sowing from it. If that next hole is empty, the turn ends. If the final counter falls into an empty hole, the contents of the following hole are captured. Play continues until one player can no longer play because there are no counters left on their side. The opponent then takes the remainder of the counters on the board. For the next round, each player counts out the counters they captured, placing three each of the holes in their row. For every three in excess of the amount required to fill all of the holes in a row, the player claims one hole from the opponent's row. Play continues in this fashion until one player captures all of the holes on the board. 
(game "Gabata (Adegrat)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top)) 
        (hand Each)
        (map "LeftMost" {(pair P1 0) (pair P2 11)})
    }) 
    (rules 
        
        (start { 
            (set Count 3 to:(sites Track)) 
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Sowing"
            (play 
                (or {
                    (move Select 
                        (from 
                            (if 
                                ("SameTurn") 
                                "PlayFromNextHole" 
                                ("OwnedHoles") 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then 
                            (sow
                                apply:(if (> (count at:(to)) 1)
                                    (if (>= (count at:("NextHoleFrom" (to) 1)) 1)
                                        (moveAgain)
                                    )
                                    (if (>= (count at:("NextHoleFrom" (to) 1)) 1)
                                        (fromTo
                                            (from ("NextHoleFrom" (to) 1))
                                            (to (handSite Mover))
                                            count:(count at:("NextHoleFrom" (to) 1))
                                        )
                                    )
                                )
                            )
                        )
                    )	
                    }
                    (then 
                        (if ("OneRowIsEmpty")
                            (and {
                                (if ("NoPiecesInP1Side")
                                    (forEach Site (sites Board)
                                        (if (< 0 (count at:(site)))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P2))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                    (forEach Site (sites Board)
                                        (if (< 0 (count at:(site)))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P1))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 3 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 3 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:3
                        (then
                            ("RemmemberOwnedHoles" (last To))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Grande Acedrex is an enlarged Chess game described in the Libro de los Juegos of Alfonso X. It could also be played with dice.12x12 checkered board. Each player begins with 24 pieces with special moves: King (x1): Moves one space orthogonally or diagonally or may jump over one space forward orthogonally or diagonally on its first move; Aanca (x2): Moves diagonally one and one space orthogonally in the same direction, and may continue moving in that same direction any distance; Crocodile (x2): moves diagonally any distance; Giraffe (x2): moves two spaces diagonally and then one orthogonally in the same direction, jumping over any intervening pieces; Rhinoceros (x2): moves diagonally one space and then one orthogonally in the same directions, jumping over any intervening pieces, and then may continue along the diagonal in the same direction; Lion (x2); jumps orthogonally three spaces away. Rook (x2): moves any distance orthogonally; Pawns (12): move forward orthogonally one pace or diagonally one space to capture. When they reach the opposite edge of the board, they are promoted to the piece which began in that space. If this is the King's space, it is promoted to Aanca. The opening position is for white: Rook, Lion, Rhinoceros, Giraffe, Crocodile, Aanca, King, Crocodile, Giraffe, Rhinoceros, Lion, Rook. This is mirrored for black so that the kings face each other. The pawns begin on the fourth row. Pieces are captured when a piece lands on a space occupied by the opposing player. The goal is to checkmnate the King. When the King can be captured on the opponent's next turn, it is in check. The player must remove the King from check on their next turn. If the King cannot move out of check, it is checkmated and the opponent wins.  The rules of Alfonso X without dice.
(game "Grande Acedrex" 
    ("TwoPlayersNorthSouth")
    (equipment {
        (board (square 12))
        <Variant:dice>
        ("ChessPawn" "Pawn" ~
            (then     
                (if (is In (last To) (sites Mover "Promotion")) 
                    (promote (last To) (piece "PromotedPiece"))
                )
            )
        )
        ("ChessBishop" "Crocodile")
        (piece "Eagle" Each
            (move (from)
                (to 
                    (union {
                        ("EagleMovement" NW (directions {N W}))
                        ("EagleMovement" NE (directions {N E}))
                        ("EagleMovement" SW (directions {S W}))
                        ("EagleMovement" SE (directions {E S}))
                    })
                    (apply 
                        if:("IsEnemyAt" (to))
                        (remove (to))
                    ) 
                )
            )
        )
        (piece "Rhino" Each 
            (move 
                (from)
                (to
                    (union {
                        ("RhinoMovement" N (directions {NE NW})) 
                        ("RhinoMovement" W (directions {NW SW})) 
                        ("RhinoMovement" S (directions {SW SE})) 
                        ("RhinoMovement" E (directions {SE NE})) 
                    })
                    (apply 
                        if:("IsEnemyAt" (to))
                        (remove (to))
                    ) 
                )
            )
        )
        (piece "Giraffe" Each ("LeapCapture" "GiraffeWalk"))
        ("ChessRook" "Rook")
        (piece "Lion" Each ("LeapCapture" { {F F F} }))
        (piece "King" Each
            (or
                ("StepToNotFriend")
                (if "HasNeverMoved"
                    (move Hop
                        Forwards
                        (between if:True)
                        (to
                            if:(not ("IsFriendAt" (to))) 
                            (apply 
                                (if ("IsEnemyAt" (to))
                                    (remove 
                                        (to) 
                                    )
                                )
                            ) 
                        )
                    )
                )
                "RememberPieceHasMoved"
            )
        )
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules
        (start {
            (place "Pawn1" (sites Row 3)) (place "Rook1" (sites {"A1" "L1"}))
            (place "Lion1" (sites {"B1" "K1"})) (place "Rhino1" (sites {"C1" "J1"}))
            (place "Giraffe1" (sites {"D1" "I1"})) (place "Crocodile1" (sites {"E1" "H1"}))
            (place "Eagle1" coord:"F1") (place "King1" coord:"G1" state:1)
            
            (place "Pawn2" (sites Row 8)) (place "Rook2" (sites {"A12" "L12"}))
            (place "Lion2" (sites {"B12" "K12"})) (place "Rhino2" (sites {"C12" "J12"}))
            (place "Giraffe2" (sites {"D12" "I12"})) (place "Crocodile2" (sites {"E12" "H12"}))
            (place "Eagle2" coord:"F12") (place "King2" coord:"G12" state:1)
        })
        (play
            <Variant:movement>
        )
        (end ("Checkmate" "King"))
    )
)

Describe the mechanics of the following Ludii game
(game "Hat Diviyan Keliya" 
    (players 2) 
    (equipment { 
        (board 
            <Board:type>
            use:Vertex
        )
        (hand Each) 
        (piece "Tiger" P1 (or "HopCapture" "StepToEmpty")) 
        (piece "Leopard" P2 "StepToEmpty") 
    }) 
    
    (rules 
        (start {
            (place "Tiger1" (handSite P1) count:<Board:initTiger>)
            (place "Leopard2" (handSite P2) count:<Board:initLeopard>)
        })
        
        phases:{
        (phase "Placement"
            (play 
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty))
                ) 
            )
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        ("PhaseMovePiece" "Movement"
            (end ("NoMovesLossAndLessNumPiecesPlayerLoss" P2 <Board:leopardGoal>))
        )
        }
    )
)
Game played in Sri Lanka during the nineteenth century, but likely to be older. It is a hunt game like others common in South Asia, particularly those known as \The game is played on a triangle board divided in half on its height and then in thirds with lines crossing the height perpendicularly. One player plays as the tiger, and the other plays as seven leopards. The tiger plays their piece on a point where lines intersect first, and then on subsequent turns the leopards are placed one-by-one. Moves occur along the lines to an adjacent intersection. The tiger captures may capture a leopard by hopping over it. The tiger's goal is to capture four of the leopards; the leopards' goal is to block the tiger so it cannot move. Played on the board described in Ludovici and Parker.

Construct a Ludii game based on the following description
Udat Pagada is a game played on a  Chaupar board, but ignoring the spaces on the board. It was played up until the early twentieth century by girls. Graffiti suggests that the game could be much older.Played on a Chaupar board. Two players. Four pieces per player. Seven cowries, used as dice. The throws are as follows: one face up = 10; two faces up = 2; three faces up = 3; four faces up = 4; five faces up = 25; six faces up = 36; seven faces up = 14; all faces down = 7. Players start from opposite ends of the board. In this game, the divisions of the arms of the board are ignored; each arm is considered one space, and the spaces between the arms are also considered a space, making eight total spaces. Players sit opposite each other, and the point in front of them is the starting point for that player. Play proceeds in an anti-clockwise direction. When one player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. A player wins by capturing all of the opponent's pieces. 6 faces up = 36.
(game "Udat Pagada" 
    (players 2) 
    (equipment { 
        (board 
            (add
                (add
                    (hole
                        (merge 
                            (shift 0 8 (rectangle 4 20)) 
                            (shift 8 0 (rectangle 20 4))
                        )
                        (poly {{8 8} {8 11} {11 11} {11 8}})
                    )
                    cells:{ { 8 28 48 68 69 70 71 51 31 11 10 9 } }
                )
                vertices:{{9.5 4} {15 4} {15 9.5} {15 15} {9.5 15} {4 15} {4 9.5} {4 4}}
            )
            {
            (track "Track" {144..151} loop:True)
            }
            use:Vertex
        )
        ("StickDice" 7)
        (piece "Pawn" Each
            (move 
                (from (from) level:(level))
                (to ("NextSiteOnTrack" ("ThrowValue") from:(from) "Track")
                    (apply 
                        (if ("IsEnemyAt" (to))
                            (forEach Level (to) FromTop
                                (remove (to) level:(level))
                            )
                        )
                    )
                )
            )		
        )
        (hand Each)
        (map "Throw" {(pair 0 7) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 <ThrowSix:value>) (pair 7 14)})
        (map "Entry" {(pair P1 144) (pair P2 148)})
    }) 
    (rules 
        (start {
            (place Stack "Pawn1" (handSite P1) count:4)
            (place Stack "Pawn2" (handSite P2) count:4)
        })
        
        (play 
            ("RollMove"
                (or
                    (if (is Occupied (handSite Mover))
                        (move 
                            (from (handSite Mover))
                            (to ("NextSiteOnTrack" (- ("ThrowValue") 1) from:(mapEntry "Entry" Mover) "Track")
                                (apply 
                                    (if ("IsEnemyAt" (to))
                                        (forEach Level (to) FromTop
                                            (remove (to) level:(level))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (forEach Piece)
                )
            )
        )
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Uturu Uturu Kaida is a simple race game played in Senegal. The board is made in the sand, and pieces of wood or iron are used as pieces. It is played with six or seven players, who race their horses to the end of the board.The board is a rectilinear track with two rows, of any number. Six or seven players, seven are preferred. One piece per player. Two seashells, used as dice. The throws are as follows: two backs = 20; two hollow sides = 10, one of each = 0. The player to reach the end of the track wins. The game involves 6 players. Each row has 20 holes.
(game "Uturu Uturu Kaida"
    (players <Player:num>)
    (equipment {
        (board 
            (rectangle 2 <Board:size>)
            (track "Track" <Board:track> directed:True)
            use:Vertex
        )
        (hand Each)
        (piece "Horse" Each
            (if ("IsOffBoard" ("SiteToMove"))
                (move Remove (from) level:(level))
                (move
                    (from (from) level:(level))
                    (to ("SiteToMove"))
                    stack:True
                )
            )
        )
        ("StickDice" 2)
        (map {(pair 0 10) (pair 1 0) (pair 2 20)})
    })
    (rules 
        (start (place "Horse" "Hand"))
        (play 
            ("RollMove"
                (if (< 0 ("ThrowValue"))
                    (or (forEach Piece) (forEach Piece container:(mover)))
                )
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Games inspired by Kanare Kato's 'Squish'        'Don't Mosey' and 'The Last Scavenger' are based on Kanare Kato's work developing 'Squish' and 'Advanced Squish'.        Originally 'Squish' was a unification game with step movement toward a friendly piece in-line, possibly involving a capture.  'Advanced Squish' added a requirement on non-capturing steps for the piece to become part of a larger group. (Singletons were exempted.)        -- 'Don't Mosey'and 'The Last Scavenger' differ by being explicitly stalemate games: Last to move wins or loses depending on the game.          They also differ by using slide moves instead of steps, and having a different 'larger group' rule that restricts empty destination choices, but applies to any group formed along the path, and does not restrict captures (which must be the first opponent along the path).Setup: Pieces of each color start distributed symmetrically on every 3rd cell of the board. (For a game on an order 4 board, the outer cells are not used.)
            
            Play    
            - Decide which player will play with which color (Dark or Light). 
            - Light is the first player to play.
            - Passing is not allowed.
            - The game ends when a player cannot move. 
            
            On each turn, the mover chooses a piece and slides it over empty cells towards a friendly piece in the same line (but not necessarily visible from the moving piece's point of view.) 
            
            The sliding piece must either:
            - stop on an empty cell next to a friendly piece to form a group of friendly pieces that is larger than the group it started in, or 
        - stop at the first opponent's piece and remove it. Don't Mosey - Misere. A piece must slide toward a friendly piece, either to reach a location where it forms a group larger than where it started, or to reach an opponent's piece, which is then removed. Last to move Loses Order 4 board
(game "Don't Mosey and The Last Scavenger"
    (players 2)
    (equipment {
        (board (hex Hexagon <Board:side>) use:Cell)
        (piece "Disc" Each)
    })
    (rules
        (start {<Board:white> <Board:black>})
        (play
            <Game:structure>
        )
        (end 
            <Game:winCondition>
        )
    )
)

Construct a Ludii game based on the following description
Mbelele is a two-row mancala-style board game played by the Mba people of the Democratic Republic of Congo. It is a unique game in that the board contains single holes that interrupt the usual arrangement of neat rows of holes.Two rows of twelve holes in the central part of the board, one hole on either end of this, two rows of two outside of these single holes on both sides of the board, and one final hole on either end of the board. Three counters in each hole. Sowing occurs only in the player's row; players use the inner single hole to their left; the outer single hole to the right. Sowing can occur in either direction. Captures are made when a counter falls into an empty hole. The counters in the opponent's opposite hole are captured. When the final counter of a sowing ends in a player's empty inner single holes, the counters in the opponent's inner single hole are captured. If it lands in a player's empty outer single hole, the counters in the opponent's outer single hole are captured. Single counters can be sown, but these cannot capture more than one of the opponent's counters. If the final counter falls into an occupied hole, the contents of this hole are picked up and sowing continues in the same direction. A player can sow such that they can make a capture from the hole in which the sowing began, but this cannot be done by sowing two or fewer counters. The player who has no counters remaining in their row loses. It is customary to play a series of round to determine the winner. 
(game "Mbelele"
    (players 2)
    (equipment {
        (board 
            (merge {
                (rectangle 2 12)
                (shift -1 0.5 (square 1))
                (shift -3 0 (square 2))
                (shift -4 0.5 (square 1))
                (shift 12 0.5 (square 1))
                (shift 13 0 (square 2))
                (shift 15 0.5 (square 1))
            })
            {
            (track "TrackCCW1" "25,26,24,0,E,31,32,35" loop:True P1)
            (track "TrackCCW2" "34,33,30,23,W,28,27,29" loop:True P2)
            (track "TrackCW1" "35,32,31,11,W,24,26,25" loop:True P1)
            (track "TrackCW2" "29,27,28,12,E,30,33,34" loop:True P2)
            }
            use:Vertex
        )
        (piece "Seed" Shared)
        (map "Opposite" {
            (pair 29 35) (pair 35 29) (pair 24 30) (pair 30 24) 
            (pair 25 27) (pair 26 28) (pair 0 12) (pair 1 13) (pair 2 14) (pair 3 15) (pair 4 16) (pair 5 17) (pair 6 18) (pair 7 19) (pair 8 20) (pair 9 21) (pair 10 22) (pair 11 23) (pair 31 33) (pair 32 34)
            (pair 27 25) (pair 28 26) (pair 12 0) (pair 13 1) (pair 14 2) (pair 15 3) (pair 16 4) (pair 17 5) (pair 18 6) (pair 19 7) (pair 20 8) (pair 21 9) (pair 22 10) (pair 23 11) (pair 33 31) (pair 34 32)
        })
        (regions P1 (union (sites Bottom) (sites {24 35})))      
        (regions P2 (union (sites Top) (sites {29 30})))      
    })
    (rules
        (start (set Count 3 to:(sites Board)))
        (play 
            (or
                (if (!= 2 (var "NumCapture"))
                    (or
                        (if (!= (var "Direction") 2)
                            (move Select
                                (from
                                    (if ("SameTurn")
                                        (sites {(var "Replay")})
                                        (sites Mover)
                                    )
                                    if:(and (if ("SameTurn") True (= 1 (count at:(from)))) (is Occupied (from)))
                                )
                                (then 
                                    (sow
                                        "TrackCCW"
                                        owner:(mover)
                                        apply:(if (= 1 (count at:(to)))
                                            (and {
                                                (if (is Occupied (mapEntry "Opposite" (to)))
                                                    (remove
                                                        (mapEntry "Opposite" (to))
                                                        count:1
                                                    )
                                                )
                                                (set Var "Direction" 0)
                                                (set Var "NumCapture" 0)
                                            })
                                            (and {
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                                (set Var "Direction" 1)
                                                (set Var "NumCapture" 1)
                                            })
                                        )
                                    )
                                )
                            )
                        )
                        (if (!= (var "Direction") 1)
                            (move Select
                                (from
                                    (if ("SameTurn")
                                        (sites {(var "Replay")})
                                        (sites Mover)
                                    )
                                    if:(and (if ("SameTurn") True (= 1 (count at:(from)))) (is Occupied (from)))
                                )
                                (then 
                                    (sow
                                        "TrackCW"
                                        owner:(mover)
                                        apply:(if (= 1 (count at:(to)))
                                            (and {
                                                (if (is Occupied (mapEntry "Opposite" (to)))
                                                    (remove
                                                        (mapEntry "Opposite" (to))
                                                        count:1
                                                    )
                                                )
                                                (set Var "Direction" 0)
                                                (set Var "NumCapture" 0)
                                            })
                                            (and {
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                                (set Var "Direction" 2)
                                                (set Var "NumCapture" 1)
                                            })
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                
                (if (!= 1 (var "NumCapture"))
                    (or
                        (if (!= (var "Direction") 2)
                            (move Select
                                (from
                                    (if ("SameTurn")
                                        (sites {(var "Replay")})
                                        (sites Mover)
                                    )
                                    if:(and (if ("SameTurn") True (< 1 (count at:(from)))) (is Occupied (from)))
                                )
                                (then 
                                    (sow
                                        "TrackCCW"
                                        owner:(mover)
                                        apply:(if (= 1 (count at:(to)))
                                            (and {
                                                (if (is Occupied (mapEntry "Opposite" (to)))
                                                    (remove
                                                        (mapEntry "Opposite" (to))
                                                        count:(count at:(to))
                                                    )
                                                )
                                                (set Var "Direction" 0)
                                                (set Var "NumCapture" 0)
                                            })
                                            (and {
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                                (set Var "Direction" 1)
                                                (set Var "NumCapture" 2)
                                            })
                                        )
                                    )
                                )
                            )
                        )
                        (if (!= (var "Direction") 1)
                            (move Select
                                (from
                                    (if ("SameTurn")
                                        (sites {(var "Replay")})
                                        (sites Mover)
                                    )
                                    if:(and (if ("SameTurn") True (< 1 (count at:(from)))) (is Occupied (from)))
                                )
                                (then 
                                    (sow
                                        "TrackCW"
                                        owner:(mover)
                                        apply:(if (= 1 (count at:(to)))
                                            (and {
                                                (if (is Occupied (mapEntry "Opposite" (to)))
                                                    (remove
                                                        (mapEntry "Opposite" (to))
                                                        count:(count at:(to))
                                                    )
                                                )
                                                (set Var "Direction" 0)
                                                (set Var "NumCapture" 1)
                                            })
                                            (and {
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                                (set Var "Direction" 2)
                                                (set Var "NumCapture" 2)
                                            })
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        (end
            (forEach NonMover
                if:("NoPiece" Player)
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Diamond is a two-player abstract strategy board game invented by Larry Back. The invention was inspired by the game Kensington, which uses a similar board pattern and game objective. Rules for Diamond were conceived in 1985 and finalized in 1994. Diamond introduces a new board geometry and neutral pieces, with the aim of enhancing the game dynamic and lowering the potential for draws.Diamond was featured in the February 2013 issue of Games magazine.The game begins with an empty Diamond board. Black moves first, then turns alternate. (To offset any advantage Black has in moving first, the pie rule is used: White can choose to switch sides after Black's first move, playing from then on as Black. White has this option only after Black's first move.) 
            
            The game is executed in two phases:
            
        1) Placement phase. Players take turns placing one of their pieces on any open point on the board. No placements result in a capture in this phase. A player can win the game in this phase if they are able to occupy all four corners of a board square; otherwise, play proceeds to the Movement phase once all 24 pieces have been placed.
        
    2) Movement phase. For their turn, a player may either:
    - move one of their pieces along a straight line to an adjacent empty point; or,
    - remove a neutral piece from the board—but only if no white or black piece is adjacent to it.
    
    Capturing moves are possible in the Movement phase. If the points of a triangle contain exactly one white and one black piece, either player can capture the opponent piece by occupying the remaining open point (\ 
(game "Diamond" 
    (players 2) 
    (equipment { 
        (board 
            (rotate 90 (tiling T33434 3))
            use:Vertex
        ) 
        (piece "Disc" Each 
            ("StepToEmpty" ~
                (then
                    (if (= 1 (count Sites in:("TrianglesWithCaptures")))
                        (forEach Site (sites Incident Cell of:Vertex at:(last To))
                            (if (and {
                                    ("IsATriangle")
                                    ("TwoFriendPieces")
                                    ("OneEnemyPiece")
                                })
                                (and
                                    (forEach Site
                                        (forEach (sites Incident Vertex of:Cell at:(site)) if:(is Next (who at:(site))))
                                        ("ReplaceEnemyPieceByNeutral")
                                    )
                                    (set Counter)
                                )
                            )
                        )
                    )
                )
            )
        ) 
        (piece "Disc" Neutral)
        (hand Each)
        (regions P1 {(sites Side W) (sites Side E) })
        (regions P2 {(sites Side N) (sites Side S) })
    }) 
    (rules
        (meta (swap))
        
        (start (place "Disc" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play 
                (move
                    (from (handSite Mover))
                    (to (sites Empty))
                    (then
                        (and
                            (forEach Site (sites Incident Cell of:Vertex at:(last To))
                                (if ("SquareFilled") (trigger "Win" Mover))
                            )
                            (set Counter)
                        )
                    )
                )
            )
            (nextPhase Mover (is Empty (handSite Mover)) "Movement")
        )
        (phase "Movement"
            (play 
                (or
                    (forEach Piece)
                    (move Remove (sites Occupied by:Neutral))
                )
            )
        )
        }
        (end { 
            (if (is Triggered "Win" Mover)
                (result Mover Win)
            )
            (if (or (no Moves Mover) (= (counter) 49)) (result Mover Draw)) 
        }) 
    )
)

Construct a Ludii game based on the following description
Grand Trictrac is a Tables game popular in France since the Early Modern period. It is different from similar games in that scores are accumulated by hypothetical moves and achieving particular positions in the game.The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has fifteen pieces, which all begin on the first point of their track. Two dice are used. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The maximum number of pieces per point is two, except for the starting point. Placing pieces on the twelfth point of a player's side is only allowed when it can be achieved by two pieces on the same dice roll. A player's pieces only actually move on the player's half of the board; points are awarded for any hypothetical move that would move a player's pieces along the imagined track onto the opponent's side of the board that would land on a point with a lone opposing piece (a \ 
(games {
        (subgame "GrandTrictracSubgame")
    })

Construct a Ludii game based on the following description
Piprjall is a European Tables game played in Iceland. It has a unique method of playing when doubles are thrown on the dice. 2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player, which begin on the rightmost point, with respect to the player, on the opposite side of the board from which they sit. Two six-sided dice. Pieces move according to the throws of the dice, the value of a die being used to move a piece the entire value of the die. A throw of double sixes makes the player play six twice, then five twice, then four twice, and so on down to one. A throw of double fives forces the player to play five twice and then six twice. A throw of double four, three, or two forces the player to play two of that number, down to one. A play of double ones forces the player to play one twice, then two twice, up to six. More than two pieces of the same player may not occupy a point on the starting side of the board. The player cannot move past the penultimate point on the opposite side of the board until five pieces have been moved from the starting point. A single opponent's piece may be removed from the board when a player's piece lands on it, and the opponent's piece must reenter the board. Pieces cannot move to a point occupied by two opponent's piece. A piece cannot reenter the board on a point occupied by another piece, whether belonging to the player or the opponent. When all of a player's pieces have reached the final quadrant of the board, the player may begin to remove them from the table. The player who bears off their pieces scores two points. 
(game "Piprjall"
    (players 2)
    (equipment {
        ("BackgammonBoard"
            {
            (track "Track1" {25..20 18..13 0..5 7..12 End} P1 directed:True)
            (track "Track2" {0..5 7..12 25..20 18..13 End} P2 directed:True)
            }
        )
        (dice d:6 num:2)
        (piece "Disc" Each ("Move")) 
        (hand Each)
        (regions "FinalQuadrant" P1 (sites {7..12}))
        (regions "FinalQuadrant" P2 (sites {13..18}))
        (regions "StartingSide" P1 (sites {25..20 18..13}))
        (regions "StartingSide" P2 (sites {0..5 7..12}))
        (regions "AfterPenultimate" P1 (sites {12}))
        (regions "AfterPenultimate" P2 (sites {13}))
        (map "Entry" {(pair P1 25) (pair P2 0)})
    })
    (rules 
        (start {
            (place Stack "Disc1" 25 count:15)
            (place Stack "Disc2" 0 count:15)
        })
        (play 
            (if (can Move ("PlayMove"))
                ("PlayMove") 
                (move Pass 
                    (then 
                        (and {
                            (set Value Mover 0)
                            (set Var "FirstPlay" 0)
                            (set Var "DoubleToPlay" 0)
                        })
                    )
                )
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Tre Guti is a capturing game played on a small board. It was played by all ages and genders in the Mianwali district of Pakistan.3x3 crossed lines, pieces move on the intersections and along the lines. Three pieces per player. In the placement phase, players alternate turns placing one of their pieces on an empty spot. When all of the pieces are placed, Players attempt to capture their opponent's pieces by hopping over them. The player who captures all of the opponent's pieces wins. 
(game "Tre Guti" 
    (players 2)
    (equipment {
        (board (square 3) use:Vertex)
        (hand Each)
        (piece "Marker" Each
            (or
                ("StepToEmpty")
                ("HopCapture")
            )	 
        )
    })
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Bagha Guti"
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Goat" P2 "StepToEmpty")
        (piece "Tiger" P1
            (or
                ("StepToEmpty")
                ("HopCapture")
            )
        )
        (hand P1)
    }) 
    
    (rules 
        (start { 
            (place Stack "Goat2" 12 count:21)
            (place "Tiger1" (handSite P1))
        })
        
        phases:{
        (phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase "Movement"))
        (phase "Movement" (play (forEach Piece top:True)))
        }
        
        (end ("NoMovesP1NoPiecesP2"))
    )
)
Bagha Guti is a hunt game played in the Bihar region of India. The tiger attempts to eat all the goats, and the goats try to trap the tiger. All of the goats begin on the same spot in this game.5x5 board, played on intersections of the lines, with diagonals for each quadrant of the board. One player plays with a tiger piece, placed anywhere on the board. The other player plays with 21 goats, placed on the central point of the board. The goats move first. Goats may move one at a time to any adjacent vacant spot along the lines of the board. The tiger moves in the same manner, but also may capture a piece by hopping over it to an empty space immediate on the opposite side of a goat. The tiger may hop the stack of goats, but may only capture one. The goal of the goats is to surround the tiger so it cannot move. The goal of the tiger is to capture all the goats.
         

Construct a Ludii game based on the following description
Acedrex is the word for Chess in Spain. This is the version given in the Libro de los Juegos of Alfonso X, from the thirteenth century.8x8 board. The pieces move as follows: King (x1): one space in any direction' Queen (x1): moves one square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. Bishop (x2): jumps exactly two squares diagonally; Knight (x2): moves one space orthogonally and then one space diagonally, jumping over the intervening spaces; Rook (x2): moves any distance orthogonally; Pawns (x8): move one square forward orthogonally or one square forward diagonally to capture. Pawns may move two squares on their first move, but only if there have been no captures yet in the game. When reaching the opposite edge of the board, pawns may be promoted to Queen if the Queen has already been taken. If the King can be captured on the opponent's next move, it is in check. The King must not be in check at the end of the player's turn. If this is impossible, it is checkmate, and the opponent wins.  
(game "Acedrex (Alfonso)" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        ("ChessKing" "King" (then (set Var 1)))
        (piece "Queen" Each
            (or
                (move Step 
                    Diagonal
                    (to 
                        if:(not ("IsFriendAt" (to))) 
                        "CaptureToPiece"
                    ) 
                )
                (if (not ("MovedBefore" (from)))
                    (move Hop Diagonal 
                        (between if:True) 
                        (to if:(is Empty (to)))
                    ) 
                )
                (then 
                    (if (not ("MovedBefore" (last To)))
                        ("RememberMoved" (last To))
                    )
                )
            )
        )
        (piece "Bishop" Each
            (move Hop Diagonal 
                (between if:True) 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPiece"
                )
            )		
        )
        ("ChessKnight" "Knight" (then (set Var 1)))
        ("ChessRook" "Rook" (then (set Var 1)))
        (piece "Pawn" Each
            (or {
                (if (and (not ("HadACapture")) (is In (from) (sites Start (piece (what at:(from))))))
                    ("DoubleStepForwardToEmpty")
                )
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                }
                (then
                    (if (and ("IsOffBoard" (where "Queen" Mover)) (is In (last To) (sites Mover "Promotion")))
                        (promote (last To) (piece "Queen") Mover)
                    )
                )
            )		
        )
        
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })  
        (play 
            (do
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King" Mover))
            )
        )
        
        (end ("Checkmate" "King"))
    )
)

Describe the mechanics of the following Ludii game
(game "NoGo" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each)
    }) 
    
    (rules 
        (play 
            (do
                (move Add (to (sites Empty)))
                ifAfterwards:(and 
                    ("HasFreedom" Orthogonal)
                    "NoCapture"
                )
            )
        )
        
        (end ("NoMoves" Loss)) 
    )
)
NoGo is a combinatorial game for two players: Black and White. It's played on the intersections (points) of an initially empty square or rectangular board. Board sizes bigger than 9x9 are not recommended. 6x7 boards have been used in some human matches.NoGo takes the Go concepts of group and liberty and uses them in the most minimalistic possible way. The resulting game, with no captures, no cycles and no scoring, is no rival for Go, but remains a fertile ground for tactical challenges in the Dots and Boxes style.Black plays first, then turns alternate. On his turn, a player must place a stone of his color on an empty point of the board. At the end of a turn, all groups on the board (both friendly and enemy) must have at least one liberty. Otherwise the player's move is illegal. Whoever can't make a move on his turn loses. The game is played on 6x7 board.

Describe the mechanics of the following Ludii game
(game "Hnefatafl" 
    (players 2) 
    (equipment { 
        (board (square 11)) 
        (regions "Fortresses" (sites Corners))
        
        (piece "Thrall" P1 
            (move Slide
                Orthogonal 
                (between if:"EmptyButNotCentreOrFortress")
                (then 
                    (and {
                        ("Custodial" "Thrall2")
                        (<Capture:type>
                            (between
                                <Capture:distance>
                                if:("IsPieceAt" "Jarl" P2 (between))
                                "JarlIsCaptured"
                            )
                            (to if:"FriendOrCentreOrFortress")
                        )
                    })
                )
            )
        )
        (piece "Thrall" P2 
            (move Slide
                Orthogonal 
                (between if:"EmptyButNotCentreOrFortress") 
                (then ("Custodial" "Thrall1")) 
            ) 
        ) 
        (piece "Jarl" P2 
            (move Slide
                Orthogonal 
                (then ("Custodial" "Thrall1")) 
            ) 
        ) 
    }) 
    (rules 
        (start { 
            (place "Thrall1" {"D1" "E1" "F1" "G1" "H1" "F2" "A4" "A5" "A6" "A7" "A8" "B6" "K4" "K5" "K6" "K7" "K8" "J6" "F10" "D11" "E11" "F11" "G11" "H11" "F10"})
            (place "Thrall2" {"F4" "E5" "F5" "G5" "D6" "E6" "G6" "H6" "E7" "F7" "G7" "F8"})
            (place "Jarl2" (centrePoint))
        })
        
        (play (forEach Piece)) 
        
        (end {
            ("PieceTypeReachWin" "Jarl2" (sites "Fortresses") P2)
            (if "JarlWasCaptured" (result P1 Win))
        })
    )
)
Hnefatafl is a Nordic game mentioned frequently in medieval texts from Scandinavia, Iceland, and the British Isles. Hnefatafl appears to be related to a range of other tafl games, where one side has a king and a smaller number of pawns, situated in the center of the board, playing against an opponent with more pieces. The king's goal is largely thought to be to escape to one of the corners, and the opponent's goal is to capture the king.Played on an 11x11 board. The defending side comprises twelve soldiers and a king, who start the game in a cross formation in the center of the board.
                Their objective is for the king to escape by reaching any of the four corner squares.
                The attackers comprise 24 soldiers positioned in four groups of 6 around the perimeter of the board.
                The King piece is the only piece that can occupy the central and the four corner squares.
        All pieces move orthogonally any number of spaces, and pieces are taken by custodial capture (surrounding an enemy  piece on either side with two of a player's pieces). The king piece must be captured by surrounding it on all four sides. The game is played with the common rules.

Construct a Ludii game based on the following description
Manifold is a polyhex buliding game for two players – Black and White – played on an initially empty hexhex board. Michael Amundsen invented Manifold in May 2022.Definitions:
            1 A group is a stone along with all stones one can reach from it through a series of steps onto adjacent stones of the same color.
            1.1 The size of a group is the number of stones in it.
            
            2 A brood is a group along with all other groups of identical color, size and shape. Shapes are considered identical across rotational and mirror-symmetries.
            2.1 The size of a brood is the number of groups in it.
            2.2 The order of a brood is the size of the groups in it.
            
            Play:
            On the very first turn of the game, Black places one stone of their color on any hex.
            After, that – starting with White – take turns doing one of the following:
            • Pass.
            • Place two stones of your color on empty hexes.
            
            When the players pass consecutively, the winner is the player with the higher score.
            
            Scoring:
        For each of your odd-sized broods, you score 1 point if its order is odd and 2 points if its order is even. A boad of size 4 is currently selected. Nothing is currently printed on the pieces.
(game "Manifold"
    (players 2)
    (equipment {
        (board <Board:size> use:Cell)
        (piece "Hex" Each maxState:7 maxValue:1023) 
        (piece "Disc" Neutral)
    })
    (rules
        (play
            (if 
                (or
                    (= 0 (count Moves))
                    (!= 0 (count MovesThisTurn))
                )
                ("PlaceHex")
                (or
                    (move Pass)
                    (and
                        {
                        ("PlaceHex")
                        } 
                        (then (moveAgain))
                    )
                )
                (then (forget Value All))
            )
        )
        (end
            (if (all Passed)
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Fill a Pix is a numerical deduction puzzle game invented by Trevor Truran.Play is on a grid of any number of squares. Some of the squares are marked with a number which indicates the number of squares adjacent to it are colored. Player determines which squares are colored and colors them in, revealing a picture. 
(game "Fill A Pix" 
    (players 1) 
    (equipment { 
        (board (square <Challenge:size>) (values Cell (range 0 1)))
        (hints { <Challenge:hints> })
        (piece "Square" P1)
    }) 
    (rules 
        (play 
            (satisfy {
                (forAll
                    Hint 
                    (is Count 
                        (sites Around (from) includeSelf:True) 
                        of:1
                        (hint)
                    )
                )
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
Hindustani Chess is the form of Chess played in northern India. It allows a special opening move for the king, and the opening position is slightly different from European Chess.8x8 board, marked as in Chaturanga. Pieces move according to specialized moves, as follows: Pawns (x8): can move one space forward and capture one space forward diagonally; Elephant (or Chariot or Boat) (x2): can move any number of spaces orthogonally; Elephant (or Camel) (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Raja (x1): can move one space orthogonally or diagonally, but can also move like the horse on its first move, if it has not yet been checked. The pieces are arranged as in Chess, except the Vizier is place to the left of the Raja on both sides. Players capture pieces by moving onto a space occupied by an opponent's piece. When a pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When a player can capture the opponent's Raja on the next turn, the Raja is in Check, the opponent's next move must free the Raja from check. If the opponent cannot, it is checkmate and the player wins. If a player captures all of the opponent's pieces aside from the Raja and pawns, it is declared a half-win, or Burd. When both players are left with only a Raja, it is a draw. Players are not allowed to stalemate the opponent. If check is given 70 times in succession, the game is a draw. 
(game "Hindustani Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8))
        
        (piece "Pawn" Each 
            (move Step 
                Forward 
                (to 
                    if:(and 
                        (or
                            (not (is In (to) (sites Mover "Promotion")))
                            (and 
                                (is In (to) (sites Mover "Promotion"))
                                ("PowerfulPieceOnColumnHasBeenRemoved")
                            )
                        )
                        (not ("IsFriendAt" (to)))
                    )
                    (apply (remove (to)))
                )
                (then ("PromotePiece"))
            )
        )
        ("ChessRook" "Boat")
        (piece "King_noCross" Each 
            (or
                ("StepToNotFriend") 
                (if (and (not ("IsInCheck" "King_noCross" Mover)) "HasNeverMoved")
                    ("LeapCapture" "KnightWalk")
                )
                "RememberPieceHasMoved"
            )
        )
        ("ChessBishop" "Elephant")
        ("ChessKnight" "Horse")
        ("ChessQueen" "Ferz_noCross")
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Boat1" {"A1" "H1"}) (place "Horse1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1" state:1) 
            (place "Boat2" {"A8" "H8"}) (place "Horse2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8" state:1) 
        })
        
        (play (do (forEach Piece) ifAfterwards:(and (not (no Moves Next)) (not ("IsInCheck" "King_noCross" Mover)))))
        
        (end {
            ("Checkmate" "King_noCross")
            (if (= (count Pieces Next) 1) (result Mover Draw)) 
            (if (= (count Pieces Next) (+ 1 (count Sites in:(sites Occupied by:Next component:"Pawn")))) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Lava is a territorial stacking game invented by Alek Erickson and Michael Amundsen in August 2021.Lava is a territorial stacking game for two players, Red and Black. Play using a Hexhex board size 4 or 5, and a sufficient supply of Red/Black stacking checkers. To setup, place one Red and one Black checker in opposite corners of the hex hex board.
            
            Definitions:
            Stack: One or more checkers occupying the same cell.
            Control: You control a stack if your color is on top of it.
            
            Players take turns, with Black moving first.
            
            Each turn, take N checkers (where N is any number from 1 to stack size) from the top of a stack you control and move them N spaces in a straight line to a destination containing N or less checkers. Then, add a new checker of your color to the destination. Stacks may not jump over enemies, but may land on enemy or friendly stacks, thereby burying them.
            
            If you at any point cannot make a move, you must pass. This does not end the game, only your turn.
            
        When the board is full, the player controlling more stacks wins the game. A size 4 board is currently selected The number of pieces in a stack is currently not shown on the top piece.
(game "Lava"
    (players 2)
    (equipment {
        (board (rotate 30 (hex <Board>)))
        (piece "Disc" Each)
    })
    (rules
        (start {
            (place "Disc1" (min (array (sites Board))))
            (place "Disc2" (max (array (sites Board))))
        })
        (play ("Select" (then ("Move"))))
        (end 
            (if (is Full) 
                (byScore {
                    (score P1 (count Sites in:(sites Occupied by:P1 top:True)))
                    (score P2 (count Sites in:(sites Occupied by:P2 top:True)))
                })
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Quela" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" <Board:CCW2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))          
        (regions "Home" P2 (sites Track "TrackCCW2"))          
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom)))  
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top)))   
        (map "LeftMost" {(pair P1 0) <Board:leftMostP2>})
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))
        )
        
        phases:{
        (phase "Rearrangement"
            (play
                (or
                    (move 
                        (from (sites Mover "Home") if:(is Occupied (from)))
                        (to (difference (sites Mover) (from)))
                    )
                    (if (and ("LeftMostCounters") ("OnlyOneInInner"))
                        (move Pass)
                    )
                )
            )
            (nextPhase (all Passed) "InitialPhase")
        )
        (phase "InitialPhase"
            (play
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover "Home") 
                        ) 
                        if:(or ("SameTurn") 
                            (and 
                                (> 3 (count at:(from))) 
                                (is Occupied (from))
                            )
                        )
                    )
                    (then
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (is Occupied ("OppositePit" (to)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (handSite Mover))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            {
            (nextPhase P1 (< 1 (count Cell at:(handSite P2))) "MiddlePhase")
            (nextPhase P2 (< 1 (count Cell at:(handSite P1))) "MiddlePhase")
            }
        )
        
        (phase "MiddlePhase"
            (play
                (move Select
                    (from 
                        ("SitesWithMaxCounter") 
                    )
                    (then
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (is Occupied ("OppositePit" (to)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (handSite Mover))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover "FinalPhase")
        )
        
        (phase "FinalPhase"
            (play
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (sites Mover "Home") 
                        ) 
                        if:(is Occupied (from))
                    )
                    (then
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (is Occupied ("OppositePit" (to)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (handSite Mover))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end ("BlockWin"))
        )
        }
    )
)
Quela is a four-row mancala-style board game played by the Quibala people of Angola.4x6-7 board. Two counters in each hole; before beginning each player rearranges these as they wish, with the following rules: The leftmost hole in the outer row must have the most counters; holes in the inner row may only have one counter. Initial phase: In this phase, only holes with two or fewer counters may be used to sow. Sowing occurs in an anti-clockwise direction, and when a counter lands in an occupied hole the sowing continues. When the final counter lands in an empty hole, the turn ends. If the empty hole is in the player's inner row, counters in the opponent's inner row opposite are captured, and if there are also counters in the opponent's outer row hole opposite, these are also taken. The initial phase ends for a player when two of the player's counters have been taken. On the next turn they must play from the hole with the largest number of counters, and from that point they may move from any hole. The rules for play remain the same as in the initial phase otherwise. The player who captures all of the opponent's counters wins. Each player has 6 holes by row.

Construct a Ludii game based on the following description
Y (Hex) is a version of Hex created by Eric Piette for Ludii. It is played with hexagonal spaces arranged in a triangular board, 8 spaces on each side is typical.Players take turns placing their pieces on a space on the board, with the goal of connecting all three sides of the triangle with their pieces. Corners count as belonging to both sides they touch. 
(game "Y (Hex)" 
    (players 2) 
    (equipment { 
        (board (tri Hexagon 7) use:Vertex) 
        (piece "Marker" Each)
        (regions "SSW" {(sites Side S) (sites Side SW) })
        (regions "NNW" {(sites Side NW) (sites Side N) })
        (regions "NESE" {(sites Side NE) (sites Side SE) })
    }) 
    (rules 
        (play (move Add (to (sites Empty))))
        (end 
            (if (is Connected {
                    (sites "SSW") 
                    (sites "NNW") 
                    (sites "NESE")
                }) 
                (result Mover Win) 
            ) 
        )
    )
)

Construct a Ludii game based on the following description
Tsoro Yemutwelve is a board game played in Zimbabwe, usually by boys and young men, though sometimes by adults as well. The board is typically scratched on the ground and played with stones.Three concentric squares, with lines connecting the diagonals and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing one of their pieces on one of the empty intersections of the board. If a player places three of their stones in a straight line, the player may remove one of the opponent's pieces. When all of the pieces have been placed, the players alternate turns moving one of their pieces to an empty adjacent point along the lines of the board. When a player is reduced to three pieces, they may move one of their stone to any empty space on the board. The player who reduces their opponent to two pieces wins. 
(game "Tsoro Yemutwelve"
    (players 2)
    
    (equipment { 
        (board (concentric Square rings:3 joinCorners:True) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3" Orthogonal exact:True)))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True)) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveEnemyPiece"
                    (if (> (count Pieces Mover) 3)
                        (forEach Piece)
                        (move 
                            (from (sites Occupied by:Mover))
                            (to (sites Empty))
                        )
                    )
                )
            )
        )
        }
        
        (end ("HavingLessPiecesLoss" Next 2))
    )
)

Construct a Ludii game based on the following description
Khrour is a two-row mancala-style board game played in West Africa. It is typically played in holes scooped out of the sand, rather than on an actual game board.2x2, 3, 4, or 6 board. Each hole contains a number of counters equal to the total number of holes in the board. Sowing begins from any hole in the player's row, and proceeds anti-clockwise. Counters are captured when the final counter lands in an occupied hole, making it contain 2, 4, 6, or 8 counters. When all of the counters have been captured, a second game begins. Each player fills their holes with the same number of counters as the beginning of the previous game. The player who has extra counters holds these in reserve. The other player will have either empty holes or one without the requisite number to fill the hole. Sowing cannot begin and captures cannot be made from these holes until the contents of these holes reaches the required number of counters to fill them. The second player in the first game now becomes the first player. Play continues with subsequent games until one player captures all the counters.
            
        Evidence Map Each player has 2 holes.
(game "Khrour" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 <Board:size> store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start {
            (set Count <Board:init> to:(sites Track)) 
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from 
                            (sites Mover)
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then
                            (sow
                                apply:(if
                                    (and
                                        (or {
                                            (= 2 (count at:(to)))
                                            (= 4 (count at:(to)))
                                            (= 6 (count at:(to)))
                                            (= 8 (count at:(to)))
                                        })
                                        (is In (to) ("PlayableSites"))
                                    )
                                    (fromTo
                                        (from (to))
                                        (to (handSite Mover))
                                        count:(count at:(to))
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("NoPieceOnBoard")
                            (forget Value "Playable" All)
                            (forEach Site (difference (sites Board) ("PlayableSites"))
                                (if (<= <Board:init> (count at:(site)))
                                    (remember Value "Playable" (site))
                                )
                            )
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                    (if (<= <Board:init> (count Cell at:(handSite Mover)))
                        (move
                            (from (handSite Mover))
                            (to (sites Mover) if:(is Empty (to)))
                            count:<Board:init>
                            (then (remember Value "Playable" (last To)))
                        )
                        (move
                            (from (handSite Mover))
                            (to (sites Mover) if:(is Empty (to)))
                            count:(count Cell at:(handSite Mover))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Hewakam Keliya" 
    (players 2) 
    (equipment {
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (piece "Marker" Each 
            (or 
                ("HopSequenceCapture") 
                ("StepToEmpty") 
            )
        )
    }) 
    
    (rules 
        (start { 
            (place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3)}))
            (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8)}))
        })
        
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("NoMoves" Loss)) 
    )
)
Hewakam Keliya is a game from South Asia that is similar to other games with leaping captures found in the region.Played on an Alquerque board with triangular appendages at the top and bottom. Sixteen pieces per player. Each player moves one spot along the lines on the board. Captures are made by hopping over an opponent's piece. Multiple hops are allowed per turn if possible. Captures are not compulsory. The player who captures all of the opponent's pieces wins. 

Construct a Ludii game based on the following description
Owela is a four-row mancala-style board game popular among the Umbundu speaking people of southwest Africa. It is played by men and boys, and can be played by tow players or on teams. The game is played in hollows made in the ground, and even-numbers of holes are generally preferred.4x12-20 board. Play begins with a number of counters that is three times the number of holes in a row minus two for a game with an even number of holes in a row; three times the number of holes minus one for odd. Counters are distributed beginning in the leftmost hole in the outer row, placing two counters in each hole in an anti-clockwise direction. Play begins from any of the player's holes, sowing anti-clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues, unless a capture can be made. Captures are made when the final counter falls into an occupied hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. These are then sown from the hole following the one from which the capture occurred. If the final counter falls into an empty hole, the turn is over. Single counters cannot be sown. Play ends when one player cannot move. Each player has 12 holes.
(game "Owela (Benguela)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Board:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))          
        (regions "Outer" P2 (sites Top))          
        (regions "InnerInit" P1 <Board:innerInitP1>)        
        (regions "InnerInit" P2 <Board:innerInitP2>)        
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 2 to:(union {(sites P1 "Outer") (sites P1 "InnerInit") (sites P2 "Outer") (sites P2 "InnerInit")})))
        
        (play 
            (move Select 
                (from 
                    (if ("SameTurn") 
                        (if "MoveAgainAfterCapture" "PlayFromNextHole" "LastHoleSowed") 
                        (sites Mover "Home") 
                    ) 
                    if:(> (count at:(from)) 1)
                )
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (> (count at:(to)) 1)
                            (if (and 
                                    (is In (to) (sites Mover "Inner")) 
                                    (> (count at:("OppositePit" (to))) 0) 
                                )
                                (and {
                                    (fromTo 
                                        (from (to)) 
                                        (to (handSite Mover)) 
                                        count:(count at:(to))
                                    ) 
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (handSite Mover)) 
                                        count:(count at:("OppositePit" (to)))
                                    ) 
                                    (if 
                                        (> (count at:("OppositeOuterPit" (to))) 0) 
                                        (fromTo 
                                            (from ("OppositeOuterPit" (to))) 
                                            (to (handSite Mover)) 
                                            count:(count at:("OppositeOuterPit" (to)))
                                        )
                                    )
                                    (if (> (count at:"NextHole") 1)
                                        (and
                                            (set Pending "NextHole") 
                                            (moveAgain)
                                        )
                                    )
                                })
                                (moveAgain)
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Uril is a two-row mancala-style board game played in Cabo Verde. It is a popular game on the islands, and also was played by immigrants to Portugal. Men typically play in public, while women generally played in private spaces. 2x6 board with a store on either end. Four counters in each hole. Players take turns sowing in an anti-clockwise direction from one of the holes in their row. Counters are captured when the final counter of a sowing is dropped into a hole in the opponent's row containing one or two counters, making it contain two or three counters. If the previous hole also contains two or three counters, they are also captured, in an unbroken line until a hole with a different number of counters is reached. If, while sowing, the hole from which the sowing originated is reached, this hole is skipped and sowing continues. If a player has no counters in their holes, the opponent must play so as to place counters in their row. The player who captures 25 coutners first wins. 
(game "Uril"
    (players 2)
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))		 
        (play 
            (do 
                (move Select 
                    (from 
                        (sites Mover) 
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (sow 
                            if:(and 
                                (is In (to) (sites Next)) 
                                (or 
                                    (= (count at:(to)) 2) 
                                    (= (count at:(to)) 3)
                                )
                            ) 
                            apply:(fromTo 
                                (from (to)) 
                                (to (mapEntry (mover))) 
                                count:(count at:(to))
                            )
                            includeSelf:False
                            backtracking:True
                        )
                    )
                )
                ifAfterwards:(< 0 (count in:(sites Next)))
            )
        )
        (end
            (forEach Player
                if:(>= (count at:(mapEntry Player)) 25)
                (result Player Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Frisian Draughts is a game from the Draughts/Checkers family that was particularly popular in Friesland, in the Netherlands.10x10 board. Twenty pieces per player, arrayed on the dark-colored spaces. The square in the left-hand corner closest to the player is a dark square. Pieces move one space forward diagonally. When a piece arrives at the furthest rank opposite their starting position, it becomes a king. Kings may move diagonally, forward or backward, any number of spaces (like a bishop in Chess). Captures are made by hopping over an adjacent piece in a diagonal or orthogonal direction, including backwards. Multiple captures are allowed, in which the player may change direction. Kings capture by flying leap. Captures are mandatory, and the maximum capture should be made based on the value of pieces. Kings are worth less than twice the number of regular pieces, but more than twice the number of pieces minus one. (e.g., three kings are worth less than six pieces, but more than five pieces). If more than one maximum capture has the same value, the one that captures more kings takes precedence. It is permitted to use the same space more than once, but not to hop over the same piece twice. Captured pieces are removed after the turn is complete. The maximum capture can be enforced when the opponent catches it, though the opponent may opt not to point it out. A king cannot make three non-capturing moves in a row without moving another king or piece. This rule does not apply if the player only has one king remaining. If one player has only two kings remaining and the opponent has only one king remaining, the player with two kings must win in seven turns. If they do not, the game is a draw. If both players have only one king remaining and neither of them is able to capture or will be forced into a position where their king will be captured on the next turn, the game is a draw. The player who captures all of their opponent's pieces wins, or if they cannot make a legal move. Standard Frisian draughts
(game "Frisian Draughts" 
    (players 2) 
    (equipment { 
        (board (square <Tag:boardSize>)) 
        (piece "Counter" P1 N)
        (piece "Counter" P2 S) 
        (piece "DoubleCounter" Each maxState:128)
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    
    (rules 
        (start { 
            (place "Counter1" (difference (expand (sites Bottom) steps: (- <Tag:pieceNumber> 1)) (sites Phase 1)) value:10)
            (place "Counter2" (difference (expand (sites Top) steps: (- <Tag:pieceNumber> 1)) (sites Phase 1)) value:10)
        })
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves withValue:True
                        ("HopCounter" (last To)
                            (then 
                                (and
                                    ("ReplayIfCanMove" ("HopCounter" (last To)) 
                                        ("PromoteIfReach" (sites Next) "DoubleCounter" (then (set Value at:(last To) 19)))
                                    ) 
                                    (forEach Site (sites Occupied by:Mover)
                                        (if (!= 0 (state at:(site)))
                                            (set State at:(site) 0)
                                        )
                                    )
                                )
                            ) 
                        )
                    )
                    (max Moves withValue:True
                        ("HopFrisianSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn) 
                    )
                )
                (priority {
                    (max Moves withValue:True
                        (or { 
                            (forEach Piece "DoubleCounter" ("HopFrisianSequenceCapture" before:(count Rows) after:(count Rows) at:EndOfTurn))					
                            (forEach Piece "Counter"
                                ("HopCounter" (from) 
                                    (then 
                                        (and
                                            ("ReplayIfCanMove" ("HopCounter" (last To))
                                                ("PromoteIfReach" (sites Next) "DoubleCounter" (then (set Value at:(last To) 19)))
                                            )
                                            (forEach Site (sites Occupied by:Mover)
                                                (if (!= 0 (state at:(site)))
                                                    (set State at:(site) 0)
                                                )
                                            )
                                        )
                                    ) 
                                ) 
                            )
                        })
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("CounterSimpleMove")
                            (then 
                                (and	
                                    ("PromoteIfReach" (sites Next) "DoubleCounter" (then (set Value at:(last To) 19)))
                                    (forEach Site (sites Occupied by:Mover)
                                        (if (!= 0 (state at:(site)))
                                            (set State at:(site) 0)
                                        )
                                    )
                                )
                            )
                        )
                        (forEach Piece "DoubleCounter" 
                            (if (if (> 2 (state at:(from))) 
                                    True
                                    (not (can Move (forEach Piece "Counter" ("CounterSimpleMove"))))
                                )
                                (move Slide Diagonal)
                            )
                            (then
                                (if ("IsNotOffBoard" (where "Counter" Mover))
                                    (and
                                        (set State at:(last To) (+ 1 (state at:(last To))))
                                        (forEach Site (sites Occupied by:Mover)
                                            (if (and (!= (site) (last To)) (!= 0 (state at:(site))))
                                                (set State at:(site) 0)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                })
                (then
                    (and
                        (if (and ("TwoKingsMoverOneKingEnemy") (= Undefined (value Player Mover)))
                            (set Value Mover 0)
                        )
                        (if (and ("NewTurn") (!= Undefined (value Player Mover)))
                            (set Value Mover (+ 1 (value Player Mover)))
                        )
                    )
                )
            )
        )
        
        (end {
            ("BlockWin")
            (if (= 7 (value Player Mover)) (result Mover Draw))
        })
        
    )
)

Construct a Ludii game based on the following description
Sim is a pencil-and-paper game played by two players.Six dots ('vertices') are drawn. Each dot is connected to every other dot by a line ('edge'). Two players take turns colouring any uncoloured lines. One player colours in one colour, and the other colours in another colour, with each player trying to avoid the creation of a triangle made solely of their colour (only triangles with the dots as corners count; intersections of lines are not relevant); the player who completes such a triangle loses immediately. 
(game "Sim" 
    (players 2)
    (equipment { 
        (board 
            (complete (regular Star 6))
            use:Edge
        )   
    }) 
    (rules 
        (play 
            (move Add
                (to
                    Edge 
                    (sites Empty Edge)
                )
            )
        ) 
        (end 
            (if 
                (is Path Edge Mover length:(exact 3) closed:True) 
                (result Mover Loss)
            )
        ) 
    )
)

Construct a Ludii game based on the following description
La'b Akila is a two-row mancala game played in Syria during the nineteenth century.2x7 board. Seven counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter falls into an occupied hole, the contents of that hole are picked up and sowing continues. If the final counter falls into a hole containing one or three counters, the player captures those counters, plus any counters in the hole in the opposite row, as well as the contents of any holes in an unbroken sequence following the one in which the final counter which also contain two or four counters.When the final counter falls into an empty hole, the turn ends. Play continues until all of the pieces are captured. The player who captured the most counters wins. 
(game "La'b Akila" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "TrackCCW" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start (set Count 7 to:(sites Track)))
        
        (play 
            (move Select
                (from
                    (sites Mover)
                    if:(is Occupied (from))
                )
                (then
                    (sow
                        if:True
                        apply:(if
                            (or 
                                (= 2 (count at:(to)))
                                (= 4 (count at:(to)))
                            )
                            (and
                                (fromTo
                                    (from (to))
                                    (to (handSite Mover))
                                    count:(count at:(to))
                                )
                                (if (!= 0 (count at:("OppositePitTwoRows" (to))))
                                    (fromTo
                                        (from ("OppositePitTwoRows" (to)))
                                        (to (handSite Mover))
                                        count:(count at:("OppositePitTwoRows" (to)))
                                    )
                                )
                            )
                        )
                        backtracking:(or 
                            (= 2 (count at:(to)))
                            (= 4 (count at:(to)))
                        )
                    )
                )
            )	
        )
        
        (end ("MancalaByScoreWhen" ("NoPieceOnBoard")))
    )
)

Describe the mechanics of the following Ludii game
(game "Cittabhramanrpasya Khelanam"
    (players {(player S) (player N)}) 
    (equipment { 
        (board (square 8))
        
        (piece "Pawn" P1 
            (or 
                "StepForwardToEmpty" 
                ("StepToEnemy" (directions {FR FL}))
                (then
                    (if (is In (last To) (sites Mover "Promotion")) 
                        (and
                            (promote (last To) (piece "Ferz_noCross") Mover)	
                            (fromTo (from (last To)) (to (last From)))
                        )
                    )
                )
            )
        )
        (piece "Rook" P1 ("SlideCapture" ~ Orthogonal))
        (piece "King_noCross" P1 ("StepToNotFriend"))
        (piece "Elephant" P1 ("SlideCapture" ~ Diagonal))
        (piece "Knight" P1 ("LeapCapture"  "KnightWalk"))
        (piece "Ferz_noCross" P1  ("SlideCapture"))
        (piece "King_noCross" P2 
            (or
                (move Leap 
                    "KnightWalk" 
                    (to 
                        if:(and (not ("IsFriendAt" (to))) (not (is In (to) (sites Around (where "King-noCross" Next)))))
                        (apply (remove (to))) 
                    ) 
                )
                
                (move Slide 
                    (to 
                        if:("IsEnemyAt" (to)) 
                        (apply 
                            if:(not (is In (to) (sites Around (where "King-noCross" Next))))
                            (remove (to))
                        )
                    ) 
                )
            )
        )
        (regions "Promotion" P1 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 6))
            (place "Rook1" {"A8" "H8"}) (place "Knight1" {"B8" "G8"}) (place "Elephant1" {"C8" "F8"}) (place "Ferz_noCross1" coord:"E8") (place "King_noCross1" coord:"D8") 
            (place "King_noCross2" coord:"E1")
        })
        
        (play (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))))
        
        (end ("Checkmate" "King_noCross"))
    )
)
Cittabhramanrpasya Khelanam is a game dervied from Chaturanga played in India during the nineteenth century. In it, one player plays as a single King, which can move like any of the other pieces, against the opponent who plays with their usual complement of pieces. It is described in the Kriddakausalya of Harikrishna.8x8 board. One player plays with the following pieces: Raja (x1): moves one space in any direction; Mantri (x1): moves any distance orthogonally or diagonally; Ushtra (x2): moves diagonally any distance; Vaha (x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (x2): moves orthogonally any distance. Padati (x8): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. The opponent plays as one Raja, which can move as any of the other pieces. This Raja cannot move to a space adjacent to the opponent's Raja. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. Check and checkmate rules apply to the player with a single Raja. 

Describe the mechanics of the following Ludii game
(game "Manalath" 
    (players 2) 
    (equipment { 
        (board (rotate 90 (hex 5))) 
        (piece "Marker" Each)
        (hand Shared size:2)
    }) 
    (rules 
        (start {
            (place "Marker1" (handSite Shared)) 
            (place "Marker2" (handSite Shared 1))
        })
        (play 
            (do
                (move 
                    (from (sites Hand Shared)) 
                    (to (sites Empty)) 
                    copy:True
                )
                ifAfterwards:(< (size Group at:(last To)) 6)
                (then
                    (forEach Site (sites Occupied by:Mover container:"Board")
                        (if (= (size Group at:(site)) 5)
                            (set Var "Group5" 1)
                            (if (= (size Group at:(site)) 4)
                                (set Var "Group4" 1)
                            )
                        )
                    )
                )
            )
        )
        (end {
            (if (= (var "Group4") 1) (result Mover Loss)) 
            (if (= (var "Group5") 1) (result Mover Win)) 
        }) 
    )
)
Manalath was invented in 2012 by Dieter Stein and Néstor Romeral Andrés. It is a Yavalath-like game in which the players must create a group of five without first making a group of four.Players take turns placing pieces of any colour. They can't  create groups of more than five pieces which are adjacent to each other. 
            
            A group of 4 pieces is called a quart. A group of 5 pieces is called a quint.
            
            Players win if they finish their turn with a friendly quint, but lose if they finish their turn with a friendly quart on the board.
            
            Note: The winning and losing conditions for a player are checked after their move, only on their own turn.
            
        An end condition (win or loss) is effective when it occurred first and cannot be averted. 

Construct a Ludii game based on the following description
Twelve Men's Morris is a game of alignment known since at least the seventh century. It is played on a Nine Men's Morris board with corners of the concentric squares connected with diagonals.Each player uses twelve pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. They cannot remove an opponent's piece that is in a three in a row formation unless there are no other options. Once all pieces are place, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. Once a player is reduced to three pieces, that player may move to any open space on the board. The game is won when the opponent is reduced to two pieces. The board has no diagonal.
(game "Twelve Men's Morris"
    (players 2)
    
    (equipment { 
        (board <Board> use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3" Orthogonal exact:True)))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True)) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveEnemyPiece"
                    (if (> (count Pieces Mover) 3)
                        (forEach Piece)
                        (move 
                            (from (sites Occupied by:Mover))
                            (to (sites Empty))
                        )
                    )
                )
            )
        )
        }
        
        (end ("HavingLessPiecesLoss" Next 2))
    )
)

Construct a Ludii game based on the following description
T'oki is a capturing game played by the Fula and Tukulor people of Mali. It combines the typical placement and movement phases into a single phase, with captures made by hopping over opponent's pieces. Typically played by men, it is a complex  game unique among games with this type of capture because multiple pieces may occupy one spot. It was primarily a game played by chiefs.5x5 board. Twenty pieces per player. Players alternate turns placing pieces on the board, two at a time into the same square. At any time, a player may move one piece from a square one spot in an orthogonal direction. Pieces may capture opponent's pieces when either a single square or an unbroken line of squares with opponent's pieces has an empty space beyond it; the player's piece hops over the opponent's pieces and captures them all. When the unbroken line ends at the edge of the board, it is treated as though there were an empty square beyond the edge of the board, and the capturing piece is placed on the last space on the board in that line. Players may enter any reserved pieces on any turn as they see fit. The player to capture all of the opponent's pieces wins. 
(game "T'oki"
    (players 2)
    (equipment {
        (board (square 5)) 
        (piece "Marker" Each
            (or
                ("StepOrthogonalToEmpty")
                (move Hop 
                    Orthogonal
                    (between 
                        (range 1 (count Rows))
                        if:("IsEnemyAt" (between)) 
                        (apply (remove (between)))
                    )
                    (to 
                        if:(or 
                            (and 
                                (is In (to) (sites Outer)) 
                                ("IsEnemyAt" (to))
                            ) 
                            (is Empty (to))
                        )
                    )
                )
            )
        )
        (hand Each)
    })
    (rules 
        (start (place "Marker" "Hand" count:20))
        (play
            (or
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                    count:2
                ) 
                (forEach Piece)
            )
        )
        (end (if (and ("HandEmpty" Next) (no Pieces Next)) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Also known as Weiqi in China, Go is one of the most popular board games, and one of the oldest continuously played games in the world. From an early date, it spread from China to Japan and Korea, and more recently it has become a popular game worldwide. It is a game of configuration, where the goal is to gain points by controlling territory on the board. Played on a 19x19 board. The board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players total the number of intersections their pieces occupy or surround. The player with the highest total wins.  The game is played on a 9x9 board
(game "Go" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each)
    })
    
    (rules 
        (meta (no Repeat))
        (play 
            (or
                (do
                    (move Add
                        (to (sites Empty))
                        (then "CaptureSurroundedPiece")
                    )
                    ifAfterwards:("HasFreedom" Orthogonal)
                )
                (move Pass)
            )
        )
        
        (end
            (if (all Passed)
                (byScore {
                    (score P1 (+ (score P1) (size Territory P1))) 
                    (score P2 (+ (score P2) (size Territory P2)))
                })
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Ilpion" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board <Board:type> use:Vertex)
        (piece "Disc" Each) 
        (piece "Marker" Shared)   
    }) 
    (rules
        (start
            <Play:start>
        )
        
        (play   
            <Play:move>
        )
        (end
            (if (no Moves Mover)	
                (byScore)
            )
        )
    )
)
Ilpion is a graph theory game that uses a centroid decomposition method. It is played on an undirected and unweighted tree. The board graph is initially coloured with a common colour.Players take turns adding his friendly colour in an uncoloured vertex. The aim of each player is to colour the centre vertex of the coloured tree. It is a scoring based game, and it has two versions. At the centroid version, each player gets one point for correctly coloured a tree centre. In the second version is the degree version, where a player gets a score, which is equal to the degree of his last coloured tree centre. For both versions, all the incident edges of last move are uncoloured. So the tree is divided into subtrees. The game ends when there is no coloured tree available. The player with the highest score wins.  The scoring is based on centroid. The version of the game played with 2 players.

Describe the mechanics of the following Ludii game
(game "Luuth" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "6,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        phases:{
        (phase "Opening"
            (play 
                (move 
                    (from (sites Mover))
                    (to 
                        (if (is In (from) (sites Centre))
                            (difference (sites Board) (from))
                            (difference (sites Board) (sites {(from) ("OppositePit" (from))}))
                        )
                    )
                    count:(count at:(from))
                )
            )
            (nextPhase Mover "Sowing")
        )
        
        (phase "Sowing"
            (play
                (or
                    (move Select
                        (from
                            (sites Mover)
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                numPerHole:4
                                "TrackCCW"
                                apply:(if (and (is In (to) (sites Mover)) (= 4 (count at:(to))))
                                    (and
                                        (moveAgain)
                                        (if (is Occupied ("OppositePit" (to)))
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (move Select
                        (from
                            (sites Mover)
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                numPerHole:4
                                "TrackCW"
                                apply:(if (and (is In (to) (sites Mover)) (= 4 (count at:(to))))
                                    (and
                                        (moveAgain)
                                        (if (is Occupied ("OppositePit" (to)))
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end ("MancalaByScoreWhen" ("NoPieceOnBoard")))
    )
)
Luuth is a game played by the Nuer people of Ethiopia. It is similar to a mancala game, but the movement rules only sometimes involve sowing.2x7 board. Four counters per hole. The first player takes all of the counters from one of their holes. If they take from the central hole, they can be placed in any other hole on the board. If they are from any other hole, they can be placed in any hole except the opposite hole on the opponent's side. Once both players have made this initial move, the main phase of the game begins. Players alternate turns taking counters from one of the holes on their side of the board and sowing them. Groups of four counters are always sown. Play can occur in a clockwise or anti-clockwise direction. Players sow four counters at a time; that is, placing four counters in each hole. When the final four counters land in an empty hole in the player's row, any counters in the opponent's opposite hole are captured, and the player may sow again from another hole. Play continues until all of the counters have been captured, and the player with the most counters wins. 

Construct a Ludii game based on the following description
Sudoku X is a variant of Sudoku included the diagonals of the square board in the constraints.The rules are the same of Sudoku except the diagonals of the square board also have to contain only different numbers. 
(game "Sudoku X" 
    (players 1) 
    (equipment { 
        (board (square 9) (values Cell (range 1 9))) 
        (regions {Columns Rows SubGrids})
        (regions (sites Direction from:(intersection (sites Left) (sites Bottom)) NE included:True))
        (regions (sites Direction from:(intersection (sites Right) (sites Bottom)) NW included:True))
    }) 
    (rules
        (start <Challenge>)
        (play (satisfy (all Different)))
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
Pasa is a dice game that was played in the Andes since at least the eighteenth century. It involves a special seven-sided die, and includes rolls where players may lose points. The highest roll is called \The board is a double-headed eagle, with two lines of ten holes. One seven-sided die. One side has a special mark, one is blank, and the others are numbered 1-5. The special mark scores 10, the blank side scores -10. Players roll the die, and add up their scores as they go, placing a peg in a hole to mark ten points. The player who reaches 100 points first wins. 
(game "Pasa" 
    (players 2)
    (equipment {
        (board (rectangle 10 2))
        (piece "Disc" Each)
        (dice d:7 from:0 num:1)
        (map {(pair 0 -10) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 5) (pair 6 6) (pair 7 10)})
    })
    (rules
        (play 
            (do 
                (roll (then (addScore Mover (mapEntry (count Pips))))) 
                next:(move Pass
                    (then 
                        (and
                            (remove (sites Column "Column"))
                            (if (>= (score Mover) 10) 
                                (add 
                                    (piece (id "Disc" Mover)) 
                                    (to (intersection (sites Column "Column") (sites Row "Row")))
                                )
                            )
                        )
                    )
                )
            )
        )
        (end (if (>= (score Mover) 100) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Jacquet de Versailles is a European Tables game played in France in the nineteenth century.2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Pieces begin on the leftmost point on their opponent's side of the board. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When doubles are thrown, the player may move the value of one of the die (n), n times (e.g., double sixes allows a player to move 6 six times, double twos allow a player to move 2 twice). Each player progresses in a clockwise direction around the board, to bear off upon reaching the final point on the opposite side of the board from which the player started. This first piece must reach the opposite quadrant of the board from where it started before the player may enter any other pieces. In the quadrant where the players enter their pieces, that player may only have two or more pieces on a point on a maximum of two points. When a piece lands on a point occupied by a single opponent's piece, The opponent's piece is removed from the board and must enter the board again. When all of the player's pieces have entered the opposite quadrant from the one in which they entered, they may begin to bear off. The first player to bear off all their pieces wins. It is considered a double win if the player bears off all their pieces before the opponent bears off any.  
(game "Jacquet de Versailles" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" "BackgammonTracksSameDirectionOppositeCornersWithBars") 
        (dice num:2)
        (piece "Disc" Each) 
        (map {(pair 1 6) (pair 2 19)}) 
        (regions "Home" P1 { 13..18 }) 
        (regions "Home" P2 { 12..7 }) 
        (regions "OppositeQuadrant" P1 { 0..5 }) 
        (regions "OppositeQuadrant" P2 { 20..25 }) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 13 count:15)
            (place Stack "Disc2" 12 count:15)
        })
        
        (play 
            (do
                ("RollEachNewTurnMove"
                    (if (all DiceEqual)
                        (forEach Site
                            (sites Occupied by:Mover)
                            (if (and ("CanEscape" ("NextSiteFromDistDoubleDice" (site))) ("AllPieceInOpponentSide"))
                                ("RemoveAPiece")
                                (if (or 
                                        (!= (site) "StartPos")
                                        (and 
                                            (= (site) "StartPos")
                                            ("PieceInOpponentQuadrantOrNoPieceInTheBoard")
                                        )
                                    )
                                    (move 
                                        (from (site))
                                        (to ("NextSiteFromDistDoubleDice" (site))
                                            if:("NoEnemyOrOnlyOne" (to))
                                            ("HittingCapture" ("Bar" (next))) 
                                        )
                                    )
                                )
                            )
                            (then ("UpdateCounterDoublePlay"))
                        )
                        (forEach Die
                            if:("DieNotUsed")
                            (forEach Site
                                (sites Occupied by:Mover)
                                (if (and ("CanEscape" ("NextSiteFrom" (site))) ("AllPieceInOpponentSide"))
                                    ("RemoveAPiece")
                                    (if (or 
                                            (!= (site) "StartPos")
                                            (and 
                                                (= (site) "StartPos")
                                                ("PieceInOpponentQuadrantOrNoPieceInTheBoard")
                                            )
                                        )
                                        (move 
                                            (from (site))
                                            (to ("NextSiteFrom" (site))
                                                if:("NoEnemyOrOnlyOne" (to))
                                                ("HittingCapture" ("Bar" (next))) 
                                            )
                                        )
                                    )
                                )
                            )
                            (then ("ReplayNotAllDiceUsed"))
                        )
                    )
                )
                ifAfterwards:(<= ("NumSitesInFirstQuadrantWithMoreThan2Pieces") 2)
            )
        )
        
        (end {
            (if ("AllPieceEscaped")
                (byScore { 
                    ("SetScoreOf" P1 P2)
                    ("SetScoreOf" P2 P1)
                })
            )
        })
    )
)

Construct a Ludii game based on the following description
Adugo has been reported among several indigenous groups in Brazil, including the Bororo, Pareci, Guaraní, and the Manchakeri. The game is played on a board which is usually scratched into the earth, with stones or other small objects used as pieces.5x5 intersecting lines, forming a grid Diagonals in each quadrant. A triangular appendage, the apex being the midpoint of one of the sides of the grid. A line from the apex to the midpoint of the base, and a line bisecting this line and intersecting with the midpoints of the two sides of the triangle. There are fourteen \ The objective of the player 1 is to capture all the dogs.
(game "Adugo" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithBottomTriangle") 
        (piece "Jaguar" P1 (or "HopCapture" "StepToEmpty"))
        (piece "Dog" P2 "StepToEmpty") 
    }) 
    (rules 
        (start { 
            (place "Dog2" (difference (expand (sites Top) steps:2) (sites {"C5"})))
            (place "Jaguar1" coord:"C5")
        })
        
        (play (forEach Piece)) 
        
        (end ("NoMovesLossAndLessNumPiecesPlayerLoss" P2 <Num:dogs>))
    )
)

Describe the mechanics of the following Ludii game
(game "Qatranj"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 10)) 
        ("ChessRook" "Rook") 
        ("ChessKnight" "Knight") 
        ("ChessBishop" "Bishop_noCross") 
        ("ChessQueen" "Queen")
        
        (piece "Commoner" Each
            (or
                ("SlideCapture")
                ("LeapCapture" "KnightWalk")	
            )
        )
        ("ChessKing" "King_noCross") 
        (piece "Mann" Each 
            (or
                ("SlideCapture")
                ("LeapCapture" "KnightWalk")	
            )		
        )
        
        (piece "Wazir" Each
            (do
                ("StepToNotFriend") 
                ifAfterwards:(> (count Steps
                        (last From)
                        (where "King_noCross" Next)
                    )
                    (count Steps
                        (last To)
                        (where "King_noCross" Next)
                    )
                )
            )
        )
        
        
        (piece "Pawn" Each
            (or 
                "StepForwardToEmpty" 
                ("StepToEnemy" (directions {FR FL}))
            )		
        )
    })
    (rules 
        (start {
            (place "Rook1" (sites {"A1" "J1"})) (place "Rook2" (sites {"A10" "J10"}))
            (place "Knight1" (sites {"B1" "I1" "E3" "F3"})) (place "Knight2" (sites {"B10" "I10" "E8" "F8"}))
            (place "Bishop_noCross1" (sites {"C1" "H1"})) (place "Bishop_noCross2" (sites {"C10" "H10"}))
            (place "Queen1" coord:"D1") (place "Queen2" coord:"G10")
            (place "Commoner1" coord:"E1") (place "Commoner2" coord:"F10")
            (place "King_noCross1" coord:"F1") (place "King_noCross2" coord:"E10")
            (place "Mann1" coord:"G1") (place "Mann2" coord:"D10")
            (place "Wazir1" (sites {"E2" "F2"})) (place "Wazir2" (sites {"E9" "F9"}))
            (place "Pawn1" (difference (sites Row 1) (sites {"E2" "F2"})))
            (place "Pawn2" (difference (sites Row 8) (sites {"E9" "F9"})))
        })
        (play (do (forEach Piece) 
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        (end ("Checkmate" "King_noCross"))
    )
)
Qatranj is a game with replacement captures played on a 10x10 board with 22 pieces. It was played in nineteenth century India.10x10 board. 22 pieces per player. Pieces begin on the board in the following  arrangement, and with the following movements: Outer row, from  left corner: Rukh: moves orthogonally any distance; Ghora: moves orthogonally one space and then diagonally another  space, jumping over the first space;  Fil: moves diagonally any distance; Wazir: moves diagonally or orthogonally any distance; Shahzada: can move like the Wazir and like the Ghora; Padshah: moves one space in any direction; Kotwal: moves like the Shahzada; Fil, Ghora, Rukh. In the next row, the central two squares are occupied by the Urdabegini: move one space in the direction of the opponent's Padshah; the other spaces are occupied by Paidal: moves one square forward orthogonally or one diagonally to capture. The central two squares of the third row contain two more Ghora. Players alternate turns moving a piece to a space on the board. If one of the opponent's pieces is on the space to which a player moves their piece, the opponent's piece is captured. If  the Padshah can be captured on the opponent's next turn, it is in check. The Padshah cannot remain in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins.   

Construct a Ludii game based on the following description
Bul is a game played in the Maya area by men, and which plays an important role in the Vigil of the Maize ceremony. It is a race game that involves capturing and stacking.Six or more players (even number), played on two teams. The games Aj Sayil, Aj T'iwil, Aj Sina'anil, Aj Sakakil, and A K'aak'il are played in succession. The game has 6 players.
(games {
        (subgame "Aj Sayil"  <Player:option> next:1)
        (subgame "Aj T'iwil" <Player:option> next:2)
        (subgame "Aj Sina'anil" <Player:option> next:3)
        (subgame "Aj Sakakil" <Player:option> next:4)
        (subgame "A K'aak'il" <Player:option>  )
    })

Describe the mechanics of the following Ludii game
(game "Ploy" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board (square 9) use:Vertex) 
        <Version:rulesCommander>
        
        (piece "Commander" Each ("StepOrChangeDirection" (directions {FR FL BL BR} of:All)))
        (piece "Shield" Each ("StepOrChangeDirection" (directions Forward of:All) (then (moveAgain))))
        (piece "LanceW" Each ("SlideOrChangeDirection" (directions Forwards of:All) (max 3))) 
        (piece "LanceY" Each ("SlideOrChangeDirection" (directions {FR FL Backward} of:All) (max 3))) 
        (piece "LanceT" Each ("SlideOrChangeDirection" (directions {Forward Rightward Leftward} of:All) (max 3))) 
        (piece "ProbeI" Each ("SlideOrChangeDirection" (directions {Forward Backward} of:All) (max 2)))
        (piece "ProbeMinV" Each ("SlideOrChangeDirection" (directions {Forward FR} of:All) (max 2)))
        (piece "ProbeBigV" Each ("SlideOrChangeDirection" (directions {FR FL} of:All) (max 2)))
    }) 
    (rules 
        (start { 
            <Version:start>
        })
        (play
            (if "SameTurn"
                (or 
                    (move Set Rotation (to (last To))) 
                    (move Pass)
                )
                (forEach Piece <Version:consequence>)
            )
        )
        <Version:endRules>
    )
)
Ploy was invented by Frank Thibault in 1970. It can be played by two or four players and the goal is to capture the opponent's Commander.The goal is to capture the enemy Commander, or reduce the opponent army to a single Commander. Each piece has an indicator which determines at which directions the piece can move. This can be altered by rotating the piece 45 degrees= to the left or right. Rotating the piece costs a move. Each player has 3 Shields, 5 Probes, 6 Lances, and one Commander. The Shield moves one step and has only one movement freedom at any time. The Probe slides two steps and has two freedoms. The Lance slides three steps and has three freedoms. The Commander has four, but can only move one step. A player must either make a direction move or a motion move. The three Shields are the only pieces that can perform a direction move immediately after a motion move. Capture occurs by displacement. The two players version of Ploy.

Describe the mechanics of the following Ludii game
(game "Sig (El Oued)"
    (players <Player:num>) 
    (equipment {
        (board
            (scale 2 1 
                (merge {
                    (square 5)
                    (shift 4 5 (rectangle 3 1))
                    (scale 2 1 (shift 1.5 8 (rectangle 3 1)))
                })
            )
            {
            (track "FirstTrack" "0,E,N1,W,N1,E1" directed:True)
            (track "SecondTrack" "13,E,N1,W,N1,E" directed:True)
            }
        )
        (dice d:2 from:0 num:6)
        (piece "Father" Each ("Move" (if (= 1 (var "SpecialSig")) (+ 1 ("ThrowValue")) ("ThrowValue"))))
        (piece "Djinn" Each 
            (if (= ("Mecca") (where "Father" Mover))
                ("Move" (* 2 (if (= 1 (var "SpecialSig")) (+ 1 ("ThrowValue")) ("ThrowValue"))) ("GoToStep1Djinn"))
            )
        )
        (piece "Mother" Each 
            (if (= ("Mecca") (where "Djinn" Mover))
                ("Move" (if (= 1 (var "SpecialSig")) (+ 1 ("ThrowValue")) ("ThrowValue")))
            )
        )
        (map "Throw" {(pair 0 12) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 1) (pair 6 6)})
        (map "ExtraThrow" {(pair 0 3) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 1)})
    })
    (rules
        <Player:start>
        (play 
            ("RollMove"
                (if (can Move (forEach Piece)) (forEach Piece) (move Pass))
                (then
                    (if (!= 0 ("ExtraThrowValue"))
                        (and
                            (if (= 3 ("ExtraThrowValue"))
                                (if (<= (var) 0)
                                    (set Var 2)
                                )
                            )
                            (if (!= (mover) (prev))
                                (and 
                                    (moveAgain)
                                    (if (!= 1 ("ThrowValue")) (set Var "SpecialSig" 1))
                                )
                            )
                        )
                        (if (> (var) 0)
                            (and {
                                (set Var (- (var) 1))
                                (moveAgain)
                            })
                            (set Var "SpecialSig" 0)
                        )
                    )
                )
            )
        )
        (end (if ("AllPiecesInMecca") (result Mover Win)))
    )
)
Sig is a name use for many different games in Saharan Africa. This version is played in El Oued, Algeria, and is a representation of the Hajj taken by a father, a mother, and a djinn.5x5 grid, with six spaces extending up from the rightmost column. The central space of the grid is the minaret, the final three spaces in the extending track are Cairo, Medina, and Mecca. Three pieces per player, each having one father, one mother, and one djinn, which all begin on the first space. The track is boustrophedon, starting in the bottom left corner and moving to the right, until it reaches the top right corner where it proceeds down the extended track. Six sticks, used as dice, with one polished side and one rough side. Throws equal the number of polished sides which land face-up, with the following exceptions: five polished or five rough sides = sig, this grants a move of one plus another throw, in which the player moves the number of polished sides up, six polished = sig of 6, grants the player another throw, and the player moves the number of polished sides up; if the second throw is regular sig, the value is 7, six rough = sig of twelve, grants the player three throws and the player moves the number of polished sides up; if any of those three extra throws are a regular sig, the total value of the extra throws is 13. Pieces move one at a time from the starting space. The first piece to move is the father, the second the djinn, and the third is the mother. The djinn moves twice the value of the throw in any space that does not require a sig to move through it. A player must throw a regular sig to leave the starting space; when they do, they move one space and throw again. When a player passes the piece of an opponent, the opponent's piece returns to the starting space and must enter the board according to the same rules. Certain spaces require a throw of sig to move into and out of them. This means that the move of 1 given by the regular sig can be used to do this, but the extra throw granted by it does not; however, the total value awarded by a sig of six or twelve does count. These are the Minaret, and all of the spaces in the extended track. If a player cannot enter a space because their is not a sig attached to their throw, they stop their move at the point before it. The space for Cairo counts for three of the value of the throw. When a piece reaches Mecca and there is still value left in the throw, the next piece may be entered and moved using the remaining moves left in the throw. The djinn is entered when the father reaches Mecca, and the mother is entered once the djinn reaches Mecca. The first player to place all of their pieces on Mecca wins. The game has 2 players.

Describe the mechanics of the following Ludii game
(game "Ouk Chatrang"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (hand Each size:5)
        (piece "King_noCross" Each 
            (or
                ("StepToNotFriend")
                (if (= 1 (state at:(from)))
                    ("LeapToEmpty" "KnightWalk")
                )
                "RememberPieceHasMoved"
            )
        )
        ("ChessRook" "Boat")
        (piece "Ferz_noCross" Each
            (or
                ("StepToNotFriend" Diagonal)
                ("StepToNotFriend" Forward)
            )
        )
        ("ChessKnight" "Knight")
        ("ChessPawn" "Fish" ~ (then ("PromoteIfReach" (sites Mover "Promotion") "Queen")))
        (piece "Queen" Each
            (or
                ("StepToNotFriend" Diagonal)
                (if (= 1 (state at:(from)))
                    (move Hop 
                        Forward 
                        (between if:True) 
                        (to 
                            if:(not ("IsFriendAt" (to))) 
                            (apply (remove (to)))
                        )
                    )
                )
                "RememberPieceHasMoved"
            )		
        )
        (regions "Promotion" P1 (sites Row 5))
        (regions "Promotion" P2 (sites Row 2))
    })
    (rules 
        (start { 
            (place "Fish1" (sites Row 2))
            (place "Fish2" (sites Row 5))
            (place "Boat1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Ferz_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King_noCross1" coord:"E1" state:1) 
            (place "Boat2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Ferz_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King_noCross2" coord:"E8" state:1) 
        })
        (play (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))))
        (end {
            ("Checkmate" "King_noCross")
            ("DrawIfNoMoves" Mover)
        })
    )
)
Ouk Chatrang is a game of captures played in Cambodia. It is related, and very similar to, Makruk as played in Thailand. It is popular among Cambodian men. Chess-playing scenes from the Angkor period show figures playing a similar game, but it is unknown how old the rules as they are played today are.8x8 board, not checkered. Pieces, their number, and moves are as follows: Ang/Sdaach (\ 

Describe the mechanics of the following Ludii game
(game "Wolf and Sheep" 
    (players 2) 
    (equipment { 
        (board (square 8)) 
        (piece "Sheep" P1 N ("StepToEmpty" (directions {FR FL}))) 
        (piece "Wolf" P2 "StepDiagonalToEmpty")
    }) 
    (rules 
        (start { 
            (place "Wolf2" {"D8"})
            (place "Sheep1" {"A1" "C1" "E1" "G1"})
        })
        
        (play (forEach Piece))
        
        (end {
            (if (and (no Moves P2) (is Mover P2)) (result P1 Win))
            (if (is In (where "Wolf" P2) (sites Bottom)) (result P2 Win))
        }) 
    )
)
Wolf and Sheep is a hunt game, said to be originally derived from Scandinavian halatafl games. Played on an 8x8 checkerboard and only played on the dark squares.Four pieces are the sheep; they are placed on the dark squares along one side of the board. one piece is the wolf; it is placed on any dark square on the side opposite the sheep. The goal of the wolf is to reach one of the sheep's original spaces, the sheep's goal is to block the wolf from doing so. Sheep move diagonally forward one square, the wolf moves diagonally forward or backward one square. 

Construct a Ludii game based on the following description
Doblet is a race game from medieval Spain that is related to other European Tables games. It is documented in Alfonso X's Libro de los Juegos.2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Twelve pieces per player. Pieces begin on one half of a player's side of the board (the half to the left of one player, and to the right of the other player), two per space, stacked on top of one another. Three dice. To begin, a player must first unstack their pieces, by rolling the number of the space on which the stack is located, and thus removing the stack, but keeping the piece on the same space. Once complete, pieces move in a track the long way around the board toward the portion where the opponent begins. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. No more than two pieces can occupy a space at a time. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board. Players attempt to bear off their pieces by rolling the exact number of spaces left on the board, plus one. When unstacking the pieces in the beginning or when bearing off at the end, if the player cannot play their roll but the opponent is able, the opponent may use the roll. The first player to bear off all of their pieces wins.
         
(game "Doblet"
    (players 2)
    (equipment {
        ("TableBoard" ("TableTracksOpposite" End))
        (dice d:6 num:3)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsEndTrack" ("NextSiteOnTrack" (pips)))
                    "RemoveAPiece"
                    (move 
                        (from) 
                        (to 
                            ("NextSiteOnTrack" (pips)) 
                            if:"StackSizeLessThan2"
                            (apply (if ("IsEnemyAt" (to)) (remove (to))))
                        )
                    )
                )
            )
        )
        (map "StartTrack" {(pair P1 0) (pair P2 12)})
    })
    (rules 
        (start {
            (place Stack "Disc1" (sites {0..5}) count:2 state:1)
            (place Stack "Disc2" (sites {12..17}) count:2 state:1)
        })
        
        phases:{
        (phase "UnStacking" 
            (play 
                ("RollEachNewTurnMove"
                    (forEach Die 
                        if:("DieNotUsed")
                        (if ("PieceStacked" "SiteToSelect")
                            (move Select (from ("SiteToSelect"))
                                (then 
                                    (and {
                                        ("Unstack")
                                        ("ReplayNotAllDiceUsed")
                                    })
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not ("PieceStacked" (site)))) "BearingOff")
        )
        (phase "BearingOff"
            (play 
                ("RollEachNewTurnMove"
                    (forEach Piece top:True)
                    (then (if (and (not (was Pass)) (not (all DiceUsed))) (moveAgain)))
                )
            )
        )
        }
        
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Oware is two-row mancala-style game originating and very popular in West Africa. It is also widely played in the Caribbean. It is played on a board with two rows of six holes, sometimes with a larger hole on both ends.2x6 board, with a storage hole on either end. The game starts with four counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a counterclockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. Players capture counters when the final counter is sown in the opponent's row and the hole containing it has two or three counters (counting the counter just dropped into it). If the hole before it also has two or three counters, these are also captured and so on until reaching a hole without two or three counters or one not belonging to the opponent. A move which would capture all of the opponent's counters is not allowed. If an opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. Play continues until all of the counters are captured. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row.  The game ended when a player has no piece on his side or if the two players are agree on the end of the game in case a cycle.
(game "Oware" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))		 
        (play 
            (if (is Proposed "End")
                (or (move Vote "End") (move Vote "No"))
                (or
                    (if (is Cycle) (move Propose "End")) 
                    (do 
                        (move Select 
                            (from 
                                (sites Mover) 
                                if:(< 0 (count at:(from)))
                            )
                            (then 
                                (sow 
                                    if:(and 
                                        (is In (to) (sites Next)) 
                                        (or 
                                            (= (count at:(to)) 2) 
                                            (= (count at:(to)) 3)
                                        )
                                    ) 
                                    apply:(fromTo 
                                        (from (to)) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:(to))
                                    )
                                    includeSelf:False
                                    <Skip>
                                    backtracking:True
                                )
                            )
                        )
                        ifAfterwards:(< 0 (count in:(sites Next)))
                    )
                )
            )
        )
        <End:rule>
    )
)

Construct a Ludii game based on the following description
Maak Yék is a capturing game played in Thailand. It involves custodial capture of pieces, as well as a reverse form of this, where a single piece can capture two pieces surrounding it.8x8 board. Sixteen pieces per player. The pieces begin on the first and third rank or squares with respect to each player. Pieces move orthogonally any distance. Pieces are captured when surrounded on both sides by an enemy piece. Enemy pieces may also be taken if a piece moves into a space such that the enemy pieces are on either side of it. The goal is to capture all of the enemy's pieces. 
(game "Maak Yek" 
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Marker" Each 
            (move Slide Orthogonal
                (then 
                    (and
                        ("InterveneCapture" Orthogonal)
                        ("CustodialCapture" Orthogonal)
                    )
                )
            )
        )
    })
    (rules
        (start {
            (place "Marker1" (union (sites Row 0) (sites Row 2)))
            (place "Marker2" (union (sites Row 5) (sites Row 7)))
        })
        (play (forEach Piece))
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Katro" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 6 "Columns" store:None
            <Row:tracks>	
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Track "TrackCCW1")) 
        (regions "Home" P2 (sites Track "TrackCCW2")) 
        (regions "Inner" P1 (sites Row 2))    
        (regions "Inner" P2 (sites Row 3))    
        (regions "Middle" P1 (sites Row 1))    
        (regions "Middle" P2 (sites Row 4))    
        (regions "Outer" P1 (sites Bottom))    
        (regions "Outer" P2 (sites Top))    
    }) 
    (rules 
        
        (start (set Count 2 to:(sites Board)))
        
        (play 
            (or {
                (if (or (= (value Player Mover) 1) (<= (value Player Mover) 0))
                    (move Select
                        (from 
                            (if ("SameTurn") 
                                "LastHoleSowed" 
                                ("OuterMostRowWithPieces") 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then
                            (sow
                                "TrackCCW"
                                owner:(mover)
                                apply:(if (> (count at:(to)) 1)
                                    (and {
                                        (if (<= (value Player Mover) 0)
                                            (set Value Mover 1)
                                        )
                                        (moveAgain)
                                        (if (is In (to) (sites Mover "Inner"))
                                            (if (!= 0 (count at:("OppositePit" (to))))
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (to))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (if (!= 0 (count at:("OppositeMiddlePit" (to))))
                                                    (fromTo
                                                        (from ("OppositeMiddlePit" (to)))
                                                        (to (to))
                                                        count:(count at:("OppositeMiddlePit" (to)))
                                                    )
                                                    (if (!= 0 (count at:("OppositeOuterPit" (to))))
                                                        (fromTo
                                                            (from ("OppositeOuterPit" (to)))
                                                            (to (to))
                                                            count:(count at:("OppositeOuterPit" (to)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    })
                                    (set Value Mover 0)
                                )
                            )
                        )
                    )
                )
                (if (or (= (value Player Mover) 2) (<= (value Player Mover) 0))
                    (move Select
                        (from 
                            (if ("SameTurn") 
                                "LastHoleSowed" 
                                ("OuterMostRowWithPieces") 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then 
                            (sow
                                "TrackCW"
                                owner:(mover)
                                apply:(if (> (count at:(to)) 1)
                                    (and {
                                        (if (<= (value Player Mover) 0)
                                            (set Value Mover 2)
                                        )
                                        (moveAgain)
                                        (if (is In (to) (sites Mover "Inner"))
                                            (if (!= 0 (count at:("OppositePit" (to))))
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (to))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (if (!= 0 (count at:("OppositeMiddlePit" (to))))
                                                    (fromTo
                                                        (from ("OppositeMiddlePit" (to)))
                                                        (to (to))
                                                        count:(count at:("OppositeMiddlePit" (to)))
                                                    )
                                                    (if (!= 0 (count at:("OppositeOuterPit" (to))))
                                                        (fromTo
                                                            (from ("OppositeOuterPit" (to)))
                                                            (to (to))
                                                            count:(count at:("OppositeOuterPit" (to)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    })
                                    (set Value Mover 0)
                                )
                            )
                        )
                    )
                )
                (if ("OneSingePieceInTheOuter")
                    (move
                        (from 
                            (sites Mover "Outer")
                            if:(> (count at:(from)) 0)
                        )
                        (to
                            (if (is Mover P1)
                                (ahead (from) N)
                                (ahead (from) S)
                            )
                        )
                    )
                )
                (if ("OneSingePieceInTheMiddle")
                    (move
                        (from 
                            (sites Mover "Middle")
                            if:(and 
                                (> (count at:(from)) 0)
                                (< 1 (count in:(sites Column (column of:(from)))))
                            )
                        )
                        (to
                            (if (is Mover P1)
                                (ahead (from) N)
                                (ahead (from) S)
                            )
                        )
                        (then 
                            (and
                                (if (!= 0 (count at:("OppositePit" (last To))))
                                    (fromTo
                                        (from ("OppositePit" (last To)))
                                        (to (last To))
                                        count:(count at:("OppositePit" (last To)))
                                    )
                                    (if (!= 0 (count at:("OppositeMiddlePit" (last To))))
                                        (fromTo
                                            (from ("OppositeMiddlePit" (last To)))
                                            (to (last To))
                                            count:(count at:("OppositeMiddlePit" (last To)))
                                        )
                                        (if (!= 0 (count at:("OppositeOuterPit" (last To))))
                                            (fromTo
                                                (from ("OppositeOuterPit" (last To)))
                                                (to (last To))
                                                count:(count at:("OppositeOuterPit" (last To)))
                                            )
                                        )
                                    )
                                )
                                (moveAgain)
                            )
                        )
                    )
                )
            })
        )
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)
Katro is a unique six-row mancala-style board game played in Madagascar.6x3 or 6 board. Two counters in each hole. Sowing occurs from one of the holes in the player's outermost row which contains counters, in either direction. Sowing moves in a boustrophedon path along the holes, moving from the last hole in the innermost row to the beginning of the outer row. When the final counter lands in an occupied hole, the contents of this hole are picked up and sowing continues. If this hole is in the player's inner row, the contents of the opponent's hole opposite it are captured, and these counters are also used along with the hole in which the last counter fell for the sowing to continue. If the opponent's inner row hole is empty, counters may be captured from their central row, and if both the inner and central rows are empty, captures may be made from the outer hole. Sowing ends when the final counter lands in an empty hole. When a player has only one counter on their side of the board, it may capture by moving from the central row directly to the inner row hole above it to make a capture (i.e., without following the normal track), and on the move prior to the capture, from the outer to the central row. Play continues until one player has captured all of the counters. 3 Holes per row.

Construct a Ludii game based on the following description
Akidada is a simple game of alignment played by Yoruba people in what is now Ghana.3x3 intersecting lines. Three sticks per player, the sticks angled toward the player to indicate ownership. Players alternate turns placing sticks on the board. Once all of the sticks are placed, players alternate turns moving a stick to any empty spot on the board. The first player to place three sticks in an orthogonal row along the lines wins. 
(game "Akidada"
    (players 2) 
    (equipment {
        (board (square 3) use:Vertex)
        (hand Each)
        (piece "Stick" Each (move (from) (to (sites Empty))))
    }) 
    (rules 
        (start (place "Stick" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end (if (is Line 3 Orthogonal) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Quinze Tablas is a race game related to other European Tables games. It is documented in the Libro de los Juegos of Alfonso X.2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Pieces begin on one half of a player's side of the board (the half to the left of one player, and to the right of the other player), two per space, then two on the next space and one on the space following that one. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Pieces move in a track the long way around the board toward the portion where the opponent begins. No more than two pieces can occupy a space at a time. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board. The opponent must then reenter this piece on the board onto an open point according to the throw of the dice, from the original starting quadrant on the board. Players attempt to bear off their pieces by rolling the exact number of spaces left on the board, plus one. The first player to bear off all their pieces wins. 
(game "Quinze Tablas"
    (players 2)
    (equipment {
        ("TableBoard" ("TableTracksOppositeWithHands" End))
        (dice d:6 num:3)
        (hand Each)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsEndTrack" "SiteToMoveOnTrack")
                    "RemoveAPiece"
                    (if ("IsNotOffBoard" "SiteToMoveOnTrack")
                        (if ("IsEmptyOrSingletonStack" ("SiteToMoveOnTrack"))
                            (move 
                                (from) 
                                (to 
                                    "SiteToMoveOnTrack"
                                    ("HittingCapture" (handSite Next)) 
                                )
                            )
                        )
                    )
                )
            )
        )
    })
    (rules 
        (start {
            (place Stack "Disc1" (sites {0..6}) count:2)
            (place Stack "Disc1" 7 count:1)
            (place Stack "Disc2" (sites {12..18}) count:2)
            (place Stack "Disc2" 19 count:1)
        })
        (play 
            ("RollEachNewTurnMove"
                (if ("BarEmpty")
                    (forEach Piece top:True)
                    ("MoveAPieceIf" ("DieNotUsed") ("Bar"))
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )
        (end {
            (if (no Pieces P1) (result P1 Win))
            (if (no Pieces P2) (result P2 Win))
        })
    )
)

Construct a Ludii game based on the following description
Njombwa is a four-row mancala-style board game played by the Yao people of East Africa. 4x8 board, occasionally 4x9 or 10. 29 counters in each player's leftmost hole in their outer row, two in the hole to the right of it and one in the hole to the right of that one. Sowing occurs in an anti-clockwise direction in the player's two rows. Each player begins with a stylised move, by sowing the contents of the hole with two counters. Players alternate turns sowing only from their hole with two counters. When finally a single counter is sown into an inner-row hole that is opposite a hole with a single counter in the opponent's inner row, this counter is captured. The opponent then sows their two remaining counters, capturing two from the opponent. Then, the players sow from their hole with 29 counters, picking up the contents of a hole when the final counter lands in an occupied hole, ending the turn when the final counter lands in an empty hole. When both players have completed this phase, the main phase of the game begins. Players sow from any hole in their two rows. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opponent's opposite hole in their inner row are captured. If there are also counters in the opponent's opposite hole in the outer row, these are also captured, but only when a capture from the inner row was also made. Players cannot sow single counters, unless there are no holes with multiple counters left, in which case single counters may be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. Each row has 8 holes.
(game "Njombwa" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start {
            (set Count 29 to:(sites {0 (- (* 4 <Row:size>) 1)})) 
            (set Count 2 to:(sites {1 (- (* 4 <Row:size>) 2)})) 
            (set Count 1 to:(sites {2 (- (* 4 <Row:size>) 3)})) 
        })
        
        phases:{
        (phase "Opening1"
            (play 
                (move Select
                    (from
                        (forEach (sites Mover "Home") if:(= 2 (count at:(site))))	
                    )
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (and
                                    (is In (to) (sites Mover "Inner"))
                                    (is Occupied ("OppositePit" (to)))
                                )
                                (remove ("OppositePit" (to)))
                            )
                        )
                    )
                )
            )
            (nextPhase ("NoSiteWith2Seeds") "Opening2")
        )
        
        (phase "Opening2"
            (play 
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            (forEach (sites Mover "Home") if:(= 29 (count at:(site))))	
                        ) 
                        if:(> (count at:(from)) 0)
                    )
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (moveAgain)
                            )
                        )
                    )
                )
            )
            
            (nextPhase (not (is Next Mover)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (if ("AllSitesNoMoreThanOne")
                    (move Select
                        (from (sites Mover "Home") if:(and (is Occupied (from)) (is Empty ("NextHole" (from) 1))))
                        (then 
                            (sow
                                "Track"
                                owner:(mover)		
                            )
                        )
                    )
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                "LastHoleSowed"
                                (sites Mover "Home") 
                            ) 
                            if:(> (count at:(from)) 1)
                        )
                        (then
                            (sow
                                "Track"
                                owner:(mover)
                                apply:(if (< 1 (count at:(to)))
                                    (moveAgain)
                                    (if (and 
                                            (is In (to) (sites Mover "Inner"))
                                            (is Occupied ("OppositePit" (to)))
                                        )
                                        (and
                                            (remove ("OppositePit" (to)))
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (remove ("OppositeOuterPit" (to)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )		
            )
        )
        }
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Overflow"
    (players 2)
    (equipment {
        (board (square <Board>))
        (piece "Disc" P1)
    })
    (rules
        (start {
            (place "Disc1" (sites Board))
            (set Score P1 (count Sites in:(sites Phase 1)))
            (set Score P2 (count Sites in:(sites Phase 0)))
        })
        (play
            (do
                (or
                    ("ContainedMove")
                    ("OverflowMove")
                    (then (remove (last From) count:(size Stack at:(last From))))
                )
                ifAfterwards:(= 1 (count Groups))
                (then 
                    ("UpdateScores")
                )
            )
        )
        (end 
            (if 
                (= 0
                    (* (score P1) (score P2))
                )
                (byScore)
            )
        )
    )
)
Overflow is a drawless Mancala-inspired game invented by Michael Amundsen in April 2022.Overflow is played on a checkered board initially filled with neutral stackable pieces, one per square.
            The dark squares make up the house of the Dark player, and the light squares make up the house of the Light player. The goal is to empty your opponent's house.
            
            There are two types of moves in Overflow, both of which are sowing moves, somewhat akin to what you see in mancalas. All moves are bound by the restriction that there must always be exactly one orthodiagonally connected group of stacks on the board. The one kind of sowing only drops pieces onto already occupied squares and the other kind spills out of both the group of already occupied squares and out of the board itself, hence the names: contained moves and overflow moves.
            
            Sowing in general:
            Sowing in general is picking up a stack from any square and distributing its pieces along one of the 8 directions onto a contiguous line of squares – usually placing one of the N pieces from the chosen stack in each of the N or so squares in the sowing direction. The details are given below.
            
            Overflow moves:
            An overflow move involves sowing into empty squares – possibly in addition to occupied squares – and over the edge of the board. It's important to remember that these two things always go together in this game, namely (1) sowing over the edge and (2) sowing into empty squares. That is to say, if you are to sow into one or more empty squares, the number of squares in the chosen sowing direction must be smaller than the number of stones in the chosen stack. The pieces that end up outside the board are removed from the game.
            
            Contained moves:
            Contained moves only sow onto already occupied squares. A contained move must sow the chosen stack as far as possible. If it's impossible to sow each of the pieces in the stack into an occupied square of its own, you place the remainder of the pieces on the last occupied square you reached. You are not obligated to chose the stack that can be sown the farthest, but whatever stack you chose, if you do not make an overflow move move with it, you must chose a sowing direction that allows you to sow onto as many occupied squares as possible.
            
            You may always chose freely between contained moves and overflow moves when both kinds are available.
            
        Note that no stack will have both a contained move and an overflow move available in the same direction. All moves are completely determined by the choice of stack and direction. A 3x3 board is currently selected

Construct a Ludii game based on the following description
Nao Guti is a game of alignment played in South Asia, with nine pieces on a board that is widely used throughout the world.Three concentric squares, with lines connecting the midpoints. Nine pieces per player. Players alternate turns placing a piece on the board on an empty spot. When all of the pieces have been placed, the players alternate turns moving a piece to an empty adjacent spot along the lines of the board. During either phase, if a player places three of their pieces in a row along the lines on the board, the player removes one of the opponent's pieces. The player who removes all of the opponent's peices wins. 
(game "Nao Guti"
    (players 2)
    
    (equipment { 
        ("NineMensMorrisBoard")
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3" Orthogonal exact:True)))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:9))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3" Orthogonal exact:True)) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    "RemoveAnyEnemyPiece"
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Nchayo" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            <Board:tracks>	
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    })
    (rules 
        (start (set Count 1 to:(sites Board)))
        
        (play 
            (move Select
                (from 
                    (if ("SameTurn")
                        ("LastHoleSowed")
                        (sites Mover "Home")
                    )
                    if:(is Occupied (from))
                )
                (then
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (< 1 (count at:(to)))
                            (moveAgain)
                            (if (is In (to) (sites Mover "Inner"))
                                (if (is Occupied ("OppositePit" (to)))
                                    (and
                                        (fromTo 
                                            (from ("OppositePit" (to)))
                                            (to (handSite Mover))
                                            count:(count at:("OppositePit" (to)))
                                        )	
                                        (if (is Occupied ("OppositeOuterPit" (to)))
                                            (fromTo 
                                                (from ("OppositeOuterPit" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositeOuterPit" (to)))
                                            )	
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Next)))
    )
)
Nchayo is a four-row mancala-style board game played by the Makonde people of Mozambique and Tanzania. The board is generally made of holes in the ground, and stones or fruit seeds are used as counters.4x5 or 8 board. One counter in each hole.  Players alternate turns picking up the counters in one of their holes and sowing them in an anti-clockwise direction. When the final counter lands in a hole with counters, these counters are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opponent's opposite inner row hole are captured, and if this capture was possible, any counters in the outer row hole are also captured. The player who captures all of the opponent's counters wins. Each player has 6 holes per row.

Construct a Ludii game based on the following description
Nein Ari is a puzzle based on the graph theory concept of k-regular graphs. A k-regular graph is a graph where every vertex has exactly k neighbours (i.e. every vertex has a degree of k). The graph is initially coloured. The goal of the general version of the puzzle is to uncolour edges until the coloured graph is a regular graph. The goal of the parameter-k version of the puzzle is to uncolour edges until the coloured graph is a k-regular graph.
         The game is played on the Graph1. General version
(game "Nein Ari" 
    (players 1)
    (equipment { 
        (board <Board:type> use:Edge)
    }) 
    
    (rules  	 
        (start 
            (set P1 Edge (sites Board Edge))
        )
        
        (play 
            (move Remove
                (sites Occupied by:Mover on:Edge) 
            )
        )
        (end   
            <Version:result>
        )
    )
)

Construct a Ludii game based on the following description
Ryakati is a four-row mancala-style board game played by the Bari people of South Sudan. The holes are scooped out of the ground and counters are seeds or pebbles, and represent cows.4x8 board. Two counters in each hole. Sowing proceeds in an anti-clockwise direction. The first move must begin from the second hole from the right in the player's outer row, and proceed as follows, and is played simultaneously by both players: sow the two counters from that first hole, capture the counters in the opponent's two opposite holes and sow them, starting in the rightmost hole in the outer row, capture from the opposite two holes on the opponent's side and sow them again from the same hole. When the final counter falls in an occupied hole, those counters are picked up and sowing continues. The opening move ends when the final counter falls in an empty hole. The main phase then begins. When the final counter falls into an occupied hole in the player's inner row and both of the opposite holes on the opponent's side of the board are occupied, the counters in the opposite holes are captured and sown beginning in the first hole that was sown into to begin the sowing that caused the capture. When the final counter falls into an occupied hole and a capture is not possible, the contents of the hole are picked up and sowing continues. When the final counter lands in an empty hole, the turn ends. Players cannot sow from a hole containing a single counter. The player who captures all of their opponent's counters wins. 
(game "Ryakati" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "16,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (map "RightMostOuter" {(pair P1 7) (pair P2 24)})
        (map "SecondHoleRightOuter" {(pair P1 6) (pair P2 25)})
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(sites Board)) 
        )
        
        phases:{
        (phase "Opening1"
            (play
                (move Select
                    (from
                        (mapEntry "SecondHoleRightOuter" Mover)	
                    )
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(and
                                (fromTo
                                    (from ("OppositePit" (to)))
                                    (to (mapEntry "RightMostOuter" Mover))
                                    count:2
                                )
                                (fromTo
                                    (from ("OppositeOuterPit" (to)))
                                    (to (mapEntry "RightMostOuter" Mover))
                                    count:2
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover "Opening2")
        )
        (phase "Opening2"
            (play
                (move Select
                    (from
                        (mapEntry "RightMostOuter" Mover)	
                    )
                    (then
                        (sow
                            count:4
                            "Track"
                            owner:(mover)
                            apply:(and
                                (fromTo
                                    (from ("OppositePit" (to)))
                                    (to (mapEntry "RightMostOuter" Mover))
                                    count:2
                                )
                                (fromTo
                                    (from ("OppositeOuterPit" (to)))
                                    (to (mapEntry "RightMostOuter" Mover))
                                    count:2
                                )
                            )
                            origin:True
                        )
                    )
                )
            )
            (nextPhase Mover "Opening3")
        )
        
        (phase "Opening3"
            (play
                (move Select
                    (from
                        (if 
                            ("SameTurn") 
                            (var "Replay")
                            (mapEntry "RightMostOuter" Mover) 
                        ) 
                    )
                    (then
                        (sow
                            count:(if ("SameTurn") (count at:(last To)) 4)
                            "Track"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (and
                                    (moveAgain)
                                    (set Var "Replay" (to))
                                )
                            )
                            origin:("NewTurn")
                        )
                    )
                )
            )
            (nextPhase Mover (not (is Next Mover)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (move Select
                    (from 
                        (if 
                            ("SameTurn") 
                            (sites {(var "Replay") })
                            (sites Mover "Home") 
                        ) 
                        if:(> (count at:(from)) 1)
                    )
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (if (and {
                                        (is In (to) (sites Mover "Inner"))
                                        (is Occupied ("OppositePit" (to)))
                                        (is Occupied ("OppositeOuterPit" (to)))
                                    })
                                    (and {
                                        (fromTo
                                            (from ("OppositePit" (to)))
                                            (to (last From))
                                            count:(count at:("OppositePit" (to)))
                                        )
                                        (fromTo
                                            (from ("OppositeOuterPit" (to)))
                                            (to (last From))
                                            count:(count at:("OppositeOuterPit" (to)))
                                        )
                                        (sow
                                            (last From)
                                            count:(+ (count at:("OppositeOuterPit" (to))) (count at:("OppositePit" (to))))
                                            "Track"
                                            owner:(mover)
                                        )
                                        
                                    })
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Moxie"
    (players 2)
    (equipment {
        (board (square 4))
        (piece "Pawn" Each)
        (hand Each)
    })
    (rules
        (start (place "Pawn" "Hand" count:8))
        (play 
            (if ("SameTurn")
                ("HopCapture"
                    (from (last To))
                    ~
                    (then
                        (if (can Move ("HopCapture" (from (last To))))
                            (moveAgain)
                        )
                    )
                )
                (priority {
                    (forEach Piece 
                        ("HopCapture" ~ ~
                            (then
                                (if (can Move ("HopCapture" (from (last To))))
                                    (moveAgain)
                                )
                            )
                        )
                    )
                    (or
                        (if (is Occupied (handSite Mover))
                            (move (from (handSite Mover)) (to (sites Empty)))
                        )
                        (forEach Piece (move Step (to if:(is Empty (to)))))
                    )
                    
                })
            )
        )
        (end {
            (forEach NonMover
                if:(<= (count Pieces Player) 2)
                (result Player Loss)
            )
            ("Line3Win" All)
        }) 
    )
)
This game is played on an empty 4x4 square board. Each player has 8 stones off board. 

Construct a Ludii game based on the following description
Lamosh is a two-row mancala-style board game played in Ethiopia. It is similar to the many other games played in the area.2x6 board. Four counters in each hole. Play begins with a stylized move. One player takes one counter from their rightmost hole, and holds it in their hand. They then take one counter from the next hole, moving in an anti-clockwise direction, and place it in the next hole. They then take a counter from the next hole after that, and placing it in the next hole, continuing until there is an alternating pattern of a hole with five counters followed by a hole with three counters. Upon reaching the original hole, one counter is dropping in it, and then one counter in the following hole, thus capturing the counters in this hole. Players then alternate turns, sowing in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, these counters are picked up and the sowing continues. During sowing, the contents of any hole made to contain four counters are captured by the player in whose row the hole is located, except when this is the final counter of a sowing, in which case the player who is sowing captures these counters. When the sowing ends in an empty hole, the turn ends. Play continues until one player cannot move, and the other player captures the remaining counters. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, but not if there are one or two extra. Play continues in several rounds like this until one player captures all the holes.
         
(game "Lamosh" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightMost" {(pair P1 5) (pair P2 6)})
    }) 
    (rules 
        
        (start { 
            (set Count 4 to:(sites Track)) 
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Opening1"
            (play
                (move
                    (from
                        (if ("SameTurn")
                            (var "Replay")
                            11
                        )
                    )	
                    (to
                        ("NextHole" (from) 1)	
                    )
                    (then
                        (if (!= ("NextHole" (last To) 1) 11)
                            (and
                                (moveAgain)
                                (set Var "Replay" ("NextHole" (last To) 1))
                            )
                            (
                                (fromTo
                                    (from 11)
                                    (to (handSite Mover))
                                    count:(count at:11)
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (not (is Next Mover)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (or 
                    {
                    (move Select 
                        (from
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(is Occupied (from))
                        )
                        (then
                            (do
                                (set Var "NumSowed" (count at:(last To)))
                                next:(sow
                                    "TrackCCW"
                                    apply:(if (= 4 (count at:(to)))
                                        (fromTo
                                            (from (to))
                                            (to (handSite Mover))
                                            count:4
                                        )
                                        (if (< 1 (count at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                )
                                (then
                                    (and
                                        (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1)))
                                            (if (= 4 (count at:(site)))
                                                (fromTo
                                                    (from (site))
                                                    (to (if (is In (to) (sites (values Remembered "OwnedP1"))) (handSite P1) (handSite P2)))
                                                    count:4
                                                )
                                            )
                                        )
                                        (set Var "NumSowed" 0)
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("APlayerCanNotMove")
                            (and { 
                                (if (no Moves P1)
                                    (forEach Site (sites Board)
                                        (if (is Occupied (site))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P1))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                    (forEach Site (sites Board)
                                        (if (is Occupied (site))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P2))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 3 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 3 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("RightMostEmpty"))
                        count:(if (>= (count Cell at:(handSite Mover)) 4) 4 3)
                        (then
                            ("RemmemberOwnedHoles" (last To))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Pam Pait (\3x5 lines, intersecting one another and forming a square. Diagonals are drawn in the four quadrants of the board. Two triangles, their apices intersecting the main board at opposite midpoints. The base of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. Fourteen pieces per player, which begin on the points in the triangle and the first two rows of the square closest to each player. The central line remains empty. Players alternate turns moving to an empty adjacent point along the lines. A player may capture an opponent's piece by hopping over it to an empty space on the opposite side of the opponent's piece along the lines of the board. The player who captures all of the opponent's pieces wins. 
(game "Pam Pait" 
    (players 2) 
    (equipment { 
        (board
            (add
                (remove 
                    ("AlquerqueGraphWithBottomAndTopTriangles")
                    vertices:{1 11 21 23 13 3}
                )
                edges:{ {0 1} {1 2} {8 9} {9 10} {16 17} {17 18} }
            )
            use:Vertex
        )
        (piece "Marker" Each (or "HopCapture" "StepToEmpty"))
    }) 
    (rules 
        (start {
            (place "Marker1" (union (sites {"A4" "E4"}) (expand (sites Bottom) steps:3)))
            (place "Marker2" (union (sites {"A6" "E6"}) (expand (sites Top) steps:3)))
        })
        (play (forEach Piece))
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Chandaraki is a game with replacement captures played in Tibet since the eighteenth century. This version was reported in 1775.Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space orthogonally forward, or two steps orthogonally forward only if it is the first move of any of that player's pawns, capture one space diagonally forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. When a player is reduced to a King without any other pieces, the game is a draw.
         
(game "Chandaraki" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn" "InitialPawnMove")
        ("ChessRook" "Rook")
        ("ChessKing" "King")
        ("ChessBishop" "Bishop")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Queen")
        
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (do (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King" Mover))
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (= 1 (count Pieces Next)) (result Mover Draw))
        })
    )
)

Describe the mechanics of the following Ludii game
(game "A K'aak'il"
    (players <Player:num>)
    (equipment {
        (board
            (rectangle 1 <Player:size>)
            <Player:tracks> 
            use:Edge
        )
        (regions "AllSites" (sites Board Vertex))
        (piece "Stick" Each
            (forEach Value (values Remembered "Throws")
                (or
                    (if ("FreePiece" (state at:(from) level:(level)))
                        (if ("IsOffBoard" ("NextSiteOnTrack" (value) from:(from) "Track"))
                            (move 
                                (from (from) level:(level))
                                (to 
                                    (handSite Mover)
                                    (apply (forget Value "Throws" (value)))		
                                )
                            )
                            (move 
                                (from (from) level:(level)
                                    if:(if (is In (from) (sites Hand Mover))
                                        ("NoPieceOnBoard")
                                        True
                                    )
                                )
                                (to 
                                    ("NextSiteOnTrack" (value) from:(from) "Track")
                                    (apply (forget Value "Throws" (value)))
                                )
                                (then 
                                    (if ("AtLeastAnEnemyPieceThere" (last To))
                                        ("CaptureMove")
                                    )
                                )
                            )
                        )
                    )
                    (if ("CapturingPiece" (state at:(from) level:(level)))
                        (if ("IsOffBoard" ("NextSiteOnTrack" (value) from:(from) "CaptureTrack"))
                            (do (forget Value "Throws" (value))
                                next:(move Remove (from) level:(level)
                                    (then
                                        (and {
                                            ("UnsetCapturingPieces")
                                            ("RemoveCapturedPieces")	
                                            ("RebirthCapturingPiece")
                                        })
                                    )
                                )
                            )
                            (move 
                                (from (from) level:(level))
                                (to 
                                    ("NextSiteOnTrack" (value) from:(from) "CaptureTrack")
                                    (apply (forget Value "Throws" (value)))
                                )
                                (then 
                                    (and
                                        ("CapturedPiecesFollowCapturingPiece")
                                        ("UnsetCapturingPieces")
                                    )
                                )
                            )
                        )
                    )
                )
            )		
        )
        ("StickDice" 4)
        (hand Each)
    })
    (rules 
        (start {
            <Player:team>
        })
        
        phases:{
        (phase "ThrowPhase" 
            (play 
                ("RollMove"
                    (move Pass
                        (then
                            (if (not (no Pieces Mover))
                                (and {
                                    (if (!= 0 ("ThrowValue"))
                                        (do
                                            (remember Value "Throws" ("ThrowValue"))
                                            ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece)))
                                        )
                                    )
                                    (moveAgain)
                                    (if ("SameTurn") (set Pending))
                                })
                            )
                        )
                    )
                )	
            )
            (nextPhase (is Pending) "MovePhase")
        )
        (phase "MovePhase" 
            (play 
                (or (forEach Piece) (forEach Piece container:(mover))
                    (then
                        (and
                            (if (< 0 (size Array (values Remembered "Throws")))
                                (moveAgain)
                            )
                            (forEach Site ("FireSites")
                                (if (is Occupied (site))
                                    (forEach Level (site) FromTop
                                        (remove (site) level:(level))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase")
        )
        }
        
        (end ("CaptureAllTeam"))
    )
)
A K'aak'il, \Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. A circle is drawn in the central space; this is the \ The game has 6 players.

Describe the mechanics of the following Ludii game
(game "Unnee Tugalluulax" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "5,W,N,E" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (hand Each)
    }) 
    
    (rules 
        (start (set Count 6 to:(sites Track)))		 
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(< 0 (count at:(from)))
                )
                (then 
                    (sow 
                        if:(= (count at:(to)) 4)
                        apply:(fromTo 
                            (from (to)) 
                            (to (handSite Mover)) 
                            count:(count at:(to))
                        )
                    )
                )
            )
        )
        (end ("MancalaByScoreWhen" <End:cond>))
    )
)
Unnee Tugullalax is a two-row mancala-style board game from Mongolia. It is typically played with camel droppings on a board. The game is imbued with the symbolism of the cycle of reproduction of a cow, as a hole fills with counters it progresses along the cycle of reproduction until it has four counters, when the calve is produced and the four counters are captured.2x6 board. Six counters in each hole. Sowing occurs from any of the holes in the player's row, and continues in a clockwise direction. If the final counter lands in a hole in the player's row containing three counters, four with the addition of the final counter, these are captured. Play continues until one player cannot move or the board position repeats. When one player cannot move, the other player captures the remaining counters. The player with the most counters wins. The game ends if no moves.

Construct a Ludii game based on the following description
Sokkattan is a race game played on a cross-shaped board played in Sri Lanka. It is closely related to similar games found throughout South Asia.Four 3x8 rectangles, arranged in a cross shape around a large central square space. Squares marked with \ 
(game "Sokkattan" 
    (players 4) 
    (equipment { 
        ("PachisiBoard"
            {
            (track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True)
            (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True)
            (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True)
            (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)
            }
        )
        (hand Each) 
        ("StickDice" 6)
        (piece "Pawn" Each ("Move" ("ThrowValue")))
        (regions "SafeSites" (sites {67 63 65 23 38 3 82 84 86 30 47 15}))
        (map "Throw" {(pair 0 6) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 12)})
        (map "Entry" {(pair P1 67) (pair P2 23) (pair P3 82) (pair P4 30)})
    }) 
    (rules 
        (start {
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
            (place Stack "Pawn1" (handSite P1) count:3)
            (place Stack "Pawn2" (handSite P2) count:3)
            (place Stack "Pawn3" (handSite P3) count:3)
            (place Stack "Pawn4" (handSite P4) count:3)
        })
        
        (play 
            ("RollMove"
                (if (= (var "ExtraOne") 1)
                    (priority {
                        (if (is Occupied (handSite Mover))
                            (move
                                (from (handSite Mover))
                                (to (mapEntry "Entry" Mover))
                            )
                        )
                        (forEach Piece ("Move" 1))
                        }
                        (then 
                            (and 
                                (moveAgain)
                                (set Var "ExtraOne" 0)
                            )
                        )
                    )
                    (or
                        (if (and (is Occupied (handSite Mover)) ("IsSpecialThrow"))
                            (move
                                (from (handSite Mover))
                                (to (mapEntry "Entry" Mover))
                            )
                        )
                        (forEach Piece)
                    )
                )
                (then
                    (if (not ("StopThrow")) 
                        (and
                            (if ("IsSpecialThrow") (set Var "ExtraOne" 1))
                            (moveAgain)
                        )
                    )
                )
            )
        )
        
        (end ("EscapeTeamWin"))
    )
)

Construct a Ludii game based on the following description
Rithmomachia is a mathematical game of capture played in medieval and early modern Europe. Its complex mathematical rules suggest that it was originally only played in learned circles. There are many treatises and fragments of the rules, which suggest several variations on the rules through time.8x16 board. Two players, one black, one white. Each player has three types of pieces: Circles, triangle, squares, and one pyramid made up of multiple pieces stacked. Circles move one space orthogonally. Triangles move two spaces diagonally. Squares move three spaces orthogonally. Pyramids may move in any of the directions allowed by one of its constituent pieces. Each piece has a number. For white—circles: 2, 4, 6, 8, 4, 16, 36, 64; triangles: 6, 20 , 42, 72, 9, 25, 49, 81; squares: 15, 45, 153, 25, 81, 169, 289; pyramid (91) from the base: square 36, square 25, triangle 16, triangle 9, circle 4, circle 1. For black—circles: 3, 5, 7, 9, 9, 25, 49, 81; triangles: 12, 30, 56, 90, 16, 36, 64, 100; squares: 28, 66, 120, 49, 121, 225, 361; pyramid (190): from the base: square 64, square 49, triangle 36, triangle 25, circle 16. 
            
            Pieces capture other pieces by mathematical allowances based on the numbers on the pieces. There are nine scenarios in which pieces can be taken when a piece moves to a space occupied by an opponent's piece. 
            
            Multiplication with distance: If the value of the piece to be taken equals the value of the piece making the capture multiplied by the distance between the two pieces; 
            
            Division by distance: If the value of the piece to be taken equals the value of the piece making the capture divided by the distance between the pieces. 
            
            Addition: When two pieces can both move to the space of an opponent's piece, if the sum of the two pieces equals the value of the opponent's piece, it is captured and the player chooses which piece to move to that space. 
            
            Subtraction: When two pieces can both move to the space of an opponent's piece, if the difference between the value of these pieces equals the value of the opponent's piece, it is taken, and the player chooses which piece to move to the space. 
            
            Multiplication: When two pieces can both move to the space of an opponent's piece, if the product of the values of the two pieces equals the value of the opponent's piece, it is taken and the player chooses which piece to move to the space. 
            
            Division: When two pieces can both move to the space of an opponent's piece, if the quotient of the values of the two pieces equals the value of the opponent's piece, it is taken and the player chooses which piece to move to the space.
            
            Encirclement: If pieces are positioned such that there is no possible move or capture for the opponent's piece, the opponent's piece is taken.
            
            Pyramid capture: A pyramid can be captured by capturing its constituent pieces one-by-one according to the above methods; by encircling it so it cannot move, or by obtaining the sum of the constituent pieces or of its base pieces according to the above rules; A pyramid captures as a single one of its component pieces according to the above rules (the direction of the move is independent of the value chosen), or by using the sum of its pieces according to the above rules.
            
        The goal of the game is to capture the opponent's pyramid and to create an alignment on the opponent's half of the board forming a mathematical progression. The progression may be arithmetic (a sequence where the difference between the values is constant), geometric (where each value after the first is determined by multiplying the previous value by a fixed number), or harmonic (1/a, 1/a+d, 1/a+2d, 1/a+3d). The pieces in the progression must be in a straight orthogonal or diagonal line or in a chevron shape, and must be equally spaced. 
(game "Rithmomachia"
    (players 2)
    (equipment {
        (board (rectangle 16 8))
        (piece "Square" Each
            (move Slide Orthogonal
                (between (exact 3) if:(is Empty (between)))
                (to
                    if:(and ("IsEnemyAt" (to)) ("CaptureConditions"))
                    (apply 
                        (if 
                            ("IsEnemyAt" (to)) 
                            (forEach Level (to) FromTop
                                (remove (to) level:(level))
                            )
                        )
                    )		
                )
                stack:True
            )		
        )
        (piece "Triangle" Each
            (move Slide Diagonal
                (between (exact 2) if:(is Empty (between)))
                (to
                    if:(and ("IsEnemyAt" (to)) ("CaptureConditions"))
                    (apply
                        (if ("IsEnemyAt" (to)) 
                            (forEach Level (to) FromTop
                                (remove (to) level:(level))
                            )
                        )
                    )		
                )
                stack:True
            )
        )
        (piece "Disc" Each
            (move Step Orthogonal
                (to 
                    if:(if ("IsEnemyAt" (to)) ("CaptureConditions") (is Empty (to)))
                    (apply 
                        (if ("IsEnemyAt" (to)) 
                            (forEach Level (to) FromTop
                                (remove (to) level:(level))
                            )
                        )
                    )		
                )
                stack:True
            )
        )
        (regions P1 (expand (sites Bottom) steps:7))
        (regions P2 (expand (sites Top) steps:7))
    })
    (rules 
        (start {
            (place "Square1" coord:"A1" value:289) 
            (place "Square1" coord:"B1" value:169) 
            (place "Square1" coord:"G1" value:81) 
            (place "Square1" coord:"H1" value:25) 
            (place "Square1" coord:"A2" value:153) 
            (place "Square1" coord:"G2" value:45) 
            (place "Square1" coord:"H2" value:15) 
            
            (place "Triangle1" coord:"G3" value:6) 
            (place "Triangle1" coord:"E2" value:20) 
            (place "Triangle1" coord:"D2" value:42) 
            (place "Triangle1" coord:"B3" value:72) 
            (place "Triangle1" coord:"H3" value:9) 
            (place "Triangle1" coord:"F2" value:25) 
            (place "Triangle1" coord:"C2" value:49) 
            (place "Triangle1" coord:"A3" value:81) 
            
            (place "Disc1" coord:"F4" value:2) 
            (place "Disc1" coord:"E4" value:4) 
            (place "Disc1" coord:"F3" value:4) 
            (place "Disc1" coord:"D4" value:6) 
            (place "Disc1" coord:"C4" value:8) 
            (place "Disc1" coord:"E3" value:16) 
            (place "Disc1" coord:"D3" value:36) 
            (place "Disc1" coord:"C3" value:64) 
            
            (place "Square2" coord:"H16" value:361) 
            (place "Square2" coord:"G16" value:225) 
            (place "Square2" coord:"B16" value:121) 
            (place "Square2" coord:"A16" value:49) 
            (place "Square2" coord:"G15" value:120) 
            (place "Square2" coord:"B15" value:66) 
            (place "Square2" coord:"A15" value:28) 
            
            (place "Triangle2" coord:"B14" value:12) 
            (place "Triangle2" coord:"D15" value:30) 
            (place "Triangle2" coord:"E15" value:56) 
            (place "Triangle2" coord:"G14" value:90) 
            (place "Triangle2" coord:"A14" value:16) 
            (place "Triangle2" coord:"C15" value:36) 
            (place "Triangle2" coord:"F15" value:64) 
            (place "Triangle2" coord:"H14" value:100) 
            
            (place "Disc2" coord:"C13" value:3) 
            (place "Disc2" coord:"D13" value:5) 
            (place "Disc2" coord:"E13" value:7) 
            (place "Disc2" coord:"F13" value:9) 
            (place "Disc2" coord:"C14" value:9) 
            (place "Disc2" coord:"D14" value:25) 
            (place "Disc2" coord:"E14" value:49) 
            (place "Disc2" coord:"F14" value:81) 
            
            (place Stack "Square1" 9 value:36)
            (place Stack "Square1" 9 value:25)
            (place Stack "Triangle1" 9 value:16)
            (place Stack "Triangle1" 9 value:9)
            (place Stack "Disc1" 9 value:4)
            (place Stack "Disc1" 9 value:1)
            
            (place Stack "Square2" 119 value:64)
            (place Stack "Square2" 119 value:49)
            (place Stack "Triangle2" 119 value:36)
            (place Stack "Triangle2" 119 value:25)
            (place Stack "Disc2" 119 value:16)
        })
        (play
            (or
                (forEach Piece)
                (forEach Site (sites Occupied by:Next)
                    (forEach Level (site) FromBottom
                        (if 
                            ("Encirclement")
                            (move Remove (site) level:(level))
                        )
                    )
                )
            )
        )
        (end (if 
                (and
                    ("MathematicalProgressionAlignementOpponentSide") 
                    ("NoStackedPiece" Next)
                )
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Leyla Gobale is a name for mancala-style games in the Horn of Africa. This game was played in Somaliland in the early twentieth century and is a two-row game.2x6, 8, or 12 holes. Four counters in each hole. Play begins from a player's righthand hole and counters are sown clockwise. After this, a player may begin sowing from any hole in their row. When the final counter falls into an occupied hole, the counters in that hole are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends; if this hole is in the player's own row, the contents of the opponent's hole are captured if they contain one, two, four, or more counters. If it contains three counters, one of the opponent's counters is taken and placed into the hole where sowing ended, so that each now has two counters. These holes cannot be sown from for the rest of the game and are owned by the player whose turn created them. Play ends when one player can no longer play. The opponent then takes all of the counters in their own row, and each player takes the counters that have accumulated in their captured holes. The player with the most counters wins. Each player has 6 holes.
(game "Leyla Gobale (Somaliland)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 <Board:size> store:None
            (track "Track" <Board:track> loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (hand Each)  
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play
            (or {
                (move Select
                    (from
                        (if (= 0 (count Moves)) 
                            (sites {5})
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover) 
                            )
                        )
                        if:(and 
                            (is Occupied (from)) 
                            (= 0 (state at:(from)))
                        )
                    )
                    (then
                        (sow
                            apply:(if (< 1 (count at:(to)))
                                (if (= 0 (state at:(to)))
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                )
                                (if (is In (to) (sites Mover))
                                    (if (!= 3 (count at:("OppositePitTwoRows" (to))))
                                        (if (!= 0 (count at:("OppositePitTwoRows" (to))))
                                            (fromTo
                                                (from ("OppositePitTwoRows" (to)))
                                                (to (handSite Mover))
                                                count:(count at:("OppositePitTwoRows" (to)))
                                            )
                                        )
                                        (and {
                                            (fromTo
                                                (from ("OppositePitTwoRows" (to)))
                                                (to (to))
                                                count:1
                                            )
                                            (set State at:(to) (mover))
                                            (set State at:("OppositePitTwoRows" (to)) (mover))
                                        })
                                    )
                                )
                            )
                        )
                    )
                )
                }
                (then
                    (if ("APlayerCanNotMove")
                        (and { 
                            (forEach Site 
                                (sites P1)
                                (if (= 0 (state at:(site)))
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                            )
                            (forEach Site 
                                (sites P2)
                                (if (= 0 (state at:(site)))
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                            )
                            (forEach Site 
                                (sites Board)
                                (if (= (state at:(site)) P1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                    (if (= (state at:(site)) P2)
                                        (fromTo
                                            (from (site))
                                            (to (handSite P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                            )
                        })
                    )
                )
            )
        )	
        
        (end ("MancalaByScoreWhen" ("NoPieceOnBoard")))
    )
)

Construct a Ludii game based on the following description
Gyre is a connection game for a hexhex board designed by Mark Steere.Players take turns placing a stone on an empty cell. A player wins as soon as some or all of their stones form a group with the following property: If all the cells of that group where removed (imagined away) from the board, none of the resulting partitions of the board would contain a majority of the set of cells comprising both the center cell and the perimeter cells (a majority relative to the entire intact board, that is, not of the imagined result of partitioning it). A size 5 board is currently selected
(game "Gyre"
    (players 2)
    (equipment {
        (board (hex <Board>))
        (piece "Disc" Each)
    })
    (rules
        (meta (swap))
        (play (move Add (to (sites Empty))))
        (end 
            (if 
                (>=
                    (count Sites 
                        in:(union
                            (sites Outer)
                            (sites {(centrePoint)})
                        )
                    )
                    (max
                        (results
                            from:(difference
                                (sites Board)
                                (sites Group at:(last To))
                            )
                            to:2 
                            (* (to)
                                (count Sites
                                    in:(intersection
                                        (union
                                            (sites Outer)
                                            (sites {(centrePoint)})
                                        )
                                        (sites Group at:(from)
                                            if:(not
                                                (is In
                                                    (to)
                                                    (sites Group at:(last To))
                                                )
                                            )
                                        )
                                    )
                                )
                            ) 
                        )
                    )
                )
                (result Mover Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "To Kinegi tou Lagou"
    (players 2) 
    (equipment { 
        (board 
            (add
                (remove
                    (remove
                        (merge {
                            (concentric {1 8})
                            (shift 0 -5 (concentric {1 4}))
                            (shift 0 5 (concentric {1 4}))
                            (shift -5 0 (concentric {1 4}))
                            (shift 5 0 (concentric {1 4}))
                            (shift 5 5 (concentric {1 8}))
                            (shift 5 -5 (concentric {1 8}))
                            (shift -5 -5 (concentric {1 8}))
                            (shift -5 5 (concentric {1 8}))
                        })
                        vertices:{20 18 27 11 48 49 50 51 52 41 42 43 44 45 34 35 36 37 30 59 58 57 64 63}
                    )
                    edges:{
                    {0 1} {0 7} {0 5} {0 3} {33 35} {30 29} {27 25} {39 37}
                    }
                )
                edges:{
                {15 8} {22 6} {4 12} {19 2} {18 36} {38 20} {40 14} {16 26}
                {28 24} {23 32} {31 11} {10 34} {5 30} {3 35} {39 1} {27 7}    
                }
            )
            use:Vertex
        )
        (piece "Human" Each ("StepToEmpty"))
        (piece "Dog" Each ("StepToEmpty"))
        (piece "Hare" Each ("StepToEmpty"))
        (hand Each size:2)
    }) 
    
    (rules 
        (start {
            (place "Hare2" (centrePoint))
            (place "Human1" (handSite P1))
            (place "Dog1" (handSite P1 1) count:2)
        })
        
        <Rule:rule>
    )
)
To Kynégi tou Lagoú (\A square, with lines bisecting the sides drawn to the center. A circle is drawn around the central point. arcs are drawn inside the square around the midpoints of the sides and the corners. Diagonals are drawn from the corner arcs to the central circle. One player plays as the hare, one player plays as the hunter and two hounds. The hare begins on the central spot, and the hunter and hounds are placed on three of the points on the central circle. Pieces move to an empty adjacent spot along the lines of the board. The hare moves first. When the hunter and hounds prevent the hare from being able to move, the game ends and the players switch roles. The game has two rounds.

Construct a Ludii game based on the following description
Bara Guti is a term used for a couple of different board games in India. In the Bihar region, it is used for this circular game. Three concentric circles, with four diameters dividing it into eight equal sections. Twelve pieces per player, placed on the points on one half of the circle, leaving the central point open. Players alternate turns moving one of their pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to an empty spot immediately on the opposite side of the opponent's piece along the lines. The player who captures all of the opponent's pieces wins. 
(game "Bara Guti (Bihar)" 
    (players 2) 
    (equipment { 
        (board (concentric {1 8 8 8}) use:Vertex)
        (piece "Counter" Each 
            (or 
                ("HopRotationalCapture") 
                ("StepRotationalToEmpty") 
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Counter1" (sites {2..5 10..13 18..21}) )
            (place "Counter2" (sites {1 9 17 6..8 14..16 22..24}))
        })
        
        (play (forEach Piece))
        
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
Icebreaker is a drawless game for two players competing to break the most ice with their ships. Mark Steere designed Icebreaker in November, 2021.There are three red ships and three black ships. The remainder
            of the cells contain white icebergs. The two players, Red and Black, take turns
            moving one of their own ships, one move per turn, starting with Red. Players are
            not allowed to pass.
            
            MOVES:
            You must move one of your ships to an adjacent cell which doesn't contain
            another ship. By moving to a cell containing an iceberg, you capture the iceberg,
            and your score increases by 1.
            
            MOVE DIRECTION:
            You must select one of your ships to move, and move it closer to its closest
            iceberg. Distance is measured by the number of cells between ship and iceberg
            along the shortest path of cells that connects them, going around other ships. If
            the ship you've chosen to move has icebergs adjacent to it, you must capture one
            of them.
            
            OBJECT OF THE GAME:
            The goal is to capture the majority of the icebergs. On the default size 5 board, there are 55 icebergs starting out. If you capture 28 of them, you
        win. A size 8 board is currently selected
(game "Icebreaker"
    (players 2)
    (equipment {
        (board (hex <Board>))
        (piece "Disc" Each
            (move Step
                (to 
                    if:(and
                        (or
                            (= (id Neutral) (who at:(to)))
                            (is Empty (to))
                        )
                        (= 1
                            (-
                                (count Steps
                                    ("OntoEmptyOrIceberg")
                                    (from)
                                    ("NearestIcebergs")
                                )
                                (count Steps
                                    ("OntoEmptyOrIceberg")
                                    (to)
                                    ("NearestIcebergs")
                                )
                            )
                        )
                    )
                    (apply 
                        (if
                            (is Occupied (to))
                            (and
                                (remove (to))
                                (addScore Mover 1)
                            )
                        )
                    )
                )
            )
        )
        (piece "Disc" Neutral)
    })
    (rules
        (start {
            (place "Disc0" (difference (sites Board) (sites Corners)))
            
            (place "Disc1" (sites Around (centrePoint) distance:(- <Board> 1) NNW))
            (place "Disc1" (sites Around (centrePoint) distance:(- <Board> 1) E))
            (place "Disc1" (sites Around (centrePoint) distance:(- <Board> 1) SSW))
            
            (place "Disc2" (sites Around (centrePoint) distance:(- <Board> 1) NNE))
            (place "Disc2" (sites Around (centrePoint) distance:(- <Board> 1) W))
            (place "Disc2" (sites Around (centrePoint) distance:(- <Board> 1) SSE))
            
        })
        (play (forEach Piece Mover))
        (end 
            (if 
                (or
                    (<
                        (/ (- (count Sites in:(sites Board)) 6) 2)
                        (score P1)
                    )
                    (<
                        (/ (- (count Sites in:(sites Board)) 6) 2)
                        (score P2)
                    )
                )
                (byScore)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Dai Hasami Shogi" 
    (players 2) 
    
    (equipment { 
        (<Board>)
        
        (piece "Marker" Each 
            (or 
                (move Slide Orthogonal) 
                ("HopAllPiecesToEmpty" Orthogonal) 
                (then 
                    (or 
                        ("CustodialCapture" Orthogonal (max 1))
                        "Surrounded"
                    )
                )
            )
        )
        (regions P1 (expand (sites Bottom)))
        (regions P2 (expand (sites Top)))
    })
    
    (rules 
        (start { 
            (place "Marker1" (sites P1))
            (place "Marker2" (sites P2))
        })
        
        (play
            (forEach Piece)
        )
        
        (end {
            (if 
                (is Line 5 Orthogonal if:(not (is In (to) (sites Mover)))) 
                (result Mover Win)
            ) 
            (if 
                (and 
                    (< (count Pieces P1) 5) 
                    (< (count Pieces P2) 5) 
                ) 
                (result Mover Draw)
            ) 
        })
    )
)
Dai Hasami Shogi is a Hasami Shogi variant played with Go pieces.Played on a 9x9 board with nine Go pieces per player occupying their two nearest ranks. Pieces move as a rook in Shogi. Pieces may also move by hopping over an adjacent piece of any color. This does not capture the piece, and multiple hops are not allowed in on turn. The goal is to create an orthogonal line of five of a player's pieces outside the player's starting rows. The game is played on a Shogi board.

Construct a Ludii game based on the following description
Tenjiku Shogi is a large version of Shogi dated to the Edo period in Japan.16x16 board. 156 pieces. Includes the same pieces as Sho Shogi, Chu Shogi, and Dai Shogi, with the addition of the following pieces: Great General: moves any distance orthogonally or diagonally, jumping over any intervening pieces; Vice General: moves one space orthogonally or any distance diagonally; Fire Demon: moves two spaces forward or backward; moves any distance left or right or diagonally, pieces in adjacent squares \ The rules are describing from wikipedia.
(game "Tenjiku Shogi"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 16))
        (piece "Pawn" ("StepMove" Forward))
        (piece "King" ("StepMove" Adjacent))
        (piece "Prince" ("StepMove" Adjacent))
        (piece "DrunkenElephant" ("StepMove" (difference Adjacent (directions {Backward}))))
        
        (piece "ViceGeneral"
            (or {
                (if ("NewTurn")
                    (or
                        ("RangingJump"
                            Diagonal
                            (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2") (id "ViceGeneral1") (id "ViceGeneral2")})
                            (sites {(id "King" Next) (id "Prince" Next)}) 
                        )
                        ("SlideMove" Diagonal)
                    )
                )
                ("StepToEmpty"
                    Adjacent
                    (then 
                        (if (< (value Player Mover) 1)
                            (and
                                (set Value Mover (+ 1 (value Player Mover)))
                                (moveAgain)
                            )
                            (set Value Mover Undefined)
                        )
                    )
                )
                ("StepToEnemy" Adjacent
                    (then 
                        (set Value Mover Undefined)
                    )
                )
            })
        )
        
        (piece "GreatGeneral"
            (or
                ("RangingJump"
                    Adjacent
                    (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2")})
                    (sites {(id "King" Next) (id "Prince" Next)}) 
                )
                ("SlideMove" Adjacent)
            )
        )
        
        (piece "BishopGeneral"
            (or
                ("RangingJump"
                    Diagonal
                    (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2") (id "ViceGeneral1") (id "ViceGeneral2") (id "BishopGeneral1") (id "BishopGeneral2") (id "RookGeneral1") (id "RookGeneral2")})
                    (sites {(id "King" Next) (id "Prince" Next)}) 
                )
                ("SlideMove" Diagonal)
                "Promote"
            )
        )
        
        (piece "RookGeneral"
            (or
                ("RangingJump"
                    Orthogonal
                    (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2") (id "ViceGeneral1") (id "ViceGeneral2") (id "BishopGeneral1") (id "BishopGeneral2") (id "RookGeneral1") (id "RookGeneral2")})
                    (sites {(id "King" Next) (id "Prince" Next)}) 
                )
                ("SlideMove" Orthogonal)
                "Promote"
            )	
        )
        
        (piece "Lion"
            (or {
                ("DoubleStep" Adjacent N)
                ("DoubleStep" Adjacent S)
                ("DoubleStep" Adjacent E)
                ("DoubleStep" Adjacent W)
                ("DoubleStep" Adjacent NE)
                ("DoubleStep" Adjacent NW)
                ("DoubleStep" Adjacent SW)
                ("DoubleStep" Adjacent SE)
                ("HopMove" Adjacent)
                ("LeapCapture" "KnightWalk")
                }
                "Promote"
            )		
        )
        
        (piece "HornedFalcon"
            (or {
                ("DoubleStep" Forward N)
                ("DoubleStep" Forward S)
                ("HopMove" Forward)
                ("SlideMove" (difference Adjacent (directions {Forward})))
                }
                "Promote"
            )	
        )
        
        (piece "SoaringEagle"
            (or {
                ("DoubleStep" FL NW)
                ("DoubleStep" FL SE)
                ("DoubleStep" FR SW)
                ("DoubleStep" FR NE)
                ("HopMove" (directions {FL FR}))
                ("SlideMove" (difference Adjacent (directions {FL FR})))
                }
                "Promote"
            )
        )
        
        (piece "DragonHorse"
            (or
                ("StepMove" Orthogonal)
                ("SlideMove" Diagonal)	
                "Promote"
            )
        )
        
        (piece "DragonKing"
            (or
                ("StepMove" Diagonal)
                ("SlideMove" Orthogonal)	
                "Promote"
            )
        )
        
        (piece "Bishop"
            ("SlideMove" Diagonal ~ "Promote")	
        )
        
        (piece "Rook"
            ("SlideMove" Orthogonal ~ "Promote")	
        )
        
        (piece "FerociousLeopard"
            ("StepMove" (directions {Backward Forward FL FR BR BL}) "Promote")
        )
        
        (piece "GoldGeneral"
            ("StepMove" (directions {Backward Forward FL FR Rightward Leftward}) "Promote")
        )
        
        (piece "FireDemon"
            (or 
                (if ("NewTurn")
                    ("SlideMove" (directions {FL FR BR BL Rightward Leftward}) ~
                        (then
                            (remove 
                                ("AdjacentEnemyPieces" (last To))
                            )		
                        )	 
                    )	
                )
                ("StepToEmpty" Adjacent
                    (then 
                        (if (!= 0 (count Sites in:("AdjacentEnemyPieces" (last To))))
                            (and
                                (remove 
                                    ("AdjacentEnemyPieces" (last To))
                                )
                                (set Value Mover Undefined)
                            )
                            (if (< (value Player Mover) 1)
                                (and
                                    (set Value Mover (+ 1 (value Player Mover)))
                                    (moveAgain)
                                )
                                (set Value Mover Undefined)
                            )
                        )
                    )
                )
            )
        )
        
        (piece "HeavenlyTetrarch"
            (or {
                ("DoubleStep" N S)
                ("DoubleStep" NE SW)
                ("DoubleStep" E W)
                ("DoubleStep" SE NW)
                ("DoubleStep" S N)
                ("DoubleStep" SW NE)
                ("DoubleStep" W E)
                ("DoubleStep" NW SE)
                (move Slide
                    (directions {FR FL BR BL Forward Backward})
                    (between 
                        if:(or 
                            (is Empty (between))
                            (is In (between) (sites Around (from)))
                        )
                    )
                    (to 
                        if:(and 
                            (not (is In (to) (sites Around (from)))) 
                            ("IsEnemyAt" (to))
                        ) 
                        (apply 
                            if:(not (is In (to) (sites Around (from)))) 
                            (if 
                                ("IsEnemyAt" (to)) 
                                (remove (to))
                            )
                        )
                    ) 
                )	
                (move Slide 
                    (directions {Rightward Leftward}) 
                    (between 
                        (max 3)
                        if:(or 
                            (is Empty (between))
                            (is In (between) (sites Around (from)))
                        )
                    )
                    (to 
                        if:(and 
                            (not (is In (to) (sites Around (from)))) 
                            ("IsEnemyAt" (to))
                        ) 
                        (apply 
                            if:(not (is In (to) (sites Around (from)))) 
                            (if 
                                ("IsEnemyAt" (to)) 
                                (remove (to))
                            )
                        )
                    ) 
                )	
            })
        )
        
        (piece "WaterBuffalo"
            (or 
                ("SlideMove" (directions {FR FL BR BL Rightward Leftward}))
                ("SlideMove" (directions {Forward Backward}) (between (max 2)))
                "Promote"
            )
        )
        
        (piece "ChariotSoldier"
            (or 
                ("SlideMove" (directions {FR FL BR BL Forward Backward}))
                ("SlideMove" (directions {Rightward Leftward}) (between (max 2)))
                "Promote"
            )	
        )
        
        (piece "SideSoldier"
            (or {
                ("SlideMove" (directions {Rightward Leftward}))
                ("SlideMove" Forward (between (max 2)))
                ("StepMove" Backward)
                }
                "Promote"
            )	
        )
        
        (piece "VerticalSoldier"
            (or {
                ("SlideMove" Forward)
                ("SlideMove" (directions {Rightward Leftward}) (between (max 2)))
                ("StepMove" Backward)
                }
                "Promote"
            )	
        )
        
        (piece "Knight" ("ForwardKnightMove" "Promote"))
        
        (piece "IronGeneral" ("StepMove" (directions {Forward FR FL}) "Promote"))
        
        (piece "FreeEagle"
            (or {
                ("SlideMove" Adjacent)
                ("DoubleStep" NE NE)
                ("DoubleStep" NE NW)
                ("DoubleStep" NE SE)
                ("DoubleStep" SE SE)
                ("DoubleStep" SE NE)
                ("DoubleStep" SE SW)
                ("DoubleStep" SW SW)
                ("DoubleStep" SW NW)
                ("DoubleStep" SW SE)
                ("DoubleStep" NW NW)
                ("DoubleStep" NW NE)
                ("DoubleStep" NW SW)
                }
            )		
        )
        
        (piece "LionHawk"
            (or {
                ("SlideMove" Diagonal)
                ("DoubleStep" Adjacent N)
                ("DoubleStep" Adjacent S)
                ("DoubleStep" Adjacent E)
                ("DoubleStep" Adjacent W)
                ("DoubleStep" Adjacent NE)
                ("DoubleStep" Adjacent NW)
                ("DoubleStep" Adjacent SW)
                ("DoubleStep" Adjacent SE)
                ("HopMove" Adjacent)
                (move
                    Leap 
                    "KnightWalk" 
                    (to 
                        if:(not ("IsFriendAt" (to))) 
                        ("CaptureEnemy")
                    ) 
                )
                }
            )
        )
        
        (piece "Queen" ("SlideMove" Adjacent ~ "Promote"))
        
        (piece "Phoenix"
            (or
                ("StepMove" Orthogonal)
                ("HopMove" Diagonal)
                "Promote"
            )
        )
        
        (piece "Kirin"
            (or
                ("StepMove" Diagonal)
                ("HopMove" Orthogonal)
                "Promote"
            )	
        )
        
        (piece "FreeBoar" ("SlideMove" (directions {FR FL BR BL Rightward Leftward})))
        
        (piece "FlyingOx" ("SlideMove" (directions {FR FL BR BL Forward Backward})))
        
        (piece "SideMover"
            (or
                ("StepMove" (directions {Forward Backward}))
                ("SlideMove" (directions {Rightward Leftward}))
                "Promote"
            )
        )
        
        (piece "VerticalMover"
            (or
                ("StepMove" (directions {Rightward Leftward}))
                ("SlideMove" (directions {Forward Backward}))
                "Promote"
            )	
        )
        
        (piece "CopperGeneral"
            ("StepMove" (directions {Forward Backward FR FL}) "Promote")
        )
        
        (piece "SilverGeneral"
            ("StepMove" (directions {Forward BR BL FR FL}) "Promote")
        )
        
        (piece "MultiGeneral"
            ("SlideMove" (directions {Forward BR BL}))		
        )
        
        (piece "FlyingStag"
            (or
                ("SlideMove" (directions {Forward Backward}))	
                ("StepMove" (directions {Rightward Leftward BR BL FR FL}))
            )
        )
        
        (piece "Dog"
            ("StepMove" (directions {BR BL Forward}) "Promote")
        )
        
        (piece "BlindTiger" ("StepMove" (difference Adjacent (directions {Forward})) "Promote"))
        
        (piece "WhiteHorse" ("SlideMove" (directions {Forward FR FL Backward})))
        
        (piece "Whale" ("SlideMove" (directions {Forward BR BL Backward})))
        
        (piece "Lance" ("SlideMove" Forward ~ "Promote"))
        
        (piece "ReverseChariot" ("SlideMove" (directions {Forward Backward}) ~ "Promote"))
        
        (regions "Promotion" P1 (expand (sites Top) steps:4))
        (regions "Promotion" P2 (expand (sites Bottom) steps:4))
        
        (map "Promoted" { 
            (pair (id "FerociousLeopard" P1) (id "Bishop" P1)) (pair (id "FerociousLeopard" P2) (id "Bishop" P2))
            (pair (id "Bishop" P1) (id "DragonHorse" P1)) (pair (id "Bishop" P2) (id "DragonHorse" P2))
            (pair (id "DragonHorse" P1) (id "HornedFalcon" P1)) (pair (id "DragonHorse" P2) (id "HornedFalcon" P2))
            (pair (id "HornedFalcon" P1) (id "BishopGeneral" P1)) (pair (id "HornedFalcon" P2) (id "BishopGeneral" P2))
            (pair (id "BishopGeneral" P1) (id "ViceGeneral" P1)) (pair (id "BishopGeneral" P2) (id "ViceGeneral" P2))
            (pair (id "Knight" P1) (id "SideSoldier" P1)) (pair (id "Knight" P2) (id "SideSoldier" P2))
            (pair (id "SideSoldier" P1) (id "WaterBuffalo" P1)) (pair (id "SideSoldier" P2) (id "WaterBuffalo" P2))
            (pair (id "WaterBuffalo" P1) (id "FireDemon" P1)) (pair (id "WaterBuffalo" P2) (id "FireDemon" P2))
            (pair (id "Phoenix" P1) (id "Queen" P1)) (pair (id "Phoenix" P2) (id "Queen" P2))
            (pair (id "Queen" P1) (id "FreeEagle" P1)) (pair (id "Queen" P2) (id "FreeEagle" P2))
            (pair (id "CopperGeneral" P1) (id "SideMover" P1)) (pair (id "CopperGeneral" P2) (id "SideMover" P2))
            (pair (id "SideMover" P1) (id "FreeBoar" P1)) (pair (id "SideMover" P2) (id "FreeBoar" P2))
            (pair (id "Dog" P1) (id "MultiGeneral" P1)) (pair (id "Dog" P2) (id "MultiGeneral" P2))
            (pair (id "Lance" P1) (id "WhiteHorse" P1)) (pair (id "Lance" P2) (id "WhiteHorse" P2))
            (pair (id "DrunkenElephant" P1) (id "Prince" P1)) (pair (id "DrunkenElephant" P2) (id "Prince" P2))
            (pair (id "Pawn" P1) (id "GoldGeneral" P1)) (pair (id "Pawn" P2) (id "GoldGeneral" P2))
            (pair (id "GoldGeneral" P1) (id "Rook" P1)) (pair (id "GoldGeneral" P2) (id "Rook" P2))
            (pair (id "Rook" P1) (id "DragonKing" P1)) (pair (id "Rook" P2) (id "DragonKing" P2))
            (pair (id "DragonKing" P1) (id "SoaringEagle" P1)) (pair (id "DragonKing" P2) (id "SoaringEagle" P2))
            (pair (id "SoaringEagle" P1) (id "RookGeneral" P1)) (pair (id "SoaringEagle" P2) (id "RookGeneral" P2))
            (pair (id "RookGeneral" P1) (id "GreatGeneral" P1)) (pair (id "RookGeneral" P2) (id "GreatGeneral" P2))
            (pair (id "IronGeneral" P1) (id "VerticalSoldier" P1)) (pair (id "IronGeneral" P2) (id "VerticalSoldier" P2))
            (pair (id "VerticalSoldier" P1) (id "ChariotSoldier" P1)) (pair (id "VerticalSoldier" P2) (id "ChariotSoldier" P2))
            (pair (id "ChariotSoldier" P1) (id "HeavenlyTetrarch" P1)) (pair (id "ChariotSoldier" P2) (id "HeavenlyTetrarch" P2))
            (pair (id "Kirin" P1) (id "Lion" P1)) (pair (id "Kirin" P2) (id "Lion" P2))
            (pair (id "Lion" P1) (id "LionHawk" P1)) (pair (id "Lion" P2) (id "LionHawk" P2))
            (pair (id "SilverGeneral" P1) (id "VerticalMover" P1)) (pair (id "SilverGeneral" P2) (id "VerticalMover" P2))
            (pair (id "VerticalMover" P1) (id "FlyingOx" P1)) (pair (id "VerticalMover" P2) (id "FlyingOx" P2))
            (pair (id "BlindTiger" P1) (id "FlyingStag" P1)) (pair (id "BlindTiger" P2) (id "FlyingStag" P2))
            (pair (id "ReverseChariot" P1) (id "Whale" P1)) (pair (id "ReverseChariot" P2) (id "Whale" P2))
        })
    })
    (rules 
        (start {
            
            (place "Lance1" (sites {"A1" "P1"})) (place "Lance2" (sites {"A16" "P16"}))
            (place "Knight1" (sites {"B1" "O1"})) (place "Knight2" (sites {"B16" "O16"}))
            (place "FerociousLeopard1" (sites {"C1" "N1"})) (place "FerociousLeopard2" (sites {"C16" "N16"}))
            (place "IronGeneral1" (sites {"D1" "M1"})) (place "IronGeneral2" (sites {"D16" "M16"}))
            (place "CopperGeneral1" (sites {"E1" "L1"})) (place "CopperGeneral2" (sites {"E16" "L16"}))
            (place "SilverGeneral1" (sites {"F1" "K1"})) (place "SilverGeneral2" (sites {"F16" "K16"}))
            (place "GoldGeneral1" (sites {"G1" "J1"})) (place "GoldGeneral2" (sites {"G16" "J16"}))
            (place "King1" (sites {"H1"})) (place "King2" (sites {"I16"}))
            (place "DrunkenElephant1" (sites {"I1"})) (place "DrunkenElephant2" (sites {"H16"}))
            
            
            (place "ReverseChariot1" (sites {"A2" "P2"})) (place "ReverseChariot2" (sites {"A15" "P15"}))
            (place "ChariotSoldier1" (sites {"C2" "N2" "D2" "M2"})) (place "ChariotSoldier2" (sites {"C15" "N15" "D15" "M15"}))
            (place "BlindTiger1" (sites {"F2" "K2"})) (place "BlindTiger2" (sites {"F15" "K15"}))
            (place "Kirin1" (sites {"G2"})) (place "Kirin2" (sites {"J15"}))
            (place "Lion1" (sites {"H2"})) (place "Lion2" (sites {"I15"}))
            (place "Queen1" (sites {"I2"})) (place "Queen2" (sites {"H15"}))
            (place "Phoenix1" (sites {"J2"})) (place "Phoenix2" (sites {"G15"}))
            
            
            (place "SideSoldier1" (sites {"A3" "P3"})) (place "SideSoldier2" (sites {"A14" "P14"}))
            (place "VerticalSoldier1" (sites {"B3" "O3"})) (place "VerticalSoldier2" (sites {"B14" "O14"}))
            (place "Bishop1" (sites {"C3" "N3"})) (place "Bishop2" (sites {"C14" "N14"}))
            (place "DragonHorse1" (sites {"D3" "M3"})) (place "DragonHorse2" (sites {"D14" "M14"}))
            (place "DragonKing1" (sites {"E3" "L3"})) (place "DragonKing2" (sites {"E14" "L14"}))
            (place "WaterBuffalo1" (sites {"F3" "K3"})) (place "WaterBuffalo2" (sites {"F14" "K14"}))
            (place "FireDemon1" (sites {"G3" "J3"})) (place "FireDemon2" (sites {"G14" "J14"}))
            (place "LionHawk1" (sites {"H3"})) (place "LionHawk2" (sites {"I14"}))
            (place "FreeEagle1" (sites {"I3"})) (place "FreeEagle2" (sites {"H14"}))
            
            
            (place "SideMover1" (sites {"A4" "P4"})) (place "SideMover2" (sites {"A13" "P13"}))
            (place "VerticalMover1" (sites {"B4" "O4"})) (place "VerticalMover2" (sites {"B13" "O13"}))
            (place "Rook1" (sites {"C4" "N4"})) (place "Rook2" (sites {"C13" "N13"}))
            (place "HornedFalcon1" (sites {"D4" "M4"})) (place "HornedFalcon2" (sites {"D13" "M13"}))
            (place "SoaringEagle1" (sites {"E4" "L4"})) (place "SoaringEagle2" (sites {"E13" "L13"}))
            (place "BishopGeneral1" (sites {"F4" "K4"})) (place "BishopGeneral2" (sites {"F13" "K13"}))
            (place "RookGeneral1" (sites {"G4" "J4"})) (place "RookGeneral2" (sites {"G13" "J13"}))
            (place "GreatGeneral1" (sites {"H4"})) (place "GreatGeneral2" (sites {"I13"}))
            (place "ViceGeneral1" (sites {"I4"})) (place "ViceGeneral2" (sites {"H13"}))
            
            
            (place "Pawn1" (sites Row 4)) (place "Pawn2" (sites Row 11))
            
            
            (place "Dog1" (sites {"E6" "L6"})) (place "Dog2" (sites {"E11" "L11"}))
        })
        
        (play 
            (if ("SameTurn")
                (or
                    (if (= (what at:(last To)) (id "ViceGeneral" Mover))
                        (forEach Piece "ViceGeneral")
                        (if (= (what at:(last To)) (id "FireDemon" Mover))
                            (forEach Piece "FireDemon")
                            (move 
                                Promote 
                                (last To) 
                                (piece (mapEntry "Promoted" (what at:(last To)))) 
                                (then (set State at:(last To) 1))
                            )
                        )
                    )
                    (move Pass (then (set Value Mover Undefined)))
                )
                (forEach Piece)
                (then ("PassiveBurn"))
            )
        )
        
        (end 
            (if 
                (and { 
                    (not (is Mover Next)) 
                    ("IsOffBoard" (where "King" Next)) 
                    ("IsOffBoard" (where "Prince" Next)) 
                }) 
                (result Mover Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Halma" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board (square ("Dim"))) 
        (piece "Counter" Each)
        <Version:home>
    }) 
    (rules 
        (start { 
            <Version:start>
        })
        
        phases:{
        (phase "Movement" 
            (play 
                (forEach Piece 
                    (or 
                        ("HopSequence" (from)) 
                        (move Step
                            (to 
                                if:(and
                                    (is Empty (to))
                                    (or
                                        (not ("FromIsOnTheRegionToFill" (from)))
                                        ("ToIsOnTheRegionToFill" (to))
                                    )
                                )
                            )
                        )
                    )
                )
            ) 
            (nextPhase (is Mover (next)) "MultiJump")
        ) 
        (phase "MultiJump" 
            (play 
                (or 
                    ("HopSequence" (last To)) 
                    (move Pass)
                )
            ) 
            (nextPhase (not (is Mover (next))) "Movement")
        ) 
        }
        
        (end ("FillWin" (sites (player (mapEntry (mover)))))) 
    )
)
Halma was invented in 1883 by George Howard Monks in Boston, and inspired other games such as Chinese Checkers.Played on a 16x16 checkered board. Can be played with two or four players. It is played with nineteen pieces for a two-player game, thirteen for a four-player game. The pieces begin play in opposing corners of the board, called the \ The version of the game played with 2 players. The game is played on a 4x4 board.

Construct a Ludii game based on the following description
Crusade can be played on a 8x8 square board. In the initial position, all squares are occupied by a stone: white stones on the white squares and black stones on the black squares.Each stone must move to any adjacent(orthogonal or diagonal) cell, which is occupied by an enemy stone. This stone is captured by replacement. After that, all adjacent enemy stones (orthogonal or diagonal) are converted to friendly ones. There are fewer and fewer stones on the board as the game proceeds, which is a major difference with Othello and Ataxx.
            
        The player which has more stones, after there is no valid move left, wins the game. 
(game "Crusade"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Ball" Each
            ("StepToEnemy" ~
                (then
                    (forEach Site
                        (sites Around (last To))
                        (if ("IsEnemyAt" (site))
                            (and
                                (remove (site))
                                (add (piece (id "Ball" Mover)) (to (site)))
                            )
                        )
                    )
                )
            )
        )
    })
    (rules
        (start {
            (place "Ball1" (sites Phase 1))
            (place "Ball2" (sites Phase 0))
        })
        
        (play (forEach Piece))
        
        (end (if (no Moves Next)
                (byScore {
                    (score P1 (count Pieces P1))
                    (score P2 (count Pieces P2))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Waurie is a two-row mancala-style board game from the Cayman Islands. This game does not involve captures, and players attempt to empty their row of holes to win.Two rows of six holes with two stores. Each player owns the store to their right. Four counters in each hole. Sowing occurs from any hole in the player's row in an anti-clockwise direction. Sowing includes the player's store but not the opponent's. When the final counter lands into the player's store, they play again. When a player has no more counters in their row, they win, even if it is now the opponent's turn and they could place counters in the player's row. 
(game "Waurie" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "0,ESE,E,ENE,WNW,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 LastSite) (pair P2 FirstSite)}) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 4 to:(union (sites P1) (sites P2))))
        
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        apply:(if (= (to) (mapEntry Mover))
                            (moveAgain)
                        )
                        skipIf:(= (to) (mapEntry Next))
                    )
                )
            )
        )
        
        (end
            (if (all Sites (sites Mover) if:(= 0 (count at:(site))))
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Havannah is a connection game invented by Christian Freeling and played on a hexagonal board.Players take turns placing pieces on the board. There are three winning conditions: 1. Connect any three edges (without corner points), or 2. Make a bridge connection between any two corners, or 3. loop around any site. The game is played on a 4x4 board The game uses the swap rule.
(game "Havannah" 
    (players 2) 
    (equipment { 
        (board (hex <Board>)) 
        (piece "Marker" Each) 
    }) 
    (rules 
        <Meta:rule>
        (play (move Add (to (sites Empty))))
        (end 
            (if 
                (or {
                    (is Loop) 
                    (is Connected 3 SidesNoCorners) 
                    (is Connected 2 Corners) 
                })
                (result Mover Win)
            )
        ) 
    )
)

Construct a Ludii game based on the following description
Dice Chess is a variant of Chess involving a die.This game is a variant of classic Chess, which adds a random factor to the strategy. The following list describes all differences of the rules:
            There is no check or checkmate, it is allowed to move the king to a square attacked by opponent's piece. The goal is to capture opponent's king.
            
            A die is rolled for every move. The number determines which piece can be used to make the move. 1 - pawn, 2 - knight, 3 - bishop, 4 - rook, 5 - queen, 6 - king.
        If a pawn is to be promoted (would advance to the last row), the player can move it even if the die does not show 1. However, he can only promote it to the piece chosen by the die roll - for example, if 3 is rolled, the pawn can be promoted to a bishop only. If 1 is rolled, the pawn can be promoted to any piece. The game is played on a 8x8 board.
(game "Dice Chess" 
    (players {(player N) (player S) }) 
    (equipment { 
        (board (square <Board:size>))
        (dice d:6 from:1 num:1)
        
        (piece "Pawn" Each
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    ("DoubleStepForwardToEmpty")
                )
                ("StepForwardToEmpty") 
                ("CaptureForwardDiagonal")
                }
                (then ("ReplayInMovingOn" (sites Mover "Promotion")))
            )
        )
        ("ChessBishop" "Bishop")
        ("ChessKnight" "Knight")
        ("ChessRook" "Rook")
        ("ChessQueen" "Queen")
        ("ChessKing" "King_noCross")
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    
    (rules 
        <Board:start>
        
        (play 
            (do (if ("NewTurn") (roll))
                next:(if ("SameTurn")
                    (if (= (count Pips) 1)
                        (or {
                            ("PromoteTo" "Bishop")
                            ("PromoteTo" "Knight")
                            ("PromoteTo" "Rook")
                            ("PromoteTo" "Queen")
                            ("PromoteTo" "King_noCross")
                        })
                        (if (= (count Pips) 2)
                            ("PromoteTo" "Knight")
                            (if (= (count Pips) 3)
                                ("PromoteTo" "Bishop")
                                (if (= (count Pips) 4)
                                    ("PromoteTo" "Rook")
                                    (if (= (count Pips) 5)
                                        ("PromoteTo" "Queen")
                                        ("PromoteTo" "King_noCross")
                                    )
                                )
                            )
                        )
                    )
                    "PlayAPiece"
                )
            )
        )
        
        (end 
            (if "NoEnemyKings"
                (result Next Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Go with the Floe was invented by Phil Leduc. It is a chase game in which a player has seals pursued by another player's polar bears.Players take turns moving their pieces. Black starts. Players may: Move one or two empty spaces in any direction, or hop over one ring marker in any direction into an empty space. multiple jumps. White may capture an opponent's piece by moving onto its space from an adjacent one. Both the white and black pieces are removed from play. After moving or capturing, the moving player places a hole-in-the-ice ring marker on the moving tokens starting space and any empty space passed over. The goal for the white player is to capture both black tokens. The goal for the black player is to isolate at least one of their pieces so that it cannot be captured. If both players cannot play, black wins. 
(game "Go with the Floe" 
    (players 2) 
    (equipment { 
        (board 
            (keep 
                (square 8) 
                (poly { {-3 4} {4 -3} {11 4} {4 11} })
            ) 
        )
        (piece "Seal" P1 N (or 
                (move Slide
                    (between 
                        (max 2) 
                        trail:(id "Disc0")
                    ) 
                ) 
                (move Hop
                    (between if:("IsPieceAt" "Disc0" Neutral (between)))
                    (to if:(is Empty (to))) 
                    (then "LetADiscOnTheFromLocation")
                )
            )
        )
        (piece "Bear" P2 (or {
                (move Slide
                    (between 
                        (max 2) 
                        trail:(id "Disc0")
                    ) 
                ) 
                (move Hop
                    (between if:("IsPieceAt" "Disc0" Neutral (between))) 
                    (to if:(is Empty (to))) 
                    (then "LetADiscOnTheFromLocation")
                )
                (move Step
                    (to 
                        if:("IsPieceAt" "Seal1" P1 (to))
                        (apply (remove (to)))
                    )
                    (then 
                        (and 
                            (remove (last To)) 
                            ("LetADiscOnTheFromLocation")
                        )
                    )
                )
            })
        )
        (piece "Disc" Neutral)
    })
    
    (rules 
        (start { 
            (place "Bear2" {"G2" "G7"})
            (place "Seal1" {"B2" "B7"})
        })
        
        (play (forEach Piece))
        
        (end {
            (if ("NoSites" (sites Occupied by:All)) (result P2 Win))
            (if 
                (and 
                    (no Moves P1) 
                    (not (can Move 
                            (forEach Piece "Bear" 
                                (step 
                                    (to if:("IsPieceAt" "Seal1" P1 (to)))
                                )
                            )
                    ))
                ) 
                (result P1 Win)
            )
            (if (all Passed) (result P1 Win))
        })
    )
)

Construct a Ludii game based on the following description
The Jeu de Renard is a hunt game played on a Draughts board from early modern France. This is the standard version, where one fox plays against twelve hens.8x8 Draughts board. One player plays with a single fox, the other with twelve hens, played on the white squares. The hens begin on the first three rows; the fox may begin on whatever spot the player chooses. Hens move one space forward diagonally, the fox moves one space diagonally forward or backward. The fox may capture a hen by hopping over it to an empty space diagonally on the other side of it. The hens win by blocking the fox from being able to move; the fox wins by capturing all the hens. 
(game "Jeu de Renard" 
    (players 2) 
    (equipment { 
        (board (square 8)) 
        (piece "Fox" P1 
            (or
                "StepDiagonalToEmpty"
                "HopDiagonalCapture"
            )
        )
        (piece "Hen" P2 N ("StepToEmpty" (directions {FR FL})))
        (hand P1)
    }) 
    (rules 
        (start { 
            (place "Fox1" (handSite P1))
            (place "Hen2" (difference (expand (sites Bottom) steps:2) (sites Phase 0)))
        })
        
        phases:{
        (phase "Placement" P1
            (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Phase 0)))))
            (nextPhase "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("NoMovesP1NoPiecesP2")) 
    )
)

Describe the mechanics of the following Ludii game
(game "Scachs" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then
                (if (and ("IsOffBoard" (where "Queen" Mover)) (is In (last To) (sites Mover "Promotion")))
                    (promote (last To) (piece {"Queen"}) Mover)
                )
            )
        )
        
        ("ChessRook" "Rook" ~ ("RememberPieceHasMoved"))
        (piece "King" Each 
            (or
                (if (and (not ("IsInCheck" "King" Mover)) ("HasNeverMoved" "King"))
                    (move Slide
                        (between (exact 2))
                        (to if:(is Empty (to)))
                    )
                )
                ("StepToNotFriend")
                "RememberPieceHasMoved"
            )
        )
        ("ChessBishop" "Bishop")
        ("ChessKnight" "Knight")
        (piece "Queen" Each 
            (move
                Slide 
                (to 
                    if:(and (not ("IsPieceAt" "Queen" Next (to))) ("IsEnemyAt" (to))) 
                    "CaptureToPiece"
                ) 
            ) 
        )
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (do 
                (or 
                    (forEach Piece)
                    (if (and 
                            ("HasNeverMoved" "King")
                            (not ("IsInCheck" "King" Mover)) 
                        )
                        (or
                            (if (and 
                                    ("HasNeverMoved" "RookLeft")
                                    (can Move ("CastleRook" "RookLeft" E 3 (is Empty (to))))
                                )
                                "BigCastling"
                            )
                            (if (and 
                                    ("HasNeverMoved" "RookRight")
                                    (can Move ("CastleRook" "RookRight" W 2 (is Empty (to))))
                                )
                                "SmallCastling"
                            )
                        )
                    )
                )
                ifAfterwards:(not ("IsInCheck" "King" Mover))
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (= 1 (count Pieces Next)) (result Mover Win)) 
            ("BlockWin")
        })
    )
)
Scachs is the word for Chess in Catalan. This version of the game is described in the fifteenth century poem. The poem describes the courtship of Venus and Mars through a game of Scachs played between them, observed by Mercury.
            Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space orthogonally forward, or two steps orthogonally forward on their first move, capture one space diagonally forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally, cannot capture another Queen; Kings (1): can move one space orthogonally or diagonally, but on the first turn may move two squares provided it is not currently in check. The King cannot capture with this move. Castling, En Passant, and Pawn promotion allowed. Pawns promote to Queens when reaching the last row on the board only if that player's Queen has already been captured. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. If the opponent is reduced to only a king, it is considered a win. Stalemate is also a win for the player causing the stalemate. 
            
         

Construct a Ludii game based on the following description
Säntäräj is a capturing game played in Ethiopia since at least the seventeenth century, among the ruling classes. It is very similar to Shatranj, though it begins with an opening phase known as Wärära (\8x8 board. The pieces move as follows, with the number per player: 1 x Negus (king): moves one space orthogonally or diagonally. 1 x Ferz (counselor): One square diagonally. 2 x Der (castle): Any number of spaces orthogonally. 2 x Säbä (man): Three squares diagonally, jumping over the first two. 2 x Färäs (horse): Moves as a chess knight. 8 x Médéq: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Ferz when reaching the eighth rank. No castling, except in the opening phase. In the opening phase, players play simultaneously at will, with no turn structure, until the first piece is captured, at which point turns alternate for the main phase of the game. Castling is allowed during the opening phase, and pawns may move any distance forward. If only a player's Negus remains, the opponent must checkmate it in ten moves or less, or the game is a stalemate. The player who checkmates the king wins. 
(game "Santaraj"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (hand Each size:5)
        ("ChessKing" "King_noCross")
        ("ChessRook" "Castle")
        (piece "Ferz_noCross" Each
            (move Hop Diagonal 
                (between (exact 2) if:True) 
                (to
                    if:(not ("IsFriendAt" (to))) 
                    (apply (if ("IsEnemyAt" (to)) (remove (to)))) 
                ) 
            )		
        )
        ("ChessKnight" "Knight")
        ("ChessPawn" "Pawn" ~ (then ("PromoteIfReach" (sites Mover "Promotion") "Queen")))
        (piece "Queen" Each ("StepToNotFriend" Diagonal))
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Castle1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Ferz_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Castle2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Ferz_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        (play 
            (do
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
                (then 
                    (if
                        (and
                            (> (count Pieces P1) 1) 
                            (> (count Pieces P2) 1) 
                        )	
                        (set Counter)
                    )
                )
            )		
        )
        (end {
            ("Checkmate" "King_noCross")
            (if 
                (and 
                    (or
                        (= (count Pieces P1) 1) 
                        (= (count Pieces P2) 1) 
                    )	
                    (= (counter) 20)
                ) 
                (result Mover Draw)
            ) 
        })
    )
)

Construct a Ludii game based on the following description
Bheri Bakhri (\3x8 board. Eight pieces per player, which start in the spaces of the outer rows of the board. Four cowrie shells used as dice, the number of mouths face up being the value of the throw. A throw of 1 grants the player another throw. A player must throw 1 for the first move of each of their pieces. Players may only play with one piece out of the home row at a time and cannot move the next of their pieces until the piece being played has been captured. Throws of 1 must be used to move a piece in the home row, if possible. Pieces move from left to right in the player's home row, then from right to left in the central row, left to right in the opponent's home row, and right to left in the central row. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. The player who captures all of the opponent's pieces wins. 
(game "Bheri Bakhri"
    (players 2)
    (equipment {
        (board
            (rectangle 3 8)
            {
            (track "Track1" "0,E,N1,W,N1,E,S1,W" loop:True P1)
            (track "Track2" "23,W,S1,E,S1,W,N1,E" loop:True P2)
            }
        )
        ("StickDice" 4)
        (piece "Marker" Each ("Move"))
        (regions "Home" P1 (sites Bottom))
        (regions "Home" P2 (sites Top))
    })
    (rules 
        (start { 
            (place "Marker1" (sites Bottom))
            (place "Marker2" (sites Top))
        })
        (play 
            ("RollMove"
                (if (= 1 ("ThrowValue"))
                    (priority {
                        (forEach Piece
                            ("Move" (is In (from) (sites Mover "Home")))
                        )
                        (forEach Piece)
                    })
                    (forEach Piece)
                )
                (then 
                    (if (= 1 ("ThrowValue"))
                        (moveAgain)
                    )
                )
            )
        )
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Impartial game played with the 4x4 board full of one kind of piece. A number of \A player may remove one or more adjacent pieces from a row or column. The loser is the person who takes the last piece off the board. 
(game "TacTix" 
    (players 2) 
    (equipment { 
        (board (square 4))
        (piece "Ball" Shared) 
    }) 
    
    (rules 
        (start (place "Ball" (sites Board)))
        
        (play 
            (if ("SameTurn")
                (or
                    (if (= 1 (count MovesThisTurn))
                        (move Select
                            (from (last To))
                            (to (intersection (sites Around (last To) Orthogonal) (sites Occupied by:Shared)))
                            (then
                                (and
                                    (remove (last To))
                                    (if 
                                        (and
                                            (is Occupied (ahead (last To) ("LastDirection" Cell)))
                                            (!= (last To) (ahead (last To) ("LastDirection" Cell)))
                                        )
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                        (move Select
                            (from (last To))
                            (to (ahead (last To) ("LastDirection" Cell)))
                            (then 
                                (and
                                    (remove (last To))
                                    (if (and
                                            (is Occupied (ahead (last To) ("LastDirection" Cell)))
                                            (!= (last To) (ahead (last To) ("LastDirection" Cell)))
                                        )
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                    )
                    (move Pass)
                )
                (move Remove
                    (sites Board)
                    (then (if (not (all Sites (sites Around (last To) Orthogonal) if:(is Empty (site)))) (moveAgain)))
                )
            )
        )
        
        (end ("NoMoves" Win))
    )
)

Construct a Ludii game based on the following description
Zurgaan Tal is a game of alignment from Mongolia played on a hexagonal board.Three concentric hexagons, with lines connecting the corners and midpoints of the sides. Seventeen pieces per player. Players alternate turns placing one of their pieces on an empty spot on the board. When all of the pieces are placed, they alternate turns moving one of their pieces to an empty adjacent spot along the lines of the board. During either phase, when a player places three of their pieces in a row, they may remove one of the opponent's pieces from the board. Pieces which are in a three-in-a-row arrangement cannot be removed from the board. The player who captures all of the opponent's pieces wins. 
(game "Zurgaan Tal"
    (players 2)
    
    (equipment { 
        (board
            (rotate 30 (concentric Hexagon rings:3 joinCorners:True))
            use:Vertex
        ) 
        (hand Each)
        (piece "Marker" Each 
            ("StepToEmpty" ~ (then ("ReplayIfLine3")))
        ) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:17))
        
        phases:{
        (phase "Placement"
            (play
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (move 
                        (from (handSite Mover)) 
                        (to (sites Empty)) 
                        (then ("ReplayIfLine3")) 
                    ) 
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    ("RemoveAnyEnemyPieceNotInLine3" Orthogonal)
                    (forEach Piece)
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Gabata (Wuqro)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "LeftMost" {(pair P1 0) (pair P2 11)})
    }) 
    (rules 
        
        (start {
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
            (set Count 3 to:(sites Track)) 
        })
        
        phases:{
        (phase "Opening"
            (play
                (if ("SameTurn")
                    (move Select
                        (from (var "Replay"))
                        (then
                            (sow
                                apply:(if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                    (set Var "Round" (+ 1 (var "Round")))
                                )
                            )
                        )
                    )
                    (move
                        (from 0)
                        (to 11)
                        count:(count at:(to))
                        (then
                            (and {
                                (forEach Site (sites Mover)
                                    (if (is Occupied (site)) 
                                        (fromTo
                                            (from (site))
                                            (to 11)
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (moveAgain)
                                (set Var "Replay" 11)
                            })
                        )
                    )
                )
            )
            (nextPhase (not (is Next Mover)) "Sowing")
        )
        
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles")
                            )
                            if:(is Occupied (from))
                        )
                        (then
                            (do
                                (set Var "NumSowed" (count at:(last To)))
                                next:(sow
                                    apply:(if (< 1 (count at:(to)))
                                        (if (= 4 (count at:(to)))
                                            (fromTo
                                                (from (to))
                                                (to (handSite Mover))
                                                count:4
                                            )
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                )
                                (then
                                    (and
                                        (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1)))
                                            (if (= 4 (count at:(site)))
                                                (fromTo
                                                    (from (site))
                                                    (to (handSite Mover))
                                                    count:4
                                                )
                                            )
                                        )
                                        (set Var "NumSowed" 0)
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if (= 4 ("NumPiecesOnBoard"))
                            (and { 
                                (forEach Site (sites Board)
                                    (fromTo
                                        (from (site))
                                        (to (handSite Mover))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                                (set Var "Round" (+ 1 (var "Round")))
                            })
                            (if ("NoPieceOnBoard") 
                                (and {
                                    (forget Value "OwnedP1" All)
                                    (forget Value "OwnedP2" All)
                                    (set Var "Round" (+ 1 (var "Round")))      		 
                                })
                            )
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 2 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 2 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 3 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:3
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 3 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 2 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("LeftMostEmpty"))
                                                count:2
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("LeftMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("LeftMostEmpty"))
                                        })
                                    )
                                )
                            })
                        )
                    )
                    (then
                        (if (and (is Empty (handSite P1)) (is Empty (handSite P2))) 
                            (and
                                (if 
                                    (is Even (var "Round"))
                                    (set NextPlayer (player 2))
                                    (set NextPlayer (player 1))
                                )
                                (set Pending)
                            )
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Opening")
        )
        }
    )
)
Gabata is a term used for several mancala-style board games in the Horn of Africa. This is a two-row version played in the Wuqro area of Ethiopia.2x6 board. Three counters in each hole. Play begins with a stylized move. One player takes all of the counters from their leftmost hole, and proceeding in an anti-clockwise direction, takes all of the counters from the holes in their row. They then begin sowing these counters into the opponent's row, proceeding around the board in an anti-clockwise direction. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the final counter lands in an empty hole, the turn ends. The main phase of the game begins, in which sowing continues in the same manner, but the player may begin their turn from any hole in their row. At the end of sowing, any holes containing four counters are captured by the owner of the row in which the hole is located, unless it is the hole in which the final counter fell, in which case the player captures them and the turn ends. If at the end of the game there are not sufficient counters to cause a hole to contain four, the players decide how the counters are allocated, and a new round begins. The players fill as many of their holes with four counters as they are able. The player with more counters will capture as many holes from the opponent in which they can place three or counters. If the player has two remaining counters after holes are filled with three, the opponent would cede their one remaining counter to the player to make three and the player captures one further hole. The player who played second in the previous round begins the new round with the same stylized move, and play continues as before after that. Play continues until one player owns no holes; the opponent wins. 

Construct a Ludii game based on the following description
Los Escaques is a game based on the zodiac and movements of the planets, sun and moon. Points are awarded for placing the piece in certain alignments with the other pieces. Seven players. Seven concentric circles, divided into twelve equal sections, labeled after the twelve zodiac signs. The inner circle has one space per section, the next circle out has two per section, and so on, with the outer circle having seven spaces per section. Each player controls one piece, which travels in its circle only. Each piece begins in a different section, on the first space in that section: Saturn, beginning in Aquarius; Jupiter, beginning in Sagittarius; Mars, beginning in Scorpio; Sun, beginning in Leo; Venus, beginning in Taurus; Mercury, beginning in Virgo, and the Moon, beginning in Cancer. Each player rolls a seven-sided die, to determine which piece they play as, seven being Saturn and one being the Moon, and the others in order as already given. Movement is determined by the roll of this die, and proceeds in a clockwise direction. When a piece enters a new section, the player gains or loses points. Points are allocated based on how many sections away (either forward or behind) from the new section the other pieces are located. If a piece is two sections away, the player gains 24 points; if four sections away, 36; if three sections away, the player loses 36, if six sections away, loses 72; if the same section; 144.  
(game "Los Escaques"
    (players 7)
    (equipment {
        (board
            (remove
                (concentric {0 12 24 36 48 60 72 84})
                cells:{1}
            )
            {
            (track "Ring7" {11..2 0 1} loop:True)
            (track "Ring6" {35..14 12 13} loop:True)
            (track "Ring5" {71..38 36 37} loop:True)
            (track "Ring4" {119..74 72 73} loop:True)
            (track "Ring3" {179..122 120 121} loop:True)
            (track "Ring2" {251..182 180 181} loop:True)
            (track "Ring1" {335..254 252 253} loop:True)
            }
        )
        (regions "AllSites" (sites Board))
        (piece "Marker" Each ("MovePiece"))
        (dice d:7 num:1)
        (hand Each)
        (map "FirstSite" {
            (pair 7 1) (pair 6 13) (pair 5 37) (pair 4 73)
            (pair 3 121) (pair 2 181) (pair 1 253)
        })
        (map "Score" {
            (pair 0 144) (pair 1 0) (pair 2 24) (pair 3 -36)
            (pair 4 36) (pair 5 0) (pair 6 -72)
        })
        (regions "Section0" (expand origin:1 steps:6 Out))
        (regions "Section1" (expand origin:0 steps:6 Out))
        (regions "Section2" (expand origin:2 steps:6 Out))
        (regions "Section3" (expand origin:3 steps:6 Out))
        (regions "Section4" (expand origin:4 steps:6 Out))
        (regions "Section5" (expand origin:5 steps:6 Out))
        (regions "Section6" (expand origin:6 steps:6 Out))
        (regions "Section7" (expand origin:7 steps:6 Out))
        (regions "Section8" (expand origin:8 steps:6 Out))
        (regions "Section9" (expand origin:9 steps:6 Out))
        (regions "Section10" (expand origin:10 steps:6 Out))
        (regions "Section11" (expand origin:11 steps:6 Out))
    })
    (rules 
        (start (place "Marker" "Hand"))
        phases:{
        (phase "Opening"
            (play 
                ("RollMove"
                    (if (is Empty (mapEntry "FirstSite" (count Pips)))
                        (move 
                            (from (handSite Mover))
                            (to (mapEntry "FirstSite" (count Pips)))
                        )
                        (move Pass (then (moveAgain)))
                    )
                )
            )
            (nextPhase (and (is Mover P7) (is Next P1)) "Playing")
        )
        (phase "Playing" 
            (play 
                (if (is Proposed "End")
                    (or (move Vote "End") (move Vote "No"))
                    ("RollMove"
                        (or (forEach Piece) (move Propose "End"))
                    )
                )
            )
        )
        }
        (end 
            (if 
                (is Decided "End")
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
This game, called Terhüchü, is played on a smaller board than the same game which is also played by the Angami Naga people of India.5x5 intersecting lines, with diagonals drawn in each quadrant. Ten pieces per player, which begin on the two rows closes to the player. Players alternate turns moving a piece to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it along the lines of the board to an empty spot immediately on the opposite side of the opponent's piece. The player who captures all of the opponent's pieces wins. Each player has 8 pieces.
(game "Terhuchu (Small)" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Marker" Each
            (or
                ("StepToEmpty")
                ("HopCapture")
            )
        )
    }) 
    
    (rules 
        <Start:rules>
        
        (play (forEach Piece))
        
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Invented in 1969 by Haar Hoolim and published in Sid Sackson's A Gamut of Games.Played on a 5x5 board. There are 3 'Musketeer' pieces and 22 'Enemy' pieces. Musketeers can only move by capturing enemies on any adjacent space. Enemies can only move to empty adjacent spaces. Enemies win if all three musketeers are ever on the same line or column. Musketeers win as soon as they run out of legal moves. 
(game "Three Musketeers"
    (players 2)
    (equipment {
        (board (square 5))
        (piece "Musketeer" P1 
            (move Step Orthogonal (to if:("IsEnemyAt" (to)) (apply (remove (to)))))
        )
        (piece "Enemy" P2 ("StepOrthogonalToEmpty"))
    })
    (rules
        (start {
            (place "Musketeer1" {"A1" "C3" "E5"})
            (place "Enemy2" (difference (sites Board) (sites {"A1" "C3" "E5"})))
        })
        (play (forEach Piece))
        (end {
            (if (no Moves P1) (result P1 Win))
            (if 
                (and 
                    (is Mover P1)
                    (is Line 3 Orthogonal contiguous:False)
                )
                (result P2 Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Tapatan is a very popular simple alignment game played in the Philippines. It was played during the nineteenth century, and probably is much older.3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Three pieces per player. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they win. Once all pieces are place, players take turns moving pieces one spot to an adjacent point along the lines trying to make three in a row.
         
(game "Tapatan"
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 3 3)
        (hand Each)
        (piece "Marker" Each "StepToEmpty")
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
Pippinzip is a square-board connection game for two players.  This is the 'Zipline' variant, and these rules are 'Freestyle', where there are no restrictions on the placement of Black's stones.  The game starts with a chicken ballot phase similar to Unlur, in which players both place 1-3 White stones per turn until one decides to pass their turn and take White.  Subsequently, White places one stone per turn, and Black places two stones per turn.  The Black player ('Pip') wins if they connect any two sides of the board with a single orthogonally-connected group of stones.  The White player ('Zip') wins if they connect all four sides of the board with a single group connected both orthogonally and diagonally.This game is played on a square grid board of any size, though 13x13 or 19x19 are recommended. Then the players take it in turns to place 1-3 White stones each turn until one decides to pass; that player then becomes White, and the other becomes Black.  After that, Black places two stones per turn on any empty point, while White places just one White stone per turn.  If Black connects any two sides of the board with a single orthogonally-connected group, they win; White wins if they connect all four sides with a group connected either orthogonally or diagonally.
            
        During the initial chicken ballot phase, you may add stones by clicking on available spaces, or skip the rest of your placements (by choosing the Next Player action).  Alternatively, you may Pass at the start of your turn to take White.  After that, play continues with White playing one stone and Black playing two, until one player forms a connection (draws are impossible). Played on a size 5 board.
(game "Pippinzip (Zipline variant)" 
    (players 2) 
    (equipment { 
        (board (square <Board:size>) use:Vertex) 
        (piece "Disc" Each) 
    }) 
    (rules 
        phases:{
        (phase "Opening"
            (play
                (or
                    (or
                        (move Add 
                            (piece (id "Disc" P2)) 
                            (to (sites Empty))
                            (then (if (< (count MovesThisTurn) 2) (moveAgain)))
                        )
                        "Skip"
                    )
                    (if (= (count MovesThisTurn) 0)
                        (move Pass
                            (then
                                (if
                                    (is Mover P1)
                                    (swap Players P1 P2
                                        (then
                                            (note "Player 1 is now White. Player 2 is now Black." to:All)
                                        )
                                    )
                                    (note "Player 1 is now Black. Player 2 is now White." to:All)
                                    (then
                                        (do (set NextPlayer (player 1))
                                            next:(set Var 1) 
                                        )
                                    )
                                )
                            )
                    ))
                )
            )
            (nextPhase ("IsPlayingPhase") "Playing")
        )
        (phase "Playing"
            (play
                (or 
                    (move Add (to (sites Empty) if:(= (id P1) (mover)))
                        (then 
                            (if 
                                (= 0 (count MovesThisTurn)) 
                                (moveAgain)
                            )
                        )
                    ) 
                    (move Add (to (sites Empty) if:(= (id P2) (mover))))
                )
            )
        )
        }
        (end {
            (if (and (not ("IsPlayingPhase")) ("WhiteVC")) (result Mover Win))
            (if (and {(= (id P1) (mover)) ("BlackVC")}) (result P1 Win))
            (if (and {(= (id P2) (mover)) ("WhiteVC")}) (result P2 Win)) 
        })
    )
)

Construct a Ludii game based on the following description
Shantarad is a game with captures played in Somaliland. It is closely related to the game Seega, and is typically played with stones on a board made from lines drawn in the sand.5x5 board. Players begin by placing their pieces two-by-two in places as they see fit, except for the central space. Once all the spaces except the central one are filled, the player who placed their pieces last moves a piece one space orthogonally to the empty space. Pieces are captured by surrounding them on either side by a player's own pieces. Multiple captures are allowed, and multiple pieces can be captured in a single move. A player may move their piece between two of the opponent's pieces without it resulting in a capture. Pieces in the central spot cannot be captured. If a player cannot move, the opponent must move so that the player can move on their next turn. The player to capture all of the opponent's pieces wins.
         
(game "Shantarad" 
    (players 2) 
    (equipment { 
        (board (square 5)) 
        (hand Each) 
        
        (piece "Marker" Each 
            ("StepToEmpty" Orthogonal
                (then
                    ("Custodial" (from (last To)) "CaptureAndMoveAgain")
                )
            )
        )
    }) 
    
    (rules 
        (start (place "Marker" "Hand" count:12))
        phases:{
        (phase "Placement"
            (play 
                (if (= (count Moves) 24)
                    (forEach Piece)
                    (move 
                        (from (handSite Mover)) 
                        (to (difference (sites Empty) (centrePoint))) 
                        (then 
                            (if 
                                (or (= (count Moves) 24) ("NewTurn"))
                                (moveAgain)
                            )
                        )
                    ) 
                )
            ) 
            (nextPhase (= (count Moves) 25) "Movement")
        )
        (phase "Movement" 
            (play 
                (if "SameTurn"
                    (move Step
                        (from (last To)) 
                        Orthogonal 
                        (to if:(and 
                                (is Empty (to)) 
                                (or {
                                    (and ("IsEnemyAt" (ahead (to) W)) ("IsFriendAt" (ahead (ahead (to) W) W))) 
                                    (and ("IsEnemyAt" (ahead (to) E)) ("IsFriendAt" (ahead (ahead (to) E) E))) 
                                    (and ("IsEnemyAt" (ahead (to) N)) ("IsFriendAt" (ahead (ahead (to) N) N))) 
                                    (and ("IsEnemyAt" (ahead (to) S)) ("IsFriendAt" (ahead (ahead (to) S) S))) 
                                }) 
                            )
                        )
                        (then
                            ("Custodial" (from (last To)) "CaptureAndMoveAgain")
                        )
                    )
                    (do
                        (forEach Piece) 
                        ifAfterwards:(not (no Moves Next))
                    )
                )
            )
        )
        }
        
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Tron" 
    (players 2) 
    (equipment { 
        (board (square 10)) 
        (piece "King" Each 
            (move Step 
                Orthogonal 
                (to 
                    (apply 
                        (if 
                            (is Occupied (to)) 
                            (trigger "Collision" (mover))
                        )
                    )
                ) 
                (then 
                    (add 
                        (piece (id "Square" Mover)) 
                        (to (last From)) 
                    )
                )
            )
        )
        (piece "Square" Each)
    }) 
    (rules 
        (start { 
            (place "King1" coord:"E5")
            (place "King2" coord:"F6")
        })
        
        (play (forEach Piece))
        
        (end (if (is Triggered "Collision" Mover) (result Next Win)))
    )
)
Tron is a video game based on the movie Tron by Walt Disney Pictures from 1982.In the game, played on a grid of any size, two players move their pieces simultaneously, which leave a trail behind them. The first player to run into one of the trails or the edge of the board loses. 

Construct a Ludii game based on the following description
RootZone is an experimental territorial placement meta-game of the Mycilleum family (i.e. group growth), but based on growth from edges inward, with a goal of largest group, and prohibition on touching enemy positions. The game is played on a triangular grid in the shape of a hexagon that has alternating edges of 2N and 2N+2. This shape is chosen to avoid play points at the center of the board or of its edges.                    The implementation provides a selection of restrictions on the neighborhood of the piece being placed. Non-looping option has not been implemented. The standard is placement next to any number of friendly pieces, but not next to pieces with more than 3 neighbors. Please comment to author about which variants you prefer and why.Goal: Scoring is based on your largest group (x2), with an extra point given to the first player to create a given size. 
            The player with the largest group at the end of the game thus wins, and ties go to the first player to achieve this goal.
            
            Setup: 
            Yellow starts by creating a set-up, then Orange begins actual play - Pass to skip this phase
            
            To create a set-up, Yellow first places a black blocking stone on any intersection and then a Yellow stone on an empty edge position. Orange then either begins play, or else exchanges the yellow piece with his own.
            
            Play:
            Players take turns placing their piece on an empty intersection that is either along the edge or next to another fiendly piece, but never adjacent to an enemy position.
            
            These placements are subject to 2 possible additional restrictions selected by the players before starting:
            
        A) The number range of friendly neighbors the piece being placed may have: (Standard is to play with no restriction.)
        
        and/or
        
    B) The maximum number of neighbors that are allowed for the pieces against which the piece may be placed, with 2 being standard play.
    
    Ending the game.
Play continues until both players pass consecutively, and then the final scores are compared. Board & size: Hexhex with edges alternating 2 and 4 Must place next to exactly one friendly piece, but not next to pieces that already have more than 1 neighbor.
(game "RootZone" 
    (players 2)
    (equipment {
        (board (tri <Board:size>) use:Vertex)
        (piece "Disc" Each)
        (piece "Disc" Neutral)
    })
    (rules 
        (play
            (if 
                (= -1 (counter)) 
                (or 
                    (move Pass)
                    (move Add (piece "Disc0") (to (sites Board)))
                )
                (or
                    {
                    (if (= 1 (counter))
                        (move Select 
                            (from (sites Occupied by:Enemy)) 
                            (then 
                                (remove (last To) 
                                    (then (add (to (last To))))
                                )
                            ) 
                        )
                    ) 
                    (move Pass)
                    (move Add
                        (to 
                            (difference
                                (union
                                    (sites Outer)        
                                    (sites Around (sites Occupied by:Mover)) 
                                )
                                (union { 
                                    (sites Around (sites Occupied by:Enemy)) 
                                    (sites Around "SitesTooDense")   
                                    (sites Around (sites Occupied by:Neutral)) 
                                })
                            )
                            if:(and
                                (is Empty (to)) 
                                (>=    
                                    <PlaceBy:qtyMax> 
                                    (count Pieces Mover in:(sites Around (to))) 
                                )
                            )
                        )
                        (then "ScoreUpdate")
                    )
                    }
                )
            ) 
        )
        (end 
            (if (all Passed) 
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Gioco dell'Orso is a game that was played in Piedmont, Northern Italy. It was documented in the twentieth century, but graffiti in the region suggests that the game could be much older.Two concentric circles, with four radii from the outer circle to in the center, dividing the circles into four equal parts. There are four arcs, each of which bisects a radius between where each radius intersects the circumference of each circle, the arc also intersecting with the outer circle's circumference. One player plays as a bear, which begins on the central point, the other as three hunters, which begin on any three points on the inner circle. The bear plays first. Players alternate turns moving a piece to an empty adjacent spot along the lines. When the bear is unable to move, the game ends and the players play again, switching sides. The player who lasts longest while playing as the bear wins. The game has two rounds.
(game "Gioco dell'Orso"
    (players 2) 
    (equipment { 
        (board
            (add
                (concentric {1 4 12})
                edges:{{6 8} {9 11} {12 14} {5 15}}
            )
            use:Vertex
        )
        (piece "Human" Each ("StepToEmpty"))
        (piece "Bear" Each ("StepToEmpty"))
        (hand Each)
    }) 
    
    (rules 
        (start {
            (place "Human1" (handSite P1) count:3)
            (place "Bear2" (sites Centre))
        })	
        
        <Rule:rule>
        
    )		
)

Construct a Ludii game based on the following description
Spline was invented in 2011 by Néstor Romeral Andrés. It is a game of alignment in which marbles are stacked on top of one another.Starting with white, each player places a marble on an empty space or platform (2x2 arrangement of marbles). The first player making a full line of his color on any layer wins. Lines may be diagonal. This is, for a 4x4 set, a 4-in-a-row on the first layer, or a 3-in-a-row on the 2nd layer, or a 2-in-a-row on the 3rd layer. The game is played with two players. The game is played on a 2x2 board.
(game "Spline" 
    (players <Num:players>) 
    (equipment { 
        (board (square <Board> pyramidal:True) use:Vertex) 
        (piece "Ball" Each) 
    }) 
    (rules 
        (play 
            (move Add 
                (to (sites Empty) 
                    if:(is Flat)
                )
            )
        )
        (end 
            (if 
                (is Line (- (count Rows) (layer of:(last To))) SameLayer) 
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Far-ranging stacks compete for all territory in sight.Tumbleweed is played with stackable tokens on a hexhex board.
            
            A stack is said to be seen from a hex when they are connected by a straight line, with no stacks in between.
            
            The players take turns settling hexes by placing a stack of their tokens on a hex of their choice. The height of a new stack is equal to the number of friendly stacks seen from the settled hex. Removing a stack occupying a hex and re-settling it with a new stack is possible, only as long as the new stack is taller than the previous one. This works with opponent stacks (to capture), or your own stacks (to reinforce).
            
            The board is initially empty, except for a central neutral (blue) two-stack. The first player sets up initial one-stacks: White and Red. The second player then chooses which side he wants to play, by clicking on a stone. Red goes first.
            
        The game ends when no more moves can be made by either player, or after two successive passes. The player who occupies over half the board wins. The program automatically scores indirectly controlled territory. Played on a size 5 board.
(game "Tumbleweed"
    (players 2)
    (equipment {
        (board (hex <Board>))
        (piece "Disc" Each)
        (piece "Disc" Neutral)
    })
    (rules
        (start (place Stack "Disc0" (centrePoint) count:2))
        phases:{
        (phase "Opening" 
            (play
                (if (= 0 (count Moves))
                    (move Add (piece "Disc1") (to (sites Empty)) (then (moveAgain)))
                    (if (= 1 (count Moves))
                        (move Add (piece "Disc2") (to (sites Empty)))
                        (move Select (from (union (sites Occupied by:P1) (sites Occupied by:P2)))
                            (then 
                                (if (= 1 (who at:(last From)))
                                    (do (swap Players 1 2) next:(set NextPlayer (player 1)))
                                    (pass)
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (= 3 (count Moves)) "Play")
        )
        (phase "Play"
            (play
                (or 
                    (move Select (from "PlayableSites")
                        (then
                            (add (to (last From)) count:(- "FriendlyInSight" ((size Stack at:(last From)))) stack:True)
                        )
                    )
                    (move Pass)
                )
            )
        )
        }
        (end
            (if
                (all Passed)
                (byScore {
                    (score P1 "TerritoryP1")
                    (score P2 "TerritoryP2")
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
El Mundo is a four-player race game played in medieval Spain that is related to European Tables games. It is player on a circular board, and is conceptualized as a game of the four seasons.Four players. Circular board, with 24 semi-circular sockets along the circumference, divided into four sections of six. Twelve pieces per player; the player's colors are green, red, black, and white, the sections to which they enter are in that order anti-clockwise around the board. Three seven-sided dice. Play proceeds in an anti-clockwise fashion around the board, as is the order of player turns. Players enter their pieces on the board according to the throws of the dice. The player must enter all of their pieces, and then attempt to move all of their pieces in the section of the board belonging to the player sitting opposite them. Once the player achieves this, they begin bearing their pieces off the board. When a piece lands on a spot occupied by a single piece belonging to the opponent, the opponent's piece is returned to the place where it started. When a player bears off all their pieces, they win. 
(game "El Mundo"
    (players 4)
    (equipment {
        (board 
            (concentric {24})
            {
            (track "Track1" {24 0 2 4 6 8 10 12 14 16 18 20 22 23 21 19 17 15 13} P1 directed:True)
            (track "Track2" {25 12 14 16 18 20 22 23 21 19 17 15 13 11 9 7 5 3 1} P2 directed:True)
            (track "Track3" {26 23 21 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10} P3 directed:True)
            (track "Track4" {27 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20 22} P4 directed:True)
            }
            use:Vertex
        )
        (dice d:7 num:3)
        (regions "Mundo" P1 {23 21 19 17 15 13})
        (regions "Mundo" P2 {11 9 7 5 3 1})
        (regions "Mundo" P3 {0 2 4 6 8 10})
        (regions "Mundo" P4 {12 14 16 18 20 22})
        (piece "Marker" Each
            (forEach Die
                if:("DieNotUsed")
                (if (and ("AllPiecesInLastQuadrant") (= ("NextSiteFrom" (from)) Off))
                    (move Remove (from))
                    (move
                        (from (from))
                        (to
                            ("NextSiteFrom" (from))
                            if:("NoEnemyOrOnlyOne" (to))
                            ("HittingCapture" (handSite (who at:(to))))
                        )
                    )
                )
                (then ("ReplayNotAllDiceUsed"))
            )		
        )
        (map "Entry" {(pair P1 0) (pair P2 6) (pair P3 12) (pair P4 18)})
        (hand Each)
        (regions "FinalQuadrant" P1 (sites {13 15 17 19 21 23}))
        (regions "FinalQuadrant" P2 (sites {1 3 5 7 9 11}))
        (regions "FinalQuadrant" P3 (sites {10 8 6 4 2 0}))
        (regions "FinalQuadrant" P4 (sites {22 20 18 16 14 12}))
    })
    (rules 
        (start {
            (place Stack "Marker1" (handSite P1) count:12)
            (place Stack "Marker2" (handSite P2) count:12)
            (place Stack "Marker3" (handSite P3) count:12)
            (place Stack "Marker4" (handSite P4) count:12)
        })
        (play 
            ("RollEachNewTurnMove"
                (or (forEach Piece top:True) (forEach Piece container:(mover) top:True))
            )
        )
        (end ("EscapeWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "Boseog Gonu" 
    (players 2)
    
    (equipment {
        (board
            (remove
                (merge { 
                    (rectangle 3 3 diagonals:Alternating)
                    (shift 0 -1 (rotate 180 (wedge 2))) 
                    (shift 0 2 (wedge 2)) 
                    (shift -1.5 0.5 (rotate 90 (wedge 2))) 
                    (shift 1.5 0.5 (rotate -90 (wedge 2))) 
                })
                edges:{ 
                {{1 1} {0 0}} 
                {{1 1} {2 2}} 
                {{1 1} {2 0}} 
                {{1 1} {0 2}}
                } 
            )
            use:Vertex
        )
        (piece "Disc" Each <Disc>)
    })
    
    (rules 
        (start {
            (place "Disc1" {"A3" "B3" "B4" "B2" })
            (place "Disc2" {"D2" "D3" "E3" "D4" })
        })
        (play (forEach Piece)) 
        (end ("HavingLessPiecesLoss" Next 1))
    )
)
Boseog Gonu is a Korean game of capture of uncertain history.Each player has four pieces.
            Players take turns moving a piece to an empty dot.
            A player may capture an opponent’s piece by placing a piece on either side of an opponent’s piece. If a player moves their own piece between two of the opponent’s pieces, it is not captured.
            A player wins by reducing the opponent to one piece.
         The game is played according to the rules of the source.

Describe the mechanics of the following Ludii game
(game "Selus" 
    (players 2) 
    (equipment { 
        (mancalaBoard 3 "Columns" store:None
            (track "Track" "0,E,N1,W2,17,W,S1,E2" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions "Home" P1 (union (intersection (sites Row 1) (expand (sites Right) steps:2)) (sites Bottom))) 
        (regions "Home" P2 (union (intersection (sites Row 1) (expand (sites Left) steps:2)) (sites Top))) 
        (regions "ThreeLeftMost" P1 (intersection (sites Bottom) (expand (sites Left) steps:2))) 
        (regions "ThreeLeftMost" P2 (intersection (sites Top) (expand (sites Right) steps:2))) 
    }) 
    (rules 
        
        (start (set Count 3 to:(sites Board)))
        
        (play 
            (priority {
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover)
                        )
                        if:(< 3 (count at:(site)))
                    )
                    (then
                        (do (set Var "NumSowed" (count at:(last From)))
                            next:(sow
                                apply:(if (< 1 (count at:(to)))
                                    (if (and {
                                            (= 0 (state at:(to))) 
                                            (= 4 (count at:(to)))
                                            ("NoNedf")
                                            (is In (to) (sites Next))
                                        })
                                        (set State at:(to) (mover))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(and
                                    (= 3 (count at:(to)))
                                    (is In (to) (sites Next))
                                )
                            )
                        )
                    )
                )
                (if ("OnlyHolesWithTwoOrThree")
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover)
                            )
                            if:(= 2 (count at:(site)))
                        )
                        (then
                            (do (set Var "NumSowed" (count at:(last From)))
                                next:(sow
                                    apply:(if (< 1 (count at:(to)))
                                        (if (and {
                                                (= 0 (state at:(to))) 
                                                (= 4 (count at:(to)))
                                                ("NoNedf")
                                                (is In (to) (sites Next))
                                            })
                                            (set State at:(to) (mover))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                    skipIf:(and
                                        (= 3 (count at:(to)))
                                        (is In (to) (sites Next))
                                    )
                                )
                            )
                        )
                    )
                )
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover)
                        )
                        if:(and (is Occupied (from))
                            (if ("SameTurn")
                                True
                                (if (is In (to) (sites Mover "ThreeLeftMost"))
                                    (< 3 (count at:(to)))
                                    True
                                )
                            )
                        )
                    )
                    (then
                        (do (set Var "NumSowed" (count at:(last From)))
                            next:(sow
                                apply:(if (< 1 (count at:(to)))
                                    (if (and {
                                            (= 0 (state at:(to))) 
                                            (= 4 (count at:(to)))
                                            ("NoNedf")
                                            (is In (to) (sites Next))
                                        })
                                        (set State at:(to) (mover))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(and
                                    (= 3 (count at:(to)))
                                    (is In (to) (sites Next))
                                )
                            )
                        )
                    )
                )
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover "ThreeLeftMost")
                        )
                        if:(and (= 1 (count at:(from))) (is Occupied (from)))
                    )
                    (then
                        (do (set Var "NumSowed" (count at:(last From)))
                            next:(sow
                                apply:(if (< 1 (count at:(to)))
                                    (if (and {
                                            (= 0 (state at:(to))) 
                                            (= 4 (count at:(to)))
                                            ("NoNedf")
                                            (is In (to) (sites Next))
                                        })
                                        (set State at:(to) (mover))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(and
                                    (= 3 (count at:(to)))
                                    (is In (to) (sites Next))
                                )
                            )
                        )
                    )
                )
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover "ThreeLeftMost")
                        )
                        if:(and (= 2 (count at:(from))) (is Occupied (from)))
                    )
                    (then
                        (do (set Var "NumSowed" (count at:(last From)))
                            next:(sow
                                apply:(if (< 1 (count at:(to)))
                                    (if (and {
                                            (= 0 (state at:(to))) 
                                            (= 4 (count at:(to)))
                                            ("NoNedf")
                                            (is In (to) (sites Next))
                                        })
                                        (set State at:(to) (mover))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(and
                                    (= 3 (count at:(to)))
                                    (is In (to) (sites Next))
                                )
                            )
                        )
                    )
                )
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover "ThreeLeftMost")
                        )
                        if:(and (= 3 (count at:(from))) (is Occupied (from)))
                    )
                    (then
                        (do (set Var "NumSowed" (count at:(last From)))
                            next:(sow
                                apply:(if (< 1 (count at:(to)))
                                    (if (and {
                                            (= 0 (state at:(to))) 
                                            (= 4 (count at:(to)))
                                            ("NoNedf")
                                            (is In (to) (sites Next))
                                        })
                                        (set State at:(to) (mover))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(and
                                    (= 3 (count at:(to)))
                                    (is In (to) (sites Next))
                                )
                            )
                        )
                    )
                )
            })
        )
        
        (end ("BlockWin"))
    )
)
Selus is a three-row mancala-style game played in Ethiopia since at least the nineteenth century. It is considered an aristocratic game, and was played by nobility in the Ethiopian Empire. It involves complex rules, and is said to have taken several hours to play.3x6 board. Three counters per hole. Each player owns the row of holes closest to them, as well as the right half of the central row, with respect to their perspective. Sowing occurs from left to right in the player's complete row, right to left in the player's half of the central row, then continuing from right to left in the opponent's outer row, left to right in the opponent's holes in the central row, and then continuing as before into the player's outer row. In the opening phase, players play simultaneously. When the final counter of a sowing falls into an occupied hole, the contents are picked up and sowing continues. Each player plays until their final counter falls into an empty hole; the first player to do so begins the main phase. In the main phase, players alternate turns, and picking up the counters and continuing to sow when the final counter lands in an occupied hole, and stopping when the final counter lands in an empty hole. There are some restrictions with regard to sowing. Each of the player's three leftmost holes cannot be sown from to begin a turn if they contain three counters or less, unless there are no other options for play, in which case sowing must occur from a hole with one counter, and if none are available, then it must begin from a hole with two counters, or three counters if that is the only option. Separately, if the player's other holes only contain two or three counters, the player must play from a hole containing two counters, and these must be the option closest to the opponent's holes. Players must also play from holes containing more than three counters when available. During sowing, a player may not drop a counter into any of the opponent's holes which contain three counters (except when making a nedf, see below), skipping over them and sowing in the next available holes.  When the final counter of a sowing lands in a hole in the opponent's row containing three counters, this hole becomes a \ 

Construct a Ludii game based on the following description
Kız Tavlasi is a race game played in Anatolia since at least the past 50 years, but is likely much older. It is a simple version of Tavla. 2x12 board, with spaces as points, divided in two. Fifteen pieces per player, which start stacked, two on the players' first three points and three in the next three points. Two six-sided dice. Players unstack the pieces by moving pieces off of the stack, but remaining on the same point, according to the throws of the dice. The value of the throw indicates the number of the point which can be unstacked. For example, a throw of 1 and 4 allows the player to unstack the pieces on points 1 and 4. Doubles allow the player to unstack all pieces on that point. The player then bears off the pieces from this quadrant of the board. Players bear off the pieces in the same manner as they were unstacked. The first player to bear off all their pieces wins.
         
(game "Kiz Tavlasi"
    (players 2)
    (equipment {
        ("BackgammonBoard"
            {
            (track "Track1" {7..12} P1 directed:True)
            (track "Track2" {18..13} P2 directed:True)
            } 
        ) 
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" "SiteToMoveOnTrack")
                    "RemoveAPiece"
                    (move 
                        (from) 
                        (to "SiteToMoveOnTrack")
                    )
                )
            )
        )
        (map "StartTrack" {(pair P1 7) (pair P2 18)})
    })
    (rules 
        (start {
            (place Stack "Disc1" (sites {7..9}) count:2)
            (place Stack "Disc1" (sites {10..12}) count:3)
            (place Stack "Disc2" (sites {13..15}) count:3)
            (place Stack "Disc2" (sites {16..18}) count:2)
        })
        phases:{
        (phase "UnStacking" 
            (play 
                ("RollEachNewTurnMove"
                    (forEach Die 
                        if:("DieNotUsed")
                        (or
                            (if ("PieceFullStacked" "SiteToSelect")
                                (move Select (from ("SiteToSelect"))
                                    (then 
                                        (and 
                                            (if (= 3 (size Stack at:(last To))) ("UnstackHalf") ("UnstackFull"))
                                            ("ReplayNotAllDiceUsed")
                                        )
                                    )
                                )
                            )
                            (if ("PieceHalfStacked" "SiteToSelect")
                                (move Select (from ("SiteToSelect"))
                                    (then 
                                        (and 
                                            ("UnstackFull")
                                            ("ReplayNotAllDiceUsed")
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover 
                (all Sites (sites Occupied by:Mover) if:(not ("PieceStacked" (site)))) 
                "BearingOff"
            )
        )
        (phase "BearingOff" (play 
                (do 
                    (if (or (all DiceEqual) ("NewTurn")) (roll)) 
                    next:(forEach Piece top:True)
                    (then (if (not (all DiceUsed)) (moveAgain)))
                )
            )
            (end ("EscapeWin"))
        )
        }
    )
)

Construct a Ludii game based on the following description
Neg Tugal Tuux is a game played in Mongolia. In it, two children attempt to herd a calf from its pen to its pasture. It is thought to be a representation of herding practices as play.Rectangular board, with 32 points along each long side. Lines connect the points opposite each other, as well as a diagonal line connecting each point on the left to the next highest point on the right (e.g., the first left point with the second right point, the second left point with the third right point, an so on). One player plays as the calf, which begins in the bottom right corner. The second player plays as two children, which begin in the bottom left corner and the second point on the right. Players alternate turns moving one of their pieces to an empty adjacent spot on the board along the lines. The children move first, and cannot move backward during the game. The calf can move in any direction. The children win by forcing the calf to move to the top left corner of the board, the calf wins by returning to its starting point after first having left it. 
(game "Neg Tugal Tuux"
    (players 2)
    (equipment {
        (board 
            (add 
                (scale 15 1 (rectangle 32 2))
                edges:{
                {0 3} {2 5} {4 7}
                {6 9} {8 11} {10 13}
                {12 15} {14 17} {16 19}
                {18 21} {20 23} {22 25}
                {24 27} {26 29} {28 31}
                {30 33} {32 35} {34 37}
                {36 39} {38 41} {40 43}
                {42 45} {44 47} {46 49}
                {48 51} {50 53} {52 55}
                {54 57} {56 59} {58 61} {60 63}
                }
            )
            use:Vertex
        )
        (piece "Cow" P2 "StepToEmpty")
        (piece "Human" P1 
            (move Step 
                (to 
                    if:(and (is Empty (to)) (>= 1 (- (from) (to))))
                )
            )
        )
    })
    (rules
        (start {
            (place "Cow2" 1)
            (place "Human1" (sites {0 3}))
        })
        (play (forEach Piece))
        (end {
            (if (and (is Mover P2) (= 1 (where "Cow2" P2))) (result P2 Win))
            (if (= 62 (where "Cow2" P2)) (result P1 Win))
        })
    )
)

Construct a Ludii game based on the following description
Invented after 1 second's thought.Start with a tile of each colour placed next to each other. Players take turns adding a tile of their colour touching at least one existing tile. Win by making a line of four (or more) of your colour, but lose by making a line of three of your colour beforehand. The game uses hexagonal tiles.
(game "Bravalath" 
    (players 2) 
    (equipment { 
        (boardless <Tiling:type>) 
        (tile <Tiling:tile> Each <Tiling:numSides>) 
    }) 
    
    (rules 
        (start {
            (place <Tiling:piece1> (centrePoint)) 
            (place <Tiling:piece2> (ahead (centrePoint) E))
        })
        
        (play 
            (move Add
                (to 
                    (sites Playable) 
                    if:(<= 1 
                        (count Sites in:(sites Around (to) NotEmpty)) 
                    )
                )
            )
        )
        
        (end {
            (if (is Line 4) (result Mover Win))
            (if (is Line 3) (result Mover Loss)) 
        }) 
    )
)

Construct a Ludii game based on the following description
Press Ups was invented in 1974 by Yigal Bogoslavski.One player has red pegs, the other player blue pegs. The player who can get all his color pegs pressed down first wins the game. Each player can press his opponent's color pegs. At any time during the game, if it becomes impossible to press a peg next to the last one pressed the game finishes. The player with the most of his own color pegs pressed down is the winner. 
(game "Press Ups" 
    (players 2) 
    (equipment { 
        (board (square 7)) 
        (piece "Disc" Each) 
        (piece "Disc" Neutral) 
        (regions P1 (difference (union (sites Bottom) (sites Top)) (union (sites Right) (sites Left))))
        (regions P2 (difference (union (sites Right) (sites Left)) (union (sites Bottom) (sites Top))))
    }) 
    
    (rules 
        (start {
            (place "Disc1" (sites P1))
            (place "Disc2" (sites P2))
            (place "Disc0" "AllSitesWithoutOwnedPiece")
        })
        
        phases:{
        (phase "Init" 
            (play 
                (move Select
                    (from "AllSitesWithoutOwnedPiece") 
                    (then (remove (last To)))
                )
            ) 
            (nextPhase "Remove")
        )
        (phase "Remove" 
            (play 
                (move Select
                    (from 
                        (sites Around (last To)) 
                        if:(is Occupied (from))
                    ) 
                    (then (remove (last To)))
                )
            )
        )
        }
        
        (end {
            ("CaptureAll" P1)
            ("CaptureAll" P2)
            (if (no Moves Next)
                (byScore {
                    (score P1 (count Pieces P1)) 
                    (score P2 (count Pieces P2))
                })
            )
        })
    )
)

Construct a Ludii game based on the following description
The basic idea of the game is to rearrange the balls within the labyrinth rather than finding your way out.The balls will roll until collision in the direction of the arrow to be selected for each step. For example, while you are trying to send the red ball to the desired place the other ball will roll to and fro as well. Default setup
(game "Labirintus"
    (players 1)
    (equipment {
        (board (rectangle 16 20)) 
        (piece "Square" Neutral)
        (piece "Ball1" P1 "Move")
        (piece "Ball2" P1 "Move")
        (regions "Exit2" {<Board:start1>})
        (regions "Exit1" {<Board:start2>})
        (regions "Walls" {<Board:walls>})
    })
    (rules
        (start {
            (place "Ball1" <Board:start1>)
            (place "Ball2" <Board:start2>)
            (place "Square0" (sites "Walls"))
        })
        
        (play (forEach Piece))
        
        (end {
            (if
                (and
                    (is In (where (id "Ball1")) (sites "Exit1"))
                    (is In (where (id "Ball2")) (sites "Exit2"))
                )
                (result Mover Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Center is a strange little game invented by Alek Erickson and Michael Amundsen in February of 2022. The goal is to place a stone on the center of the board, but it's not as easy as it sounds.Take turns placing stones on a hexhex board of size 4, or a square board of an odd size not larger than 9. The winner is the player who places a stone on the center cell. A placement N steps away from the perimeter must have at least N friendly pieces in sight. On the square board, pieces see in all 8 directions. A square board of size 9 is currently selected The pie rule is currenty not in force.
(game "Center" 
    (players 2) 
    (equipment { 
        <Board> 
        (piece "Marker" Each)
    })
    
    (rules 
        <Pie>
        (play 
            (move Add
                (to 
                    (sites Empty)
                    if:(<=
                        (count Steps 
                            <Board:direction>
                            (to)
                            (sites Perimeter)
                        )
                        (count Sites 
                            in:(intersection
                                (sites LineOfSight
                                    at:(to)
                                    <Board:direction>
                                )
                                (sites Occupied by:Mover)
                            )
                        )
                    )
                )
            )
        )
        
        (end 
            (if 
                (is Occupied (centrePoint)) 
                (result Next Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Tepong is a version of Main Chator played by the Batak people of Sumatra. One player, who is generally a strong player, has to checkmate their opponent in one of the central four squares of the board.8x8 board, with diagonals in every square. Pieces have special moves, as follows: Raja (king), moves one square in any direction, but on the first move, it may jump two squares or move as a knight, with the exception that it cannot jump two squares diagonally; Mantri (minister), moves orthogonally or diagonally any number of spaces; Gajah (x2); move diagonally any distance; Kuda (horse) x2, moves orthogonally one space then diagonal one space from there, jumping over any intervening pieces; Ter/Chemor (chariot) x2, moves orthogonally any distance; Bídaq (pawn) x8: moves one square forward or one square forward diagonally to capture. May move two spaces forward orthogonally if it is that piece's first move. Upon reaching the opposite edge of the board, the Bídaq moves in the opposite direction, reversing again if it reaches the opposite edge. The Mantri is placed to the right of the Raja at the beginning of play. Castling occurs in two moves, the rook moving to the king and then the king jumping over the rook. Pieces are captured by moving onto a space occupied by an opponent's piece. If the Raja can be captured on its next turn, it is in check. The Raja cannot be in check at the end of its turn. When this is unavoidable, it is checkmate and the opponent wins.
         
(game "Tepong"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 		
        (piece "King_noCross" Each
            (or
                ("StepToNotFriend" ~
                    (then
                        (if (not ("KingMovedBefore" (last To)))
                            ("RememberKingMoved" (last To))
                        )
                    )
                )	
                (if (not ("KingMovedBefore" (from)))
                    (or {
                        (move Hop
                            Orthogonal
                            (between
                                (exact 2)
                                if:True
                            )
                            (to 
                                if:(not ("IsFriendAt" (to))) 
                                (apply (if ("IsEnemyAt" (to)) (remove (to)))) 
                            ) 
                        )
                        ("LeapCapture" "KnightWalk")
                        (if (is In (from) ("KingSites"))
                            (or
                                (if (and {
                                        (is Empty (ahead (from) steps:2 W))
                                        ("IsPieceAt" "Rook" Mover (ahead (from) W))
                                        (not ("RookMovedBefore" (ahead (from) W)))
                                    })
                                    (move
                                        (from)
                                        (to (ahead (from) steps:2 W))
                                    )
                                )
                                (if (and {
                                        (is Empty (ahead (from) steps:2 E))
                                        ("IsPieceAt" "Rook" Mover (ahead (from) E))
                                        (not ("RookMovedBefore" (ahead (from) E)))
                                    })
                                    (move
                                        (from)
                                        (to (ahead (from) steps:2 E))
                                    )
                                )
                            )
                        )
                        }
                        (then ("RememberKingMoved" (last To)))
                    )
                )
            )
        )
        ("ChessQueen" "Queen")
        ("ChessBishop" "Bishop_noCross")
        ("ChessKnight" "Knight")
        ("ChessRook" "Rook" ~
            (then
                (if (and 
                        (not ("RookMovedBefore" (last To)))
                        (not (is In (last To) ("SitesNextToKing")))
                    )
                    ("RememberRookMoved" (last To))
                )
            )
        )
        (piece "Pawn" Each
            (or {
                (if (and (= 0 (state at:(last To))) (is In (from) (sites Start (piece (what at:(from))))))
                    ("DoubleStepForwardToEmpty")
                )
                ("StepToEmpty" 
                    (if (= 1 (state at:(from))) Backward Forward)
                )
                ("StepToEnemy" (if (= 1 (state at:(from))) (directions {BR BL}) (directions {FR FL})))
                }
                (then
                    (if (is In (last To) (union (sites Bottom) (sites Top))) 
                        (if (= 0 (state at:(last To)))
                            (set State at:(last To) 1)
                            (set State at:(last To) 2)
                        )
                    )
                )
            )		
        )
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "King_noCross1" coord:"D1") (place "Queen1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "King_noCross2" coord:"E8") (place "Queen2" coord:"D8") 
        })
        
        (play 
            (do
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        
        (end ("Checkmate" "King_noCross"))
    )
)

Construct a Ludii game based on the following description
Hund efter Hare is a name applied to several blockade games played in Denmark. This game was played in Thy, on a more complex board than was common elsewhere.3x5 intersecting lines, with diagonals in the four quadrants created. On either short end, an arc connects the two corner points, and the center line is extended to the arc. One player plays as four hounds, which begin on the four points to the left side of the board. The other player plays as one hare, which begins on the point where the center line and the second line cross. Players alternate turns moving a piece to an empty adjacent spot along the lines. The hounds may only move forward. The hounds win when they block the hare from being able to move. The game has an ending condition only for P2.
(game "Hund efter Hare (Thy)"
    (players 2)
    (equipment {
        (board 
            (remove
                (add
                    (merge {
                        (rectangle 3 5) 
                        (shift 1 0 (scale 0.5 (rectangle 5 1))) 
                        (shift 3 0 (scale 0.5 (rectangle 5 1))) 
                        (shift -1 1 (rectangle 1 7)) 
                    })
                    edges:{
                    {0 15} {15 7} {7 18} {18 14} {17 4} {7 17} 
                    {7 16} {16 10} {19 10} {0 19} {20 14} {20 4}
                    {12 16} {16 5} {5 15} {15 2} {2 17} {17 9}
                    {9 18} {18 12} 
                    }
                )
                edges:{{11 6} {6 1} {13 8} {8 3}}
            )
            use:Vertex
        )
        (piece "Hare" P1 "StepToEmpty")
        (piece "Dog" P2 E "StepForwardsToEmpty")
    })
    (rules 
        (start {
            (place "Hare1" coord:"C3")
            (place "Dog2" (sites {"B3" "B1" "A3" "B5"}))
        })
        (play (forEach Piece))
        <End:rule>
    )
)

Construct a Ludii game based on the following description
Taikyoku Shogi is the largest known Shogi variant, with 804 total pieces on the board. It is first documented in Japan in the Shogi Zushiki, which is reportedly from the seventeenth century.Taikyoku Shogi's rules are similar to that of Shogi, but are expanded, with many types of pieces with different movements. The full suite of movements are listed here: <a href=\ 
(game "Taikyoku Shogi" 
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        (board (square 36))
        
        (piece "King" Each ("SlideMove" ~ (between (max 2))))
        (piece "Prince" Each ("StepMove" ~ "Promote"))
        (piece "Lance" Each ("SlideMove" Forward ~ "Promote"))
        (piece "TurtleSnake" Each (or 
                ("StepMove" (directions {Forward FL FLL Backward BL BLL}))
                ("SlideMove" (directions {NE SW}))
                "Promote"
            )
        )
        (piece "WhiteTiger" Each (or 
                ("SlideMove" (directions {N S}) (between (max 2)))
                ("SlideMove" (directions {Rightward Leftward FL}))
                "Promote"
            )
        )
        (piece "RunningRabbit" Each (or
                ("SlideMove" Forwards)
                ("StepMove" Backwards)
                "Promote"
            )
        )
        (piece "Whale" Each ("SlideMove" (directions {Forward Backwards}) ~ "Promote"))
        (piece "FireDemon" Each (or
                ("SlideMove" (directions {N S}) (between (max 2)))
                ("SlideMove" (directions {Rightwards Leftwards}))
                "Promote"
            )
        )
        (piece "MountainEagleLeft" Each (or {
                ("SlideMove" BL (between (max 2)))
                ("SlideMove" (directions {Forwards Rightward Leftward Backward BR}))
                ("HopMove" (directions {FL BR}))
                }
                "Promote"
            )
        )
        (piece "MountainEagleRight" Each (or {
                ("SlideMove" BR (between (max 2)))
                ("SlideMove" (directions {Forwards Rightward Leftward Backward BL}))
                ("HopMove" (directions {FR BL}))
                }
                "Promote"
            )
        )
        (piece "LongNosedGoblin" Each (or
                ("SlideMove" Diagonal)
                (move 
                    Slide 
                    Orthogonal 
                    (to 
                        if:("IsEnemyAt" (to)) 
                        (apply 
                            if:(and 
                                (if (is Odd (row of:(from))) 
                                    (is Odd (row of:(to))) 
                                    (is Even (row of:(to)))
                                ) 
                                (if (is Odd (column of:(from))) 
                                    (is Odd (column of:(to))) 
                                    (is Even (column of:(to)))
                                ) 
                            ) 
                            (remove (to)) 
                        )
                    ) 
                )
            )
        )
        (piece "BeastCadet" Each ("SlideMove" (directions {Forwards Rightwards Leftwards}) (between (max 2)) "Promote"))
        (piece "RunningHorse" Each (or {
                ("SlideMove" Forwards)
                ("StepMove" Backward)
                ("HopMove" (directions {BL BR}))
                }
                "Promote"
            )
        )
        (piece "FreeDemon" Each (or 
                ("SlideMove" (directions {Rightward FL FR BL BR}))
                ("SlideMove" Backward (between (max 5)))
                "Promote"
            )
        )
        (piece "EarthDragon" Each (or {
                ("SlideMove" (directions {BR BL}))
                ("StepMove" Forward)
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                }
                "Promote"
            )
        )
        (piece "CeramicDove" Each (or
                ("SlideMove" Diagonal)
                ("SlideMove" Orthogonal (between (max 2)))
            )
        )
        (piece "WoodenDove" Each (or {
                ("SlideMove" Diagonal)
                ("SlideMove" Orthogonal (between (max 2)))
                ("HopMoveWithRange" Diagonal ~ (exact 2) after:2)
                }
                "Promote"
            )
        )
        (piece "FreeDreamEater" Each (or 
                ("SlideMove" (directions {Backwards Forwards}))
                ("SlideMove" (directions {E W}) (between (max 5)))
                "Promote"
            )
        )
        (piece "Queen" Each ("SlideMove" ~ ~ "Promote"))
        (piece "RearStandard" Each (or 
                ("SlideMove" Orthogonal)
                ("SlideMove" Diagonal (between (max 2)))
                "Promote"
            )
        )
        (piece "LeftGeneral" Each ("StepMove" ~ "Promote"))
        (piece "RightGeneral" Each ("StepMove")) 
        (piece "GoldGeneral" Each ("StepMove" (directions {Forward Backward Rightward Leftward FL FR}) "Promote"))
        (piece "ReverseChariot" Each ("StepMove" (directions {N S}) "Promote"))
        (piece "WhiteElephant" Each ("SlideMove" ~ (between (max 2)) "Promote"))
        (piece "FragrantElephant" Each ("SlideMove" ~ (between (max 2)) "Promote"))
        (piece "TurtleDove" Each (or 
                ("StepMove" (directions {Rightward Leftward Backward}))
                ("SlideMove" (directions {FR FL}) (between (max 5)))
                "Promote"
            )
        )
        (piece "FlyingSwallow" Each (or 
                ("StepMove" Backward)
                ("SlideMove" (directions {FR FL}))
                "Promote"
            )
        )
        (piece "CaptiveOfficer" Each (or 
                ("SlideMove" Diagonal (between (max 3)))
                ("SlideMove" (directions {Forward Rightward Leftward}) (between (max 2)))
                "Promote"
            )
        )
        (piece "RainDragon" Each (or 
                ("StepMove" Forwards)
                ("SlideMove" (directions {Backwards Rightward Leftward}))
                "Promote"
            )
        )
        (piece "ForestDemon" Each (or 
                ("SlideMove" (directions {Forward Rightward Leftward}) (between (max 3)))
                ("SlideMove" (directions {FR FL Backward}))
                "Promote"
            )
        )
        (piece "MountainStag" Each (or {
                ("SlideMove" Backward (between (max 4)))
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                ("StepMove" Forward)
                }
                "Promote"
            )
        )
        (piece "RunningPup" Each (or 
                ("SlideMove" (directions {N S}))
                ("StepMove" (directions {E W}))
                "Promote"
            )
        )
        (piece "RunningSerpent" Each (or 
                ("SlideMove" (directions {N S}))
                ("StepMove" (directions {E W}))
                "Promote"
            )
        )
        (piece "SideSerpent" Each (or {
                ("SlideMove" (directions {E W}))
                ("SlideMove" Forward (between (max 3)))
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "GreatDove" Each (or 
                ("SlideMove" Diagonal)
                ("SlideMove" Orthogonal (between (max 3)))
                "Promote"
            )
        )
        (piece "RunningTiger" Each (or 
                ("SlideMove" (directions {N S}))
                ("SlideMove" (directions {E W}) (between (max 2)))
                "Promote"
            )
        )
        (piece "RunningBear" Each (or 
                ("SlideMove" (directions {N S}))
                ("SlideMove" (directions {E W}) (between (max 2)))
                "Promote"
            )
        )
        (piece "BuddhistDevil" Each (or 
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                ("StepMove" (directions {Rightward Leftward Backward}))
                "Promote"
            )
        )
        (piece "Yaksha" Each (or 
                ("SlideMove" (directions {E W}) (between (max 3)))
                ("StepMove" (directions {FR FL Backward}))
                "Promote"
            )
        )
        (piece "Wrestler" Each ("SlideMove" Diagonal (between (max 3)) "Promote"))
        (piece "GuardianOfTheGods" Each ("SlideMove" Orthogonal (between (max 3)) "Promote"))
        (piece "SilverGeneral" Each ("StepMove" (directions {Forward BL BR FL FR}) "Promote"))
        (piece "NeighboringKing" Each ("StepMove" (directions {Forwards Rightwards Leftwards}) "Promote"))
        (piece "DrunkenElephant" Each ("StepMove" (directions {Forwards Rightwards Leftwards}) "Promote"))
        (piece "GoldChariot" Each (or 
                ("StepMove" (directions {Rightward Leftward FL FR BL BR}))
                ("SlideMove" (directions {N S}))
                "Promote"
            )
        )
        (piece "SideDragon" Each ("SlideMove" (directions {Forward Rightward Leftward}) ~ "Promote"))
        (piece "RunningStag" Each (or 
                ("SlideMove" Backward (between (max 2)))
                ("SlideMove" (directions {FR FL Rightward Leftward}))
                "Promote"
            )
        )
        (piece "RunningWolf" Each (or 
                ("StepMove" Forward)
                ("SlideMove" (directions {FR FL Rightward Leftward}))
                "Promote"
            )
        )
        (piece "BishopGeneral" Each 
            (move
                Slide 
                Diagonal 
                (between 
                    if:(not (is In (what at:(between)) 
                            (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2") (id "ViceGeneral1") (id "ViceGeneral2") (id "RookGeneral1") (id "RookGeneral2")
                            (id "BishopGeneral1") (id "BishopGeneral2") (id "ViolentDragon1") (id "ViolentDragon2") (id "FlyingCrocodile1") (id "FlyingCrocodile2")})
                        )
                    )
                    (apply (remove (between)))
                )
                (to 
                    (apply 
                        if:(not ("IsFriendAt" (to)))
                        (remove (to))
                    )
                )
                "Promote"
            )
        )
        (piece "RookGeneral" Each 
            (move
                Slide 
                Orthogonal 
                (between if:(not (is In (what at:(between)) 
                            (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2") (id "ViceGeneral1") (id "ViceGeneral2") (id "RookGeneral1") (id "RookGeneral2")
                    (id "BishopGeneral1") (id "BishopGeneral2") (id "ViolentDragon1") (id "ViolentDragon2") (id "FlyingCrocodile1") (id "FlyingCrocodile2")})))
                    (apply (remove (between)))
                )
                (to 
                    (apply 
                        if:(not ("IsFriendAt" (to)))
                        (remove (to))
                    )
                )
                "Promote"
            )
        )
        (piece "LeftTiger" Each (or 
                ("StepMove" (directions {FL BR}))
                ("SlideMove" Rightwards)
                "Promote"
            )
        )
        (piece "RightTiger" Each (or 
                ("StepMove" (directions {FR BL}))
                ("SlideMove" Leftwards)
                "Promote"
            )
        )
        (piece "LeftDragon" Each (or 
                ("SlideMove" Leftward (between (max 2)))
                ("SlideMove" Rightwards)
                "Promote"
            )
        )
        (piece "RightDragon" Each (or 
                ("SlideMove" Rightward (between (max 2)))
                ("SlideMove" Leftwards)
                "Promote"
            )
        )
        (piece "BeastOfficer" Each (or 
                ("SlideMove" (directions {FL FR BL BR Forward}) (between (max 3)))
                ("SlideMove" (directions {E W}) (between (max 2)))
                "Promote"
            )
        )
        (piece "WindDragon" Each (or 
                ("StepMove" BR)
                ("SlideMove" (directions {Forwards Rightward Leftward Backward BL}))
                "Promote"
            )
        )
        (piece "FreePup" Each (or {
                ("StepMove" (directions {BR BL}))
                ("SlideMove" (directions {FR FL Forward Backward}))
                ("SlideMove" (directions {E W}) (between (max 2)))
                }
                "Promote"
            )
        )
        (piece "RushingBird" Each (or 
                ("StepMove" (directions {BR BL FL FR Rightward Leftward}))
                ("SlideMove" Forward (between (max 2)))
                "Promote"
            )
        )
        (piece "OldKite" Each (or 
                ("StepMove" (directions {E W}))
                ("SlideMove" Diagonal (between (max 2)))
                "Promote"
            )
        )
        (piece "Peacock" Each (or 
                ("SlideMove" (directions {FR FL}))
                ("SlideMove" (directions {BR BL}) (between (max 2)))
                "Promote"
            )
        )
        (piece "WaterDragon" Each (or {
                ("SlideMove" Orthogonal)
                ("SlideMove" (directions {BR BL}) (between (max 4)))
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                }
                "Promote"
            )
        )
        (piece "FireDragon" Each (or {
                ("SlideMove" Orthogonal)
                ("SlideMove" (directions {FR FL}) (between (max 4)))
                ("SlideMove" (directions {BR BL}) (between (max 2)))
                }
                "Promote"
            )
        )
        (piece "CopperGeneral" Each ("StepMove" (directions {Forward FR FL Backward}) "Promote"))
        (piece "KirinMaster" Each (or {
                ("SlideMove" (directions {BR BL FL FR Forward Backward}))
                ("SlideMove" (directions {E W}) (between (max 3)))
                ("HopMoveWithRange" (directions {N S}) ~ (exact 2))
            })
        )
        (piece "PhoenixMaster" Each (or {
                ("SlideMove" (directions {BR BL FL FR Forward Backward}))
                ("SlideMove" (directions {E W}) (between (max 3)))
                ("HopMoveWithRange" (directions {FR FL}) ~ (exact 2))
            })
        )
        (piece "SilverChariot" Each (or {
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                ("SlideMove" (directions {N S}))
                ("StepMove" (directions {BR BL}))
                }
                "Promote"
            )
        )
        (piece "VerticalBear" Each (or {
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("SlideMove" Forward)
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "Knight" Each 
            (forEach Direction 
                Forward 
                (to 
                    if:True 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL}) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (remove (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                ) 
                "Promote" 
            )
        ) 
        (piece "PigGeneral" Each (or 
                ("SlideMove" Backward (between (max 2)))
                ("SlideMove" (directions {FR FL}) (between (max 4)))
                "Promote"
            )
        )
        (piece "ChickenGeneral" Each (or 
                ("StepMove" (directions {BR BL}))
                ("SlideMove" Forward (between (max 4)))
                "Promote"
            )
        )
        (piece "PupGeneral" Each (or 
                ("StepMove" (directions {BR BL}))
                ("SlideMove" Forward (between (max 4)))
                "Promote"
            )
        )
        (piece "HorseGeneral" Each (or 
                ("StepMove" (directions {FR FL Backward}))
                ("SlideMove" Forward (between (max 3)))
                "Promote"
            )
        )
        (piece "OxGeneral" Each (or 
                ("StepMove" (directions {FR FL Backward}))
                ("SlideMove" Forward (between (max 3)))
                "Promote"
            )
        )
        (piece "CenterStandard" Each (or 
                ("SlideMove" Orthogonal)
                ("SlideMove" Diagonal (between (max 3)))
                "Promote"
            )
        )
        (piece "SideBoar" Each (or 
                ("StepMove" (directions {Backwards Forwards}))
                ("SlideMove" (directions {E W}))
                "Promote"
            )
        )
        (piece "SilverRabbit" Each (or 
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                ("SlideMove" (directions {BR BL}))
                "Promote"
            )
        )
        (piece "GoldenDeer" Each (or 
                ("SlideMove" (directions {BR BL}) (between (max 2)))
                ("SlideMove" (directions {FR FL}))
                "Promote"
            )
        )
        (piece "Lion" Each (or {
                ("SlideMove" ~ (between (max 2)))
                (move Leap "KnightWalk" (to if:(not ("IsFriendAt" (to))) (apply (remove (to)))))
                ("HopMove")
                }
                "Promote"
            )
        )
        (piece "CaptiveCadet" Each ("SlideMove" (directions {Forwards Rightwards Leftwards}) (between (max 3)) "Promote"))
        (piece "GreatStag" Each (or {
                ("SlideMove" Orthogonal)
                ("SlideMove" (directions {BR BL}) (between (max 2)))
                ("HopMove" (directions {FR FL}))
                }
                "Promote"
            )
        )
        (piece "ViolentDragon" Each 
            (or 
                ("SlideMove" Orthogonal (between (max 2)))
                (move
                    Slide 
                    Diagonal 
                    (between if:(not (is In (what at:(between)) (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2") (id "ViceGeneral1") (id "ViceGeneral2") (id "RookGeneral1") (id "RookGeneral2")
                        (id "BishopGeneral1") (id "BishopGeneral2") (id "ViolentDragon1") (id "ViolentDragon2") (id "FlyingCrocodile1") (id "FlyingCrocodile2")})))
                        (apply (remove (between))) 
                    )
                    (to 
                        (apply 
                            if:(not ("IsFriendAt" (to)))
                            (remove (to))
                        )
                    )
                )
                "Promote"
            )
        )
        (piece "WoodlandDemon" Each (or 
                ("SlideMove" (directions {FR FL Forward Backward}))
                ("SlideMove" (directions {E W}) (between (max 2)))
                "Promote"
            )
        )
        (piece "GreatGeneral" Each 
            (move
                Slide 
                (between 
                    if:(not (is In (what at:(between)) (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2")})))
                    (apply (remove (between))) 
                )
                (to 
                    (apply 
                        if:(not ("IsFriendAt" (to)))
                        (remove (to))
                    )
                )
            )
        )
        (piece "ViceGeneral" Each 
            (or 
                ("HopMove" Orthogonal)
                (move
                    Slide
                    Diagonal
                    (between
                        if:(not (is In (what at:(between)) (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2") (id "ViceGeneral1") (id "ViceGeneral2")})))
                        (apply (remove (between)))
                    )
                    (to 
                        (apply 
                            if:(not ("IsFriendAt" (to)))
                            (remove (to))
                        )
                    )
                )
                "Promote"
            )
        )
        (piece "StoneChariot" Each
            (or {
                ("StepMove" (directions {FR FL}))
                ("SlideMove" (directions {N S}))
                ("SlideMove" (directions {E W}) (between (max 2)))
                }
                "Promote"
            )
        )
        (piece "CloudEagle" Each
            (or {
                ("StepMove" (directions {E W}))
                ("SlideMove" (directions {N S}))
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                }
                "Promote"
            )
        )
        (piece "Bishop" Each ("StepMove" Diagonal "Promote")) 
        (piece "Rook" Each ("StepMove" Orthogonal "Promote")) 
        (piece "SideWolf" Each (or 
                ("StepMove" (directions {NW SE}))
                ("SlideMove" (directions {E W}))
                "Promote"
            )
        )
        (piece "FlyingCat" Each (or 
                ("StepMove" Backwards)
                ("HopMoveWithRange" (directions {FR FL Rightward Leftward Forward}) ~ (exact 2))
                "Promote"
            )
        )
        (piece "MountainFalcon" Each (or {
                ("SlideMove" (directions {FR FL Forward Backward Rightward Leftward}))
                ("SlideMove" (directions {BR BL}) (between (max 2)))
                ("HopMove" Forward)
                }
                "Promote"
            )
        )
        (piece "VerticalTiger" Each (or 
                ("SlideMove" Forward)
                ("SlideMove" Backward (between (max 2)))
                "Promote"
            )
        )
        (piece "Soldier" Each ("StepMove" Orthogonal "Promote"))
        (piece "LittleStandard" Each (or {
                ("SlideMove" Orthogonal)
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                ("StepMove" (directions {BR BL}))
                }
                "Promote"
            )
        )
        (piece "CloudDragon" Each (or 
                ("SlideMove" (directions {FR FL BR BL Backward}))
                ("StepMove" (directions {Forward Rightward Leftward}))
                "Promote"
            )
        )
        (piece "CopperChariot" Each (or 
                ("SlideMove" (directions {N S}))
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                "Promote"
            )
        )
        (piece "RunningChariot" Each ("StepMove" Orthogonal "Promote"))
        (piece "RamsHeadSoldier" Each (or 
                ("SlideMove" (directions {FR FL}))
                ("StepMove" Backward)
                "Promote"
            )
        )
        (piece "ViolentOx" Each (or 
                ("SlideMove" (directions {FR FL}))
                ("StepMove" (directions {N S}))
                "Promote"
            )
        )
        (piece "GreatDragon" Each (or 
                ("SlideMove" Diagonal)
                ("SlideMove" (directions {N S}) (between (max 3)))
                "Promote"
            )
        )
        (piece "GoldenBird" Each (or {
                ("SlideMove" (directions {FR FL Forward Backward}))
                ("SlideMove" (directions {BR BL Rightward Leftward}) (between (max 3)))
                ("HopMoveWithRange" (directions {FR FL}) ~ (range 1 3) after:35)
                }
                "Promote"
            )
        )
        (piece "Deva" Each ("StepMove" (directions {Forward FL Backwards Rightward Leftward}) "Promote"))
        (piece "DarkSpirit" Each ("StepMove" (directions {Backwards Rightward Leftward Forward FR}) "Promote"))
        (piece "WoodChariot" Each (or 
                ("SlideMove" (directions {N S}))
                ("StepMove" (directions {NW SE}))
                "Promote"
            )
        )
        (piece "WhiteHorse" Each (or 
                ("SlideMove" (directions {FR FL}))
                ("SlideMove" (directions {N S}))
                "Promote"
            )
        )
        (piece "HowlingDog" Each (or 
                ("StepMove" Backward)
                ("SlideMove" Forward)
                "Promote"
            )
        )
        (piece "SideMover" Each (or 
                ("SlideMove" (directions {E W}))
                ("StepMove" (directions {N S}))
                "Promote"
            )
        )
        (piece "PrancingStag" Each (or 
                ("StepMove" (directions {FR FL Forward Backward}))
                ("SlideMove" (directions {E W}) (between (max 2)))
                "Promote"
            )
        )
        (piece "WaterBuffalo" Each (or 
                ("SlideMove" (directions {N S}) (between (max 2)))
                ("SlideMove" (directions {Rightwards Leftwards}))
                "Promote"
            )
        )
        (piece "FerociousLeopard" Each ("StepMove" (directions {Backwards Forwards}) "Promote"))
        (piece "FierceEagle" Each (or 
                ("StepMove" (directions {Forward Rightward Leftward}))
                ("SlideMove" Diagonal (between (max 2)))
                "Promote"
            )
        )
        (piece "FlyingDragon" Each ("HopMove" Diagonal "Promote"))
        (piece "PoisonousSnake" Each (or 
                ("StepMove" (directions {FR FL Backward}))
                ("SlideMove" (directions {Forward Rightward Leftward}) (between (max 2)))
                "Promote"
            )
        )
        (piece "FlyingGoose" Each ("StepMove" (directions {Forward FR FL Backward}) "Promote"))
        (piece "StruttingCrow" Each ("StepMove" (directions {Forward BR BL}) "Promote" ))
        (piece "BlindDog" Each ("StepMove" (directions {Rightward Leftward Backward FR FL}) "Promote"))
        (piece "WaterGeneral" Each (or 
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                ("StepMove" (directions {N S}))
                "Promote"
            )
        )
        (piece "FireGeneral" Each (or
                ("StepMove" (directions {FR FL}))
                ("SlideMove" (directions {N S}) (between (max 3)))
                "Promote"
            )
        )
        (piece "Kirin" Each (or
                ("StepMove" Diagonal)
                ("HopMove" (directions {E W}))
                "Promote"
            )
        )
        (piece "Phoenix" Each (or
                ("StepMove" Orthogonal)
                ("HopMove" Diagonal)
                "Promote"
            )
        )
        (piece "Capricorn" Each (or
                ("SlideMove" Diagonal)
                (move
                    Slide 
                    Orthogonal 
                    (to 
                        if:("IsEnemyAt" (to))
                        (apply 
                            if:(and 
                                (if 
                                    (is Odd (row of:(from))) 
                                    (is Odd (row of:(to))) 
                                    (is Even (row of:(to)))
                                ) 
                                (if 
                                    (is Odd (column of:(from))) 
                                    (is Odd (column of:(to))) 
                                    (is Even (column of:(to)))
                                ) 
                            ) 
                            (remove (to))
                        )
                    )
                )
                "Promote"
            )
        )
        (piece "HookMover" Each ("SlideMove" Orthogonal))
        (piece "GreatTurtle" Each (or {
                ("SlideMove" (directions {E W}) (between (max 3)))
                ("SlideMove" (directions {Forward Backward FR FL BL BR}))
                ("HopMoveWithRange" (directions {N S}) ~ (exact 2))
                }
                "Promote"
            )
        )
        (piece "LittleTurtle" Each (or {
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("SlideMove" (directions {Backward FR FL BL BR}))
                ("StepMove" Forward)
                ("HopMove" (directions {N S}))
                }
                "Promote"
            )
        )
        (piece "TileChariot" Each (or 
                ("SlideMove" (directions {N S}))
                ("StepMove" (directions {NE SW}))
                "Promote"
            )
        )
        (piece "VerticalWolf" Each
            (or {
                ("SlideMove" Forward)
                ("SlideMove" Backward (between (max 3)))
                ("StepMove" (directions {E W}))
                }
                "Promote"
            )
        )
        (piece "SideOx" Each (or 
                ("SlideMove" (directions {E W}))
                ("StepMove" (directions {NE SW}))
                "Promote"
            )
        )
        (piece "Donkey" Each ("SlideMove" Orthogonal (between (max 2)) "Promote"))
        (piece "FlyingHorse" Each ("SlideMove" Diagonal (between (max 2)) "Promote"))
        (piece "ViolentBear" Each (or 
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                ("StepMove" (directions {Forward Rightward Leftward}))
                "Promote"
            )
        )
        (piece "AngryBoar" Each (or 
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                ("StepMove" (directions {Forward Rightward Leftward}))
                "Promote"
            )
        )
        (piece "EvilWolf" Each ("StepMove" (directions {Forward Rightward Leftward FL FR}) "Promote"))
        (piece "LiberatedHorse" Each
            (or {
                ("SlideMove" Forward)
                ("SlideMove" Backward (between (max 2)))
                ("StepMove" (directions {E W}))
                }
                "Promote"
            )
        )
        (piece "FlyingCock" Each ("StepMove" (directions {FR FL Rightward Leftward}) "Promote"))
        (piece "OldMonkey" Each ("StepMove" (directions {FR FL BR BL Backward}) "Promote"))
        (piece "ChineseCock" Each ("StepMove" (directions {Rightward Leftward Backward FR FL}) "Promote"))
        (piece "WesternBarbarian" Each (or 
                ("StepMove" (directions {FR FL Rightward Leftward}))
                ("SlideMove" (directions {N S}) (between (max 2)))
                "Promote"
            )
        )
        (piece "NorthernBarbarian" Each (or 
                ("StepMove" (directions {FR FL Forward Backward}))
                ("SlideMove" (directions {E W}) (between (max 2)))
                "Promote"
            )
        )
        (piece "EasternBarbarian" Each (or 
                ("StepMove" (directions {FR FL Rightward Leftward}))
                ("SlideMove" (directions {N S}) (between (max 2)))
                "Promote"
            )
        )
        (piece "SouthernBarbarian" Each (or 
                ("StepMove" (directions {FR FL Forward Backward}))
                ("SlideMove" (directions {E W}) (between (max 2)))
                "Promote"
            )
        )
        (piece "ViolentStag" Each ("StepMove" (directions {Forward BL BR FL FR}) "Promote"))
        (piece "ViolentWolf" Each ("StepMove" (directions {Forward Backward Rightward Leftward FL FR}) "Promote"))
        (piece "TreacherousFox" Each (or 
                ("SlideMove" (directions {Backwards Forwards}))
                ("HopMoveWithRange" (directions {Backwards Forwards}) ~ (range 1 2) after:34)
                "Promote"
            )
        )
        (piece "RocMaster" Each (or {
                ("SlideMove" (directions {N S}))
                ("SlideMove" (directions {BR BL Rightward Leftward}) (between (max 5)))
                ("HopMoveWithRange" (directions {FR FL}) ~ (exact 2) after:34)
            })
        )
        (piece "CenterMaster" Each (or {
                ("SlideMove" (directions {FR FL Forward Backward}))
                ("SlideMove" (directions {BR BL Rightward Leftward}) (between (max 3)))
                ("HopMoveWithRange" (directions {FR FL Forward Backward}) ~ ~ after:34)
            })
        )
        (piece "EarthChariot" Each (or 
                ("SlideMove" (directions {N S}))
                ("StepMove" (directions {E W}))
                "Promote"
            )
        )
        (piece "BlueDragon" Each (or 
                ("SlideMove" (directions {FR Forward Backward}))
                ("SlideMove" (directions {E W}) (between (max 2)))
                "Promote"
            )
        )
        (piece "VermillionSparrow" Each (or 
                ("StepMove" (directions {Forward FR FRR Backward BR BRR}))
                ("SlideMove" (directions {NW SE}))
                "Promote"
            )
        )
        (piece "EnchantedBadger" Each ("SlideMove" Orthogonal (between (max 2)) "Promote"))
        (piece "HorseMan" Each (or 
                ("SlideMove" (directions {FR FL Forward Backward}))
                ("SlideMove" (directions {E W}) (between (max 2)))
                "Promote"
            )
        )
        (piece "SwoopingOwl" Each ("StepMove" (directions {Forward BR BL}) "Promote"))
        (piece "ClimbingMonkey" Each ("StepMove" (directions {Forward FR FL Backward}) "Promote"))
        (piece "CatSword" Each ("StepMove" Diagonal "Promote"))
        (piece "SwallowsWings" Each (or 
                ("StepMove" (directions {FR FL Forward Backward}))
                ("SlideMove" (directions {E W}))
                "Promote"
            )
        )
        (piece "BlindMonkey" Each ("StepMove" (directions {Rightwards Leftwards}) "Promote"))
        (piece "BlindTiger" Each ("StepMove" (directions {Backwards Rightwards Leftwards}) "Promote"))
        (piece "Oxcart" Each ("SlideMove" Forward ~ "Promote"))
        (piece "SideFlier" Each (or 
                ("StepMove" (directions {BR BL FR FL}))
                ("SlideMove" (directions {E W}))
                "Promote"
            )
        )
        (piece "BlindBear" Each ("StepMove" (directions {Rightwards Leftwards}) "Promote"))
        (piece "OldRat" Each ("StepMove" (directions {BR BL Forward}) "Promote"))
        (piece "SquareMover" Each ("StepMove" Orthogonal "Promote"))
        (piece "CoiledSerpent" Each ("StepMove" (directions {BR BL Forward Backward}) "Promote"))
        (piece "RecliningDragon" Each ("StepMove" Orthogonal "Promote"))
        (piece "LionHawk" Each (or {
                ("SlideMove" ~ (between (max 2)))
                ("HopMove" Orthogonal)
                ("HopMoveWithRange" Diagonal ~ ~ after:34)
            })
        )
        (piece "FreeEagle" Each (or 
                ("SlideMove")
                ("HopMoveWithRange" Forwards ~ (range 1 2) after:34)
            )
        )
        (piece "ChariotSoldier" Each (or 
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("SlideMove" (directions {Backwards Forwards}))
                "Promote"
            )
        )
        (piece "SideSoldier" Each (or {
                ("SlideMove" (directions {E W}))
                ("SlideMove" Forward (between (max 2)))
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "VerticalSoldier" Each (or {
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("SlideMove" Forward)
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "WindGeneral" Each (or 
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("StepMove" (directions {FR FL Backward}))
                "Promote"
            )
        )
        (piece "RiverGeneral" Each (or 
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("StepMove" (directions {FR FL Backward}))
                "Promote"
            )
        )
        (piece "MountainGeneral" Each (or 
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                ("StepMove" (directions {N S}))
                "Promote"
            )
        )
        (piece "FrontStandard" Each (or 
                ("SlideMove" Orthogonal)
                ("SlideMove" Diagonal (between (max 3)))
                "Promote"
            )
        )
        (piece "HorseSoldier" Each (or {
                ("SlideMove" Forwards)
                ("SlideMove" (directions {E W}) (between (max 3)))
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "WoodGeneral" Each ("SlideMove" (directions {FR FL}) (between (max 2)) "Promote"))
        (piece "OxSoldier" Each (or {
                ("SlideMove" Forwards)
                ("SlideMove" (directions {E W}) (between (max 3)))
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "EarthGeneral" Each ("StepMove" (directions {N S}) "Promote"))
        (piece "BoarSoldier" Each (or {
                ("SlideMove" Forwards)
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "StoneGeneral" Each ("StepMove" (directions {FR FL}) "Promote"))
        (piece "LeopardSoldier" Each (or {
                ("SlideMove" Forwards)
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "TileGeneral" Each ("StepMove" (directions {FR FL Backward}) "Promote"))
        (piece "BearSoldier" Each (or {
                ("SlideMove" Forwards)
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "IronGeneral" Each ("StepMove" Forwards "Promote"))
        (piece "GreatMaster" Each (or {
                ("SlideMove" (directions {FR FL Forward Backward}))
                ("SlideMove" (directions {BR BL Rightward Leftward}) (between (max 5)))
                ("HopMoveWithRange" Forwards ~ (exact 2))
            })
        )
        (piece "GreatStandard" Each (or 
                ("SlideMove" (directions {FR FL Forward Backward Rightward Leftward}))
                ("SlideMove" (directions {BR BL}) (between (max 3)))
            )
        )
        (piece "LeftChariot" Each (or 
                ("SlideMove" (directions {FL BL Forward}))
                ("StepMove" W)
                "Promote"
            )
        )
        (piece "RightChariot" Each (or 
                ("SlideMove" (directions {FR BR Forward}))
                ("StepMove" E)
                "Promote"
            )
        )
        (piece "SideMonkey" Each (or 
                ("SlideMove" (directions {E W}))
                ("StepMove" (directions {FR FL Backward}))
                "Promote"
            )
        )
        (piece "VerticalMover" Each (or 
                ("SlideMove" (directions {N S}))
                ("StepMove" (directions {E W}))
                "Promote"
            )
        )
        (piece "FlyingOx" Each ("SlideMove" (directions {Backwards Forwards}) ~ "Promote"))
        (piece "LongbowSoldier" Each (or {
                ("SlideMove" Forward)
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "VerticalPup" Each (or 
                ("SlideMove" Forward)
                ("StepMove" Backwards)
                "Promote"
            )
        )
        (piece "VerticalHorse" Each (or 
                ("SlideMove" Forward)
                ("StepMove" (directions {FR FL Backward}))
                "Promote"
            )
        )
        (piece "BurningSoldier" Each (or {
                ("SlideMove" Forward (between (max 7)))
                ("SlideMove" (directions {FR FL}) (between (max 5)))
                ("SlideMove" (directions {E W}) (between (max 3)))
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "DragonHorse" Each (or 
                ("SlideMove" Diagonal)
                ("StepMove" Orthogonal)
                "Promote"
            )
        )
        (piece "DragonKing" Each (or 
                ("SlideMove" Orthogonal)
                ("StepMove" Diagonal)
                "Promote"
            )
        )
        (piece "SwordSoldier" Each ("StepMove" (directions {FR FL Backward}) "Promote"))
        (piece "HornedFalcon" Each (or 
                ("SlideMove")
                ("HopMove" Forward)
                "Promote"
            )
        )
        (piece "SoaringEagle" Each (or 
                ("SlideMove")
                ("HopMove" (directions {FR FL}))
                "Promote"
            )
        )
        (piece "SpearSoldier" Each (or 
                ("SlideMove" Forward)
                ("StepMove" (directions {Rightward Leftward Backward}))
                "Promote"
            )
        )
        (piece "VerticalLeopard" Each (or 
                ("SlideMove" Forward)
                ("StepMove" (directions {Backward FR FL Rightward Leftward}))
                "Promote"
            )
        )
        (piece "SavageTiger" Each ("SlideMove" Forward ~ "Promote"))
        (piece "CrossBowSoldier" Each (or 
                {
                ("SlideMove" Forward (between (max 5)))
                ("SlideMove" (directions {FR FL Rightward Leftward}) (between (max 3)))
                ("StepMove" Backward)
                }
                "Promote"
            )
        )
        (piece "LionDog" Each (or 
                ("SlideMove")
                ("HopMoveWithRange" ~ ~ (exact 2))
                "Promote"
            )
        )
        (piece "RoaringDog" Each (or {
                ("SlideMove" (directions {FR FL Rightward Leftward Forward Backward}))
                ("SlideMove" (directions {BR BL}) (between (max 3)))
                ("HopMoveWithRange" Orthogonal ~ (exact 2))
                }
                "Promote"
            )
        )
        (piece "LeftDog" Each (or 
                ("StepMove" Backward)				 
                ("SlideMove" (directions {Forward BL}))
            )
        )
        (piece "RightDog" Each (or 
                ("StepMove" Backward)						 
                ("SlideMove" (directions {Forward BR}))
            )
        )
        (piece "GoBetween" Each ("StepMove" (directions {N S}) "Promote"))
        (piece "Pawn" Each ("StepMove" Forward "Promote"))
        
        (piece "DivineTurtle" Each (or 
                ("StepMove" (directions {Forward Backward Leftward Rightward FL}))
                ("SlideMove" (directions {BR BL FR}))
            )
        )
        (piece "DivineTiger" Each (or 
                ("SlideMove" (directions {Forward Rightward Leftward FL}))
                ("SlideMove" Backward (between (max 2)))
            )
        )
        (piece "GreatWhale" Each ("SlideMove" (directions {Backwards Forwards})))
        (piece "FreeFire" Each (or 
                ("SlideMove" (directions {FR FL BL BR}))
                ("SlideMove" (directions {Forward Backward}) (between (max 5)))
            )
        )
        (piece "LeftArmy" Each (or
                ("StepMove" (directions {Forward Backward Rightwards}))
                ("SlideMove" Leftwards)
            )
        )
        (piece "RightArmy" Each (or 
                ("StepMove" (directions {Forward Backward Leftwards}))
                ("SlideMove" Rightwards)
            )
        )
        (piece "ElephantKing" Each (or 
                ("SlideMove" (directions {FR FL BL BR}))
                ("SlideMove" Orthogonal (between (max 2)))
            )
        )
        (piece "CaptiveBird" Each (or 
                ("SlideMove" (directions {FR FL BL BR Forward}))
                ("SlideMove" (directions {Rightward Leftward Backward}) (between (max 3)))
            )
        )
        (piece "ThunderRunner" Each (or 
                ("SlideMove" Forwards)
                ("SlideMove" (directions {Rightward Leftward Backward}) (between (max 4)))
            )
        )
        (piece "FreeLeopard" Each ("SlideMove" (directions {Backwards Forwards})))
        (piece "FreeSerpent" Each ("SlideMove" (directions {Forward BR BL})))
        (piece "GreatShark" Each (or {
                ("SlideMove" Orthogonal)
                ("SlideMove" (directions {FR FL}) (between (max 5)))
                ("SlideMove" (directions {BR BL}) (between (max 2)))
            })
        )
        (piece "FreeTiger" Each ("SlideMove" (directions {Backwards Rightwards Leftwards})))
        (piece "FreeBear" Each ("SlideMove" (directions {Backwards Forwards})))
        (piece "HeavenlyTetrarch" Each ("SlideMove" ~ (between (max 4))))
        (piece "PlayfulCockatoo" Each (or {
                ("SlideMove" (directions {Forward Backward}))
                ("SlideMove" (directions {Rightward Leftward}) (between (max 5)))
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                ("SlideMove" (directions {BR BL}) (between (max 2)))
            })
        )
        (piece "RunningDragon" Each (or 
                ("SlideMove" (directions {Forwards Rightwards Leftwards}))
                ("SlideMove" S (between (max 5)))
            )
        )
        (piece "FreeStag" Each ("SlideMove"))
        (piece "FreeWolf" Each ("SlideMove" (directions {Forward Rightward Leftward FR FL})))
        (piece "RainDemon" Each (or {
                ("SlideMove" Forward (between (max 3)))
                ("SlideMove" (directions {Rightward Leftward}) (between (max 2)))
                ("SlideMove" Backward)
                ("HopMoveWithRange" (directions {FR FL}) before:34 (range 1 35) after:34)
            })
        )
        (piece "FlyingCrocodile" Each
            (or {
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                ("SlideMove" (directions {BR BL}) (between (max 2)))
                (move
                    Slide 
                    Orthogonal 
                    (between 
                        if:(and {
                            (!= (what at:(between)) (id "King1"))
                            (!= (what at:(between)) (id "King2"))
                            (!= (what at:(between)) (id "Prince1"))	
                            (!= (what at:(between)) (id "Prince2"))
                        })
                        (apply (remove (between)))
                    )
                    (to
                        if:(or {
                            (= (what at:(to)) (id "King" Next))
                            (= (what at:(to)) (id "Prince" Next))
                        })
                        
                        (apply 
                            if:(not ("IsFriendAt" (to)))
                            (remove (to))
                        )
                    )
                )
            })
        )
        (piece "BeastBird" Each (or 
                ("SlideMove" (directions {FR FL BL BR Forward}))
                ("SlideMove" (directions {Rightward Leftward Backward}) (between (max 3)))
            )
        )
        (piece "FreeDragon" Each ("SlideMove" (directions {Backwards Rightwards Leftwards})))
        (piece "FreeDog" Each (or 
                ("SlideMove" (directions {Backward Forwards}))
                ("SlideMove" (directions {BR BL Rightward Leftward}) (between (max 2)))
            )
        )
        (piece "GooseWing" Each (or {
                ("SlideMove" (directions {Forward Backward}))
                ("SlideMove" (directions {Rightward Leftward}) (between (max 3)))
                ("StepMove" Diagonal)
            })
        )
        (piece "FreePig" Each (or {
                ("SlideMove" Orthogonal)
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                ("StepMove" (directions {BR BL}))
            })
        )
        (piece "FreeChicken" Each (or 
                ("SlideMove" (directions {Forwards Backward}))
                ("SlideMove" (directions {Rightward Leftward}) (between (max 2)))
            )
        ) 
        (piece "FreeHorse" Each (or {
                ("SlideMove" Orthogonal)
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                ("StepMove" (directions {BR BL}))
            })
        )
        (piece "FreeOx" Each (or {
                ("SlideMove" Orthogonal)
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                ("StepMove" (directions {BR BL}))
            })
        )
        (piece "FreeBoar" Each (or 
                ("SlideMove" (directions {Rightward Leftward Forwards}))
                ("StepMove" Backward)	
            )
        )
        (piece "FuriousFiend" Each (or {
                ("SlideMove" ~ (between (max 3)))
                (move Leap "KnightWalk" (to if:(not ("IsFriendAt" (to))) (apply (remove (to)))))
                ("HopMove")	
            })
        )
        (piece "RightPhoenix" Each (or 
                ("SlideMove" (directions {Rightward Leftward}) (between (max 5)))
                ("SlideMove" (directions {Backwards Forwards}))	
            )
        )
        (piece "WalkingHeron" Each (or 
                ("SlideMove" (directions {Forward Backward}))
                ("SlideMove" (directions {Rightward Leftward FR FL}) (between (max 2)))
            )
        )
        (piece "StrongEagle" Each ("SlideMove"))
        (piece "Cavalier" Each ("SlideMove" (directions {FR FL Forward Backward Rightward Leftward})))
        (piece "CopperElephant" Each (or 
                ("SlideMove" (directions {Forward Backward}))
                ("StepMove" (directions {Rightwards Leftwards}))
            )
        )
        (piece "BurningChariot" Each (or 
                ("SlideMove" (directions {Forwards Backward}))
                ("StepMove" (directions {Rightward Leftward}))
            )
        )
        (piece "TigerSoldier" Each (or {
                ("SlideMove" (directions {FR FL}))
                ("SlideMove" Forward (between (max 2)))
                ("StepMove" Backward)
            })
        )
        (piece "AncientDragon" Each (or 
                ("SlideMove" Diagonal)
                ("HopMoveWithRange" (directions {N S}) before:35 (range 0 35) after:35)
            )
        )
        (piece "FreeBird" Each (or {
                ("SlideMove" (directions {FR FL Forward Backward Rightward Leftward}))
                ("SlideMove" (directions {BR BL}) (between (max 3)))
                ("HopMoveWithRange" (directions {FR FL}) ~ (range 1 3) after:35)
            })
        )
        (piece "TeachingKing" Each ("HopMoveWithRange" ~ ~ (range 1 3) after:35))
        (piece "BuddhistSpirit" Each (or {
                ("SlideMove")
                (move Leap "KnightWalk" (to if:(not ("IsFriendAt" (to))) (apply (remove (to)))))
                ("HopMove")	
            })
        )
        (piece "WindSnappingTurtle" Each (or 
                ("SlideMove" (directions {FR FL}) (between (max 2)))
                ("SlideMove" (directions {Forward Backward}))
            )
        )
        (piece "GreatHorse" Each (or 
                ("SlideMove" (directions {Forwards Backward}))
                ("SlideMove" (directions {E W}) (between (max 2)))
            )
        )
        (piece "GreatDreamEater" Each (or 
                ("SlideMove")
                ("HopMoveWithRange" (directions {FR FL}) ~ (exact 2))
            )
        )
        (piece "FlyingFalcon" Each (or 
                ("SlideMove" Diagonal)
                ("StepMove" Forward)
            )
        )
        (piece "SpiritTurtle" Each (or 
                ("SlideMove")
                ("HopMoveWithRange" Orthogonal ~ (exact 2))
            )
        )
        (piece "TreasureTurtle" Each (or 
                ("SlideMove")
                ("HopMove" Orthogonal)	
            )
        )
        (piece "RunningTile" Each (or 
                ("SlideMove" (directions {N S}))
                ("SlideMove" (directions {E W}) (between (max 2)))
            )
        )
        (piece "GreatBear" Each (or 
                ("SlideMove" Forwards)
                ("StepMove" (directions {Rightward Leftward Backward}))
            )
        )
        (piece "VenomousWolf" Each ("StepMove"))
        (piece "HeavenlyHorse" Each (or {
                ("SlideMove" Forward)
                (move Leap "KnightWalk" (to if:(not ("IsFriendAt" (to))) (apply (remove (to)))))
            })
        )
        (piece "RaidingFalcon" Each (or 
                ("SlideMove" Forward)
                ("StepMove" (directions {FR FL Rightward Leftward}))
            )
        )
        (piece "MountainWitch" Each ("SlideMove" Backwards))
        (piece "WizardStork" Each ("SlideMove" (directions {Rightward Leftward Backward FR FL})))
        (piece "RushingBoar" Each ("StepMove" (directions {Forwards Rightwards Leftwards})))
        (piece "BearsEyes" Each ("StepMove"))
        (piece "MountainCrane" Each (or 
                ("SlideMove")
                ("HopMoveWithRange" ~ ~ (exact 2) after:35)
            )
        )
        (piece "YoungBird" Each (or 
                ("SlideMove" (directions {N S}))
                ("SlideMove" (directions {BR BL Rightward Leftward}) (between (max 2)))
            )
        )
        (piece "DivineDragon" Each (or 
                ("SlideMove" (directions {Forward Backward FR Rightward}))
                ("SlideMove" W (between (max 2)))
            )
        )
        (piece "DivineSparrow" Each (or 
                ("SlideMove" (directions {FR BL}))
                ("StepMove" Orthogonal)
            )
        )
        (piece "GlidingSwallow" Each ("SlideMove" Orthogonal))
        (piece "FlyingStag" Each (or 
                ("SlideMove" (directions {N S}))
                ("StepMove" (directions {Rightwards Leftwards}))
            )
        )
        (piece "PloddingOx" Each (or 
                ("SlideMove" (directions {N S}))
                ("StepMove" Diagonal)
            )
        )
        (piece "BirdOfParadise" Each ("SlideMove" (directions {Forwards Backward})))
        (piece "StrongChariot" Each ("SlideMove" (directions {Forwards Rightward Leftward Backward})))
        (piece "CoiledDragon" Each ("SlideMove" (directions {Forward BR BL})))
        (piece "HeavenlyTetrarchKing" Each (or {
                ("SlideMove")
                ("HopMoveWithRange" ~ ~ ~ after:35)
                (move Step Orthogonal 
                    (to 
                        if:(or 
                            (is Empty (to)) 
                            ("IsEnemyAt" (to))
                        ) 
                        (apply (remove (to)))
                    ) 
                    (then 
                        (fromTo 
                            (from (last To)) 
                            (to (last From))
                        )
                    )
                )	
            })
        )
        (piece "ViolentWind" Each (or
                ("SlideMove" (directions {Backwards Forwards}))
                ("StepMove" (directions {E W}))
            )
        )
        (piece "ChineseRiver" Each (or 
                ("SlideMove" (directions {Rightwards Leftwards}))
                ("StepMove" (directions {N S}))
            )
        )
        (piece "PeacefulMountain" Each (or 
                ("SlideMove" Diagonal)
                ("SlideMove" (directions {Forward Rightward Leftward}) (between (max 5)))
            )
        )
        (piece "RunningOx" Each (or 
                ("SlideMove" (directions {Rightward Leftward Forwards}))
                ("SlideMove" (directions {BR BL}) (between (max 2)))
            )
        )
        (piece "RunningBoar" Each (or 
                ("SlideMove" (directions {N S}))
                ("StepMove" (directions {E W}))	
            )
        )
        (piece "RunningLeopard" Each ("SlideMove" (directions {Forwards Rightward Leftward})))
        (piece "StrongBear" Each (or 
                ("SlideMove" (directions {Forwards Rightwards Leftwards}))
                ("SlideMove" Backward (between (max 2)))
            )
        )
        (piece "LeftIronChariot" Each ("StepMove" (directions {Forward Backward Rightward Leftward BL})))
        (piece "RightIronChariot" Each ("StepMove" (directions {Forward Backward Rightward Leftward BR})))
        (piece "FireOx" Each (or 
                ("SlideMove" (directions {Backwards Forwards}))
                ("StepMove" (directions {E W}))	
            )
        )
        (piece "LongbowGeneral" Each (or 
                ("SlideMove" (directions {Backwards Forwards}))
                ("SlideMove" (directions {E W}) (between (max 5)))
            )
        )
        (piece "LeopardKing" Each ("SlideMove" ~ (between (max 5)))	)
        (piece "BurningGeneral" Each (or {
                ("SlideMove" (directions {Backwards Forwards}))
                ("SlideMove" (directions {E W}) (between (max 3)))
                ("SlideMove" Backward (between (max 2)))
            })
        )
        (piece "SwordGeneral" Each (or 
                ("SlideMove" Forwards (between (max 3)))
                ("StepMove" Backward)		
            )
        )
        (piece "GreatFalcon" Each (or 
                ("SlideMove")
                ("HopMoveWithRange" (directions {N S}) ~ ~ after:35)
            )
        )
        (piece "GreatEagle" Each (or 
                ("SlideMove")
                ("HopMoveWithRange" ~ ~ ~ after:35)
            )
        )
        (piece "SpearGeneral" Each (or 
                ("SlideMove" (directions {Rightward Leftward Backward}) (between (max 3)))
                ("SlideMove" Forward)
            )
        )
        (piece "GreatLeopard" Each (or {
                ("SlideMove" Forward)
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                ("SlideMove" (directions {E W}) (between (max 2)))
                ("StepMove" Backward)		
            })
        )
        (piece "GreatTiger" Each (or 
                ("SlideMove" (directions {Rightward Leftward Backward}))
                ("StepMove" Forward)		
            )
        )
        (piece "CrossBowGeneral" Each (or {
                ("SlideMove" Forward)
                ("SlideMove" (directions {FR FL}) (between (max 5)))
                ("SlideMove" (directions {E W}) (between (max 3)))
                ("SlideMove" Backward (between (max 2)))
            })
        )
        (piece "GreatElephant" Each (or {
                ("SlideMove" (directions {FR FL}) (between (max 3)))
                ("HopMoveWithRange" Orthogonal ~ ~ after:35)
                ("HopMoveWithRange" (directions {BR BL}) ~ (range 1 3) after:35)
            })
        )
        
        (regions "Promotion" P1 (expand (sites Top) steps:6))
        (regions "Promotion" P2 (expand (sites Bottom) steps:6))
        
        (map "Promoted" { 
            (pair 3 1) (pair 4 2) (pair 5 181) (pair 6 182) (pair 7 419) (pair 8 420) (pair 9 421) (pair 10 422) (pair 11 287) (pair 12 288) (pair 13 423) (pair 14 424) (pair 15 425) (pair 16 426) 
            (pair 17 397) (pair 18 398) (pair 19 397) (pair 20 398) (pair 23 111) (pair 24 112) (pair 25 27) (pair 26 28) (pair 27 37) (pair 28 38) (pair 29 59) (pair 30 60) (pair 35 37) (pair 36 38)
            (pair 37 167) (pair 38 168) (pair 39 149) (pair 40 150) (pair 41 427) (pair 42 428) (pair 43 429) (pair 44 430) (pair 45 177) (pair 46 178) (pair 47 13) (pair 48 14) (pair 49 431) (pair 50 432)
            (pair 51 431) (pair 52 432) (pair 53 71) (pair 54 72) (pair 55 177) (pair 56 178) (pair 57 433) (pair 58 434) (pair 59 201) (pair 60 202) (pair 61 435) (pair 62 436) (pair 63 161) (pair 64 162)
            (pair 65 437) (pair 66 438) (pair 67 439) (pair 68 440) (pair 69 441) (pair 70 442) (pair 71 33) (pair 72 34) (pair 73 443) (pair 74 444) (pair 75 445) (pair 76 446) (pair 77 447) (pair 78 448)
            (pair 79 447) (pair 80 448) (pair 81 447) (pair 82 448) (pair 83 447) (pair 84 448) (pair 85 377) (pair 86 378) (pair 87 345) (pair 88 346) (pair 89 3) (pair 90 4) (pair 91 449) (pair 92 450)
            (pair 93 451) (pair 94 452) (pair 95 453) (pair 96 454) (pair 97 455) (pair 98 456) (pair 99 457) (pair 100 458) (pair 101 459) (pair 102 460) (pair 103 7) (pair 104 8) (pair 105 9) (pair 106 10)
            (pair 107 297) (pair 108 298) (pair 109 295) (pair 110 296) (pair 111 461) (pair 112 462) (pair 113 463) (pair 114 464) (pair 115 465) (pair 116 466) (pair 117 27) (pair 118 28) (pair 119 21) (pair 120 22)
            (pair 121 21) (pair 122 22) (pair 123 131) (pair 124 132) (pair 125 139) (pair 126 140) (pair 127 215) (pair 128 216) (pair 133 467) (pair 134 468) (pair 135 445) (pair 136 446) (pair 137 335) (pair 138 336)
            (pair 139 469) (pair 140 470) (pair 141 471) (pair 142 472) (pair 143 115) (pair 144 116) (pair 145 473) (pair 146 474) (pair 147 475) (pair 148 476) (pair 149 345) (pair 150 346) (pair 151 477) (pair 152 478)
            (pair 153 13) (pair 154 14) (pair 155 211) (pair 156 212) (pair 157 479) (pair 158 480) (pair 159 57) (pair 160 58) (pair 161 453) (pair 162 454) (pair 163 201) (pair 164 202) (pair 165 481) (pair 166 482)
            (pair 169 167) (pair 170 168) (pair 171 483) (pair 172 484) (pair 173 485) (pair 174 486) (pair 175 389) (pair 176 390) (pair 177 389) (pair 178 390) (pair 179 455) (pair 180 456) (pair 181 389) (pair 182 390)
            (pair 183 395) (pair 184 396) (pair 185 443) (pair 186 444) (pair 187 487) (pair 188 488) (pair 189 39) (pair 190 40) (pair 191 201) (pair 192 202) (pair 193 489) (pair 194 490) (pair 195 491) (pair 196 492)
            (pair 197 493) (pair 198 494) (pair 199 379) (pair 200 380) (pair 201 495) (pair 202 496) (pair 203 497) (pair 204 498) (pair 205 499) (pair 206 500) (pair 207 501) (pair 208 502) (pair 209 503) (pair 210 504)
            (pair 211 505) (pair 212 506) (pair 213 411) (pair 214 412) (pair 215 477) (pair 216 478) (pair 217 323) (pair 218 324) (pair 219 507) (pair 220 508) (pair 221 175) (pair 222 176) (pair 223 397) (pair 224 398)
            (pair 225 391) (pair 226 392) (pair 227 245) (pair 228 246) (pair 229 309) (pair 230 310) (pair 231 509) (pair 232 510) (pair 233 283) (pair 234 284) (pair 235 169) (pair 236 170) (pair 237 167) (pair 238 168)
            (pair 239 203) (pair 240 204) (pair 241 203) (pair 242 204) (pair 243 245) (pair 244 246) (pair 247 511) (pair 248 512) (pair 249 513) (pair 250 514) (pair 251 515) (pair 252 516) (pair 253 97) (pair 254 98)
            (pair 255 379) (pair 256 380) (pair 257 31) (pair 258 32) (pair 259 37) (pair 260 38) (pair 261 517) (pair 262 518) (pair 263 477) (pair 264 478) (pair 265 519) (pair 266 520) (pair 267 521) (pair 268 522) 
            (pair 269 523) (pair 270 524) (pair 271 525) (pair 272 526) (pair 273 527) (pair 274 528) (pair 275 407) (pair 276 408) (pair 277 33) (pair 278 34) (pair 279 157) (pair 280 158) (pair 281 203) (pair 283 529) (pair 284 530)
            (pair 285 531) (pair 286 532) (pair 287 533) (pair 288 534) (pair 293 535) (pair 294 536) (pair 295 537) (pair 296 538) (pair 297 539) (pair 298 540) (pair 299 31) (pair 300 32) (pair 301 487) (pair 302 488)
            (pair 303 173) (pair 304 174) (pair 305 283) (pair 306 284) (pair 307 389) (pair 308 390) (pair 309 541) (pair 310 542) (pair 311 543) (pair 312 544) (pair 313 543) (pair 314 544) (pair 315 545) (pair 316 546)
            (pair 317 93) (pair 318 94) (pair 319 543) (pair 320 544) (pair 321 547) (pair 322 548) (pair 323 549) (pair 324 550) (pair 325 551) (pair 326 552) (pair 327 201) (pair 328 202) (pair 333 553) (pair 334 554)
            (pair 335 219) (pair 336 220) (pair 337 333) (pair 338 334) (pair 339 555) (pair 340 556) (pair 341 557) (pair 342 558) (pair 343 559) (pair 344 560) (pair 345 369) (pair 346 370) (pair 347 25) (pair 348 26)
            (pair 349 49) (pair 350 50) (pair 351 561) (pair 352 562) (pair 353 49) (pair 354 50) (pair 355 563) (pair 356 564) (pair 357 49) (pair 358 50) (pair 359 565) (pair 360 566) (pair 361 49) (pair 362 50)
            (pair 363 567) (pair 364 568) (pair 365 49) (pair 366 50) (pair 371 569) (pair 372 570) (pair 373 571) (pair 374 572) (pair 375 335) (pair 376 336) (pair 377 379) (pair 378 380) (pair 379 573) (pair 380 574)
            (pair 381 575) (pair 382 576) (pair 383 577) (pair 384 578) (pair 385 389) (pair 386 390) (pair 387 579) (pair 388 580) (pair 389 395) (pair 390 396) (pair 391 397) (pair 392 398) (pair 393 581) (pair 394 582)
            (pair 395 583) (pair 396 584) (pair 397 585) (pair 398 586) (pair 399 587) (pair 400 588) (pair 401 589) (pair 402 590) (pair 403 591) (pair 404 592) (pair 405 593) (pair 406 594) (pair 407 595) (pair 408 596)
            (pair 409 407) (pair 410 408) (pair 415 89) (pair 416 90) (pair 417 45) (pair 418 46)
        }) 
    })
    
    (rules 
        (start { 
            
            (place "Lance1" {"A1" "AJ1"}) (place "TurtleSnake1" coord:"B1")
            (place "WhiteTiger1" coord:"AI1") (place "RunningRabbit1" {"C1" "AH1"})
            (place "Whale1" {"D1" "AG1"}) (place "FireDemon1" {"E1" "AF1"})
            (place "MountainEagleLeft1" coord:"F1") (place "MountainEagleRight1" coord:"AE1")
            (place "LongNosedGoblin1" {"G1" "AD1"})
            (place "BeastCadet1" {"H1" "AC1"}) (place "RunningHorse1" {"I1" "AB1"})
            (place "FreeDemon1" {"J1" "AA1"}) (place "EarthDragon1" {"K1" "Z1"})
            (place "CeramicDove1" coord:"L1") (place "WoodenDove1" coord:"Y1")
            (place "FreeDreamEater1" {"M1" "X1"}) (place "Queen1" {"N1" "W1"})
            (place "RearStandard1" {"O1" "V1"}) (place "LeftGeneral1" coord:"P1")
            (place "RightGeneral1" coord:"U1") (place "GoldGeneral1" {"Q1" "T1"})
            (place "King1" coord:"R1") (place "Prince1" coord:"S1") 
            
            
            (place "Lance2" {"A36" "AJ36"}) (place "TurtleSnake2" coord:"AI36")
            (place "WhiteTiger2" coord:"B36") (place "RunningRabbit2" {"C36" "AH36"})
            (place "Whale2" {"D36" "AG36"}) (place "FireDemon2" {"E36" "AF36"})
            (place "MountainEagleLeft2" coord:"AE36") (place "MountainEagleRight2" coord:"F36")
            (place "LongNosedGoblin2" {"G36" "AD36"})
            (place "BeastCadet2" {"H36" "AC36"}) (place "RunningHorse2" {"I36" "AB36"})
            (place "FreeDemon2" {"J36" "AA36"}) (place "EarthDragon2" {"K36" "Z36"})
            (place "CeramicDove2" coord:"Y36") (place "WoodenDove2" coord:"L36")
            (place "FreeDreamEater2" {"M36" "X36"}) (place "Queen2" {"N36" "W36"})
            (place "RearStandard2" {"O36" "V36"}) (place "LeftGeneral2" coord:"U36")
            (place "RightGeneral2" coord:"P36") (place "GoldGeneral2" {"Q36" "T36"})
            (place "King2" coord:"S36") (place "Prince2" coord:"R36")
            
            
            (place "ReverseChariot1" {"A2" "AJ2"}) (place "WhiteElephant1" coord:"B2")
            (place "FragrantElephant1" coord:"AI2") (place "TurtleDove1" {"C2" "AH2"})
            (place "FlyingSwallow1" {"D2" "AG2"}) (place "CaptiveOfficer1" {"E2" "AF2"})
            (place "RainDragon1" {"F2" "AE2"}) (place "ForestDemon1" {"G2" "AD2"})
            (place "MountainStag1" {"H2" "AC2"}) (place "RunningPup1" {"I2" "AB2"})
            (place "RunningSerpent1" {"J2" "AA2"}) (place "SideSerpent1" {"K2" "Z2"})
            (place "GreatDove1" {"L2" "Y2"}) (place "RunningTiger1" {"M2" "X2"})
            (place "RunningBear1" {"N2" "W2"}) (place "BuddhistDevil1" coord:"O2")
            (place "Yaksha1" coord:"V2") (place "Wrestler1" coord:"P2")
            (place "GuardianOfTheGods1" coord:"U2") (place "SilverGeneral1" {"Q2" "T2"})
            (place "NeighboringKing1" coord:"R2") (place "DrunkenElephant1" coord:"S2")
            
            
            (place "ReverseChariot2" {"A35" "AJ35"}) (place "WhiteElephant2" coord:"AI35")
            (place "FragrantElephant2" coord:"B35") (place "TurtleDove2" {"C35" "AH35"})
            (place "FlyingSwallow2" {"D35" "AG35"}) (place "CaptiveOfficer2" {"E35" "AF35"})
            (place "RainDragon2" {"F35" "AE35"}) (place "ForestDemon2" {"G35" "AD35"})
            (place "MountainStag2" {"H35" "AC35"}) (place "RunningPup2" {"I35" "AB35"})
            (place "RunningSerpent2" {"J35" "AA35"}) (place "SideSerpent2" {"K35" "Z35"})
            (place "GreatDove2" {"L35" "Y35"}) (place "RunningTiger2" {"M35" "X35"})
            (place "RunningBear2" {"N35" "W35"}) (place "BuddhistDevil2" coord:"V35")
            (place "Yaksha2" coord:"O35") (place "Wrestler2" coord:"U35")
            (place "GuardianOfTheGods2" coord:"P35") (place "SilverGeneral2" {"Q35" "T35"})
            (place "NeighboringKing2" coord:"S35") (place "DrunkenElephant2" coord:"R35")
            
            
            (place "GoldChariot1" {"A3" "AJ3"}) (place "SideDragon1" {"B3" "AI3"})
            (place "RunningStag1" {"C3" "AH3"}) (place "RunningWolf1" {"D3" "AG3"})
            (place "BishopGeneral1" {"E3" "AF3"}) (place "RookGeneral1" {"F3" "AE3"})
            (place "LeftTiger1" coord:"G3") (place "RightTiger1" coord:"AD3")
            (place "LeftDragon1" coord:"H3") (place "RightDragon1" coord:"AC3")
            (place "BeastOfficer1" {"I3" "AB3"}) (place "WindDragon1" {"J3" "AA3"})
            (place "FreePup1" {"K3" "Z3"}) (place "RushingBird1" {"L3" "Y3"})
            (place "OldKite1" {"M3" "X3"}) (place "Peacock1" {"N3" "W3"})
            (place "WaterDragon1" {"O3" "V3"}) (place "FireDragon1" {"P3" "U3"})
            (place "CopperGeneral1" {"Q3" "T3"}) (place "KirinMaster1" coord:"R3") 
            (place "PhoenixMaster1" coord:"S3")
            
            
            (place "GoldChariot2" {"A34" "AJ34"}) (place "SideDragon2" {"B34" "AI34"})
            (place "RunningStag2" {"C34" "AH34"}) (place "RunningWolf2" {"D34" "AG34"})
            (place "BishopGeneral2" {"E34" "AF34"}) (place "RookGeneral2" {"F34" "AE34"})
            (place "LeftTiger2" coord:"AD34") (place "RightTiger2" coord:"G34")
            (place "LeftDragon2" coord:"AC34") (place "RightDragon2" coord:"H34")
            (place "BeastOfficer2" {"I34" "AB34"}) (place "WindDragon2" {"J34" "AA34"})
            (place "FreePup2" {"K34" "Z34"}) (place "RushingBird2" {"L34" "Y34"})
            (place "OldKite2" {"M34" "X34"}) (place "Peacock2" {"N34" "W34"})
            (place "WaterDragon2" {"O34" "V34"}) (place "FireDragon2" {"P34" "U34"})
            (place "CopperGeneral2" {"Q34" "T34"}) (place "KirinMaster2" coord:"S34") 
            (place "PhoenixMaster2" coord:"R34")
            
            
            (place "SilverChariot1" {"A4" "AJ4"}) (place "VerticalBear1" {"B4" "AI4"})
            (place "Knight1" {"C4" "AH4"}) (place "PigGeneral1" {"D4" "AG4"})
            (place "ChickenGeneral1" {"E4" "AF4"}) (place "PupGeneral1" {"F4" "AE4"})
            (place "HorseGeneral1" {"G4" "AD4"}) (place "OxGeneral1" {"H4" "AC4"})
            (place "CenterStandard1" {"I4" "AB4"}) (place "SideBoar1" {"J4" "AA4"})
            (place "SilverRabbit1" {"K4" "Z4"}) (place "GoldenDeer1" {"L4" "Y4"})
            (place "Lion1" {"M4" "X4"}) (place "CaptiveCadet1" {"N4" "W4"})
            (place "GreatStag1" {"O4" "V4"}) (place "ViolentDragon1" {"P4" "U4"})
            (place "WoodlandDemon1" {"Q4" "T4"}) (place "GreatGeneral1" coord:"R4") 
            (place "ViceGeneral1" coord:"S4")
            
            
            (place "SilverChariot2" {"A33" "AJ33"}) (place "VerticalBear2" {"B33" "AI33"})
            (place "Knight2" {"C33" "AH33"}) (place "PigGeneral2" {"D33" "AG33"})
            (place "ChickenGeneral2" {"E33" "AF33"}) (place "PupGeneral2" {"F33" "AE33"})
            (place "HorseGeneral2" {"G33" "AD33"}) (place "OxGeneral2" {"H33" "AC33"})
            (place "CenterStandard2" {"I33" "AB33"}) (place "SideBoar2" {"J33" "AA33"})
            (place "SilverRabbit2" {"K33" "Z33"}) (place "GoldenDeer2" {"L33" "Y33"})
            (place "Lion2" {"M33" "X33"}) (place "CaptiveCadet2" {"N33" "W33"})
            (place "GreatStag2" {"O33" "V33"}) (place "ViolentDragon2" {"P33" "U33"})
            (place "WoodlandDemon2" {"Q33" "T33"}) (place "GreatGeneral2" coord:"S33") 
            (place "ViceGeneral2" coord:"R33")
            
            
            (place "StoneChariot1" {"A5" "AJ5"}) (place "CloudEagle1" {"B5" "AI5"})
            (place "Bishop1" {"C5" "AH5"}) (place "Rook1" {"D5" "AG5"})
            (place "SideWolf1" {"E5" "AF5"}) (place "FlyingCat1" {"F5" "AE5"})
            (place "MountainFalcon1" {"G5" "AD5"}) (place "VerticalTiger1" {"H5" "AC5"})
            (place "Soldier1" {"I5" "AB5"}) (place "LittleStandard1" {"J5" "AA5"})
            (place "CloudDragon1" {"K5" "Z5"}) (place "CopperChariot1" {"L5" "Y5"})
            (place "RunningChariot1" {"M5" "X5"}) (place "RamsHeadSoldier1" {"N5" "W5"})
            (place "ViolentOx1" {"O5" "V5"}) (place "GreatDragon1" {"P5" "U5"})
            (place "GoldenBird1" {"Q5" "T5"}) (place "Deva1" coord:"R5") 
            (place "DarkSpirit1" coord:"S5")
            
            
            (place "StoneChariot2" {"A32" "AJ32"}) (place "CloudEagle2" {"B32" "AI32"})
            (place "Bishop2" {"C32" "AH32"}) (place "Rook2" {"D32" "AG32"})
            (place "SideWolf2" {"E32" "AF32"}) (place "FlyingCat2" {"F32" "AE32"})
            (place "MountainFalcon2" {"G32" "AD32"}) (place "VerticalTiger2" {"H32" "AC32"})
            (place "Soldier2" {"I32" "AB32"}) (place "LittleStandard2" {"J32" "AA32"})
            (place "CloudDragon2" {"K32" "Z32"}) (place "CopperChariot2" {"L32" "Y32"})
            (place "RunningChariot2" {"M32" "X32"}) (place "RamsHeadSoldier2" {"N32" "W32"})
            (place "ViolentOx2" {"O32" "V32"}) (place "GreatDragon2" {"P32" "U32"})
            (place "GoldenBird2" {"Q32" "T32"}) (place "Deva2" coord:"S32") 
            (place "DarkSpirit2" coord:"R32")
            
            
            (place "WoodChariot1" {"A6" "AJ6"}) (place "WhiteHorse1" {"B6" "AI6"})
            (place "HowlingDog1" {"C6" "AH6"}) (place "SideMover1" {"D6" "AG6"})
            (place "PrancingStag1" {"E6" "AF6"}) (place "WaterBuffalo1" {"F6" "AE6"})
            (place "FerociousLeopard1" {"G6" "AD6"}) (place "FierceEagle1" {"H6" "AC6"})
            (place "FlyingDragon1" {"I6" "AB6"}) (place "PoisonousSnake1" {"J6" "AA6"})
            (place "FlyingGoose1" {"K6" "Z6"}) (place "StruttingCrow1" {"L6" "Y6"})
            (place "BlindDog1" {"M6" "X6"}) (place "WaterGeneral1" {"N6" "W6"})
            (place "FireGeneral1" {"O6" "V6"}) (place "Kirin1" coord:"P6")
            (place "Phoenix1" coord:"U6") (place "Capricorn1" coord:"Q6")
            (place "HookMover1" coord:"T6") (place "GreatTurtle1" coord:"R6")
            (place "LittleTurtle1" coord:"S6")
            
            
            (place "WoodChariot2" {"A31" "AJ31"}) (place "WhiteHorse2" {"B31" "AI31"})
            (place "HowlingDog2" {"C31" "AH31"}) (place "SideMover2" {"D31" "AG31"})
            (place "PrancingStag2" {"E31" "AF31"}) (place "WaterBuffalo2" {"F31" "AE31"})
            (place "FerociousLeopard2" {"G31" "AD31"}) (place "FierceEagle2" {"H31" "AC31"})
            (place "FlyingDragon2" {"I31" "AB31"}) (place "PoisonousSnake2" {"J31" "AA31"})
            (place "FlyingGoose2" {"K31" "Z31"}) (place "StruttingCrow2" {"L31" "Y31"})
            (place "BlindDog2" {"M31" "X31"}) (place "WaterGeneral2" {"N31" "W31"})
            (place "FireGeneral2" {"O31" "V31"}) (place "Kirin2" coord:"U31")
            (place "Phoenix2" coord:"P31") (place "Capricorn2" coord:"T31")
            (place "HookMover2" coord:"Q31") (place "GreatTurtle2" coord:"S31")
            (place "LittleTurtle2" coord:"R31")
            
            
            (place "TileChariot1" {"A7" "AJ7"}) (place "VerticalWolf1" {"B7" "AI7"})
            (place "SideOx1" {"C7" "AH7"}) (place "Donkey1" {"D7" "AG7"})
            (place "FlyingHorse1" {"E7" "AF7"}) (place "ViolentBear1" {"F7" "AE7"})
            (place "AngryBoar1" {"G7" "AD7"}) (place "EvilWolf1" {"H7" "AC7"})
            (place "LiberatedHorse1" {"I7" "AB7"}) (place "FlyingCock1" {"J7" "AA7"})
            (place "OldMonkey1" {"K7" "Z7"}) (place "ChineseCock1" {"L7" "Y7"})
            (place "WesternBarbarian1" coord:"M7") (place "NorthernBarbarian1" coord:"X7")
            (place "EasternBarbarian1" coord:"N7") (place "SouthernBarbarian1" coord:"W7")
            (place "ViolentStag1" {"O7" "V7"}) (place "ViolentWolf1" {"P7" "U7"})
            (place "TreacherousFox1" {"Q7" "T7"}) (place "RocMaster1" coord:"R7")
            (place "CenterMaster1" coord:"S7")
            
            
            (place "TileChariot2" {"A30" "AJ30"}) (place "VerticalWolf2" {"B30" "AI30"})
            (place "SideOx2" {"C30" "AH30"}) (place "Donkey2" {"D30" "AG30"})
            (place "FlyingHorse2" {"E30" "AF30"}) (place "ViolentBear2" {"F30" "AE30"})
            (place "AngryBoar2" {"G30" "AD30"}) (place "EvilWolf2" {"H30" "AC30"})
            (place "LiberatedHorse2" {"I30" "AB30"}) (place "FlyingCock2" {"J30" "AA30"})
            (place "OldMonkey2" {"K30" "Z30"}) (place "ChineseCock2" {"L30" "Y30"})
            (place "WesternBarbarian2" coord:"X30") (place "NorthernBarbarian2" coord:"M30")
            (place "EasternBarbarian2" coord:"W30") (place "SouthernBarbarian2" coord:"N30")
            (place "ViolentStag2" {"O30" "V30"}) (place "ViolentWolf2" {"P30" "U30"})
            (place "TreacherousFox2" {"Q30" "T30"}) (place "RocMaster2" coord:"S30")
            (place "CenterMaster2" coord:"R30")
            
            
            (place "EarthChariot1" {"A8" "AJ8"}) (place "BlueDragon1" coord:"B8")
            (place "VermillionSparrow1" coord:"AI8")
            (place "EnchantedBadger1" {"C8" "AH8"}) (place "HorseMan1" {"D8" "AG8"})
            (place "SwoopingOwl1" {"E8" "AF8"}) (place "ClimbingMonkey1" {"F8" "AE8"})
            (place "CatSword1" {"G8" "AD8"}) (place "SwallowsWings1" {"H8" "AC8"})
            (place "BlindMonkey1" {"I8" "AB8"}) (place "BlindTiger1" {"J8" "AA8"})
            (place "Oxcart1" {"K8" "Z8"}) (place "SideFlier1" {"L8" "Y8"})
            (place "BlindBear1" {"M8" "X8"}) (place "OldRat1" {"N8" "W8"}) 
            (place "SquareMover1" {"O8" "V8"}) (place "CoiledSerpent1" {"P8" "U8"})
            (place "RecliningDragon1" {"Q8" "T8"}) (place "LionHawk1" coord:"R8")
            (place "FreeEagle1" coord:"S8")
            
            
            (place "EarthChariot2" {"A29" "AJ29"}) (place "BlueDragon2" coord:"AI29")
            (place "VermillionSparrow2" coord:"B29")
            (place "EnchantedBadger2" {"C29" "AH29"}) (place "HorseMan2" {"D29" "AG29"})
            (place "SwoopingOwl2" {"E29" "AF29"}) (place "ClimbingMonkey2" {"F29" "AE29"})
            (place "CatSword2" {"G29" "AD29"}) (place "SwallowsWings2" {"H29" "AC29"})
            (place "BlindMonkey2" {"I29" "AB29"}) (place "BlindTiger2" {"J29" "AA29"})
            (place "Oxcart2" {"K29" "Z29"}) (place "SideFlier2" {"L29" "Y29"})
            (place "BlindBear2" {"M29" "X29"}) (place "OldRat2" {"N29" "W29"}) 
            (place "SquareMover2" {"O29" "V29"}) (place "CoiledSerpent2" {"P29" "U29"})
            (place "RecliningDragon2" {"Q29" "T29"}) (place "LionHawk2" coord:"S29")
            (place "FreeEagle2" coord:"R29")
            
            
            (place "ChariotSoldier1" {"A9" "AJ9"}) (place "SideSoldier1" {"B9" "AI9"})
            (place "VerticalSoldier1" {"C9" "AH9"}) (place "WindGeneral1" {"D9" "AG9"})
            (place "RiverGeneral1" {"E9" "AF9"}) (place "MountainGeneral1" {"F9" "AE9"})
            (place "FrontStandard1" {"G9" "AD9"}) (place "HorseSoldier1" {"H9" "AC9"})
            (place "WoodGeneral1" {"I9" "AB9"}) (place "OxSoldier1" {"J9" "AA9"})
            (place "EarthGeneral1" {"K9" "Z9"}) (place "BoarSoldier1" {"L9" "Y9"})
            (place "StoneGeneral1" {"M9" "X9"}) (place "LeopardSoldier1" {"N9" "W9"}) 
            (place "TileGeneral1" {"O9" "V9"}) (place "BearSoldier1" {"P9" "U9"})
            (place "IronGeneral1" {"Q9" "T9"}) (place "GreatMaster1" coord:"R9")
            (place "GreatStandard1" coord:"S9")
            
            
            (place "ChariotSoldier2" {"A28" "AJ28"}) (place "SideSoldier2" {"B28" "AI28"})
            (place "VerticalSoldier2" {"C28" "AH28"}) (place "WindGeneral2" {"D28" "AG28"})
            (place "RiverGeneral2" {"E28" "AF28"}) (place "MountainGeneral2" {"F28" "AE28"})
            (place "FrontStandard2" {"G28" "AD28"}) (place "HorseSoldier2" {"H28" "AC28"})
            (place "WoodGeneral2" {"I28" "AB28"}) (place "OxSoldier2" {"J28" "AA28"})
            (place "EarthGeneral2" {"K28" "Z28"}) (place "BoarSoldier2" {"L28" "Y28"})
            (place "StoneGeneral2" {"M28" "X28"}) (place "LeopardSoldier2" {"N28" "W28"}) 
            (place "TileGeneral2" {"O28" "V28"}) (place "BearSoldier2" {"P28" "U28"})
            (place "IronGeneral2" {"Q28" "T28"}) (place "GreatMaster2" coord:"S28")
            (place "GreatStandard2" coord:"R28")
            
            
            (place "LeftChariot1" coord:"A10") (place "RightChariot1" coord:"AJ10")
            (place "SideMonkey1" {"B10" "AI10"})
            (place "VerticalMover1" {"C10" "AH10"}) (place "OxGeneral1" {"D10" "AG10"})
            (place "LongbowSoldier1" {"E10" "AF10"}) (place "VerticalPup1" {"F10" "AE10"})
            (place "VerticalHorse1" {"G10" "AD10"}) (place "BurningSoldier1" {"H10" "AC10"})
            (place "DragonHorse1" {"I10" "AB10"}) (place "DragonKing1" {"J10" "AA10"})
            (place "SwordSoldier1" {"K10" "Z10"}) (place "HornedFalcon1" {"L10" "Y10"})
            (place "SoaringEagle1" {"M10" "X10"}) (place "SpearSoldier1" {"N10" "W10"}) 
            (place "VerticalLeopard1" {"O10" "V10"}) (place "SavageTiger1" {"P10" "U10"})
            (place "CrossBowSoldier1" {"Q10" "T10"}) (place "LionDog1" coord:"R10")
            (place "RoaringDog1" coord:"S10")
            
            
            (place "LeftChariot2" coord:"AJ27") (place "RightChariot2" coord:"A27")
            (place "SideMonkey2" {"B27" "AI27"})
            (place "VerticalMover2" {"C27" "AH27"}) (place "OxGeneral2" {"D27" "AG27"})
            (place "LongbowSoldier2" {"E27" "AF27"}) (place "VerticalPup2" {"F27" "AE27"})
            (place "VerticalHorse2" {"G27" "AD27"}) (place "BurningSoldier2" {"H27" "AC27"})
            (place "DragonHorse2" {"I27" "AB27"}) (place "DragonKing2" {"J27" "AA27"})
            (place "SwordSoldier2" {"K27" "Z27"}) (place "HornedFalcon2" {"L27" "Y27"})
            (place "SoaringEagle2" {"M27" "X27"}) (place "SpearSoldier2" {"N27" "W27"}) 
            (place "VerticalLeopard2" {"O27" "V27"}) (place "SavageTiger2" {"P27" "U27"})
            (place "CrossBowSoldier2" {"Q27" "T27"}) (place "LionDog2" coord:"S27")
            (place "RoaringDog2" coord:"R27")
            
            
            (place "Pawn1" (sites Row 10))
            
            
            (place "Pawn2" (sites Row 25))
            
            
            (place "LeftDog1" {"F12" "O12"}) (place "RightDog1" {"V12" "AE12"})
            (place "GoBetween1" {"K12" "Z12"})
            
            
            (place "LeftDog2" {"V25" "AE25"}) (place "RightDog2" {"F25" "O25"})
            (place "GoBetween2" {"K25" "Z25"})
        })
        
        (play
            (if "SameTurn"
                (or
                    (move 
                        Promote 
                        (last To) 
                        (piece (mapEntry "Promoted" (what at:(last To)))) 
                        (then (set State at:(last To) 1))
                    )
                    (move Pass)
                ) 
                (forEach Piece) 
            )
        )
        
        (end 
            (if 
                (and { 
                    (not (is Mover Next)) 
                    (= (where "King" Next) Off) 
                    (= (where "Prince" Next) Off) 
                }) 
                (result Mover Win)
            )
        )
        
    )
)

Construct a Ludii game based on the following description
Nerenchi Keliya is an alignment game played in Sri Lanka. Graffiti on earlier monuments may suggest the game has a certain degree of antiquity on the island.Three concentric squares with lines connecting the midpoints of the squares. Nine pieces per player. Players alternate turns placing one of their pieces on an empty space. If a player places three of their pieces along one of the straight lines, they take another turn. Once all of the pieces are on the board, players take turns moving a piece to an empty space on the board. When a player creates a line of three in this phase, the player removes one of the opponent's pieces, and receives another turn. The player who reduces the opponent to two pieces wins. 
(game "Nerenchi Keliya"
    (players 2)
    
    (equipment { 
        ("NineMensMorrisBoard")
        (hand Each)
        (piece "Marker" Each ("StepToEmpty" ~ (then ("ReplayIfLine3")))) 
    }) 
    (rules 
        (start (place "Marker" "Hand" count:9))
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                    "IfLine3MoveAgainPlacement" 
                ) 
            ) 
            (nextPhase (and ("HandEmpty" P1) ("HandEmpty" P2)) "Movement")
        )
        
        (phase "Movement" 
            (play (forEach Piece))
            (nextPhase Mover (is Line 3) "Capture")
        )
        
        (phase "Capture" 
            (play ("RemoveAnyEnemyPiece" (then (moveAgain))))
            (nextPhase Mover "Movement")
        )
        }
        
        (end
            (forEach Player
                if:(<= (count Pieces Player) 2)
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Players take turn placing tiles onto a 5x5 square board.DROP - A player, on his turn, can drop a stone on an empty cell.
            SHIFT - Instead of dropping a stone, the player may decide to shift one row or column, one cell left/right (for rows) or up/down (for columns). 
            All stones are shifted on the chosen direction. If a stone is shifted off-board, it is placed on the other end of the shifted row/column (so, for shift purposes, the board is a Torus).
            KO rule- If a player has just shifted, the next player cannot shift that row/column.
            
        GOAL - A player wins when he makes a 5 in-a-row (orthogonal or diagonal). If a shift give both players a 5 in-a-row, wins the player that made that shift. 
(game "Kassle"
    (players 2)
    (equipment {
        (board (square 5))
        (piece "Square" Each)
    })
    (rules
        (play 
            (or {
                (move Add (to (sites Empty)))
                ("ShiftLeft")
                ("ShiftRight")
                ("ShiftUp")
                ("ShiftDown")
            })
        )
        (end {
            (if (and ("IsLine" P1) ("IsLine" P2)) 
                (result Mover Win)
            )
            (if ("IsLine" P1) 
                (result P1 Win)
            )
            (if ("IsLine" P2) 
                (result P2 Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
The Babylonian was a game that became popular in Paris around 1736, and continued to be played in the Netherlands into the nineteenth century. It was played on a Polish Draughts Board, but the pieces move as Chess queens.10x10 checkered board. Twenty pieces per player, arranged on the four rows closest to the player. Pieces move orthogonally or diagonally in any direction, only on the white spaces. Pieces may capture by jumping over an enemy piece to an empty space on the other side of it. Multiple captures in one turn are allowed. The player to capture all of the opponent's pieces wins. 
(game "The Babylonian" 
    (players 2) 
    (equipment { 
        (board (square 10)) 
        (piece "Counter" Each "CounterMove")
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    (rules 
        ("WhiteCellsSetup" 4)
        
        (play 
            (if ("SameTurn")
                (or {
                    ("HopCapture" (from (last To)) Diagonal ("MoveAgainIfCanCaptureAgain"))
                    ("OrthogonalHopCaptureCounter" (from (last To)) ("MoveAgainIfCanCaptureAgain"))
                    (move Pass)
                })
                (forEach Piece)
            )
        ) 
        
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
Manzhouqi is a game described by Xu Ke, a Qing Dynasty historian, who says it was played in Manchuria. It is similar to Xiangqi, and each player plays with different pieces.Manzhouqi is played on a Xiangqi board. The black player's pieces are set up as in Xiangqi, but the white player has the following pieces: Five soldiers: Move one space forward orthogonally. Two courtiers: Move one space diagonally and cannot leave the palace. One general: Moves on space orthogonally and cannot leave the palace. Two elephants: Move two spaces diagonally and cannot cross the river. One chariot: can move any distance orthogonally, taking either by jumping or by landing on the same space, and can also move like a knight in chess. The player that checkmates the other player's general wins. 
(game "Manzhouqi" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (rectangle 10 9) use:Vertex)
        
        
        (piece "Jiang" Each ("StepMoveOnThePalace" Orthogonal)) 
        
        
        (piece "Shi" Each ("StepMoveOnThePalace" Diagonal)) 
        
        
        (piece "Xiang" Each 
            ("SlideCapture"
                Diagonal 
                (between 
                    (exact 2) 
                    if:(and { 
                        (is In (between) (sites Mover "Home")) 
                        (is Empty (between)) 
                    })
                )
            )
        ) 
        
        
        (piece "Ma" Each "HorseMove")
        
        
        (piece "Ju" Each 
            (if (is Mover P2) 
                "ChariotMove" 
                (or { "ChariotMove" "HorseMove" "CanonMove" })
            ) 
        )
        
        
        (piece "Pao" Each "CanonMove") 
        
        
        (piece "Zu" Each 
            ("StepToNotFriend"
                (if 
                    (is In (from) (sites Mover "Home")) 
                    Forward 
                    (directions {Forward Rightward Leftward})
                ) 
            )
        )
        
        (regions "PalaceP1" P1 { 3..5 12..14 21..23 })
        (regions "PalaceP2" P2 { 66..68 75..77 84..86 })
        (regions "Home" P1 (expand (sites Bottom) steps:4))
        (regions "Home" P2 (expand (sites Top) steps:4))
    }) 
    
    (rules 
        (start { 
            (place "Jiang1" coord:"E1") (place "Shi1" {"D1" "F1"}) (place "Xiang1" {"C1" "G1"}) (place "Ju1" coord:"A1") (place "Zu1" {"A4" "C4" "E4" "G4" "I4"})
            (place "Jiang2" coord:"E10") (place "Shi2" {"D10" "F10"}) (place "Xiang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Ju2" {"A10" "I10"}) (place "Pao2" {"B8" "H8"}) (place "Zu2" {"A7" "C7" "E7" "G7" "I7"})
        })
        
        (play (do 
                (forEach Piece) 
                ifAfterwards:(and 
                    ("JiangSameColumnWithNoPieceBetween")
                    (not ("IsInCheck" "Jiang" Mover))
                )
            )
        )
        
        (end { 
            ("Checkmate" "Jiang")
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
A variation of 4-player chess with levels.All movement of chessman’s are the same, just if you want to go on higher level, you can just go on first reachable chess box of higher level. And on next move, go on that level or to lower levels without restrictions. Knight goes without any restrictions.
            
        Once a player is checkmated their king is removed, but all their other pieces remain on the board as neutral obstacles. Neutral pieces cannot help checkmate other players. If a player cannot make a move when there are more than two players remaining, they skip their turn rather than giving a stalemate. Four Players.
(game "Level Chess" 
    (players <NumOfPlayers:NumPlayers>) 
    (equipment { 
        (board 
            <NumOfPlayers:BoardShape>
        ) 
        
        (piece "Pawn" Each 
            (if (is Active (who at:(from)))
                (or {
                    (if (is In (from) (sites Start (piece (what at:(from)))))
                        "DoubleStep"
                    )
                    "StepForwardToEmpty" 
                    ("StepToEnemy" (directions {FR FL}))
                    "EnPassant"
                    }
                    (then
                        (and
                            ("ReplayInMovingOn" (sites Mover "Promotion"))
                            (set Counter)
                        )
                    )
                )
            )
        )
        
        (piece "Rook" Each 
            (if (is Active (who at:(from)))
                (move Slide 
                    Orthogonal 
                    (to 
                        if:(or ("IsEnemyAt" (to)) (and (< ("GetSiteLevel" (from)) ("GetSiteLevel" (to))) (not ("IsFriendAt" (to)))))
                        "CaptureToPieceAndResetCounter"
                    ) 
                    "RememberPieceHasMoved"
                )
            )
        )
        (piece "King" Each 
            (if (is Active (who at:(from)))
                (move Step 
                    (to 
                        if:(not ("IsFriendAt" (to))) 
                        "CaptureToPieceAndResetCounter"
                    ) 
                    "RememberPieceHasMoved"
                )
            )
        )
        (piece "Bishop" Each 
            (if (is Active (who at:(from)))
                (move Slide 
                    Diagonal 
                    (to 
                        if:(or ("IsEnemyAt" (to)) (and (< ("GetSiteLevel" (from)) ("GetSiteLevel" (to))) (not ("IsFriendAt" (to)))))
                        "CaptureToPieceAndResetCounter"
                    ) 
                )
            )
        )
        (piece "Knight" Each 
            (if (is Active (who at:(from)))
                (move
                    (from)
                    (to 
                        (difference
                            (forEach 
                                (sites Board)
                                if:(and { 
                                    (not ("IsFriendAt" (site)))
                                    (= 3 (count Steps Orthogonal (from) (site)))
                                })
                            )
                            (sites To (slide (between if:True)))
                        )
                        "CaptureToPieceAndResetCounter"
                    )
                )
            )
        )
        (piece "Queen" Each 
            (if (is Active (who at:(from)))
                (move Slide 
                    (to 
                        if:(or ("IsEnemyAt" (to)) (and (< ("GetSiteLevel" (from)) ("GetSiteLevel" (to))) (not ("IsFriendAt" (to)))))
                        "CaptureToPieceAndResetCounter"
                    ) 
                ) 
            )
        )
        
        <NumOfPlayers:BoardRegions>
        
    }) 
    (rules 
        (start { 
            <NumOfPlayers:PieceSetup>
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        (if (and 
                                ("HasNeverMoved" "King")
                                (not ("IsInCheck" "King" Mover)) 
                            )
                            (or {
                                (if (and 
                                        ("HasNeverMoved" "RookLeft")
                                        (can Move ("CastleRook" "RookLeft" E 3 (is Empty (to))))
                                    )
                                    "BigCastlingHor"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookRight")
                                        (can Move ("CastleRook" "RookRight" W 2 (is Empty (to))))
                                    )
                                    "SmallCastlingHor"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookLeft")
                                        (can Move ("CastleRook" "RookLeft" S 3 (is Empty (to))))
                                    )
                                    "BigCastlingVer"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookRight")
                                        (can Move ("CastleRook" "RookRight" N 2 (is Empty (to))))
                                    )
                                    "SmallCastlingVer"
                                )
                            })
                        )
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
                (then
                    <NumOfPlayers:CheckMate>
                )
            )
        )
        
        (end {
            (forEach NonMover
                if:("IsOffBoard" (where "King" Player)) 
                (result Player Loss)
            )
            (if (and (<= (count Active) 2) (or (no Moves Mover) (= (counter) (* 50 (count Active))))) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Lau Kata Kati is a leaping capture game similar to Alquerque observed during the nineteenth century in India, but which is probably much older.Play begins with each player's pieces on the pieces occupying the points of one of the triangles, leaving the shared apex empty. Pieces move to the next adjacent point connected by a line. Captures are made by hopping over an opponent's piece. The player who captures all of the opponent's pieces wins. The player loses when he has no piece.
(game "Lau Kata Kati" 
    (players 2) 
    (equipment { 
        (board 
            (merge
                (wedge 4)
                (shift 0 3 (rotate 180 (wedge 4)))
            ) 
            use:Vertex
        )
        (piece "Counter" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Counter1" (expand (sites Bottom) steps:2))
            (place "Counter2" (expand (sites Top) steps:2))
        })
        
        (play (forEach Piece))
        
        (end <End>)
    )
)

Describe the mechanics of the following Ludii game
(game "Msuwa" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start {
            (set Count 2 to:(difference (sites Board) (sites {<Row:specialHoles>}))) 
            (set Count 1 to:(sites {<Row:singleHoles>})) 
        })
        
        (play 
            (if (and 
                    ("SameTurn") 
                    (< 0 (var))
                )
                (move Remove 
                    (forEach
                        (sites Next "Home")
                        if:(< 0 (count at:(site)))
                    )
                    (then 
                        (and
                            (if (> (var) 1)
                                (moveAgain)
                            )
                            (set Var (- (var) 1))
                        )
                        
                    )
                )
                (if ("HaveHolesWithMoreThanOneCounter") 
                    (move Select
                        (from 
                            (if ("SameTurn") 
                                "LastHoleSowed" 
                                (sites Mover "Home") 
                            ) 
                            if:(< 1 (count at:(from)))
                        )
                        (then 
                            (sow
                                "Track"
                                owner:(mover)
                                apply:(if (< 1 (count at:(to)))
                                    (moveAgain)
                                    (if (is In (to) (sites Mover "Inner"))
                                        (if (< 0 (count at:("OppositePit" (to))))
                                            (and
                                                (remove ("OppositePit" (to)))
                                                (if (< 0 (count at:("OppositeOuterPit" (to))))
                                                    (and {
                                                        (remove ("OppositeOuterPit" (to)))
                                                        (set Var 2)
                                                        (moveAgain)
                                                    })
                                                )
                                            )
                                        )
                                    )
                                ) 
                            )
                        )
                    )
                    (move Select
                        (from 
                            (sites Mover "Home") 
                            if:(and
                                (= 1 (count at:(from)))
                                (= 0 (count at:("NextHoleFrom" (from))))
                            )
                        )
                        (then 
                            (sow
                                "Track"
                                owner:(mover)
                                apply:
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (< 0 (count at:("OppositePit" (to))))
                                        (and
                                            (remove ("OppositePit" (to)))
                                            (if (< 0 (count at:("OppositeOuterPit" (to))))
                                                (and {
                                                    (remove ("OppositeOuterPit" (to)))
                                                    (set Var 2)
                                                    (moveAgain)
                                                })
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)
Msuwa is a four-row mancala-style board game played by the Nyanja people of East Africa.4x10-20 holes, with even numbers. Two counters in each hole, except the rightmost hole in the inner row of each player, which has zero, and the hole to its left, which has one. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from two other holes on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 10 holes.

Describe the mechanics of the following Ludii game
(game "Isolo" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))          
        (regions "Outer" P2 (sites Top))           
        (piece "Seed" Shared)
        (hand Each)
        (map "RightmostOuter" {(pair P1 7) (pair P2 24)})
        (map "RightmostInner" {(pair P1 15) (pair P2 16)})
        (map "SecondRightmostInner" {(pair P1 14) (pair P2 17)})
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))
        )
        
        phases:{
        (phase "Opening1"
            (play
                (forEach Site (difference (sites Mover "Outer") (mapEntry "RightmostOuter" Mover))
                    (if (is Occupied (site))
                        (move
                            (from (site))
                            (to (mapEntry "RightmostOuter" Mover))
                            count:(count at:(site))
                        )
                    )
                )
            )
            (nextPhase Mover (all Sites (difference (sites Mover "Outer") (mapEntry "RightmostOuter" Mover)) if:(is Empty (site))) "Opening2")
        )
        (phase "Opening2"
            (play
                (forEach Site (sites Mover "Inner")
                    (if (= 2 (count at:(site)))
                        (move
                            (from (site))
                            (to ("InnerToOuter" (site)))
                            count:1
                        )
                    )
                )
            )
            
            (nextPhase Mover (all Sites (sites Mover "Inner") if:(= (count at:(site)) 1)) "Opening3")
        )
        
        (phase "Opening3"
            (play
                (move Select 
                    (from
                        (if ("SameTurn")
                            ("LastHoleSowed") 
                            (sites {(mapEntry "RightmostInner" Mover)})
                        )
                    )
                    (then 
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (!= (to) (mapEntry "RightmostOuter" Mover))
                                (moveAgain)
                                (fromTo
                                    (from (to))
                                    (to (mapEntry "SecondRightmostInner" Mover))
                                    count:1
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (not (is Next Mover)) "InitialSowing")
        )
        
        (phase "InitialSowing"
            (play
                (move Select
                    (from
                        (if ("SameTurn")
                            ("LastHoleSowed") 
                            (sites Mover "Home")
                        )
                        if:(is Occupied (from))
                    )
                    (then
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (or (is Occupied ("OppositePit" (to))) (is Occupied ("OppositeOuterPit" (to))))
                                        (and {
                                            (if (is Occupied ("OppositePit" (to)))
                                                (fromTo
                                                    (from ("OppositePit" (to)))	
                                                    (to (last From))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                            )
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))	
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                            )
                                            (sow
                                                (last From)
                                                count:(+ (count at:("OppositeOuterPit" (to))) (count at:("OppositePit" (to))))
                                                "TrackCCW"
                                                owner:(mover)
                                                skipIf:(is In (to) (sites {(mapEntry "RightmostOuter" Mover) (mapEntry "RightmostInner" Mover)}))
                                            )
                                        })
                                        (moveAgain)
                                    )
                                    (moveAgain)
                                )
                            )
                            skipIf:(is In (to) (sites {(mapEntry "RightmostOuter" Mover) (mapEntry "RightmostInner" Mover)}))
                        )
                    )
                )
                
            )
            (nextPhase Mover (is In (last From) (sites {(mapEntry "RightmostOuter" Mover) (mapEntry "RightmostInner" Mover)})) "InitialSowing")
        )
        
        (phase "Sowing"
            (play
                (move Select
                    (from
                        (sites Mover "Home")
                        if:(is Occupied (from))
                    )
                    (then
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (or (is Occupied ("OppositePit" (to))) (is Occupied ("OppositeOuterPit" (to))))
                                        (and {
                                            (if (is Occupied ("OppositePit" (to)))
                                                (fromTo
                                                    (from ("OppositePit" (to)))	
                                                    (to (last From))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                            )
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))	
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                            )
                                            (sow
                                                (last From)
                                                count:(+ (count at:("OppositeOuterPit" (to))) (count at:("OppositePit" (to))))
                                                "TrackCCW"
                                                owner:(mover)
                                            )
                                        })
                                        (moveAgain)
                                    )
                                    (moveAgain)
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        (end ("ForEachPlayerNoMovesLoss"))
    )
)
Isolo is a four-row mancala-style board game played by the Sukuma people in Tanzania. This game is typically played by boys.4x8 board. Play begins with two counters in each hole. Opening moves: Players place all of the counters in the outer row into their rightmost hole. They then take one counter from each of the holes in the inner row and redistribute them into the outer row, one in each hole. Then, each player sows counters in an anti-clockwise direction beginning from the rightmost hole in the inner row, proceeding, picking up the contents of holes when the last counter falls into an occupied hole and continuing sowing. However, the final counter that would fall into the rightmost hole in the outer row (which should now contain 17 counters) is not placed there, but rather on the second to right hole in the inner row, which should now contain one counter. Initial phase: In the initial phase, the rightmost hole in the inner and outer row for each player are out of play. All sowing and capturing only occurs on the remaining holes. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an empty hole, the turn ends. When it falls into an occupied hole in the player's inner row the contents of the opponent's opposite holes in the inner and outer row are captured. These are then sown in the player's holes beginning with the hole from where the previous sowing began. If the final counter of a sowing falls into an occupied hole that cannot make a capture, then the counters in this hole are picked up and sowing continues. Second phase: The initial phase ends when a player plays from the rightmost hole in the outer row. This can be by necessity or by choice. Once this happens, that player must play in all of their holes. The opponent may remain in the initial phase after this point until they play from their rightmost hole. The same sowing and capturing rules as before. Play continues until one player can no longer move. 

Construct a Ludii game based on the following description
Walak-Pussa is a two-row mancala-style board game played in Sri Lanka. 2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. Players sow beginning from holes in their row. If the last counter falls into a hole with counters, the counters in the next hole are picked up and sowing continues, and if this hole is empty, the counters in the hole following the empty hole are captured. If there is an unbroken sequence of alternating empty and occupied holes, the counters in the occupied holes are captured until there are two empty or two occupied holes. If the final counter falls into an empty hole the turn ends. Throughout the game, singletons cannot be moved is a player has a hole with multiple counters, and a singleton in the front hole cannot be moved if there are other singletons in the player's row. The round ends when one player's holes are empty. 
            
            A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round. The player with empty holes begins play in the direction of the empty hole. Counters cannot be captured or sowed from puta or naga holes. Play continues as before.
            
            When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters.
            
        Play continues until one player cannot sow at the beginning of a round. 
(game "Walak-Pussa" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "TrackCCW" "1,E,N,W" loop:True)
            (track "TrackCW" "7,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        (start { 
            (set Count 4 to:(sites Track)) 
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "StartingMove" 
            (play
                (or
                    (move Select
                        (from
                            (sites Mover)
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (and
                                (sow
                                    "TrackCCW"
                                    apply:(if (= 1 (count at:(to)))
                                        (if (< 0 (count at:("NextHole" (to) "TrackCCW" 1)))
                                            (and
                                                (fromTo
                                                    (from ("NextHole" (to) "TrackCCW" 1))
                                                    (to (mapEntry Mover))
                                                    count:(count at:("NextHole" (to) "TrackCCW" 1))
                                                )
                                                (if (and (= 0 (count at:("NextHole" (to) "TrackCCW" 2))) (< 0 (count at:("NextHole" (to) "TrackCCW" 3))))
                                                    (and
                                                        (fromTo
                                                            (from ("NextHole" (to) "TrackCCW" 3))
                                                            (to (mapEntry Mover))
                                                            count:(count at:("NextHole" (to) "TrackCCW" 3))
                                                        )
                                                        (if (and (= 0 (count at:("NextHole" (to) "TrackCCW" 4))) (< 0 (count at:("NextHole" (to) "TrackCCW" 5))))
                                                            (and
                                                                (fromTo
                                                                    (from ("NextHole" (to) "TrackCCW" 5))
                                                                    (to (mapEntry Mover))
                                                                    count:(count at:("NextHole" (to) "TrackCCW" 5))
                                                                )
                                                                (if (and (= 0 (count at:("NextHole" (to) "TrackCCW" 6))) (< 0 (count at:("NextHole" (to) "TrackCCW" 7))))
                                                                    (fromTo
                                                                        (from ("NextHole" (to) "TrackCCW" 7))
                                                                        (to (mapEntry Mover))
                                                                        count:(count at:("NextHole" (to) "TrackCCW" 7))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                    skipIf:(not (is In (to) ("PlayableSites")))
                                )
                                (set Var "Direction" 1)
                            )
                        )
                    )
                    (move Select
                        (from
                            (sites Mover)
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (and
                                (sow
                                    "TrackCW"
                                    apply:(if (= 1 (count at:(to)))
                                        (if (< 0 (count at:("NextHole" (to) "TrackCW" 1)))
                                            (and
                                                (fromTo
                                                    (from ("NextHole" (to) "TrackCW" 1))
                                                    (to (mapEntry Mover))
                                                    count:(count at:("NextHole" (to) "TrackCW" 1))
                                                )
                                                (if (and (= 0 (count at:("NextHole" (to) "TrackCW" 2))) (< 0 (count at:("NextHole" (to) "TrackCW" 3))))
                                                    (and
                                                        (fromTo
                                                            (from ("NextHole" (to) "TrackCW" 3))
                                                            (to (mapEntry Mover))
                                                            count:(count at:("NextHole" (to) "TrackCW" 3))
                                                        )
                                                        (if (and (= 0 (count at:("NextHole" (to) "TrackCW" 4))) (< 0 (count at:("NextHole" (to) "TrackCW" 5))))
                                                            (and
                                                                (fromTo
                                                                    (from ("NextHole" (to) "TrackCW" 5))
                                                                    (to (mapEntry Mover))
                                                                    count:(count at:("NextHole" (to) "TrackCW" 5))
                                                                )
                                                                (if (and (= 0 (count at:("NextHole" (to) "TrackCW" 6))) (< 0 (count at:("NextHole" (to) "TrackCW" 7))))
                                                                    (fromTo
                                                                        (from ("NextHole" (to) "TrackCW" 7))
                                                                        (to (mapEntry Mover))
                                                                        count:(count at:("NextHole" (to) "TrackCW" 7))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                    skipIf:(not (is In (to) ("PlayableSites")))
                                )
                                (set Var "Direction" 2)
                            )
                        )
                    )
                )
            )
            (nextPhase "Sowing")
        )
        
        (phase "Sowing" 
            (play
                (if (= 1 (var "Direction"))
                    (move Select
                        (from
                            (if (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay")})
                                (sites Mover)
                            )
                            if:(and { 
                                (is Occupied (from)) 
                                (is In (from) ("PlayableSites")) 
                                (not (is In (from) ("BlockingHoles")))
                                (if (not ("OnlySingleCounters"))
                                    (< 1 (count at:(from)))
                                )
                            })
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                apply:(if (= 1 (count at:(to)))
                                    (if (< 0 (count at:("NextHole" (to) "TrackCCW" 1)))
                                        (and
                                            (fromTo
                                                (from ("NextHole" (to) "TrackCCW" 1))
                                                (to (mapEntry Mover))
                                                count:(count at:("NextHole" (to) "TrackCCW" 1))
                                            )
                                            (if (and (= 0 (count at:("NextHole" (to) "TrackCCW" 2))) (< 0 (count at:("NextHole" (to) "TrackCCW" 3))))
                                                (and
                                                    (fromTo
                                                        (from ("NextHole" (to) "TrackCCW" 3))
                                                        (to (mapEntry Mover))
                                                        count:(count at:("NextHole" (to) "TrackCCW" 3))
                                                    )
                                                    (if (and (= 0 (count at:("NextHole" (to) "TrackCCW" 4))) (< 0 (count at:("NextHole" (to) "TrackCCW" 5))))
                                                        (and
                                                            (fromTo
                                                                (from ("NextHole" (to) "TrackCCW" 5))
                                                                (to (mapEntry Mover))
                                                                count:(count at:("NextHole" (to) "TrackCCW" 5))
                                                            )
                                                            (if (and (= 0 (count at:("NextHole" (to) "TrackCCW" 6))) (< 0 (count at:("NextHole" (to) "TrackCCW" 7))))
                                                                (fromTo
                                                                    (from ("NextHole" (to) "TrackCCW" 7))
                                                                    (to (mapEntry Mover))
                                                                    count:(count at:("NextHole" (to) "TrackCCW" 7))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                )
                                skipIf:(not (is In (to) ("PlayableSites")))
                            )
                        )
                    )
                    (move Select
                        (from
                            (if (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay")})
                                (sites Mover)
                            )
                            if:(and { 
                                (is Occupied (from)) 
                                (is In (from) ("PlayableSites")) 
                                (not (is In (from) ("BlockingHoles")))
                                (if (not ("OnlySingleCounters"))
                                    (< 1 (count at:(from)))
                                )
                            })
                        )
                        (then 
                            (sow
                                "TrackCW"
                                apply:(if (= 1 (count at:(to)))
                                    (if (< 0 (count at:("NextHole" (to) "TrackCW" 1)))
                                        (and
                                            (fromTo
                                                (from ("NextHole" (to) "TrackCW" 1))
                                                (to (mapEntry Mover))
                                                count:(count at:("NextHole" (to) "TrackCW" 1))
                                            )
                                            (if (and (= 0 (count at:("NextHole" (to) "TrackCW" 2))) (< 0 (count at:("NextHole" (to) "TrackCW" 3))))
                                                (and
                                                    (fromTo
                                                        (from ("NextHole" (to) "TrackCW" 3))
                                                        (to (mapEntry Mover))
                                                        count:(count at:("NextHole" (to) "TrackCW" 3))
                                                    )
                                                    (if (and (= 0 (count at:("NextHole" (to) "TrackCW" 4))) (< 0 (count at:("NextHole" (to) "TrackCW" 5))))
                                                        (and
                                                            (fromTo
                                                                (from ("NextHole" (to) "TrackCW" 5))
                                                                (to (mapEntry Mover))
                                                                count:(count at:("NextHole" (to) "TrackCW" 5))
                                                            )
                                                            (if (and (= 0 (count at:("NextHole" (to) "TrackCW" 6))) (< 0 (count at:("NextHole" (to) "TrackCW" 7))))
                                                                (fromTo
                                                                    (from ("NextHole" (to) "TrackCW" 7))
                                                                    (to (mapEntry Mover))
                                                                    count:(count at:("NextHole" (to) "TrackCW" 7))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                )
                                skipIf:(not (is In (to) ("PlayableSites")))
                            )
                        )
                    )
                    (then
                        (if (no Moves Next) 
                            (and {
                                (forEach Site (sites P1)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry P1))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site (sites P2)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forget Value "Playable" All)
                                (forget Value "Blocked" All)
                                (if (< ("PiecesOwnedBy" P1) ("PiecesOwnedBy" P2))
                                    (and
                                        (set NextPlayer (player 2))
                                        (set Var "Winner" 2)
                                    )
                                    (and
                                        (set NextPlayer (player 1))
                                        (set Var "Winner" 1)
                                    )
                                )
                            })
                        )
                    )
                )
            )
            
            (end (if (no Moves Next)
                    {
                    (if (> 2 (count at:(mapEntry P1))) (result P2 Win))
                    (if (> 2 (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase (no Moves Next) "BetweenRounds")
        )
        
        (phase "BetweenRounds" 
            (play
                (if (and ("NewTurn") (!= (mover) (var "Winner")))
                    (or
                        (move
                            (from (mapEntry Mover))
                            (to ("RightMostEmpty") if:(is Empty (to)))
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (if (> 4 (count at:(last To)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (mapEntry Next))
                                                count:(- 4 (count at:(last To)))
                                            )
                                            (remember Value "Blocked" (last To))
                                        )
                                    )
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                    (set Var "Direction" 2)
                                })
                            )
                        )
                        (move
                            (from (mapEntry Mover))
                            (to ("LeftMostEmpty") if:(is Empty (to)))
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (if (> 4 (count at:(last To)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (mapEntry Next))
                                                count:(- 4 (count at:(last To)))
                                            )
                                            (remember Value "Blocked" (last To))
                                        )
                                    )
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                    (set Var "Direction" 1)
                                })
                            )
                        )
                    )
                    (if (!= (mover) (var "Winner"))
                        (move
                            (from (mapEntry Mover))
                            (to 
                                (if (= (var "Direction") 1)
                                    ("NextHole" (last To) "TrackCCW" 1) 
                                    ("NextHole" (last To) "TrackCW" 1) 
                                )
                                if:(is Empty (to))
                            )
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                })
                            )
                        )
                        (move
                            (from (mapEntry Mover))
                            (to (sites Mover) if:(is Empty (to)))
                            count:4
                            (then (and
                                    (remember Value "Playable" (last To))
                                    (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing") 
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Shatren" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn" ~
            (then
                (if (is In (last To) (sites Mover "Promotion")) 
                    ("PromotedPiece")
                )
            )
        )
        
        ("ChessRook" "Castle")
        (piece "King_noCross" Each 
            (or
                ("StepToNotFriend")
                (if (not ("IsInCheck" "King_noCross" Mover))
                    ("LeapCapture" "KnightWalk")
                )
            )
        )
        ("ChessBishop" "Elephant")
        ("ChessKnight" "Horse")
        ("ChessQueen" "Queen")
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Castle1" {"A1" "H1"} state:1) (place "Horse1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1" state:1) 
            (place "Castle2" {"A8" "H8"} state:1) (place "Horse2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8" state:1) 
        })
        
        (play 
            (do 
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        
        (end ("Checkmate" "King_noCross"))
    )
)
Shatren is a capturing game similar to other games that are derived from Chaturanga. It was played in Colombo, typically by Tamil and other Indian residents of the city, but not in the villages throughout the island.8x8 checkered board. Pieces move according to specialized moves, as follows: Piyatha (x8): can move one space forward, and one space forward diagonally to capture. When they reach the final rank, they may be promoted to the piece belonging to that rank, as long as it has already been captured by the opponent; Rukh (castle), (x2): can move any number of spaces orthogonally; Fil (elephant), (x2): can move any number of spaces diagonally; Ghoda (horse), (2): moves in any direction, one space orthogonally with one space forward diagonally; Farthir (x1): can move any number of spaces orthogonally or diagonally; Shah (x1): can move one space orthogonally or diagonally, and can also move like the horse if it has not yet been checked. The pieces are arranged as in Chess. Players capture pieces by moving onto a space occupied by an opponent's piece.  When a player can capture the opponent's Shah on the next turn, the Shah is in Check, the opponent's next move must free the Shah from Check. If the opponent cannot, it is Checkmate and the player wins. Stalemate is allowed.
         

Construct a Ludii game based on the following description
This blocking game is played on a 5x5.TURNS - At each turn, each player slides (vertically or horizontally) a stone into the only empty cell.
            
        GOAL - Wins the player who made the last move. 
(game "Lewthwaite's Game" 
    (players 2) 
    (equipment { 
        (board (square 5) use:Vertex)
        (piece "Ball" Each (move Slide)) 
    }) 
    (rules 
        (start {
            (place "Ball1" (sites Phase 1))
            (place "Ball2" (difference (sites Phase 0) (sites Centre)))
        })
        (play (forEach Piece)) 
        (end ("BlockWin"))
    )
)

Construct a Ludii game based on the following description
Pon Chocotl is a hunt game played by the Pima people in the southwest United States. It seems to be related to hunt games played by the Spanish.To be reconstructed. Rules as inferred by Murray 1951. One player is the bean, and the other player plays with twelve corn kernels. The corn kernels move along the lines. The goal is to corner the bean so that it cannot move. The bean may hop over the corn kernels to capture them or move to an adjacent empty point along the lines. The bean wins by reducing the opponent to nine corn kernels. The coyote can jump to capture.
(game "Pon Chochotl" 
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 5 5)
        (piece "Corn" P1 "StepToEmpty") 
        (piece "Bean" P2 
            (or <Jump:bean> 
                (if ("SameTurn") 
                    (move Pass) 
                    ("StepToEmpty")
                ) 
            ) 
        )
    }) 
    (rules 
        (start { 
            (place "Corn1" (union {(expand (sites Bottom)) (sites {"A3" "E3"})}))
            (place "Bean2" (centrePoint))
        })
        
        (play (forEach Piece)) 
        
        (end ("NoMovesLossAndLessNumPiecesPlayerLoss" P1 9))
    )
)

Construct a Ludii game based on the following description
Enindji is a two-row mancala-style board game that was documented in Dahomey in the early twentieth century. It is similar to other games in the region like Oware, but has a unique capture where the owner of the hole, rather than the person sowing, captures the counters.2x6 board, with a storage hole on either end. The game starts with four counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a counterclockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. When the final counter of a sowing lands in a hole with three counters, the owner of that hole captures the counters. If an opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row.
         
(game "Enindji" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (if (is Proposed "End")
                (or (move Vote "End") (move Vote "No"))
                (or
                    (if (is Cycle) (move Propose "End")) 
                    (do 
                        (move Select 
                            (from 
                                (sites Mover) 
                                if:(< 0 (count at:(from)))
                            )
                            (then 
                                (sow 
                                    if:(= (count at:(to)) 4)
                                    apply:(fromTo 
                                        (from (to)) 
                                        (to (if (is In (to) (sites P1)) (mapEntry 1) (mapEntry 2)))
                                        count:(count at:(to))
                                    )
                                    includeSelf:False
                                )
                            )
                        )
                        ifAfterwards:(< 0 (count in:(sites Next)))
                    )
                )
            )		
        )
        
        (end ("MancalaByScoreWhen" (and (no Moves Mover) (no Moves Next))))
    )
)

Construct a Ludii game based on the following description
Krida Buddhibalasrita (\8x8 board, with markings in the four central squares, the four corner squares, and the two middle squares of each edge. The pieces have the following movement values: Raja (x1): moves one space in any direction; Mantri (x1): moves diagonally one space; Karabha (x2): jumps exactly two squares diagonally; Raji (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Kunjara (x2): moves orthogonally any distance; Patti (x8): move forward orthogonally one space, diagonally forward one space to capture. When a Patti reaches a marked space on the opposite edge of the board, it is promoted to Mantri if it is on a marked square. If it is on an unmarked square, the Patti must move back to the space from which it moved to the last row and is then promoted to Mantri. If the Raja can be taken on the opponent's next turn, it is in check. The Raja must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins.If a Raja is in stalemate, and no other pieces can move the player may remove one of the opponent's pieces causing the stalemate. If the opponent is reduced to only their Raja, it is also a victory, though considered a lesser one. Checking the opponent's Raja 64 consecutive times is a win.
         
(game "Krida Buddhibalasrita" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        ("ChessKing" "King_noCross")
        (piece "Ferz_noCross" Each ("StepToNotFriend" Diagonal))
        ("ChessKnight" "Knight")
        (piece "Elephant" Each ("ElephantMove"))
        ("ChessRook" "Rook")
        ("ChessPawn" "Pawn" ~
            (then
                (if (is In (last To) (sites Mover "Promotion"))
                    (and
                        (promote (last To) (piece "Ferz_noCross") Mover)
                        (if (not (is In (last To) (sites "PromotionMarked")))
                            (fromTo (from (last To)) (to (last From)))	
                        )
                    )
                )
            )
        )
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
        (regions "PromotionMarked" (sites {"A1" "D1" "E1" "H1" "A8" "D8" "E8" "H8"}))
    })
    
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        
        (play 
            (if (can Move ("Move"))
                ("Move")
                (move Remove (difference (sites Occupied by:Next) (sites Occupied by:Next component:"King_noCross")))
            )
        )
        
        (end {
            (if (or
                    (and 
                        ("IsInCheck" "King_noCross" Next)
                        ("NextCanNotMove")
                    ) 
                    (= 1 (count Pieces Next))
                )
                (result Mover Win)
            ) 
            (if (= (value Player P1) 64) (result P1 Win)) 
            (if (= (value Player P2) 64) (result P2 Win)) 
        })
    )
)

Construct a Ludii game based on the following description
Quarto has a 4×4 board and 16 pieces. Each piece has four dichotomous attributes – color, height, shape, and consistency – so each piece is either black or white, tall or short, square or round, and hollow or solid.Each piece has four dichotomous attributes – color, height, shape, and consistency – so each piece is either black or white, tall or short, square or round, and hollow or solid. The object is to place the fourth piece in a row in which all four pieces have at least one attribute in common. The twist is that your opponent gets to choose the piece you place on the board each turn. 
(game "Quarto"
    (players 2)
    (equipment {
        (board (square 4) use:Vertex)
        (piece "Disc" Each)
        (piece "Square" Each)
        (hand Shared size:16)
    })
    (rules 
        (start {
            (place "Disc1" (handSite Shared 0))
            (place "Disc1" (handSite Shared 1) value:1)
            (place "Disc1" (handSite Shared 2) state:1)
            (place "Disc1" (handSite Shared 3) state:1 value:1)
            (place "Disc2" (handSite Shared 4))
            (place "Disc2" (handSite Shared 5) value:1)
            (place "Disc2" (handSite Shared 6) state:1)
            (place "Disc2" (handSite Shared 7) state:1 value:1)
            (place "Square1" (handSite Shared 8))
            (place "Square1" (handSite Shared 9) value:1)
            (place "Square1" (handSite Shared 10) state:1)
            (place "Square1" (handSite Shared 11) state:1 value:1)
            (place "Square2" (handSite Shared 12))
            (place "Square2" (handSite Shared 13) value:1)
            (place "Square2" (handSite Shared 14) state:1)
            (place "Square2" (handSite Shared 15) state:1 value:1)
        })
        phases:{
        (phase "Select" 
            (play 
                (move Select 
                    (from 
                        Cell
                        (difference 
                            (sites Hand Shared) 
                            (sites Empty 1)
                        )
                    )
                )
            )
            (nextPhase "Place")
        )
        (phase "Place" 
            (play
                (move 
                    (from Cell (last From))
                    (to (sites Empty))
                    (then (moveAgain))
                )
            )
            (end { 
                
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2)}) (result Mover Win))
                (if (is Line 4 All whats:{(id "Square" P1) (id "Square" P2)}) (result Mover Win))
                
                
                (if (is Line 4 All P1) (result Mover Win))
                (if (is Line 4 All P2) (result Mover Win))
                
                
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 0 (state at:(to)))) (result Mover Win))
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 1 (state at:(to)))) (result Mover Win))
                
                
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 0 (value Piece at:(to)))) (result Mover Win))
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 1 (value Piece at:(to)))) (result Mover Win))
            })
            (nextPhase "Select")
        )
        }
    )
)

Construct a Ludii game based on the following description
Njombwa is a four-row mancala-style board game played by the Yao people of East Africa. In this version, players begin with one counter in each hole.4x8 board, occasionally 4x9 or 10. One counter in each hole. Sowing occurs in an anti-clockwise direction. The players start by each making a stylised move. Sowing begins from the rightmost hole in the outer row. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the sowing reaches the hole immediately before the one from which the sowing began (I.e,, the second-to-right hole in the outer row), these two counters are picked up and both placed in the rightmost hole in the outer row. The player then removes the two counters in the second-to-right hole in the inner row from the board. When both players complete this move, the main phase of the game begins. Players sow from any hole in their two rows. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opponent's opposite hole in their inner row are captured. If there are also counters in the opponent's opposite hole in the outer row, these are also captured, but only when a capture from the inner row was also made. Players cannot sow single counters, unless there are no holes with multiple counters left, in which case single counters may be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. Each row has 8 holes.
(game "Njombwa (One Counter)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Row:track2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (regions "Outer" P1 (sites Bottom))          
        (regions "Outer" P2 (sites Top))          
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start 
            (set Count 1 to:(sites Board)) 
        )
        
        phases:{
        (phase "Opening1"
            (play
                (move Select
                    (from
                        (if 
                            ("SameTurn") 
                            "LastHoleSowed" 
                            ("RightMostHole")
                        ) 
                        if:(> (count at:(from)) 0)
                    )
                    (then
                        (sow
                            "Track"
                            owner:(mover)
                            apply:(if (and (not (is In ("NextHole" (to) 1) ("RightMostHole"))) (< 1 (count at:(to)))) (moveAgain))
                        )
                    )
                )
            )
            
            (nextPhase Mover (not (is Next Mover)) "Opening2")
        )
        
        (phase "Opening2"
            (play
                (move 
                    (from
                        (sites Mover "Home")
                        if:(is In ("NextHole" (from) 1) ("RightMostHole"))
                    )
                    (to
                        ("RightMostHole")	
                    )
                    count:2
                )
            )
            
            (nextPhase Mover "Opening3")
        )
        
        (phase "Opening3"
            (play
                (move Remove
                    ("SecondToRightInnerRow")
                )
            )
            
            (nextPhase Mover "Sowing")
        )
        (phase "Sowing"
            (play
                (if ("AllSitesNoMoreThanOne")
                    (move Select
                        (from (sites Mover "Home") if:(and (is Occupied (from)) (is Empty ("NextHole" (from) 1))))
                        (then 
                            (sow
                                "Track"
                                owner:(mover)		
                            )
                        )
                    )
                    (move Select
                        (from 
                            (if 
                                ("SameTurn") 
                                "LastHoleSowed"
                                (sites Mover "Home") 
                            ) 
                            if:(> (count at:(from)) 1)
                        )
                        (then
                            (sow
                                "Track"
                                owner:(mover)
                                apply:(if (< 1 (count at:(to)))
                                    (moveAgain)
                                    (if (and 
                                            (is In (to) (sites Mover "Inner"))
                                            (is Occupied ("OppositePit" (to)))
                                        )
                                        (and
                                            (remove ("OppositePit" (to)))
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (remove ("OppositeOuterPit" (to)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )		
            )
        )
        }
        
        (end
            (forEach NonMover
                if:("NoPiece")
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Len Doat is a race game that was played in nineteenth century Thailand. Four 3x5 grids, arranged in four corners of a rectangular board. Three pieces per player. Five cowrie shells used as dice; the value of the throw equaling the number of the mouths which land face up. Players begin by entering their pieces onto the board from the square in the central row of the grid to their right. A single piece may be entered with a throw of 1, or all of the player's pieces may be entered with a throw of 5. Throws of 1 and 5 grant the player another throw, and pieces are moved only after all of the players throws are made. Play proceeds down the central row where the pieces entered, in an anti-clockwise direction until reaching the bottom right hand corner of the left grid, at which point the track continues on the opponent's side of the board from the top right corner of the left board (with respect to the current player), proceeding around the opponent's grids in an anti-clockwise direction until reaching the top left square of the opponent's right grid. At this point, the piece returns to the player's own right grid, on the bottom left corner, and proceeding in an anti-clockwise direction into the central row, and off the board once moving past the final space. When a player lands on a space occupied by an opponent's piece, the opponent's piece is removed from the board and must re-enter as before. Pieces are safe from being sent back when resting on the left two corners of each grid on the left and the right two corners of each grid on the right. The first player to remove all of their pieces from the board wins.
         
(game "Len Doat"
    (players 2)
    (equipment {
        (board 
            (merge {
                (rectangle 3 5)
                (shift 7.5 0 (rectangle 3 5))
                (shift 0 3.5 (rectangle 3 5))
                (shift 7.5 3.5 (rectangle 3 5))
            })
            { 
            (track "Track1" "20,E,N,W,14,W,S,E,44,W,S,E,45,E,N,W,15,E,N1,W,End" P1 directed:True)
            (track "Track2" "39,W,S,E,45,E,N,W,15,E,N,W,14,W,S,E,44,W,S1,E,End" P2 directed:True)
            }
        )
        ("StickDice" 5)
        (hand Each)
        (piece "Marker" Each
            (if ("IsEndTrack" "SiteToMoveOnTrack")
                "RemoveAPiece"
                (if ("IsNotOffBoard" "SiteToMoveOnTrack") 	 			
                    (if (if
                            (not ("IsEnemyAt" "SiteToMoveOnTrack"))
                            True
                            (not (is In "SiteToMoveOnTrack" (sites "Protect")))
                        )
                        (move 
                            (from) 
                            (to 
                                "SiteToMoveOnTrack" 
                                "CaptureEnemyPiece"
                            )
                            (then 
                                (if 
                                    (or (= 1 (value Player Mover)) (= 5 (value Player Mover)))
                                    ("ThrowAgainAndPlay")
                                ) 
                            )
                        )
                    )
                )
            )
        )
        (map "EntrySite" {(pair P1 (coord "F2")) (pair P2 (coord "E5"))})
        (regions "Protect" (sites {"A1" "A3" "A4" "A6" "J1" "J3" "J4" "J6"}))
    })
    (rules 
        (start (place "Marker" "Hand" count:3))
        (play 
            (if (can Move ("ThrowMove"))
                ("ThrowMove")
                (move Pass 
                    (then 
                        (and 
                            (if 
                                (or (= 1 (value Player Mover)) (= 5 (value Player Mover)))
                                ("ThrowAgainAndPlay")
                            ) 
                            ("StopTurnIfNoMoveAgain")
                        )
                    )
                )
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Chisolo is a four-row mancala-style board game played by the Ba-ile people in the early twentieth century. 4x7-10 board (seven most common). Three counters in each hole, except the leftmost four in the inner row which have, from right to left: 0-0-1-2. On the first turn, sowing occurs in a clockwise direction. On the second turn, the player may sow in either direction, but must continue in the chosen direction for the rest of the game. When the final counter lands in an empty hole in the inner row, the contents of the hole in the opponent's inner row are also captured. If there are also contents in the opponent's outer row hole opposite, these are also taken. When a capture is made, the player may then capture the counters in any one of the opponent's holes as well. If the final counter lands in an occupied hole, the player picks up these counters and continues sowing. The player who captures all of the opponent's counters wins. Each player has 7 holes on each row. Starting positions of the Natatu ruleset. No Opening. Capture all the opposite holes.
(game "Chisolo" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" <Board:CCW2> loop:True P2)
            (track "TrackCW1" <Board:CW1> loop:True P1)
            (track "TrackCW2" <Board:CW2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (regions "FourLeftInner" P1 (sites {<Board:LeftInnerHolesP1>}))   
        (regions "FourLeftInner" P2 (sites {<Board:LeftInnerHolesP2>}))   
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        <Start:rules>
        
        phases:
        {
        <Phase:opening>
        
        (phase "SowingCW"
            (play 
                (if (and ("SameTurn") (= (var "CaptureOther") 1))
                    (move
                        (from (sites Next) if:(is Occupied (from)))
                        (to (handSite Mover))
                        count:(count at:(from))
                        (then (set Var "CaptureOther" 0))
                    )
                    (move Select
                        (from 
                            (if ("SameTurn") 
                                "LastHoleSowed" 
                                (sites Mover "Home") 
                            ) 
                            if:(is Occupied (from))
                        )
                        (then
                            (sow
                                "TrackCW"
                                owner:(mover)
                                apply:<Capture:type>
                            )
                        )
                    )	
                )
            )
            (nextPhase Mover (not (is Next Mover)) "Sowing")
        )
        
        (phase "Sowing"
            (play 
                (if (and ("SameTurn") (= (var "CaptureOther") 1))
                    (move
                        (from (sites Next) if:(is Occupied (from)))
                        (to (handSite Mover))
                        count:(count at:(from))
                        (then (set Var "CaptureOther" 0))
                    )
                    (or
                        (if (or (<= (value Player Mover) 0) (= (value Player Mover) 1))
                            (move Select
                                (from 
                                    (if ("SameTurn") 
                                        "LastHoleSowed" 
                                        (sites Mover "Home") 
                                    ) 
                                    if:(is Occupied (from))
                                )
                                (then
                                    (and
                                        (sow
                                            "TrackCW"
                                            owner:(mover)
                                            apply:<Capture:type>
                                        )
                                        (set Value Mover 1)
                                    )
                                )
                            )	
                        )
                        
                        (if (or (<= (value Player Mover) 0) (= (value Player Mover) 2))
                            (move Select
                                (from 
                                    (if ("SameTurn") 
                                        "LastHoleSowed" 
                                        (sites Mover "Home") 
                                    ) 
                                    if:(is Occupied (from))
                                )
                                (then
                                    (and
                                        (sow
                                            "TrackCCW"
                                            owner:(mover)
                                            apply:<Capture:type>
                                        )
                                        (set Value Mover 2)
                                    )
                                )
                            )	
                        )
                    )
                )
            )
        )
        }
        (end ("ForEachPlayerNoMovesLoss"))
    )
)

Construct a Ludii game based on the following description
Keryo-Pente was invented by Rollie Tesh in 1983, as an alternative way to mitigate the first-player advantage in Pente.  As in Pente, players compete to be the first to form an orthogonal or diagonal line of five stones.  However, in Keryo-Pente players may capture two or three opposing stones rather than only two; the threshold to win the game by capture also increases from 10 to 15 stones.  This variation reduces the first-player advantage by significantly increasing the second player's defensive options.Keryo-Pente is played on a 19x19 Go board.  White goes first, and plays their first move on the centre point (unless playing Freestyle).  After the opening, players alternate playing one stone of their colour onto any empty point.  If their placement results in a pair or a line of three enemy stones being sandwiched between two of their own stones, those enemy stones are captured.  The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 15 enemy stones, wins the game. Played on a 19x19 board. Open at the centre point.
(game "Keryo-Pente" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Ball" Each) 
    }) 
    (rules 
        (start (set Score Each 0))
        <Play>
        (end {
            (if (is Line 5 All) (result Mover Win))
            (if (> (score Mover) 14) (result Mover Win))
        }) 
    )
)

Construct a Ludii game based on the following description
Nine Holes is an alignment game played at least since the seventeenth century in Great Britain, but likely goes back to the Roman Empire.3x3 intersecting lines. Three pieces per player. Players alternate turns placing pieces on an empty spot on the board. When all pieces are placed, players alternate turns moving a piece to any empty spot on the board. The first player to place their pieces in an orthogonal row along the lines wins. 
(game "Nine Holes"
    (players 2) 
    (equipment {
        (board (square 3) use:Vertex)
        (hand Each)
        (piece "Marker" Each (move (from) (to (sites Empty))))
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win" Orthogonal))
    )
)

Describe the mechanics of the following Ludii game
(game "Mewelad" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightMost" {(pair P1 5) (pair P2 6)})
    }) 
    (rules 
        
        (start { 
            (set Count 4 to:(sites Track)) 
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or 
                    {
                    (move Select 
                        (from
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(is Occupied (from))
                        )
                        (then
                            (do
                                (set Var "NumSowed" (count at:(last To)))
                                next:(sow
                                    "TrackCCW"
                                    apply:(if (= 4 (count at:(to)))
                                        (fromTo
                                            (from (to))
                                            (to (handSite Mover))
                                            count:4
                                        )
                                        (if (< 1 (count at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                )
                                (then
                                    (and
                                        (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1)))
                                            (if (= 4 (count at:(site)))
                                                (fromTo
                                                    (from (site))
                                                    (to (if (is In (to) (sites (values Remembered "OwnedP1"))) (handSite P1) (handSite P2)))
                                                    count:4
                                                )
                                            )
                                        )
                                        (set Var "NumSowed" 0)
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("APlayerCanNotMove")
                            (and { 
                                (if (no Moves P1)
                                    (forEach Site (sites Board)
                                        (if (is Occupied (site))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P1))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                    (forEach Site (sites Board)
                                        (if (is Occupied (site))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P2))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 3 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 3 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("RightMostEmpty"))
                        count:(if (>= (count Cell at:(handSite Mover)) 4) 4 3)
                        (then
                            ("RemmemberOwnedHoles" (last To))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)
Mewelad is a two-row mancala-style board game played in Eritrea. It involves a unique rule of capturing, where if a player does not capture when they are supposed to, there is a penalty assigned to that hole with alternative capturing rules.2x6 board. Four counters per hole. Play begins with a simultaneous racing move, where players attempt to be the first to drop the final counter of their sowing into an empty hole. Sowing occurs in an anti-clockwise direction. If the final counter falls into an occupied hole, these are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends. At any time during the sowing, if a hole is made to contain four counters, the owner of the hole in which the four counters are located captures them, unless it is the final hole of the sowing, in which case the player who is sowing captures them. Play continues until a player can no longer move because there are no counters in their row, and the opponent captures the remaining counters. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes. 

Describe the mechanics of the following Ludii game
(game "Sumi Naga Game (War)" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Marker" Each
            (or
                ("StepToEmpty")
                ("HopSequenceCapture")
            )
        )
    }) 
    
    (rules 
        (start { 
            (place "Marker1" (union (expand (sites Bottom)) (sites {"A3"})))
            (place "Marker2" (union (expand (sites Top)) (sites {"E3"})))
        })
        
        (play (forEach Piece))
        
        (end ("CaptureAll" Next))
    )
)
This game played by the Sümi Naga people of India is a game with leaping captures. 5x5 intersecting lines, with diagonals drawn in each quadrant. Eleven pieces per player, which begin on the two rows closest to the player, with the eleventh on the outer spot of the middle of to the left of the player. Players alternate turns moving a piece to an empty adjacent spot along the lines. A piece may capture an opponent's piece next to it by hopping over it to an empty spot immediately on the opposite side of the opponent's piece along the lines of the board. The player who captures all of the opponent's pieces wins. 

Construct a Ludii game based on the following description
Gale is a connection game on two overlapping rectangular grids to form a square game board.A player wins by connecting opposite sides of the square board with a chain of their pieces. The game is played on a 5x5 board The first player to connect their two sides wins.
(game "Gale" 
    (players 2) 
    (equipment { 
        (board (square <Board>)) 
        (piece "Square" Each)
        (regions P1 {(sites Top) (sites Bottom) })
        (regions P2 {(sites Left) (sites Right) })
    }) 
    (rules 
        (start {
            (place "Square1" (forEach (sites Board) if:(and (is Even (column of:(site))) (is Odd (row of:(site))))))
            (place "Square2" (forEach (sites Board) if:(and (is Even (row of:(site))) (is Odd (column of:(site))))))
        })
        (play (move Add (to (sites Empty))))
        
        (end (if (is Connected Mover) (result Mover <Result>)))
    )
)

Describe the mechanics of the following Ludii game
(game "Lielow"
    (players 2)
    (equipment {
        (board (square 10))
        (piece "Disc" Each)
    })
    (rules
        (start {
            (place "Disc1" 
                (difference
                    (difference 
                        (expand (sites Bottom) steps:2)
                        (expand (sites Bottom) steps:1)
                    )
                    (sites Outer)
                )
            )
            (place "Disc2" 
                (difference
                    (difference 
                        (expand (sites Top) steps:2)
                        (expand (sites Top) steps:1)
                    )
                    (sites Outer)
                )
            )
        })
        (play
            (forEach Piece
                ("Move")
                Mover
                top:True
                (then 
                    (do
                        (remove (sites Outer) count:(size Stack at:(last To)))
                        next:("UpdateKing")
                    )
                )
            )
        )
        (end {
            (if 
                (= 1 (var "MoverHasLost")) 
                (result Mover Loss)
            )
            (if 
                (= 1 (var "MoverHasWon")) 
                (result Mover Win)
            )
        })
    )
)
Lielow is a finite and drawless checkmate game played with stackable checkers instead of differentiated pieces. It was invented by Alek Erickson and Michael Amundsen in the summer of 2021.Each turn you must move one of your stacks, in a straight line orthogonally or diagonally, a distance exactly equal to the size of that stack.
            If it lands on an empty space, the stack grows by 1.
            If it lands on an enemy, the enemy is removed and your stack shrinks down to size 1.
            It is not legal to land on a friendly stack.
            Jumping over stacks is allowed.
            Stacks may also jump off the board, removing themselves from the game. 
            Passing is not allowed.
            
            Definitions for crown and king: In this implementation, the king-stack will have a red stroke color. This red ring is the crown. Which stack has the crown is determined like this: After your move, if there is, among your stacks, a unique stack of the biggest size, the crown will be on that stack. There is no other way the crown can change heads. The piece with a crown on it is the king.
            
            Goal: If the enemy king is removed from the game, you win.
            
        Note: In this implementation, jumping off the board is only possible if the stack can reach exactly 1 row or column beyond the perimeter. But it seems to always be the case that it is possible to jump off the board when a stack is big enough. Please let Michael know if you encounter a scenario where a piece is stuck. This should not be allowed according to the rules of the game. 

Construct a Ludii game based on the following description
Ngré É É is an alignment game played in the Republic of Congo by children.3x3 intersecting lines with diagonals. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. When a player succeeds in making a line of three with their pieces, they win. 
(game "Ngre E E"
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 3 3)
        (hand Each)
        (piece "Marker" Each)
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        (play (move (from (handSite Mover)) (to (sites Empty))))
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
XII scripta (\Play begins in the central row and continues from left to right, then down the furthest row from right to left, then on the closest row from left to right. Played using three dice; throws can be used singly or combined but could not be divided. No second throw with doubles or triples. More than one piece of the same player can occupy one point, Single pieces can be removed from the board when the opponent lands on it; it must then be re-entered to the board before the player can move their other pieces. The goal is to bear off all of the player's pieces, which can be done one they are all in the closest row. The rules are describing with the Murray ruleset.
(game "XII Scripta"
    (players 2) 
    (equipment { 
        (board 
            (add
                (merge (rectangle 3 6) (shift 7 0 (rectangle 3 6))) 
                edges:{{5 18} {11 24} {17 30}}
            )
            { 
            (track "Track1" "36,6,E,N1,W,0,E,End" P1 directed:True)
            (track "Track2" "38,6,E,S1,W,12,E,End" P2 directed:True)
            } 
            use:Vertex
        )
        (dice num:3)
        (hand Each size:2)
        (piece "Disc" Each ("PieceMove" (from) (from))) 
    }) 
    
    (rules 
        (start { 	
            (place "Disc1" (handSite P1) count:15)
            (place "Disc2" (handSite P2) count:15)
        })	
        
        (play 
            ("RollEachNewTurnMove"
                (if (!= (what at:(handSite Mover 1)) 0)
                    ("PieceMove" (handSite Mover 1) (handSite Mover))
                    (or (forEach Piece) (forEach Piece container:(mover)))
                    (then (if (can Move 
                                (if (!= (what at:(handSite Mover 1)) 0)
                                    ("PieceMove" (handSite Mover 1) (handSite Mover))
                                    (or (forEach Piece) (forEach Piece container:(mover)))
                                )
                            )
                            (moveAgain)
                        )
                    )
                )
            )
        )
        
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Dama is a game with leaping captures played in the Philippines. In it, a kinged piece may capture by the flying leap in one direction. 5x5 grid of points, four point in each row, each alternating position with an end point on the left or right edge. Points are connecting with diagonal lines. Twelve pieces per player, positioned on the first three rows closest to the player. Players alternate turns moving a piece forward to an empty adjacent spot along the lines. A player may capture an opponent's piece by hopping over it to an empty spot on the opposite side of it along the lines. Multiple captures are allowed, if possible. When a player's piece reaches the opposite edge of the board from which it started, it becomes a king. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The king cannot take in multiple directions in one turn. The first player to capture all of the opponent's pieces wins.
         
(game "Dama (Philippines)" 
    (players 2) 
    ("DraughtsEquipment" 
        (rotate 45
            (merge {
                (rectangle 5 4)
                (shift -1 1 (rectangle 3 6))
                (shift -2 2 (rectangle 1 8))
                (shift 1 -1 (rectangle 7 2))
            })
        )
        use:Vertex
    ) 
    (rules 
        ("BottomTopSetup" 3 "Counter1" "Counter2")
        
        (play 
            (if "SameTurn"
                (or
                    (if "IsUnpromoted"
                        ("HopCounter" (last To)
                            (then 
                                ("ReplayIfCanMove" ("HopCounter" (last To))
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                        ("HopDoubleCounter" (from (last To)) SameDirection)
                    )
                    (move Pass)
                )
                (or {
                    (forEach Piece "Counter"
                        ("HopCounter" (from) 
                            (then 
                                ("ReplayIfCanMove" ("HopCounter" (last To))
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        ) 
                    )
                    (forEach Piece "DoubleCounter" ("HopDoubleCounter" (from) Orthogonal))
                    (forEach Piece "Counter" 
                        ("StepToEmpty" (directions {FR FL}) )
                        (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                    )
                    (forEach Piece "DoubleCounter" (move Slide))
                })
            )
        ) 
        
        (end ("BlockWin"))
    )
)

Describe the mechanics of the following Ludii game
(game "Battleships" 
    (players 2) 
    (equipment { 
        (board (rectangle 10 20))
        ("DefinePiece" "CarrierTemplate" { {F F F F} {L F F F F}} "Carrier")
        ("DefinePiece" "BattleshipTemplate" { {F F F} {L F F F}} "Battleship")
        ("DefinePiece" "DestroyerTemplate" { {F F} {L F F}} "Destroyer")
        ("DefinePiece" "SubmarineTemplate" { {F F} {L F F}} "Submarine")
        ("DefinePiece" "PatrolBoatTemplate" { {F} {L F}} "PatrolBoat")
        (regions "Defence" P1 (expand (sites Left) steps:9))
        (regions "Defence" P2 (expand (sites Right) steps:9))
        (hand Each size:5)
    }) 
    (rules
        (start {
            (set Hidden (sites P1 "Defence") to:P2)
            (set Hidden (sites P2 "Defence") to:P1)
            (set Hidden (sites Hand P1) to:P2)
            (set Hidden (sites Hand P2) to:P1)
            (place "CarrierTemplate1" (handSite P1 0))
            (place "CarrierTemplate2" (handSite P2 0))
            (place "BattleshipTemplate1" (handSite P1 1))
            (place "BattleshipTemplate2" (handSite P2 1))
            (place "DestroyerTemplate1" (handSite P1 2))
            (place "DestroyerTemplate2" (handSite P2 2))
            (place "SubmarineTemplate1" (handSite P1 3))
            (place "SubmarineTemplate2" (handSite P2 3))
            (place "PatrolBoatTemplate1" (handSite P1 4))
            (place "PatrolBoatTemplate2" (handSite P2 4))
        })
        phases: {
        (phase "Setup"
            (play (forEach Piece container:(mover)))
            (nextPhase (>= (count Turns) 10) "Playing")
        )
        (phase "Playing"
            (play
                (move Select
                    (from (intersection (sites Next "Defence") (sites Hidden to:Mover)))
                    (then
                        ("ClearShotSpace"
                            (then
                                ("CheckForVictory")
                            )
                        )
                    )
                )
            )
        )
        }
        (end {
            ("DeclareVictory" P1)
            ("DeclareVictory" P2)
        })
    )
)
Battleships is a strategy type guessing game for two players. It is played on ruled grids (paper or board) on which each player's fleet of ships (including battleships) are marked. The locations of the fleets are concealed from the other player. Players alternate turns calling shots at the other player's ships, and the objective of the game is to destroy the opposing player's fleet.The first player (Grey) has their home area on the left; the second player (Black) on the right.
            
            In the initial setup phase players move their pieces from their hand to their home area. By default the pieces will be placed vertically. Press 'r' whilst moving it, to place one horizontally.
            
        Finally the players take turns to guess spaces in their opponent's home area. These are revealed to be either water or a ship according to the following code: <b>C</b>arrier - 5 spaces; <b>B</b>attleship - 4 spaces; <b>D</b>estroyer - 3 spaces; <b>S</b>ubmarine - 3 spaces; <b>P</b>atrol Boat - 2 spaces. 

Construct a Ludii game based on the following description
Bao Ki Arabu is one of two mancala-style games by the same name is played by people in Zanzibar, where it is said to have been the original version that came to the island from Arabia. Indeed, it is quite similar to Hawalis, which has been documented in Oman. 4x8 board. Play begins with two counters in each hole. Sowing occurs in an anti-clockwise direction. When the last counter falls into an occupied hole, the counters in it are picked up and sowing continues. Sowing ends when the last counter falls into an empty hole. When this hole is in the inner row, the counters in the opponent's inner row opposite it are captured; if there are also counters in the opponent's outer row opposite, these are also captured, but not if the inner row is empty. Play continues until one player has lost all of their counters. 
(game "Bao Ki Arabu (Zanzibar 2)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "16,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))        
        (regions "Home" P2 (sites Track "Track2"))        
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 2 to:(sites Board)))
        
        (play 
            (move Select
                (from 
                    (if ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover "Home") 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        apply:(if (= (count at:(to)) 1)
                            (if (is In (to) (sites Mover "Inner"))
                                (if (> (count at:("OppositePit" (to))) 0) 
                                    (and
                                        (fromTo 
                                            (from ("OppositePit" (to))) 
                                            (to (handSite Mover)) 
                                            count:(count at:("OppositePit" (to)))
                                        ) 
                                        (if 
                                            (> (count at:("OppositeOuterPit" (to))) 0) 
                                            (fromTo 
                                                (from ("OppositeOuterPit" (to))) 
                                                (to (handSite Mover)) 
                                                count:(count at:("OppositeOuterPit" (to)))
                                            ) 
                                        ) 
                                    ) 
                                ) 
                            )
                            (moveAgain)
                        )
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Adi is a two-row mancala-style board game played by the Ewe people of Togo and Ghana. The game can either be played on wooden boards, which are sometimes elaborately carved, or as holes in the ground using seeds or stones as counters.2x6 board with two stores. Four counters in each hole. Sowing occurs in an anti-clockwise direction from a hole in the player's row. If the final counter falls into a hole in the opponent's row containing two counters, making it contain three, they are captured. Any holes containing three counters in an unbroken line behind it in the opponent's row are also captured. A player cannot sow into a hole from which they sowed until it has been sown into by the opponent. Play continues until no more captures are possible, and the players win the counters they captured and the counters on their side of the board. A new round begins. The player with fewer counters fills up their holes from right to left with four counters. The opponent fills the same number of holes, and continues to play, holding any remaining counters for future rounds, if necessary. Play proceeds as before with the present number of holes in play. Play continues until one player cannot fill any holes. 
(game "Adi"
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "TrackCCW" "1,E,N,W" loop:True)
            (track "TrackCW" "6,W,N,E" loop:True)
            }
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
        (map "RightMost" {(pair P1 6) (pair P2 7)})
        (map "CorrespondingHoles" {(pair 1 12) (pair 2 11) (pair 3 10) (pair 4 9) (pair 5 8) (pair 6 7) (pair 7 6) (pair 8 5) (pair 9 4) (pair 10 3) (pair 11 2) (pair 12 1)})
    }) 
    
    (rules 
        (start {
            (set Count 4 to:(sites Track))
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        phases:{
        (phase "Sowing"
            (play 
                (or {
                    (move Select 
                        (from 
                            ("OwnedHoles") 
                            if:(and ("PossibleSowFrom") (< 0 (count at:(from))))
                        )
                        (then 
                            (and {
                                (sow 
                                    "TrackCCW"
                                    if:(and 
                                        (is In (to) (sites Next)) 
                                        (= (count at:(to)) 3)
                                    ) 
                                    apply:(fromTo 
                                        (from (to)) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:(to))
                                    )
                                    backtracking:True 
                                )
                                (forEach Value 
                                    (array (sites Track from:(last From) to:("NextHole" (last From) (min 12 (count at:(last From))))))
                                    (if (is Mover P1)
                                        (if (is In (value) (values Remembered "P2SowFrom"))
                                            (forget Value "P2SowFrom" (value))
                                        )
                                        (if (is In (value) (values Remembered "P1SowFrom"))
                                            (forget Value "P1SowFrom" (value))
                                        )
                                    )
                                )
                                (if (is Mover P1)
                                    (remember Value "P1SowFrom" (last From))
                                    (remember Value "P2SowFrom" (last From))
                                )
                            })
                        )
                    )
                    }
                    (then
                        (if ("NoMoreCapturePossible")
                            (and {
                                (forEach Site (sites P1)
                                    (if (< 0 (count at:(site)))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry P1))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site (sites P2)
                                    (if (< 0 (count at:(site)))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                                (forget Value "P1SowFrom" All)
                                (forget Value "P2SowFrom" All)
                                (if (>= 
                                        (+
                                            (count at:(mapEntry P2))
                                            (count in:(sites P2))
                                        )
                                        (+ 
                                            (count at:(mapEntry P1))
                                            (count in:(sites P1))
                                        )
                                    )
                                    (set NextPlayer (player 1))
                                    (set NextPlayer (player 2))
                                )
                            })
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 4 (count at:(mapEntry P1))) (result P2 Win))
                    (if (> 4 (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count at:(mapEntry Mover)))
                    (move
                        (from (mapEntry Mover))
                        (to ("RightMostEmpty"))
                        count:4
                        (then
                            (and
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 4 (count at:(mapEntry Mover)))		
                                    (moveAgain)
                                    (forEach Site (sites Mover)
                                        (if (is Occupied (site))
                                            (and
                                                (fromTo
                                                    (from (mapEntry Next))
                                                    (to (mapEntry "CorrespondingHoles" (site)))
                                                    count:(count at:(site))
                                                )
                                                ("RemmemberNextOwnedHoles" (mapEntry "CorrespondingHoles" (site)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (> 4 (count at:(mapEntry Mover))) "Sowing")
        )
        }
    )	
)

Construct a Ludii game based on the following description
Kolowis Awithlaknannai is a capturing game played by the Zuni people of New Mexico in the late nineteenth century. The game is named after the kolowisi, a supernatural serpent in Zuni belief.A series of three parallel lines are drawn, with diagonals connecting the outer lines at intervals, crossing each other at the central line. Sixteen spaces each row. Pieces begin on all of the points on the board, except the central point and the leftmost point of the central row. Pieces are moved along the intersections, and they are placed on the board on opposing sides, leaving the central spot empty. The first player moves to this spot along one of the lines, and the opponent jumps this pieces, thereby capturing it. 
(game "Kolowis Awithlaknannai" 
    (players 2) 
    (equipment { 
        (board
            (merge {
                (repeat 1 1 step:{{0.5 0} {1 0}} (poly {{-0.5 0} {0.5 0} {0 0.5}}))
                (repeat 1 1 step:{{0.5 0} {1 0}} (poly {{-0.5 0} {0.5 0} {0 -0.5}}))
                (repeat 15 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 0.5} {1 0.5}}))
                (repeat 15 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 -0.5} {1 -0.5}}))
                (shift 0.5 0 (rectangle 1 15))
            })
            use:Vertex
        )
        (piece "Counter" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Counter1" (difference (union (sites Bottom) (sites Direction from:(centrePoint) W)) (coord "A2")))
            (place "Counter2" (union (sites Direction from:(centrePoint) E) (sites Top)))
        })
        (play (forEach Piece))
        (end ("NoMoves" Loss))
    )
)

Construct a Ludii game based on the following description
Broken Line is a game played on a board tiling by hexagon. The goal is to make a line with stones connected diagonally.Players take turns placing their pieces on one empty space on the board, with the goal of making a line with stones connected diagonally of at least length 4. The length of the line is 3 or more. The game is played on a 3x3 board. The board is a diamond tiling by hexagon. The game uses the swap rule. The first player to connect their two sides wins. The connection between two stones is using all the diagonal directions.
(game "Broken Line" 
    (players 2) 
    (equipment { 
        (board (<Board:type> <BoardSize>)) 
        (piece "Marker" Each)
    }) 
    (rules 
        <Meta:rule>
        (play (move Add (to (sites Empty))))
        (end (if (is Line <Line:size> <Connection:type>) (result Mover <Result>))) 
    )
)

Describe the mechanics of the following Ludii game
(game "Quoridor" 
    (players "NumPlayers")
    (equipment {
        (board (square 9))
        (piece "Pawn" Each
            (or
                (move Step
                    Orthogonal
                    (to 
                        if:(and 
                            (is Empty (to)) 
                            ("NoEdgeBetweenCells" (from) (to))
                        )
                    )
                )
                (move Hop
                    Orthogonal
                    (between if:("IsEnemyAt" (between)))
                    (to if:(and {
                            (is Empty (to))
                            ("NoEdgeBetweenCells" (from) (between))
                            ("NoEdgeBetweenCells" (between) (to))
                        })
                    )
                )
            )
        )
        (piece "Rectangle" Shared)
        (hand Each)
        <Players:regions>
    })
    (rules 
        <Players:start>
        (play 
            (or
                (do
                    (if (is Occupied (handSite Mover))
                        (move 
                            (from (handSite Mover)) 
                            (to Edge (difference (sites Empty Edge) (sites Outer Edge)))
                        )
                    )
                    ifAfterwards:<Players:pathRule>
                )
                (forEach Piece)
            )
        )
        (end (if "ReachedTarget" (result Mover Win))) 
    )
)
Quoridor is a 2 or 4-player intuitive strategy game designed by Mirko Marchesi and published by Gigamic Games. Quoridor received the Mensa Mind Game award in 1997 and the Game Of The Year in the USA, France, Canada and BelgiumThe abstract strategy game Quoridor is surprisingly deep for its simple rules. The object of the game is to advance your pawn to the opposite edge of the board. On your turn you may either move your pawn or place a wall. You may hinder your opponent with wall placement, but not completely block them off. Meanwhile, they are trying to do the same to you. The first pawn to reach the opposite side wins. The game has 2 players

Construct a Ludii game based on the following description
Üxrijn Ever is a game played in Mongolia. The game is thought to be a representation of cattle herding practices. One player plays as a cow and a calf, the other as two children. The calf attempts to reach its mother, which remains at the start, while the children try to force the calf into the pasture, at the opposite end of the board.Two arcs which meet, in the shape of a horn, curving to the left. Nine points along the left side, and eight along the right, with one at the apex. Zig-zag lines connect points  on either side of the board, connecting the first on the left to the first on the right, the first on the right to the second on the left, the second on the left to the second on the right, and so on. One player plays as the cow and the calf (black). The cow begins on the first point on the left, the calf on the second point on the right. The other player plays as two children (white), which begin on the second point on the left and the first point on the right. Players alternate turns moving a piece to an empty adjacent spot along the lines on the board. The cow never moves from its position. The calf plays first. The calf wins when it reaches the cow; the children win when they force the calf onto the apex of the board (the pasture). 
(game "Uxrijn Ever"
    (players 2)
    (equipment {
        (board 
            (graph 
                vertices:{
                {0 0} {5 0}
                {0.17 1} {4.65 1}
                {0.3 2} {4.3 2}
                {0.38 3} {3.9 3}
                {0.25 4} {3.5 4}
                {-0.13 5} {2.97 5}
                {-0.75 6} {2.2 6}
                {-1.47 7} {0.95 7}
                {-2.22 8} 
                {-3 9} 
                }
                edges:{
                {0 1} {0 2} {2 4}
                {4 6} {6 8} {8 10}
                {10 12} {12 14} {14 16}
                {16 17} {1 3} {3 5}
                {5 7} {7 9} {9 11}
                {11 13} {13 15} {1 2}
                {2 3} {3 4} {4 5}
                {5 6} {6 7} {7 8}
                {8 9} {9 10} {10 11}
                {11 12} {12 13} {13 14} 
                {14 15} {15 16} {15 17} 
                }
            )
            use:Vertex
        )
        (piece "Cow" P1)
        (piece "Calf" P1 
            (move Step 
                (to 
                    if:(or ("IsPieceAt" "Cow" P1 (to)) (is Empty (to)))
                    (apply (remove (to)))
                )
            )
        )
        (piece "Human" P2 
            "StepToEmpty"
        )
    })
    (rules
        (start {
            (place "Cow1" 0)
            (place "Calf1" 3)
            (place "Human2" (sites {1 2}))
        })
        (play (forEach Piece))
        (end {
            (if (is In (where "Calf" P1) (sites Top)) (result P2 Win))
            (if (= 1 (count Sites in:(sites Occupied by:P1))) (result P1 Win))
        })
    )
)

Construct a Ludii game based on the following description
Wrigglers Squared is an adaptation of Wrigglers to a Square board. Wrigglers is a game that allows a minimal amount of self-removal, and has a goal of maximizing the product of one's largest 2 groups.        The rules are very simple and the actions of the players highly independent, except for blocking by site occupation. However the goal and the difficulty of modifying one's groups make the game challenging and removals allow for end-game turnarounds.            Removal is only allowed where a player has committed to the removal on a previous turn by placing a stone that overcrouds an existing piece. This destroys the group's scoring potential, but allows the overcrouded piece to be removed, potetially dividing the group in a way the increases its potential to score.         With multiplicative scoring, two equal sized groups score far more than a single group with the same number of pieces. But if there is a 3rd group available, the benefit might be much less.Goal:Score the product of the sizes of your two largest chains. Highest score wins. 
            In case of a tie, the last to play wins.
            
            Chains are a series of adjacent like-colored stones with no branching.
            
            Play:
            Boards starts empty. The darker color starts.
            
            On a turn the moving player does one of these actions:
            - Place one of their stones onto an empty site adjacent to no more than 2 of their stones, or
            - Remove one of their stones that is adjacent to more than two of their stones.
            
            Otherwise he passes.
            
        The game ends when both players pass.  Order 9, Square Ortho-Grid
(game "Wrigglers Squared"
    (players 2)
    (equipment {
        (board <BoardShape:gridType> use:Vertex)
        (piece "Disc" Each)
    })
    (rules
        (play
            (if
                (= 1 (var "Added"))
                (or {
                    "AddOrPass"
                    (forEach Piece
                        (if
                            (< 2 (count Pieces Mover in:(sites Around (from) "GridDirection"))) 
                            (move Remove (from)
                                (then (set Var "Added" 0))
                        ))
                        Mover
                    )
                })
                "AddOrPass"
                (then ("Score4" Mover))
            )
        )
        (end 
            (if
                (all Passed)
                {
                (if
                    (>= (score Mover) (score Next))
                    (result Mover Win)
                )
                }
                (result Next Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Boukerourou is a two-row mancala-style board game played in the Tidikelt region of Algeria at the turn of the twentieth century.2x4 board, rendered as holes in the sand. Six counters per hole. A player picks up all of the counters in one of the holes in their row and sows them in an anti-clockwise direction. When the final counter lands in an empty hole, the contents of the following hole are picked up and the sowing continues. When the final counter lands in a hole in the opponent's row causing it to contain six counters, these counters are captured. Play continues until one player has no counters in their holes, and the opponent wins. 
(game "Boukerourou" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))     
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start (set Count 6 to:(sites Track)))
        
        (play
            (move Select 
                (from 
                    (if ("SameTurn") 
                        (sites {("NextHole" ("PlayFromLastHole"))})
                        (sites Mover) 
                    )
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow 
                        apply:(if (and
                                (= 1 (count at:(to)))
                                (is Occupied ("NextHole" (to)))
                            )
                            (moveAgain)
                            (if (and (is In (to) (sites Next)) (= 6 (count at:(to))))
                                (remove (to))
                            )
                        )
                    )
                )
            )
        )
        
        (end 
            (forEach Player
                if:("NoCounters" Player)
                (result Player Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Dots and Boxes was invented in the nineteenth century by Édouard Lucas, calling it \It is played on a board that is a grid of dots. 3x3 dots is common. Players alternate turns drawing a line between two of the dots. If a player completes a square, they receive one point and play again. The player with the most points when there are no more moves wins. The board uses a square tiling. The game is played on a 3x3 board.  The first player capture half the cells wins.
(game "Dots and Boxes" 
    (players 2)
    (equipment {(board <Dual:begin> (<Board> <Size>) <Dual:end>) }) 
    
    (rules 
        (play (move Add 
                (to Edge (sites Empty Edge)) 
                (then 
                    (forEach Site
                        "CellOfLastEdge" 
                        (if "NoFreeEdge"
                            "CaptureTheCell"
                        )
                    )
                )
            )
        ) 
        (end (if (> (score Mover) "HalfBoardSize") (result Mover <Result>))) 
    )
)

Construct a Ludii game based on the following description
Dragonchess is a commercial chess variant, first published in 2005. The game is played on a 10 by 10 board, with in addition two side lanes of 3 by 4 squares. Players have the usual chess pieces, two extra pawns, and two dragons.Same rules as Chess. Dragons move like queens, but at most three squares. 
(game "Dragonchess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board 
            (merge
                (square 10)
                (shift -3 3 (rectangle 4 16))
            )
        ) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (piece "Dragon" Each 
            (move Slide 
                (between 
                    (max 3)
                    if:(is Empty (between))
                )
                (to 
                    if:("IsEnemyAt" (to)) 
                    (apply 
                        (remove 
                            (to) 
                            (then (set Counter))
                        )
                    ) 
                ) 
            ) 
        )
        
        (map "King" {(pair 1 "I1") (pair 2 "H10")})
        (map "RookLeft" {(pair 1 "E1") (pair 2 "L10")})
        (map "RookRight" {(pair 1 "L1") (pair 2 "E10")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 8))
            (place "Dragon1" {"D1" "M1"}) (place "Rook1" {"E1" "L1"} state:1) (place "Knight1" {"F1" "K1"}) (place "Bishop1" {"G1" "J1"}) (place "Queen1" coord:"H1") (place "King1" coord:"I1" state:1) 
            (place "Dragon2" {"D10" "M10"}) (place "Rook2" {"E10" "L10"} state:1) (place "Knight2" {"F10" "K10"}) (place "Bishop2" {"G10" "J10"}) (place "Queen2" coord:"I10") (place "King2" coord:"H10" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook" "Dragon"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        ("Castling")
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

Construct a Ludii game based on the following description
Damenspiel is a Draughts game played in Germany.8x8 checkered board, the dark spaces placed so that the bottom right corner is a dark space. Twelve pieces per player, placed on the dark spaces of the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space. Captures are compulsory, multiple captures are possible, the maximum capture possible is not required. When a piece reaches the opposite edge of the board from where it started, it stops moving (if in a capture sequence), becomes a king, and the turn ends. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins.
         
(game "Damenspiel" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 8)) 
    (rules 
        ("WhiteCellsSetup" 3)
        
        (play 
            (if	("SameTurn")
                (if ("IsUnpromoted")
                    ("HopCapture" (from (last To))  Diagonal
                        (then 
                            ("PromoteIfReach" (sites Next) "DoubleCounter"
                                ("ReplayIfCanMove" ("HopCapture" (from (last To)) Diagonal))
                            )
                        )
                    )
                    ("HopCaptureDistance" (from (last To)) Diagonal (range 1 (count Rows))
                        (then ("ReplayIfCanMove" ("HopCaptureDistance" (from (last To)) Diagonal (range 1 (count Rows)))))
                    )
                )
                (priority {
                    (or
                        (forEach Piece "Counter" "HopDiagonalCounter")
                        (forEach Piece "DoubleCounter" "HopDiagonalDoubleCounter")
                    )
                    (or
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL})
                                (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                            )
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal))
                    )
                })
            )
        ) 
        
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
Dongjintian is a mancala-style board game played in Yunnan Province, China. This four-player version features an orthogonal pattern of sowing not seen in other mancala-style games.4x5 board. Five counters per hole. Players can sow from any hole. Sowing occurs orthogonally in any direction, and a player can change direction orthogonally at any point in the move, but can never double back. When the last counter falls into a hole, sowing continues if there are counters in the following holes; these are picked up and sowing continues from there.  The hole from which the sowing continues will always be the next one in the opposite direction from the penultimate hole in which a counter was dropped. Therefore, if the sowing ends when a sowing hits an edge or corner, sowing does not continue. When the hole after the end of a sowing is empty, the counters in the next hole following it are captured, but captures cannot be made when the final counter falls into a hole from which a new direction must be chosen. Captures cannot be made from the central two holes of the board. The player who captures the most counters wins.
         
(game "Dongjintian (Four Players)" 
    (players 4) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None)
        (piece "Seed" Shared)
        (hand Each)
        (regions "ProtectingHoles" (sites {7 12}))
    }) 
    (rules 
        
        (start (set Count 5 to:(sites Board)))
        
        (play 
            (if (and ("SameTurn") (!= 0 (var "NumToSow")))
                (if (can Move ("SowAgainMove"))
                    ("SowAgainMove")
                    (do 
                        (and {
                            (add (piece (id "Seed" Shared)) (to (last To)) count:(var "NumToSow"))
                            (forget Value "SowedSites" All)
                            (set Var "NumToSow" 0)
                        })
                        next:(move Pass)
                    )
                )
                (if ("SameTurn")
                    (move 
                        (from ("NextSite" 1))
                        (to (sites Around (from)))
                        (then
                            (and {
                                (if (is Occupied (last From))
                                    (and {
                                        (moveAgain)
                                        (set Var "NumToSow" (count at:(last From)))
                                        (remember Value "SowedSites" (last From))
                                    })
                                    (if ("NextSiteExist" 1)
                                        (if (is Occupied ("NextSite" 1))
                                            (moveAgain)
                                            (if ("NextSiteExist" 2)
                                                (if (is Occupied ("NextSite" 2))
                                                    (and
                                                        (fromTo
                                                            (from ("NextSite" 2))
                                                            (to (handSite Mover))
                                                            count:(count at:("NextSite" 2))
                                                        )
                                                        (if (and
                                                                ("NextSiteExist" 3)
                                                                ("NextSiteExist" 4)
                                                            )
                                                            (if (and
                                                                    (is Occupied ("NextSite" 4))	
                                                                    (is Empty ("NextSite" 3))
                                                                )
                                                                (fromTo
                                                                    (from ("NextSite" 4))
                                                                    (to (handSite Mover))
                                                                    count:(count at:("NextSite" 4))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (remove (last From) count:(count at:(last From)))
                            })
                        )
                    )
                    (move 
                        (from (sites Board) if:(is Occupied (from)))
                        (to (sites Around (from)))
                        (then
                            (and {
                                (if (is Occupied (last From))
                                    (and {
                                        (moveAgain)
                                        (set Var "NumToSow" (count at:(last From)))
                                        (remember Value "SowedSites" (last From))
                                    })
                                    (if ("NextSiteExist" 1)
                                        (if (is Occupied ("NextSite" 1))
                                            (moveAgain)
                                            (if ("NextSiteExist" 2)
                                                (if (is Occupied ("NextSite" 2))
                                                    (and
                                                        (fromTo
                                                            (from ("NextSite" 2))
                                                            (to (handSite Mover))
                                                            count:(count at:("NextSite" 2))
                                                        )
                                                        (if (and
                                                                ("NextSiteExist" 3)
                                                                ("NextSiteExist" 4)
                                                            )
                                                            (if (and
                                                                    (is Occupied ("NextSite" 4))	
                                                                    (is Empty ("NextSite" 3))
                                                                )
                                                                (fromTo
                                                                    (from ("NextSite" 4))
                                                                    (to (handSite Mover))
                                                                    count:(count at:("NextSite" 4))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (remove (last From) count:(count at:(last From)))
                            })
                        )
                    )
                )
            )
        )
        
        (end 
            (if (<= (count Pieces All in:(sites Board)) 1)
                (byScore {
                    (score P1 ("PiecesOwnedBy" P1)) 
                    (score P2 ("PiecesOwnedBy" P2))
                    (score P3 ("PiecesOwnedBy" P3))
                    (score P4 ("PiecesOwnedBy" P4))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
A Latin Square is a mathematical puzzle which appears in various cultures around the world, probably independently invented.A Latin Square puzzle is one in which an n x n grid is filled with n symbols, which cannot repeat in a row or column of the grid. 
(game "Latin Square" 
    (players 1) 
    (equipment { 
        (board (square <Size>) (values Cell (range 1 <Size>))) 
        (regions {Columns Rows})
    }) 
    (rules 
        (play (satisfy (all Different)))
        (end (if (is Solved) (result P1 Win)))
    )
)

Construct a Ludii game based on the following description
Das Bohnenspiel is a two-row mancala-style game described by Fritz Jahn, who described the game and two boards, one said to be a duplicate of one used by Catherina II of Russia to play with the Persian Shah 100 years before, and a another from the wife of the Oberpresident of Waldow, who played it during her childhood in Sczeczin. The game was popular among German-Baltic and Prussian royal families during the 19th century, but was popularized with Jahn's book. It continued play through at least the 1980s, as several East German books were published about it.2x6 board with store holes at either end. The game begins with six counters in each hole. Each player owns one row of holes. At the beginning of the turn, a player picks up all of the counters from their side of the board and sows them, one each, into consecutive holes in a counterclockwise pattern. If the last counter lands in a hole that contains 2, 4, or 6 (after sowing), then the player captures the counters in that hole. If the player captures counters in a hole, then they may also capture counters in the previous hole, if it also has 2,4, or 6, continuing until reaching a hole without 2, 4, or 6. Play continues until one player cannot play on their turn, at which point the other player receives all of the remaining counters. The player with the most captured counters wins. 
(game "Das Bohnenspiel" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions "Home" P1 (sites Bottom)) 			 
        (regions "Home" P2 (sites Top)) 				
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count 6 to:(sites Track)))
        
        (play 
            (move Select 
                (from
                    (sites Mover) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        if:(is In (count at:(to)) (sites {2 4 6})) 
                        apply:(fromTo 
                            (from (to)) 
                            (to (mapEntry (mover))) 
                            count:(count at:(to))
                        ) 
                        backtracking:True
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
Adjiboto is a two-row mancala-style board game that was observed in the early twentieth century in Beidotti village, Suriname, where Saamaka people lived. The board was kept in an open structure which served as the meeting place for the village council, house of mourning, and to accommodate travelers.2x5 board. Ten counters in each hole. Sowing occurs in an anti-clockwise direction, sowing first into the hole from which the counters originally came. Opening phase: In the first ten turns, each player must sow from each of their five holes. Main phase: Captures are made when the last counter of a sowing falls into a hole preceding a hole containing one, three, or five counters. These counters are taken. Any subsequent holes also containing one, three, or five counters are captured, until a hole is reached that does not have one of these numbers of counters. The exception to this is in the first move when no captures are made. Sowing cannot begin from a hole with a single counter. A player wins when his opponent can no longer sow. However, if a player can no longer move, they can redistribute their captured beans into their holes, and if all five can be filled with ten, the game is a draw. 
(game "Adjiboto" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 5 store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
    }) 
    (rules 
        
        (start (set Count 10 to:(sites Track)))
        
        phases:{
        (phase "Opening"
            (play
                (move Select
                    (from (difference (sites Mover) (sites ("SowedHoles"))) if:(< 1 (count at:(to))))
                    (then
                        (and
                            (sow origin:True)
                            ("RemmemberSowedHoles" (last From))
                        )
                    )
                )
            )
            (nextPhase Mover (< 8 (count Turns)))
        )
        (phase "Main"
            (play
                (move Select
                    (from (sites Mover) if:(< 1 (count at:(to))))
                    (then
                        (sow
                            if:(or {
                                (= 1 (count at:("NextHole" (to) 1)))
                                (= 3 (count at:("NextHole" (to) 1)))
                                (= 5 (count at:("NextHole" (to) 1)))
                            })
                            apply:(fromTo
                                (from ("NextHole" (to) 1))
                                (to (handSite Mover))
                                count:(count at:("NextHole" (to) 1))
                            )
                            origin:True		
                            forward:True
                        )
                    )
                )
            )
            (end 
                (if (no Moves Next) 
                    {
                    (if (< (count Cell at:(handSite Next)) 50) (result Mover Win))
                    (if (>= (count Cell at:(handSite Next)) 50) (result Mover Draw))
                    }
                )
                
            )
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Wure Dune"
    (players 2)
    (equipment {
        ("ThreeMensMorrisBoard")
        (hand Each)
        (piece "Marker" Each ("StepToEmpty" All))
    })
    (rules
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end ("Line3Win" Orthogonal))
    )	
)
Wuré Duné (\3x3 intersecting lines, with diagonals. Three pieces per player. Players alternate turns placing one of their pieces on the board. Once all of the pieces are placed, players take turns moving one of their pieces to an adjacent empty spot. The first player to make an orthogonal line with their pieces wins. 

Construct a Ludii game based on the following description
Puhulmutu is a two-row mancala-style board game played in Sri Lanka. It involves complex rules for eliminating holes in multiple rounds of the game.2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. Players sow beginning from holes in their row. In the course of sowing, a player cannot sow into a hole containing three counters; if one is encountered, it is skipped and the counter is sowed into the next hole without three. If the final counter falls into a hole containing three counters, the contents of the hole are captured and the contents of the next hole are picked up and sowing continues. Otherwise, if the last counter falls into a hole with counters, these are picked up and sowing continues, or if it falls into an empty hole the turn ends. Throughout the game, single counters cannot be moved if a player has a hole with multiple counters, and a single counter in the front hole cannot be moved if there are other single counters in the player's row. The round ends when one player's holes are empty. The player with counters remaining in their holes captures these counters.
            
            A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round.  The player with empty holes begins play in the direction of the empty hole. Counters cannot be captured or sowed from puta or naga holes. Play continues as before.
            
            When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters.  
            
        Play continues until one player cannot sow at the beginning of a round. 
(game "Puhulmutu" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "TrackCCW" "1,E,N,W" loop:True)
            (track "TrackCW" "7,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        (start { 
            (set Count 4 to:(sites Track)) 
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "StartingMove" 
            (play
                (or
                    (move Select
                        (from
                            (sites Mover)
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (and
                                (sow
                                    "TrackCCW"
                                    apply:(if (= 4 (count at:(to)))
                                        (and
                                            (if (!= 0 (count at:("NextHole" (to) "TrackCCW" 1)))
                                                (and
                                                    (moveAgain)
                                                    (set Var "Replay" ("NextHole" (to) "TrackCCW" 1))
                                                )
                                            )
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:4
                                            )
                                        )
                                        (if (< 1 (count at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                    skipIf:(or (not (is In (to) ("PlayableSites"))) (and (= 3 (count at:(to))) (!= 1 (value)))) 
                                )
                                (set Var "Direction" 1)
                            )
                        )
                    )
                    (move Select
                        (from
                            (sites Mover)
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (and
                                (sow
                                    "TrackCW"
                                    apply:(if (= 4 (count at:(to)))
                                        (and
                                            (if (!= 0 (count at:("NextHole" (to) "TrackCW" 1)))
                                                (and
                                                    (moveAgain)
                                                    (set Var "Replay" ("NextHole" (to) "TrackCW" 1))
                                                )
                                            )
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:4
                                            )
                                        )
                                        (if (< 1 (count at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                    skipIf:(or (not (is In (to) ("PlayableSites"))) (and (= 3 (count at:(to))) (!= 1 (value)))) 
                                )
                                (set Var "Direction" 2)
                            )
                        )
                    )
                )
            )
            (nextPhase "Sowing")
        )
        
        (phase "Sowing" 
            (play
                (if (= 1 (var "Direction"))
                    (move Select
                        (from
                            (if (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay")})
                                (sites Mover)
                            )
                            if:(and { 
                                (is Occupied (from)) 
                                (is In (from) ("PlayableSites")) 
                                (not (is In (from) ("BlockingHoles")))
                                (if (not ("OnlySingleCounters"))
                                    (< 1 (count at:(from)))
                                )
                            })
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                apply:(if (= 4 (count at:(to)))
                                    (and
                                        (if (!= 0 (count at:("NextHole" (to) "TrackCCW" 1)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" ("NextHole" (to) "TrackCCW" 1))
                                            )
                                        )
                                        (if (not (is In (to) ("BlockingHoles")))
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:4
                                            )
                                        )
                                    )
                                    (if (< 1 (count at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(or (not (is In (to) ("PlayableSites"))) (and (= 3 (count at:(to))) (!= 1 (value)))) 
                            )
                        )
                    )
                    (move Select
                        (from
                            (if (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay")})
                                (sites Mover)
                            )
                            if:(and { 
                                (is Occupied (from)) 
                                (is In (from) ("PlayableSites")) 
                                (not (is In (from) ("BlockingHoles")))
                                (if (not ("OnlySingleCounters"))
                                    (< 1 (count at:(from)))
                                )
                            })
                        )
                        (then 
                            (sow
                                "TrackCW"
                                apply:(if (= 4 (count at:(to)))
                                    (and
                                        (if (!= 0 (count at:("NextHole" (to) "TrackCW" 1)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" ("NextHole" (to) "TrackCW" 1))
                                            )
                                        )
                                        (if (not (is In (to) ("BlockingHoles")))
                                            (fromTo
                                                (from (to))
                                                (to (mapEntry Mover))
                                                count:4
                                            )
                                        )
                                    )
                                    (if (< 1 (count at:(to)))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                                skipIf:(or (not (is In (to) ("PlayableSites"))) (and (= 3 (count at:(to))) (!= 1 (value)))) 
                            )
                        )
                    )
                    (then
                        (if (no Moves Next) 
                            (and {
                                (forEach Site (sites P1)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry P1))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site (sites P2)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forget Value "Playable" All)
                                (forget Value "Blocked" All)
                                (if (< ("PiecesOwnedBy" P1) ("PiecesOwnedBy" P2))
                                    (and
                                        (set NextPlayer (player 2))
                                        (set Var "Winner" 2)
                                    )
                                    (and
                                        (set NextPlayer (player 1))
                                        (set Var "Winner" 1)
                                    )
                                )
                            })
                        )
                    )
                )
            )
            
            (end (if (no Moves Next)
                    {
                    (if (> 2 (count at:(mapEntry P1))) (result P2 Win))
                    (if (> 2 (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase (no Moves Next) "BetweenRounds")
        )
        
        (phase "BetweenRounds" 
            (play
                (if (and ("NewTurn") (!= (mover) (var "Winner")))
                    (or
                        (move
                            (from (mapEntry Mover))
                            (to ("RightMostEmpty") if:(is Empty (to)))
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (if (> 4 (count at:(last To)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (mapEntry Next))
                                                count:(- 4 (count at:(last To)))
                                            )
                                            (remember Value "Blocked" (last To))
                                        )
                                    )
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                    (set Var "Direction" 2)
                                })
                            )
                        )
                        (move
                            (from (mapEntry Mover))
                            (to ("LeftMostEmpty") if:(is Empty (to)))
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (if (> 4 (count at:(last To)))
                                        (and
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (mapEntry Next))
                                                count:(- 4 (count at:(last To)))
                                            )
                                            (remember Value "Blocked" (last To))
                                        )
                                    )
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                    (set Var "Direction" 1)
                                })
                            )
                        )
                    )
                    (if (!= (mover) (var "Winner"))
                        (move
                            (from (mapEntry Mover))
                            (to 
                                (if (= (var "Direction") 1)
                                    ("NextHole" (last To) "TrackCCW" 1) 
                                    ("NextHole" (last To) "TrackCW" 1) 
                                )
                                if:(is Empty (to))
                            )
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                })
                            )
                        )
                        (move
                            (from (mapEntry Mover))
                            (to (sites Mover) if:(is Empty (to)))
                            count:4
                            (then (and
                                    (remember Value "Playable" (last To))
                                    (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing") 
        )
        }
    )
)

Construct a Ludii game based on the following description
Skirt was part of a series of games created while travelling, that sought to simplify some of my earlier games to there barest essentials.
            It featured moving and then placement near the opponent.
            Afterwards the restrictions were completely revised, in part to match the name: pieces were confined to skirting moves around other pieces.
        In order to make the game more interesting by enabling earlier territory creation, the explicit concept of territory was added and then skirting was disallowed onto opponent's territory, and placement restricted to friendly territory.Goal: Last to place a piece (i.e control more territory)
            
            One player places two adjacent pieces on the board, one of each color; the other player either switches their locations or begins regular play.
            
            Definitions:
            'Territory' is any empty cell directly adjacent to more of a player's own pieces than opponent's pieces.
            A 'Skirting Move' is a series of steps in which the moving piece remains adjacent to at least one of the pieces it was adjacent to before making the step. None of these steps may land on another piece, nor land on an enemy territory.
            
        A turn consists of an optional 'skirting move' followed by a mandatory placement onto one's own territory. Board & size: Hexhex with edges alternating 2 and 4
(game "Skirt"
    (players 2)
    (equipment
        {
        (board <Board:size> use:Vertex)
        (piece "Disc" Each)
        }
    )
    (rules 
        (play
            (if
                (> 0 (counter))
                ("PieOffer")
                (if
                    ("SameTurn")
                    ("Placement")
                    (or
                        (if
                            (= 0 (counter))
                            ("PieRefusal")
                        )
                        (or
                            ("Skirt")
                            ("Placement")
        ))))) 
        (end 
            {
            (if
                "EndCondition"
                (result Mover Loss)
            )
            
            }  
)))

Construct a Ludii game based on the following description
Grasshopper is a Halma variant played with a draughts set and published in 1948.The rules are the same as for Halma. Pieces move one space orthogonally or diagonally. They may jump over a piece of any color. Multiple jumps in one turn are possible. Jumps do not capture. The player who first places all of their pieces in the opponent's starting position wins. The game is played on a board 8x8.
(game "Grasshopper" 
    (players 2) 
    (equipment { 
        (board <Board:size>) 
        (piece "Counter" Each)
        <Board:home>
        (map {(pair P1 P2) (pair P2 P1)})
    }) 
    (rules 
        (start { 
            (place "Counter1" (sites P1))
            (place "Counter2" (sites P2))
        })
        
        phases:{
        (phase "Movement" 
            (play 
                (forEach Piece 
                    (or 
                        ("HopSequence" (from)) 
                        (move Step 
                            (to 
                                if:(and
                                    (is Empty (to))
                                    (or
                                        (not (is In (from) (sites Next)))
                                        (is In (to) (sites Next)) 
                                    )
                                )
                            )
                        )
                    )
                )
            ) 
            (nextPhase (is Mover (next)) "MultiJump")
        ) 
        (phase "MultiJump" 
            (play 
                (or 
                    ("HopSequence" (last To)) 
                    (move Pass)
                )
            ) 
            (nextPhase (not (is Mover (next))) "Movement")
        ) 
        }
        
        (end ("FillWin" (sites (player (mapEntry (mover))))))
    )
)

Construct a Ludii game based on the following description
Ofanfelling is a race game played in Iceland. Though it is played on the same board as other European Tables Games, it is different from most of them in that all of the game play for each player takes place in separate quadrants of the board, and the players' pieces never interact with one another.2x12 board, with spaces as points, divided in two. Twelve pieces per player, which start stacked, two per point in the quadrant to the player's right. Two six-sided dice. Players unstack the pieces by moving pieces off of the stack, but remaining on the same point, according to the throws of the dice. The value of the throw indicates the number of the point which can be unstacked. For example, a throw of 1 and 4 allows the player to unstack the pieces on points 1 and 4. Doubles allow players to only move one piece, but grant the player another throw. When all of a player's pieces are unstacked, they must be restacked, in the same way. When they have been successfully restacked, the player then bears off the pieces from this quadrant of the board. When bearing off, players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The first player to bear off all their pieces wins.  
(game "Ofanfelling"
    (players 2)
    (equipment {
        ("BackgammonBoard"
            {
            (track "Track1" {7..12} P1 directed:True)
            (track "Track2" {18..13} P2 directed:True)
            }
        )
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" "SiteToMoveOnTrack")
                    "RemoveAPiece"
                    (move 
                        (from) 
                        (to "SiteToMoveOnTrack")
                    )
                )
            )
        )
        (map "StartTrack" {(pair P1 7) (pair P2 18)})
    })
    (rules 
        (start {
            (place Stack "Disc1" (sites {7..12}) count:2)
            (place Stack "Disc2" (sites {13..18}) count:2)
        })
        phases:{
        (phase "UnStacking" (play 
                (do 
                    (if (or (is Pending) ("NewTurn")) (roll)) 
                    next:
                    (forEach Die 
                        if:("DieNotUsed")
                        (if ("PieceStacked" "SiteToSelect")
                            (move Select (from ("SiteToSelect"))
                                (then 
                                    (and
                                        ("Unstack")
                                        ("ReplayNotAllDiceUsed")
                                    )
                                )
                            )
                        )
                    )
                    (then (if (all DiceEqual) (and (set Pending) (moveAgain))))
                )
            )
            (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not ("PieceStacked" (site)))) "Stacking")
        )
        (phase "Stacking" (play 
                (do 
                    (if (or (is Pending) ("NewTurn")) (roll)) 
                    next:
                    (forEach Die 
                        if:("DieNotUsed")
                        (if ("PieceUnstacked" "SiteToSelect")
                            (move Select (from ("SiteToSelect"))
                                (then 
                                    (and 
                                        ("Stack")
                                        ("ReplayNotAllDiceUsed")
                                    )
                                )
                            )
                        )
                    )
                    (then (if (all DiceEqual) (and (set Pending) (moveAgain))))
                )
            )
            (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not ("PieceUnstacked" (site)))) "BearingOff")
        )
        (phase "BearingOff" 
            (play 
                (do 
                    (if (or (all DiceEqual) ("NewTurn")) (roll)) 
                    next:(forEach Piece top:True)
                    (then (if (or (not (all DiceUsed)) (all DiceEqual)) (moveAgain)))
                )
            )
            (end ("EscapeWin"))
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Squaro"
    (players 1) 
    (equipment { 
        (board (square 6) (values Vertex (range 0 1)) use:Vertex) 
        (hints 
            {
            (hint 0 3) 
            (hint 1 3) 
            (hint 2 2) 
            (hint 3 0) 
            (hint 4 2) 
            (hint 5 3) 
            (hint 6 2) 
            (hint 7 1) 
            (hint 8 0) 
            (hint 9 2) 
            (hint 10 2) 
            (hint 11 1) 
            (hint 12 2) 
            (hint 13 2) 
            (hint 14 3) 
            (hint 15 3) 
            (hint 16 3) 
            (hint 17 4) 
            (hint 18 3) 
            (hint 19 2) 
            (hint 20 3) 
            (hint 21 4) 
            (hint 22 4) 
            (hint 23 3) 
            (hint 24 1) 
            }	
            Cell
        )
        (regions "AllSites" (sites Board))
    })
    (rules 
        (play 
            (satisfy
                (forAll 
                    Cell 
                    (is Count 
                        Vertex
                        (sites Incident Vertex of:Cell at:(from)) 
                        of:1 
                        (hint Cell at:(from))
                    )
                )
            )
        )
        (end (if (is Solved) (result P1 Win)))
    )
)
Squaro is a logic puzzle played on a grid of any size with circles on the intersections.The player must color in the circles on the intersections. Numbers in the squares indicate the number of adjacent circles which should be colored. 

Describe the mechanics of the following Ludii game
(game "Geister" 
    (players 2) 
    
    (equipment { 
        (board (square 6)) 
        (hand Each size:2)
        
        (piece "GhostGood" Each)
        (piece "GhostEvil" Each)
        
        (regions "HomeP1" P1 (difference (expand (sites Bottom) steps:1) (union (sites Side E) (sites Side W))))
        (regions "HomeP2" P2 (difference (expand (sites Top) steps:1) (union (sites Side E) (sites Side W))))
        
        (regions "EscapeP1" P1 {30 35})
        (regions "EscapeP2" P2 {0 5})
        
        (map "Where" {
            (pair (id "GhostGood" P1) (handSite P1)) (pair (id "GhostEvil" P1) (handSite P1 1)) 
            (pair (id "GhostGood" P2) (handSite P2)) (pair (id "GhostEvil" P2) (handSite P2 1)) 
        })
    }) 
    
    (rules 
        (start { 
            (place "GhostGood1" 36 count:4) (place "GhostEvil1" 37 count:4)
            (set Hidden (sites Hand P1) to:P2)
            
            (place "GhostGood2" 38 count:4) (place "GhostEvil2" 39 count:4)
            (set Hidden (sites Hand P2) to:P1)
        })
        
        phases:{
        (phase "Placement" 
            (play 
                (move 
                    (from (sites Occupied by:Mover container:(mover))) 
                    (to 
                        (forEach 
                            (sites Mover "Home") 
                            if:(is Empty (site))
                        )
                    ) 
                    (then 
                        (if 
                            ("HandEmpty" P2) 
                            (and {
                                (set Hidden (sites P2 "Home") False to:P1) 
                                (set Hidden (sites P1 "Home") False to:P2)
                                (set Hidden What (sites P2 "Home") to:P1) 
                                (set Hidden What (sites P1 "Home") to:P2)
                            }) 
                        ) 
                    )
                )
            ) 
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        (phase "Movement" 
            (play
                (forEach Piece {"GhostGood" "GhostEvil"} 
                    (or
                        (move Step
                            Orthogonal 
                            (to 
                                if:(not ("IsFriendAt" (to))) 
                                (apply 
                                    (if ("IsEnemyAt" (to))
                                        (add 
                                            (piece (what at:(to))) 
                                            (to (mapEntry "Where" (what at:(to))))
                                        )
                                    )
                                ) 
                            )
                        )
                        (move Select (from (intersection (sites Occupied by:Mover component:"GhostGood") (sites Mover "Escape")))
                            (then 
                                (trigger "Escaped" (mover))
                            )
                        )
                    )
                )
            )
            (end {
                (if 
                    (or {
                        (no Pieces Mover "GhostEvil" in:(sites Board))
                        (no Pieces Next "GhostGood" in:(sites Board))
                        (is Triggered "Escaped" Mover)
                    }) 
                    (result Mover Win)
                )
                (if 
                    (or
                        (no Pieces Next "GhostEvil" in:(sites Board))
                        (no Pieces Mover "GhostGood" in:(sites Board))
                    ) 
                    (result Mover Loss)
                )
            })
        )
        }
    )
)
In Geister, each player has four good ghosts and four evil ghosts – but only the player who owns a ghost can see whether it's good or evil (as with the pieces in Stratego). These ghosts start the game in the back rows of a 6x6 game board with the corners removed. Each turn, a player moves one of his ghosts one square orthogonally. Moving into an opponent's ghost kills that ghost. To win, you must get rid of your own evil ghosts, kill your opponent's good ghosts, or move one of your good ghosts off the board from one of your opponent's corner squares.Geister is a two-player board game on a 6×6 game board.
            Each player has four good ghosts and four evil ghosts, whose
            type is not revealed to the opponent player. In each turn
            a player can move one of his ghosts one step vertically or
            horizontally. Moving into a square containing an opponent's
            ghost will capture the opponent's ghost and move it off from
            the board. Moving into a square containing an ally ghost
            is not allowed. A player can also move off one of his good
            ghosts from one of the opponent's corner squares. A player
            wins when one of the three conditions is satisfied:
            • All the player's evil ghosts are captured.
            • All the opponent's good ghosts are captured.
            • One of the player's good ghosts is moved off the board
        from one of the opponent's corner squares. 

Construct a Ludii game based on the following description
This is a solitaire game played in the city of Mawryngkneng in India, the name for which was not recorded. A vertical line, with seven lines perpendicularly crossing it at equal intervals. Six pieces, three of one color and three of another. The three of one color are placed on the top three intersections, the three of the other color on the bottom three intersections. In the first move, one piece is moved to the center line, from one of the two lines adjacent to it. Pieces may move to an empty adjacent point, or may jump over a piece of the other color to an empty point. The goal is to place the pieces on the spaces where the pieces of the opposite color started the game. 
(game "Mawryngkneng Solitaire Game" 
    (players 1) 
    (equipment { 
        (board
            (add
                (rectangle 7 1)
                vertices:{
                {0.0 -1.0}
                {-1.0 0.0} {1.0 0.0}
                {-1.0 1.0} {1.0 1.0}
                {-1.0 2.0} {1.0 2.0}
                {-1.0 3.0} {1.0 3.0}
                {-1.0 4.0} {1.0 4.0}
                {-1.0 5.0} {1.0 5.0}
                {-1.0 6.0} {1.0 6.0}
                {0.0 7.0}
            })
            use:Vertex
        )
        (piece "Marker1" P1 (or ("StepToEmpty") ("HopPiece")))
        (piece "Marker2" P1 (or ("StepToEmpty") ("HopPiece")))
    }) 
    (rules 
        (start {
            (place "Marker1" (expand (sites {0}) steps:2))
            (place "Marker2" (expand (sites {6}) steps:2))
        })
        
        phases:{
        (phase "Opening" (play (forEach Piece ("StepToEmpty"))) (nextPhase "Solving"))
        (phase "Solving" (play (forEach Piece)))
        }
        
        (end 
            (if 
                (is Target {2 2 2 0 1 1 1} {0 1 2 3 4 5 6}) 
                (result P1 Win) 
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Hex" 
    (players 2) 
    (equipment { 
        (board (hex Diamond <Board>)) 
        (piece "Marker" Each)
        (regions P1 {(sites Side NE) (sites Side SW) })
        (regions P2 {(sites Side NW) (sites Side SE) })
    }) 
    (rules 
        <Meta:rule>
        (play (move Add (to (sites Empty))))
        (end (if (is Connected Mover) (result Mover <Result>))) 
    )
)
Hex was invented by Piet Hein in 1942 then described again by John Nash in 1944. It is played on a rhombus tiled by hexagons, most commonly 11x11 in size.Players take turns placing a piece of their colour at an empty cell, and win by connecting their board sides with a chain of their pieces. The game is played on a 3x3 board. The game uses the swap rule. The first player to connect their two sides wins.

Construct a Ludii game based on the following description
The game is played on a initial empty 5x5 board.MOVE - Each player inserts a stone onto the board from an edge. Black inserts from top and pushes from top to bottom, White inserts from left and pushes from left to right.
            - Black starts with a stone on the top-left corner.
            - Passing is not allowed 
            - If a stone, when pushed meets another stone, this too is pushed on the same direction, and so on...
            
            EDGE - A stone pushed off the edge during a push is returned to the player (there are no captures). If it is an opponent stone, this row/column cannot be used on the next turn (friendly stones do not have such restriction). 
            
        GOAL - Wins the player which makes a path between the edges (top-bottom for Black, right-left for White). Stones may be connected orthogonal or diagonal. 
(game "Tara"
    (players 2)
    (equipment {
        (board (square 5) use:Vertex)
        (piece "Ball" Each)
        (regions P1 {(sites Top) (sites Bottom) })
        (regions P2 {(sites Left) (sites Right) })
    })
    (rules
        phases:{
        (phase "Opening"
            (play 
                (move Add
                    (to (intersection (sites Top) (sites Left)))
                )
            )
            (nextPhase "Main")
        )
        (phase "Main"
            (play 
                (if (is Mover P1)
                    (move Select (from (sites Top) if:(not (is In (column of:(from)) (sites Pending))))
                        (then
                            (and {
                                (if (is Enemy (who at:(coord row:0 column:(column of:(last From)))))
                                    (set Pending (row of:(coord row:0 column:(column of:(last From)))))
                                )
                                (push (from (last To)) S)
                                (add (piece (id "Ball" Mover)) (to (last To)))
                            })
                        )
                    )
                    (move Select (from (sites Left) if:(not (is In (row of:(from)) (sites Pending))))
                        (then
                            (and {
                                (if (is Enemy (who at:(coord row:(row of:(last From)) column:(- (count Columns) 1))))
                                    (set Pending (column of:(coord row:(row of:(last From)) column:(- (count Columns) 1))))
                                )
                                (push (from (last To)) E)
                                (add (piece (id "Ball" Mover)) (to (last To)))
                            })
                        )	 
                    )
                )
            )
        )
        }
        
        (end {
            (if ("ConnectedEdges" P1) (result P1 Win))
            (if ("ConnectedEdges" P2) (result P2 Win))
        }) 
    )
)

Construct a Ludii game based on the following description
This game is played on the following 8x8 square board.TURNS - At each turn, each player must move one of his stones (called Kangaroos):
            - A stone must jump over one (orthogonal or diagonal) adjacent stone landing on the immediate next empty cell.
            - If the jumped enemy stones are captured and removed from the board.
            - Jumps can be multiple but are not mandatory.
            
        GOAL - The game ends when one player cannot move. The winner is the one with more stones. 
(game "Kanguruh"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Kangaroo" Each
            (move Hop
                (between if:(is Occupied (between)))
                (to
                    if:(is Empty (to))
                    (apply
                        (and {
                            (if ("IsEnemyAt" (between))
                                (remove (between))
                            )
                            (remember Value (from))
                            (remember Value (to))
                        })
                    )
                )
                (then
                    ("ReplayIfCanMove" 
                        (hop
                            (from (last To))
                            (between if:(is Occupied (between)))
                            (to if:(and (is Empty (to)) (not (is In (to) (values Remembered)))))
                        )
                        (forget Value All)
                    )
                )
            )
        )
    })
    (rules
        (start {
            (place "Kangaroo1" (expand (sites Bottom)))
            (place "Kangaroo2" (expand (sites Top)))
        })
        
        (play 
            (if ("SameTurn")
                (or
                    (move Pass
                        (then (forget Value All))
                    )
                    (move Hop
                        (from (last To))
                        (between if:(is Occupied (between)))
                        (to 
                            if:(and (is Empty (to)) (not (is In (to) (values Remembered))))
                            (apply
                                (and
                                    (if ("IsEnemyAt" (between))
                                        (remove (between))
                                    )
                                    (remember Value (to))
                                )
                            )
                        )
                        (then
                            ("ReplayIfCanMove"
                                (hop
                                    (from (last To))
                                    (between if:(is Occupied (between)))
                                    (to if:(and (is Empty (to)) (not (is In (to) (values Remembered)))))
                                )
                                (forget Value All)
                            )
                        )
                    )
                )
                (forEach Piece)
            )
        )
        
        (end (if (no Moves Next) 
                (byScore {
                    (score P1 (count Pieces P1))
                    (score P2 (count Pieces P2))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Chong is a game played by the Nivkh people in Northern Asia. This version was played in the late nineteenth and early twentieth century on Sakhalin Island.3x12-28 board. Players begin with soldiers, equal in number to the number of spaces in one row for each player, which begin in the spaces in the row closes to the player. Each player has one king piece, which begins in the rightmost space in the central row with respect to the player. Four six-sided dice with values from 1-6. A throw of 1 is called Chong. Pieces move in a boustrophedon path along the board, from left to right in their home row, right to left in the center row, and then left to right in their opponent's row. 
            
            A player must first throw a Chong to play. On this turn, when a player throws one Chong, the King exchanges places with the soldier behind it. If more than one Chong is thrown, the King exchanges places with the soldier that many spaces behind it. Any remaining values in the throw are moved by the soldier which took the king's space. Once this move has taken place, pieces move according to the throws of the dice, which can be subdivided between the pieces as the player sees fit. The King only moves with a Chong, and it exchanges the place of a piece that number of occupied squares away, i.e., only spaces occupied by the player's pieces are counted when moving the King. When the player has only one soldier and the King, the King may move normally (like a soldier does), but on throws of Chong. When only the King is left, the first Chong in a throw is ignored and only the second, third, or fourth Chongs are moved.  
            
            When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. An opponent's King cannot be taken by a soldier until it has first moved backwards, and then it can only be taken by a Chong.
            
            The game continues after the players' Kings have been taken.
            
        When a player reaches the end of the opponent's home line, the player wins. The game is played on a 3x12 board.
(game "Chong (Sakhalin)"
    (players 2)
    (equipment {
        (board 
            (rectangle 3 <Board:size>)
            {
            (track "Track1" "0,E,N1,W,N1,E" P1 directed:True)
            (track "Track2" <Board:track2> P2 directed:True)
            }
        )
        (dice d:6 num:4)
        (piece "Marker" Each
            (move
                (from)
                (to ("SiteToMoveOnTrack" from:(from) (pips))
                    if:(or {
                        (is Empty (to))
                        (and 
                            ("IsEnemyAt" (to))
                            (if (not ("IsPieceAt" "King" Next (to)))
                                True
                                (= 1 (abs (- (to) (from))))
                            )
                        )
                    })
                    ("CaptureEnemyPiece")
                )
            )
        )
        (piece "King" Each
            (if (= 1 (pips))
                (if (<= 2 (count Pieces Mover))
                    (if (and (!= 1 (value Player Mover)) (= 1 (count Pieces Mover)))
                        (move (from (from)) (to (from)) (then (set Value Mover 1)))
                        (move
                            (from)
                            (to ("SiteToMoveOnTrack" from:(from) (pips))
                                if:(or {
                                    (is Empty (to))
                                    (and 
                                        ("IsEnemyAt" (to))
                                        (if (not ("IsPieceAt" "King" Next (to)))
                                            True
                                            (= 1 (abs (- (to) (from))))
                                        )
                                    )
                                })
                                ("CaptureEnemyPiece")
                            )
                        )
                    )
                    (firstMoveOnTrack "Track" Mover
                        (if (and (> (site) (from)) (is Mover (who at:(site))))
                            (move Swap Pieces (from) (site))
                        )
                    )
                )
            )
        )
    })
    (rules 
        (start { 
            (place "Marker1" (difference (sites Bottom) (sites Right)))
            (place "King1" (intersection (sites Bottom) (sites Right)))
            (place "Marker2" (difference (sites Top) (sites Left)))
            (place "King2" (intersection (sites Top) (sites Left)))
        })
        phases:{
        (phase "Opening"
            (play 
                ("RollMove"
                    (if (!= 0 ("NumDiceAtOne"))
                        (if (is Mover P1)
                            (if (is Mover (who at:(- (where "King" Mover) ("NumDiceAtOne"))))
                                (move Swap Pieces (where "King" Mover) (- (where "King" Mover) ("NumDiceAtOne")))
                            )
                            (if (is Mover (who at:(+ (where "King" Mover) ("NumDiceAtOne"))))
                                (move Swap Pieces (where "King" Mover) (+ (where "King" Mover) ("NumDiceAtOne")))
                            )
                            (then
                                (fromTo
                                    (from (last From))
                                    (to ("SiteToMoveOnTrack" from:(last From) (- ("SumPips") ("NumDiceAtOne")))
                                        ("CaptureEnemyPiece")
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (not (was Pass)) "Playing")
        )
        (phase "Playing"
            (play
                ("RollEachNewTurnMove"
                    (forEach Die
                        if:("DieNotUsed")
                        (forEach Piece)
                        (then ("ReplayNotAllDiceUsed"))
                    )
                )
            )
        )
        }
        
        (end {
            (if (= (who at:0) P2) (result P2 Win))
            (if (= (who at:(- (count Sites in:(sites Board)) 1)) P1) (result P1 Win))
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Ashta-kashte"
    (players <Player:num>)
    (equipment {
        (board 
            (square 7)
            {
            (track "Track1" "27,N,W,S,E,N2,SW1,W4,N4,E4,S3,W3,N2,E2,S1,W1" P1 directed:True)
            (track "Track2" "21,S,E,N,W,S2,NE1,E4,S4,W4,N3,E3,S2,W2,N1,E1" P2 directed:True)
            <Player:trackP3>
            <Player:trackP4>
            }
        )
        (piece "Paddle" Each
            (if (and (is In (from) (sites Board)) ("IsNotOffBoard" "SiteToMoveOnTrack"))
                (move 
                    (from (from) level:(level))
                    (to 
                        "SiteToMoveOnTrack" 
                        "CaptureEnemyPiece"
                    )
                )
                (then 
                    (if (= "Goal" (last To))
                        (remove (last To))
                    )
                )
            )	
        )
        (hand Each)
        ("StickDice" 4)
        (map {(pair 1 "G4") (pair 2 "A4") (pair 3 "D1") (pair 4 "D7")})
        (map "Throw" {(pair 0 8)})
        (regions "ProtectedSites" (sites {0 3 6 21 27 3 45 42 48 24}))
    })
    (rules 
        (start {
            (place Stack "Paddle1" (handSite P1) count:4)
            (place Stack "Paddle2" (handSite P2) count:4)
            <Player:startP3>
            <Player:startP4>
        })
        (play 
            ("RollMove"
                (or {
                    (forEach Piece)
                    (move Pass)
                    (if (and ("Grace") (!= 0 (who at:(handSite Mover))))
                        (move 
                            (from (handSite Mover))
                            (to (mapEntry Mover))
                        )
                    )
                })
                (then 
                    (if ("Grace") (moveAgain))
                )
            )		
        )
        
        (end ("EscapeWin"))
    )
)
Ashta-kashte is a race game that was documented in India during the nineteenth century. The exact location of this version of the game was not recorded, but it is similar to other race games that mimic Pachisi and similar games, but on a square board.7x7 board. The central square, as well as the central square on each edge of the board, is marked with an X. Two to four players. Four pieces per player. Four cowries used as dice, the values are equal to the number of mouths which land face up; when all mouths are down the value = 8 and a \ The game involves 2 players.

Construct a Ludii game based on the following description
El Perro is a hunt game played in the Canary Islands. The board is typically scratched on the ground or on a stone, and the pieces are stones, seeds or shells.5x5 intersecting lines, with diagonals drawn in the quadrants. One player plays as one dog,  which is a large stone, and the other as twelve goats, which are smaller stones. The goats begin on the two rows closest to the player to which they belong, and on the right hand spots in the central row. The dog begins in the central space. 
            
            The dog moves first. The dog may move in any direction along the lines of the board. It may capture a goat by hopping over it to an empty adjacent spot on the opposite side of the goat, according to the lines of the board. Multiple captures are allowed. The goats move one space forward orthogonally or diagonally, or sideways, along the lines of the board. 
            
            When all of the goats are unable to move forward anymore and all are are in spaces being equivalent to the starting position on the opposite side of the board, they may then commence moving in the opposite direction toward their original starting position, but not backwards with respect to this direction. 
            
        The dog wins by capturing all the goats; the goats win by blocking the dog from being able to move. 
(game "El Perro"
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 5 5)
        (piece "Goat" P2
            ("StepToEmpty" 
                (if (= (value Player Mover) 1)
                    (directions {S SE SW E W})
                    (directions {N NE NW E W})
                )
            )
        )
        (piece "Dog" P1 
            (or 
                ("HopCapture"
                    (from (from))
                    Adjacent
                    (then (if (can Move ("HopCapture" (from (last To)))) (moveAgain))) 
                )
                ("StepToEmpty")
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Goat2" (union (intersection (union (sites Left) (sites Right)) (sites Row 2)) (expand (sites Bottom))))
            (place "Dog1" (sites Centre))
        })
        (play
            (if ("SameTurn")
                (or
                    ("HopCapture"
                        (from (last To))
                        Adjacent
                        (then (if (can Move ("HopCapture" (from (last To)))) (moveAgain))) 
                    )
                    (move Pass)
                )
                (forEach Piece)
                (then
                    (if (not 
                            (can Move
                                (forEach Piece 
                                    ("StepToEmpty" 
                                        (if (= (value Player P2) 1)
                                            (directions {S SE SW})
                                            (directions {N NE NW})
                                        )	
                                    )
                                    P2
                                )
                            )
                        )
                        (set Value P2 (if (= (value Player P2) 1) 0 1))
                    )
                )
            )
        )
        
        (end ("NoMovesP1NoPiecesP2")) 
    )
)

Construct a Ludii game based on the following description
San-Noku-Narabe is a simple game of alignment played in Japan, typically in small villages and by children as well as adults. It is notably one of the only documented games played by the Ainu people.3x3 intersecting lines. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. Once all of the pieces are placed, players move a piece to any empty spot on the board. The first player to make an orthogonal row of three along the lines of the board wins. 
(game "San-Noku-Narabe"
    (players 2) 
    (equipment {
        (board (square 3) use:Vertex)
        (hand Each)
        (piece "Marker" Each (move (from) (to (sites Empty))))
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win" Orthogonal))
    )
)

Construct a Ludii game based on the following description
Sher Bakar is a hunt game played in Mianwali, Pakistan. It begins with four stacks of goats and two tigers, and is similar to Bagh Guti. It is played by all ages and genders.5x5 board, played on intersections, with diagonals for each quadrant of the board. One player plays with two tiger pieces, placed on the midpoints of two opposite sides. The other player plays with nineteen goats, divided into three stacks of five and one stack of four, placed in the center of each quadrant. The goats move first. Goats may move one at a time to any adjacent vacant spot. More than one goat can be placed on the goats' starting spots, but not elsewhere. The tiger moves in the same manner, but also may capture a piece by hopping over it. Multiple captures can be made on the same turn with subsequent hops, but only the top goat in a stack is captured when a tiger leaps over it. The goal of the goats is to surround the tigers so they cannot move. The goal of the tigers is to capture all the goats.
         
(game "Sher Bakar"
    (players 2)
    (equipment {
        ("AlquerqueBoard" 5 5)
        (piece "Goat" P1 
            (move Step 
                (to if:(or (and (is In (to) (sites "StartingSitesGoats")) ("IsFriendAt" (to))) (is Empty (to))))
            )
        )
        (piece "Tiger" P2
            (or
                ("StepToEmpty")
                ("HopSequenceCapture")
            )
        )
        (regions "StartingSitesGoats" (sites {"B2" "D2" "D4" "B4"}))
    })
    (rules 
        (start {
            (place "Tiger2" (sites {"C1" "C5"}))
            (place Stack "Goat1" (sites {"B2" "D2" "D4"}) count:5)
            (place Stack "Goat1" (sites {"B4"}) count:4)
        })
        
        (play 
            (if	
                ("SameTurn")
                (or
                    (move Pass)
                    ("HopSequenceCaptureAgain")
                )
                (forEach Piece top:True)
            )
            
        )
        
        (end ("NoMovesP2NoPiecesP1"))
    )
)

Construct a Ludii game based on the following description
Loop Xiangqi is a Xiangqi variant that incorporates the reintroduction of captured pieces into Xiangqi.The rules are the same as for Xiangqi, except instead of moving a piece, a player's turn may be taken by replacing a captured piece on the board on any empty space. This piece is controlled by the player who replaced it. Captured Shi can only be placed on positions where they could normally reach. Captured Xiang can only be placed on the controlling players side of the river. 
(game "Loop Xiangqi" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (rectangle 10 9) use:Vertex) 
        
        
        (piece "Shi" Each ("StepMoveOnThePalace" Diagonal)) 
        
        
        (piece "Xiang" Each 
            (move Slide
                Diagonal 
                (between 
                    (exact 2) 
                    if:(and { 
                        (is In (between) (sites Mover "Home")) 
                        (is Empty (between)) 
                    })
                )
                (to 
                    if:("IsEnemyAt" (to)) 
                    (apply 
                        (if 
                            ("IsEnemyAt" (to))
                            (add 
                                (piece (mapEntry "captured" (what at:(to)))) 
                                (to Cell (mapEntry "where" (what at:(to))))
                            )
                        )
                    )
                ) 
            )
        ) 
        
        
        (piece "Ma" Each 
            (forEach Direction 
                Orthogonal 
                (to 
                    if:(is Empty (to)) 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            (directions {FR FL} of:All) 
                            (if (not ("IsFriendAt" (to))) 
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (add 
                                                (piece (mapEntry "captured" (what at:(to)))) 
                                                (to Cell (mapEntry "where" (what at:(to))))
                                            )
                                        )
                                    )
                                )
                            )
                        ) 
                    )
                )
            ) 
        )
        
        
        (piece "Ju" Each 
            (move Slide
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    (apply 
                        (if 
                            ("IsEnemyAt" (to))
                            (add 
                                (piece (mapEntry "captured" (what at:(to)))) 
                                (to Cell (mapEntry "where" (what at:(to))))
                            )
                        )
                    )
                )
            )
        )
        
        
        (piece "Pao" Each 
            (or 
                (move Slide Orthogonal) 
                (move Hop
                    Orthogonal 
                    (between 
                        before:(count Rows) 
                        after:(count Rows) 
                        if:(is Occupied (between))
                    )
                    (to 
                        if:(is Empty (to)) 
                        (apply 
                            if:("IsEnemyAt" (to)) 
                            (add 
                                (piece (mapEntry "captured" (what at:(to)))) 
                                (to Cell (mapEntry "where" (what at:(to))))
                            )
                        )
                    ) 
                ) 
            )
        )
        
        
        (piece "Zu" Each
            (move Step
                (if 
                    (is In (from) (sites Mover "Home")) 
                    Forward 
                    (directions {Forward Rightward Leftward})
                ) 
                (to 
                    (apply 
                        if:("IsEnemyAt" (to))
                        (add 
                            (piece (mapEntry "captured" (what at:(to)))) 
                            (to Cell (mapEntry "where" (what at:(to))))
                        )
                    )
                )
            )
        )
        
        
        (piece "Jiang" Each ("StepMoveOnThePalace" Orthogonal)) 
        
        (regions "PalaceP1" P1 { 3..5 12..14 21..23 })
        (regions "PalaceP2" P2 { 66..68 75..77 84..86 })
        (regions "Home" P1 (expand (sites Bottom) steps:4))
        (regions "Home" P2 (expand (sites Top) steps:4))
        (map "where" {(pair 2 90) (pair 1 96) (pair 4 91) (pair 3 97) (pair 6 92) (pair 5 98) (pair 8 93) (pair 7 99) (pair 10 94) (pair 9 100) (pair 12 95) (pair 11 101)})  
        (map "captured" {(pair 1 2) (pair 2 1) (pair 3 4) (pair 4 3) (pair 5 6) (pair 6 5) (pair 7 8) (pair 8 7) (pair 9 10) (pair 10 9) (pair 11 12) (pair 12 11)})
        
        (regions "PalaceShiP1" P1 { 3 5 13 21 23 })
        (regions "PalaceShiP2" P2 { 66 68 76 84 86 })
        
        (hand Each size:6)
    }) 
    
    (rules 
        (start { 
            (place "Jiang1" coord:"E1") (place "Shi1" {"D1" "F1"}) (place "Xiang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Ju1" {"A1" "I1"}) (place "Pao1" {"B3" "H3"}) (place "Zu1" {"A4" "C4" "E4" "G4" "I4"})
            (place "Jiang2" coord:"E10") (place "Shi2" {"D10" "F10"}) (place "Xiang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Ju2" {"A10" "I10"}) (place "Pao2" {"B8" "H8"}) (place "Zu2" {"A7" "C7" "E7" "G7" "I7"})
        })
        
        (play (do 
                (or {
                    (forEach Piece) 
                    (move (from (sites Occupied by:Mover container:"Hand" components:{"Ma" "Ju" "Pao" "Zu"})) (to (sites Empty)))
                    (move (from (sites Occupied by:Mover container:"Hand" component:"Shi")) (to (intersection (sites Empty) (sites Mover "PalaceShi")))) 
                    (move (from (sites Occupied by:Mover container:"Hand" component:"Xiang")) (to (intersection (sites Empty) (sites Mover "Home"))))
                })
                ifAfterwards:(and 
                    ("JiangSameColumnWithNoPieceBetween")
                    (not ("IsInCheck" "Jiang" Mover))
                )
            )
        )
        
        (end {
            (if (and 
                    ("IsInCheck" "Jiang" Next) 
                    ("EnemyCannotMove")
                ) 
                (result Mover Win)
            ) 
            ("BlockWin")
        })
    )
)

Construct a Ludii game based on the following description
Owasokotz is a race game played by the Kawalka people of New Mexico. It can be played two ways, one which requires the player to pass the starting point, and another which requires the player to land exactly on the starting point, which also allows players to send each other back to start.Forty stones arranged in a circle, with a larger gap after every tenth stone. These gaps are known as doors. Any number of players, each player begins with one piece, which begins at the east door. Three sticks used as dice, black on one side, white on the other, with one stick notched on the white side. The throws are as follows: two black with one notched white side up = 15; three white sides up = 10; two black and one white, not notched = 3, two white and one black = 2, three black = 5. Throws of 10 and 15 grant the player another throw. Players may move in either direction around the circle. To win, the player must complete a circuit of the board and pass the east door. The game has 2 players. The goal is to pass the east door.
(game "Owasokotz"
    (players <Player:num>)
    (equipment {
        ("FortyStonesWithFourGapsBoard"
            {
            (track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True)
            (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)
            }
        )
        (regions "AllSites" (sites Board))
        (piece "Stick" Each
            (if (= (state at:(from)) 0)
                (or
                    ("MoveOn" ("NextSiteOnTrack" ("ThrowValue") "TrackCCW") (then (set State at:(last To) 2)))
                    ("MoveOn" ("NextSiteOnTrack" ("ThrowValue") "TrackCW") (then (set State at:(last To) 1)))
                )
                ("MoveOn" ("SiteToMoveOnSelectedTrack" ("ThrowValue")))
            )
        )
        ("StickDice" 3)
        (hand Each)
    })
    (rules 
        (start (place Stack items:<Player:init> Edge "EastDoor"))
        (play ("RollMove" (forEach Piece)))
        (end 
            (if 
                <Variant:goal>
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Gyan Chaupar is a game originating in India at an unknown time in the past. Since its origin in India, the game had moralistic tones, with setback and boons in the game associated with immoral or moral behavior, respectively. There are different variations based on Jain, Hindu, Islamic, and other religious traditions. It came to England around 1890 and was commercialized in other places like the Unites States as \10x10 board. Each player has one piece and move according to the roll of one die. Representations of snakes and ladders are scattered throughout the board, connecting two spaces. If a player lands at the bottom of the ladder at the end of their move, they advance to the space at the top of the ladder. If a player ends their turn on a space with the head of a snake, they move down to the space with the tail of the snake. The first player to move off the last space of the board wins. 
(game "Gyan Chaupar"
    (players 4) 
    (equipment { 
        (board (square 10) (track "Track" "0,E,N1,W,N1,E,N1,W,N1,E,N1,W,N1,E,N1,W,N1,E,N1,W" directed:True))
        (piece "Pawn" Each 
            (move 
                (from (from) level:(level)) 
                (to (mapEntry ("NextSiteOnTrack" (count Pips))))
            )
        )
        (dice num:1)
        (map { 
            (pair "B1" "C4") (pair "D1" "G2") (pair "H1" "J4") (pair "A3" "B5") (pair "E4" "D5") (pair "H3" "D9") (pair "J8" "J10") (pair "A8" "A10") (pair "J6" "G7")
            (pair "B7" "C2") (pair "G5" "F3") (pair "E2" "F1") (pair "D7" "A6") (pair "C10" "C8") (pair "H10" "H8") (pair "E10" "E8") (pair "G9" "D3") (pair "H6" "E6") (pair "I5" "J2")
        })
    }) 
    
    (rules 
        (start (place Stack items:{"Pawn4" "Pawn3" "Pawn2" "Pawn1"} coord:"A1"))	
        
        (play ("RollMove" (forEach Piece)))
        
        (end ("ReachWin" (sites {(trackSite EndSite)}) Mover)) 
    )
)

Describe the mechanics of the following Ludii game
(game "Branching Coral"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Ball" Each)
        (piece "Disc" Each)
        <Scoring:handType>
    })
    (rules
        (start (set Score Each 0))
        (play
            (do
                (move 
                    Add
                    (to 
                        (sites Empty) 
                        if:(< 1 
                            (count Sites 
                                in:(intersection
                                    (sites Around (to) "ConnectionDirection")
                                    (sites Empty)
                                )
                            )
                        )
                    )
                )
                ifAfterwards:("AllHave1Connection2Edge" 
                    (intersection 
                        (sites Around (last To) "ConnectionDirection")
                        (sites Empty)
                    )
                ) 
                (then
                    (do
                        (<Scoring:captureType> 
                            (intersection 
                                (sites Occupied by:All) 
                                (sites Around (last To) "ConnectionDirection") 
                        ))
                        next:(<Scoring:selScoring>)
                    )
                )
            )
        )
        (end 
            (if 
                (no Moves Next) {
                (if 
                    (= (score Mover) (score Next))
                    <TieScoring:finalTie>
                )
                (if 
                    (!= (score Mover) (score Next))
                    (byScore)
                )
            })
        )
    )
)
Branching Coral is a placement game based on the principle of placing pieces, such that, after placement, every site on the boards still has a connection via empty sites to an empty site at the perimeter.                 Branching Coral differs from its parent game Brain Coral by having a capture mechanism: After placement, all the neighboring stones with less than 2 adjacent empty sites are simultaneously captured. The placed piece itself must have 2 adjacent empty spaces before the captures to be a legal placement.             These capture conditions assure that the game is finite, and that the ending patterns that form are varied and gracefully branched, without thick regions either of pieces or empty space.                            Scoring is based on the size of the largest group plus a bonus factor.     The standard bonus factor is number of opponent's pieces captured.  This works to reward capture and thus encourages breaking up opponent's groups, while remaining straight forward in the need to enlarge your largest group, it allows creating come-back groups, or staging combacks by capturing material.              Other bonus options are:    Bonus for number of your own groups, serving to encourage you to make one large group and many singletons, to break up your opponent's largest group, and to try to force the opponent to connect small groups into medium sized groups. This is similar to Brain Coral, with the added tactical element of capture.             Bonus for number of opponent's groups; which is less interesting because it encourages players to form large clumps and to break up and limit opponent's group growth, and potentially partial mimicry in play.              Playing without any bonus, is similar to opponent group count bonus, but even more straight forward. It leads to clumping, though there still is a need for defense from captures severing connections. In this version the game will normally be decided early because neither player can extend or break the critical group, and there is not enough space to create a larger one. Thus this option needs the largest boards.             The standard tiebreaker is for the underdog to win based on the largest cascading group size without bonus.     If all groups are paired in size with the opponent, last to play wins.     For informal play, the tie breaker can be simplified as last-to-place.Goal: Score the most points: 
            -- One point for each stone in one's largest group.
            -- Bonus points are also awarded according to the selected option.
            
            The board starts empty.
            Players take alternating turns placing one of their stones onto an empty site.
            Directly after placement, every site of the board must remain connected to an empty perimeter site via a continuous path of empty sites, and the stone that was placed must be next to any 2 empty sites. 
            
            Capture 
            After placement, simultaneously remove all the stones adjacent to the placed stone that are no longer next to 2 empty sites.
            
            There is no passing. The game ends when no more placements can be made.  
            
            Players score one point for every stone in their largest group, then, if applicable, score bonus points according to the selected option.
            
            Bonus Options are:
            -- Captured opponent's stones
            -- Count of one's own groups
            -- Count of the opponent's groups
            -- No Bonus
            
            The player with the higher score wins. If the scores are tied, the game is decided by the tie-breaker option that was selected before the game: 
            A: Cascading largest group LOSES -- i.e. negative scores -- This excludes tied pairs; If all groups are paired, last to place. 
        B: Last player to have placed a stone. Order 3 board - about 5 moves each Triangle-Square N-2 all directions connect paths to edge - Orthogonal only form groups, about 20% more moves Scoring Option: Score a point for each piece in your largest group and each opponent piece you capture Tiebreaker is largest group (excluding tied pairs) LOSES. If all are paired, last placement wins.

Construct a Ludii game based on the following description
Invented in 1916 by Julian S. Grant Hayward, Double Chess is a Chess variant played on a 12x16 board. Each player has two complete sets of Chess pieces starting along the 16 square edge of the board.Rules are the same as Chess except pawns may move up to four squares on their first move and kings may only castle on their own half of the board. The player that checkmates one of the opposing kings wins. 
(game "Double Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (rectangle 12 16))
        
        (piece "Pawn" Each 
            (or {
                (if (is In (from) (sites Start (piece (what at:(from)))))
                    "InitialPawnMove"
                )
                "StepForwardToEmpty" 
                ("StepToEnemy" (directions {FR FL}))
                "EnPassant"
                }
                (then
                    (and
                        (if (is In (last To) (sites Mover "Promotion")) 
                            (moveAgain)
                        )
                        (set Counter)
                    )
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "KingLeft" {(pair 1 "E1") (pair 2 "E12")})
        (map "RookLeftLeft" {(pair 1 "A1") (pair 2 "A12")})
        (map "RookLeftRight" {(pair 1 "H1") (pair 2 "H12")})
        
        (map "KingRight" {(pair 1 "M1") (pair 2 "M12")})
        (map "RookRightLeft" {(pair 1 "I1") (pair 2 "I12")})
        (map "RookRightRight" {(pair 1 "P1") (pair 2 "P12")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 10))
            (place "Rook1" {"A1" "H1" "I1" "P1"} state:1) (place "Knight1" {"B1" "G1" "J1" "O1"}) (place "Bishop1" {"C1" "F1" "K1" "N1"}) (place "Queen1" {"D1" "L1"}) (place "King1" {"E1" "M1"} state:1) 
            (place "Rook2" {"A12" "H12" "I12" "P12"} state:1) (place "Knight2" {"B12" "G12" "J12" "O12"}) (place "Bishop2" {"C12" "F12" "K12" "N12"}) (place "Queen2" {"D12" "L12"}) (place "King2" {"E12" "M12"} state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (or 
                    (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King" Mover in:(sites Occupied by:Mover component:"King"))))
                    (or
                        (if (and {
                                ("InTheInitialPlace" "KingLeft")
                                ("HasNeverMoved" "KingLeft")
                                (not ("IsInCheck" "King" Mover at:(mapEntry "KingLeft" (mover)))) 
                            })
                            
                            (or
                                (if (and 
                                        ("HasNeverMoved" "RookLeftLeft")
                                        (can Move ("DoCastle" "RookLeftLeft" E 3 (is Empty (to))))
                                    )
                                    "BigLeftCastling"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookLeftRight")
                                        (can Move ("DoCastle" "RookLeftRight" W 2 (is Empty (to))))
                                    )
                                    "SmallLeftCastling"
                                )
                            )
                        )
                        
                        (if (and {
                                ("InTheInitialPlace" "KingRight")
                                ("HasNeverMoved" "KingRight")
                                (not ("IsInCheck" "King" Mover at:(mapEntry "KingRight" (mover)))) 
                            })
                            (or
                                (if (and 
                                        ("HasNeverMoved" "RookRightLeft")
                                        (can Move ("DoCastle" "RookRightLeft" E 3 (is Empty (to))))
                                    )
                                    "BigRightCastling"
                                )
                                (if (and 
                                        ("HasNeverMoved" "RookRightRight")
                                        (can Move ("DoCastle" "RookRightRight" W 2 (is Empty (to))))
                                    )
                                    "SmallRightCastling"
                                )
                            )
                        )
                    )
                )
            ) 
        )
        
        (end { 
            (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) 
            (if (and 
                    ("IsInCheck" "King" Next in:(sites Occupied by:Next component:"King"))
                    ("NextCanNotMove")
                ) 
                (result Mover Win)
            )
        }) 
    )
)

Construct a Ludii game based on the following description
Pippinzip is a square-board connection game for two players.  This is the 'Pipline' variant, the standard version of the game.  The game starts with a chicken ballot phase similar to Unlur, in which players both place 1-3 Black stones per turn until one decides to pass their turn and take Black.  Subsequently, the players place one stone per turn of their colour on any empty point.  The Black player ('Pip') wins if they connect any two sides of the board with a single orthogonally-connected group of stones.  The White player ('Zip') wins if they connect all four sides of the board with a single group connected both orthogonally and diagonally.This game is played on a square grid board of any size, though 13x13 or 19x19 are recommended. Then the players take it in turns to place 1-3 black stones each turn until one decides to pass; that player then becomes Black, and the other becomes White.  After that, players take it in turns to place one stone of their colour on the board on any empty point.  If Black connects any two sides of the board with a single orthogonally-connected group, they win; White wins if they connect all four sides with a group connected either orthogonally or diagonally.
            
        During the initial chicken ballot phase, you may add stones by clicking on available spaces, or skip the rest of your placements (by choosing the Next Player action).  Alternatively, you may Pass at the start of your turn to take Black.  After that, you and your opponent will alternate playing one stone of your colour per turn, until one player forms a connection (draws are impossible in Pippinzip). Played on a size 5 board.
(game "Pippinzip" 
    (players 2) 
    (equipment { 
        (board (square <Board:size>) use:Vertex) 
        (piece "Disc" Each) 
    }) 
    (rules 
        phases:{
        (phase "Opening"
            (play
                (or
                    (or
                        (move Add 
                            (piece (id "Disc" P2)) 
                            (to (sites Empty))
                            (then (if (< (count MovesThisTurn) 2) (moveAgain)))
                        )
                        "Skip"
                    )
                    (if (= (count MovesThisTurn) 0)
                        (move Pass
                            (then
                                (if
                                    (is Mover P1)
                                    (swap Players P1 P2
                                        (then
                                            (note "Player 1 is now Black. Player 2 is now White." to:All)
                                        )
                                    )
                                    (note "Player 1 remains White. Player 2 remains Black." to:All)
                                    (then
                                        (do (set NextPlayer (player 1))
                                            next:(set Var 1) 
                                        )
                                    )
                                )
                            )
                    ))
                )
            )
            (nextPhase ("IsPlayingPhase") "Playing")
        )
        (phase "Playing"
            (play (move Add (to (sites Empty))))
        )
        }
        (end {
            (if (and (not ("IsPlayingPhase")) ("BlackVC")) (result Mover Win))
            (if (and {(= (id P2) (mover)) ("BlackVC")}) (result P2 Win))
            (if (and {(= (id P1) (mover)) ("WhiteVC")}) (result P1 Win))
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Spreta" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" <Board:CCW2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1"))          
        (regions "Home" P2 (sites Track "Track2"))          
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom)))  
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top)))   
        (regions "Outer" P1 (sites Bottom))           
        (regions "Outer" P2 (sites Top))            
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start { 
            (set Count 1 
                to:(union { 
                    (sites P1 "Outer") 
                    (sites P2 "Outer") 
                    (difference (sites P1 "Inner") (sites { <Board:thirdHoleInnerP1> <Board:rightMostInnerHoleP1>})) 
                    (difference (sites P2 "Inner") (sites { <Board:thirdHoleInnerP2> <Board:rightMostInnerHoleP2>}))
                }) 
            )
            (set Count 2 to:(sites { <Board:thirdHoleInnerP1> <Board:thirdHoleInnerP2>})) 
            
        })
        
        phases:{
        (phase "Opening"
            (play 
                (move Select
                    (from 
                        (sites Mover) 
                        if:(= 2 (count at:(from)))
                    )	
                    (then
                        (sow
                            "Track"
                            owner:(mover)		
                        )
                    )
                )
            )
            (nextPhase Mover "Playing")
        )
        (phase "Playing"
            (play 
                (if (or (= 1 (var "ExtraCapture")) (= 2 (var "ExtraCapture")))
                    (move Remove
                        (difference (sites Next "Home") (sites Empty))
                        count:(count at:(to))
                        (then
                            (if (= 1 (var "ExtraCapture"))
                                (and 
                                    (moveAgain)
                                    (set Var "ExtraCapture" 2)
                                )
                                (set Var "ExtraCapture" 0)
                            )
                        )
                    )
                    (priority {
                        (move Select
                            (from 
                                (if ("SameTurn") 
                                    "LastHoleSowed" 
                                    (sites Mover) 
                                ) 
                                if:(< 1 (count at:(from)))
                            )
                            (then 
                                (sow
                                    "Track"
                                    owner:(mover)
                                    apply:(if (< 1 (count at:(to)))
                                        (moveAgain)
                                        (if (is In (to) (sites Mover "Inner"))
                                            (and {
                                                (if (> (count at:("OppositePit" (to))) 0) 
                                                    (remove ("OppositePit" (to)) count:(count at:("OppositePit" (to)))) 
                                                )
                                                (if (> (count at:("OppositeOuterPit" (to))) 0) 
                                                    (remove ("OppositeOuterPit" (to)) count:(count at:("OppositeOuterPit" (to)))) 
                                                )
                                                (set Var "ExtraCapture" 1)
                                                (moveAgain)
                                            })
                                        )
                                    )
                                )
                            )
                        )
                        (move Select
                            (from 
                                (if ("SameTurn") 
                                    "LastHoleSowed" 
                                    (sites Mover) 
                                ) 
                                if:(and
                                    (= 1 (count at:(from)))
                                    (= 0 (count at:("NextSite" from:(from))))
                                )
                            )
                            (then 
                                (sow
                                    "Track"
                                    owner:(mover)
                                    apply:(if (< 1 (count at:(to)))
                                        (moveAgain)
                                        (if (is In (to) (sites Mover "Inner"))
                                            (and {
                                                (if (> (count at:("OppositePit" (to))) 0) 
                                                    (remove ("OppositePit" (to)) count:(count at:("OppositePit" (to)))) 
                                                )
                                                (if (> (count at:("OppositeOuterPit" (to))) 0) 
                                                    (remove ("OppositeOuterPit" (to)) count:(count at:("OppositeOuterPit" (to)))) 
                                                )
                                                (set Var "ExtraCapture" 1)
                                                (moveAgain)
                                            })
                                        )
                                    )
                                )
                            )
                        )
                    })
                )
            )
        )
        }
        
        (end
            (if (all Sites (sites Next "Home") if:(= 0 (count at:(site))))
                (result Mover Win)
            )
        )
    )
)
Spreta is a four-row mancala-style game board played by the Chikunda people of Malawi. 4x10-12 board (even numbers only). One counter in each hole, except for the third hole from the left of the inner row, which contains two, and the rightmost hole of the inner row, which is empty. Play must begin from the hole containing two counters. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole. These are picked up and sowing continues. When the final counter falls in an empty hole, the contents of the hole in the opponent's  inner row opposite this hole are captured; if there are also counters in the opponent's outer row, these are also captured, along with the contents of any other two holes on the opponent's side of the board. Single counters can be moved only when there are no holes with multiple counters and they may only be moved to an empty hole. The player who captures all of the opponent's counters wins. Each player has 10 holes by row.

Describe the mechanics of the following Ludii game
(game "Brazilian Draughts" 
    (players 2) 
    ("DraughtsEquipment" (square 8))
    
    (rules 
        ("BlackCellsSetup" 3)
        
        (play 
            (if "SameTurn"
                (if "IsUnpromoted"
                    (max Moves
                        ("HopInternationalDraughtsStyle" (from (last To)) 
                            (then 
                                ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To)))
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                    )
                    (max Moves ("HopDiagonalSequenceCaptureAgain" before:(count Rows) after:(count Rows) at:EndOfTurn))
                )
                (priority {
                    (max Moves
                        (or 
                            (forEach Piece "Counter"
                                ("HopInternationalDraughtsStyle" (from) 
                                    (then 
                                        ("ReplayIfCanMove" ("HopInternationalDraughtsStyle" (from (last To)))
                                            ("PromoteIfReach" (sites Next) "DoubleCounter")
                                        ) 
                                    ) 
                                ) 
                            )
                            (forEach Piece "DoubleCounter" ("HopDiagonalSequenceCapture" before:(count Rows) after:(count Rows) at:EndOfTurn))
                        )
                    )
                    (or 
                        (forEach Piece "Counter" 
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                        (forEach Piece "DoubleCounter" (move Slide Diagonal))
                    )
                })
            )
        )
        
        (end ("BlockWin"))
    )
)
Brazilian Draughts is played in Brazil, and seems to have been invented and popularised in the late nineteenth or early twentieth century there, though its exact origins are not well documented.Played on an 8x8 board with 12 pieces per side. Pieces move one space diagonally. Capturing occurs when an opponent's piece is adjacent to a player's piece and there is an open space on the other side of the opponent and the player's piece jumps the opponent's. Capturing can happen either forwards or backwards. Capturing must happen if it is possible. Multiple jumps can be made in a turn, and the maximum number of jumps must be made. Pieces become kings when they reach the opposite side of the board from which they started at the end of its turn. Kings can move multiple spaces in one direction. 

Describe the mechanics of the following Ludii game
(game "Medio Emperador"
    (players 2)
    (equipment {
        ("TableBoard" "TableTracksOppositeWithHands")
        (dice d:6 num:<Dice:num>)
        (hand Each)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" "SiteToMoveOnTrack")
                    "RemoveAPiece"
                    (if ("NoEnemyOrOnlyOne" "SiteToMoveOnTrack")
                        (move 
                            (from) 
                            (to 
                                "SiteToMoveOnTrack" 
                                ("HittingCapture" (handSite Next))
                            )
                        )
                    )
                )	
            )
        )
    })
    (rules 
        (start {
            (place Stack "Disc1" 0 count:15)
            (place Stack "Disc2" 12 count:15)
        })
        (play
            ("RollEachNewTurnMove"
                (or 
                    (forEach Piece top:True) 
                    (forEach Piece container:(mover) top:True)
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )
        (end {
            ("EscapeWin")
            (if (and (no Moves P1) (no Moves P2)) (result Mover Draw))
        })
    )
)
Medio Emperador is a race game from medieval Spain that is related to other European Tables games. It is very similar to Emperador, using only half of the board and without a prime win.2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Two or three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, only on the half of the board where the pieces begin, toward the point where the opponent's pieces begin, and bearing off the board from there. When a piece lands on the same space as an opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins. If players move their pieces such that they fill up all the points in a quadrant, and the other fills up all of the points in an adjacent quadrant such that neither player can move, the game is a draw.
         The game involves 2 dice

Construct a Ludii game based on the following description
The goal is to capture the black queen with the white pieces. 
(game "Capture the Queen" 
    (players 2) 
    (equipment { 
        (board (square 8)) 
        (piece "Queen" Each ("SlideCapture"))
    }) 
    (rules 
        (start { 
            (place "Queen2" coord:"D8") 
            (place "Queen1" {"B1" "C1" "E1" "F1"})
        })
        
        (play (forEach Piece))
        
        (end {
            ("CaptureAll" P2) 
            (if (= (count Moves) 100) (result P2 Win)) 
        })
    )
)

Describe the mechanics of the following Ludii game
(game "Tawula"
    (players 2)
    (equipment {
        ("BackgammonBoard" "BackgammonTracksSameDirectionOppositeCornersWithBars2")
        (dice d:6 num:2)
        (piece "Disc" Each
            (if (or 
                    (!= (from) (mapEntry "StartTrack" Mover))
                    (and 
                        (= (from) (mapEntry "StartTrack" Mover))
                        ("HandEmpty" Mover)
                    )
                )
                (forEach Die 
                    if:("DieNotUsed")
                    (if ("IsOffBoard" "SiteToMoveOnTrack")
                        "RemoveAPiece"
                        (move 
                            (from) 
                            (to 
                                "SiteToMoveOnTrack" 
                                if:(or 
                                    (or
                                        ("EmptySiteIfOneSpecialRegion")
                                        ("EmptyOrFriednIfNotSpecialRegion")
                                    )
                                    ("OneEnemyPiece")
                                )
                                (apply ("CaptureEnemyPiece"))
                            )
                        )
                    )
                )	
            )
        )
        (hand Each)
        (map "Bar" {(pair P1 6) (pair P2 19)})
        (map "StartTrack" {(pair P1 25) (pair P2 0)})
        (regions "OnePieceMax" P1 (sites {14..18 20..24}))
        (regions "OnePieceMax" P2 (sites {1..5 7..11}))
    })
    (rules 
        (start {
            (place Stack "Disc1" 25 count:2) 
            (place Stack "Disc2" 0 count:2)
            (place Stack "Disc1" (handSite P1) count:13)
            (place Stack "Disc2" (handSite P2) count:13)
        })
        (play 
            ("RollEachNewTurnMove"
                (or 
                    (if ("BarEmpty" Mover)
                        
                        (forEach Piece top:True) 
                        
                        (forEach Die 
                            if:("DieNotUsed")
                            (move 
                                (from ("BarSite" Mover)) 
                                (to 
                                    ("SiteToEnterCapturePiece")
                                    if:(or 
                                        (or
                                            ("EmptySiteIfOneSpecialRegion")
                                            ("EmptyOrFriednIfNotSpecialRegion")
                                        )
                                        ("OneEnemyPiece")
                                    )
                                    (apply ("CaptureEnemyPiece"))
                                )
                            )
                        )
                    )
                    
                    (if ("HandOccupied" Mover)
                        (forEach Die 
                            if:("DieNotUsed")
                            (move 
                                (from (handSite Mover))
                                (to
                                    ("SiteToEnter")
                                    if:(or 
                                        (is Empty (to))
                                        ("OneEnemyPiece")
                                    )
                                    (apply ("CaptureEnemyPiece"))
                                )
                            )
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )
        (end ("EscapeWin"))
    )
)
Tawula is a race game similar to the constituent games of Tavli that was also played in Turkey and in Egypt during the nineteenth and twentieth centuries. The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; both players progress in an anti-clockwise direction. Fifteen pieces per player, two six-sided dice. Each player begins with two pieces on the rightmost point on the opposite side of the board. Players move according to the number on each die by moving one piece the number on one die and other the number on the other die, or by moving one piece the total number of both die. Further pieces are entered based on the roll of the dice, the point after the one with the two pieces on it at the beginning being counted as the first point. When entering captured pieces, however, the point where the two pieces start is counted as the first point. The two pieces which start on the board cannot be moved until all of the remaining pieces have been entered on the board. No more than one piece may rest on a point on the first half of the board, except for the two which start and also on the leftmost point on the opposite side of the board from where the player sits. When a piece lands on a point occupied by an opponent's piece, the opponent's piece is removed from the board and must be entered again. Players must enter captured pieces before continuing to move the other pieces on the board. When a piece is captured in the opponent's starting quadrant, a point must be left open or with only one piece, thus allowing the opponent to enter their piece. The player to move all of their pieces off the board wins.
         

Construct a Ludii game based on the following description
Pachisi is a race game and one of the longest-played games in South Asia. It is widely played throughout South Asia, and was transformed in the UK and US as Ludo and Parcheesi.Four pieces per player. Play begins in the central row of each player's arm of the board. Values of the cowries are: 0=6, 1=10, 2=2, 3=3, 4=4, 5=25, 6=12. A roll of 25 adds an extra move of 1. This extra move can be assigned to any piece or allows the player to move a piece onto the board. Play proceeds in an anti-clockwise direction. Pieces on a space marked \ 
(game "Pachisi" 
    (players 4) 
    (equipment { 
        ("PachisiBoard"
            {
            (track "Track1" "97,68,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,55,N8" P1 directed:True)
            (track "Track2" "98,46,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,34,W8" P2 directed:True)
            (track "Track3" "99,81,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,94,S8" P3 directed:True)
            (track "Track4" "100,4,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,19,E8" P4 directed:True)
            }
        )
        (hand Each) 
        ("StickDice" 6)
        (map "Die" {(pair 0 25) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 5) (pair 6 6)})
        (map "Entry" {(pair 1 68) (pair 2 46) (pair 3 81) (pair 4 4)})
        (map "PreviousGoal" {(pair 1 9) (pair 2 27) (pair 3 52) (pair 4 26)})
        (regions "Castle" {61 63 65 32 47 15 80 84 86 21 38 3})
        (regions "Grace" {0 1 6})
        (piece "Pawn" Each
            (if (or 
                    (= ("NextSiteOnTrack" (count Pips)) ("Goal")) 
                    (and 
                        (is In (count Pips) (sites "Grace")) 
                        (= (from) (mapEntry "PreviousGoal" (mover)))
                    )
                ) 
                (move Select 
                    (from) 
                    (to ("Goal")) 
                    (then (remove (last From)))
                )
                (if (and 
                        (not (= ("NextSiteOnTrack" (mapEntry "Die" (count Pips))) ("Goal"))) 
                        (not ("IsOffBoard" ("NextSiteOnTrack" (mapEntry "Die" (count Pips))))) 
                    )
                    (move 
                        (from (from) level:(level)) 
                        (to 
                            ("NextSiteOnTrack" (mapEntry "Die" (count Pips))) 
                            (apply if:(or 
                                    (not 
                                        (is In 
                                            ("NextSiteOnTrack" (mapEntry "Die" (count Pips))) 
                                            (sites "castle")
                                        )
                                    ) 
                                    (and 
                                        (is In 
                                            ("NextSiteOnTrack" (mapEntry "Die" (count Pips))) 
                                            (sites "Castle")
                                        )
                                        ("IsFriendAt" ("NextSiteOnTrack" (mapEntry "Die" (count Pips))))
                                    )
                                ) 
                                (if 
                                    ("IsEnemyAt" (to)) 
                                    (fromTo 
                                        (from (to)) 
                                        (to (handSite (who at:(to))))
                                    )
                                )
                            )
                        )
                    ) 
                )
            )
        )
    }) 
    (rules 
        (start {
            (place Stack "Pawn1" (handSite P1) count:4)
            (place Stack "Pawn2" (handSite P2) count:4)
            (place Stack "Pawn3" (handSite P3) count:4)
            (place Stack "Pawn4" (handSite P4) count:4)
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
        })
        
        phases:{
        (phase "firstTurn" 
            (play 
                ("RollMove"
                    (move
                        (from (handSite (mover))) 
                        (to 
                            ("NextSiteOnTrack" (mapEntry "Die" (count Pips))
                                from:(handSite (mover)) 
                            )
                        )
                    ) 
                )
            ) 
            (nextPhase (> (count Moves) 3) "Movement")
        )
        (phase "Movement" 
            (play ("RollMove"
                    (or
                        {
                        (forEach Piece)
                        (if (and 
                                (is Occupied (handSite (mover))) 
                                (is In (count Pips) (sites "Grace")) 
                            )
                            (move
                                (from 
                                    (handSite Mover) 
                                    level:(topLevel at:(handSite (mover)))
                                )
                                (to (mapEntry "Entry" (mover)))
                            )
                        )
                        (move Pass)
                        }
                        (then 
                            (if 
                                (is In (count Pips) (sites "Grace")) 
                                (moveAgain)
                            ) 
                        ) 
                    )
                )
            )
        )
        }
        (end ("EscapeTeamWin"))
    )
)

Construct a Ludii game based on the following description
An original n-in-row game with discs and rings.Players complete two actions in turns:
            1. Place a disc of their colour inside any ring.
            2. Pick up the ring in which they placed their disc and move it somewhere else:
            – It must be placed horizontally or vertically adjacent to at least another ring.
            – It must be placed on an empty space (i.e. not over a disc or ring that was placed before).
            - If a player has used up his/her stock of discs, he/she continues by removing one of his/her discs from anywhere on the table and places it in a ring as usual.
            
            However rings and discs must always remain (orthogonally or diagonally) connected to form one unique group. 
            
        The winner is the first player who succeeds in placing four of his/her discs or four of his/her rings in a horizontal, vertical or diagonal row.  
(game "Ringo" 
    (players 2) 
    (equipment { 
        (boardless Square) 
        (piece "Disc" Each ("MoveDisc")) 
        (piece "Ring" Each) 
    }) 
    (rules 
        (start {
            (place "Ring1" (ahead (centrePoint) NE)) 
            (place "Ring1" (ahead (centrePoint) SE)) 
            (place "Ring1" (ahead (centrePoint) SW)) 
            (place "Ring1" (ahead (centrePoint) NW)) 
            (place "Ring2" (ahead (centrePoint) N))
            (place "Ring2" (ahead (centrePoint) E))
            (place "Ring2" (ahead (centrePoint) S))
            (place "Ring2" (ahead (centrePoint) W))
        })
        phases:{
        (phase "PlacePhase"
            (play
                (do 
                    (if ("NewTurn") 
                        ("AddDisc") 
                        ("MoveRing") 
                        
                    )
                    ifAfterwards:(= 1 (count Groups))
                )
            )
            (nextPhase Mover 
                (and ("NewTurn") ("AllDiscsPlaced")) 
                "MovePhase"
            )
        )
        (phase "MovePhase"
            (play
                (do 
                    (if ("NewTurn") 
                        (forEach Piece) 
                        ("MoveRing")
                    )
                    ifAfterwards:(= 1 (count Groups))
                )
            )
        )
        }
        (end {
            (if (is Line 4 what:(id "Disc" P1)) (result P1 Win))
            (if (is Line 4 what:(id "Ring" P1)) (result P1 Win))
            (if (is Line 4 what:(id "Disc" P2)) (result P2 Win))
            (if (is Line 4 what:(id "Ring" P2)) (result P2 Win))
        })
    )
)

Construct a Ludii game based on the following description
Windflowers is a finite, 2-4 player, place-or-capture, connectivity game.             It is playable on a wide variety of grid and connectivity types.                        It is still experimental, as the best scoring and tiebreker combination needs to be resolved.            Also more investigation is needed concerning the degree that kingmaking will be a broblem for the multiplayer version.                        Placement is to empty sites: Capture is by replacing an opponent's stone during placement if that opponent owns more of the surrounding stones than the moving player does. On boards with diagonals, diagonal connections are included in the count to determine if a piece can be captured, but are not used for determining scoring groups discussed below.                        Passing is allowed, and the game ends when all players have passed consecutively. The board typically is full at this point, but there might be capture options still available that are disadvantageous to take.                        Scoring has 2 options:             Either scoring for stones placed, or for the largest group.            Tie breakers scoring is needed to reduce the frequency of ties.                        multi-player cascade group scoring: Between those tied for winner, each pair of players is considered separately and the difference in size of their largest groups (after excluding all pairs of equal-size groups) is awarded to the owner of the larger group for cascade scoring (or to the owner of the smaller group for underdog scoring.)  Underdog tiebreaking is currently prefered.            In 2-player games, the last player to place is the final tie-breaker.                        Finiteness:            Each individual placement/capture is obviously finite as eventually one of the players with the smallest number of surrounding pieces will have placed there. Proof is needed that, as a whole, cycling is impossible, but this is what is experienced practically, even with multiple players.                        If every thing is equal, the last to play wins. Thus on even boards, the first player is obligated to break mirror play to win.            ----------------------                       The previous version had the goal of least number of groups. This goal was flawed, allowing the simple strategy of always passing to force a win.Choose between two versions: 
            -- Place the most stones, or 
            -- Form the largest group. 
            
            Ties are broken by relying on a cascading comparison of largest groups; 
            - With a standard choice of breaking the tie in favor of the underdog.
            
            The board starts empty.
            Players take turns in sequence. Passing is allowed. 
            The game ends when all players have passed in succession. 
            
            On a turn, the mover either:
            1: Places a stone on an empty site, - or -
            2: Replaces an opponent's stone with their own,
            ---- But replacing a stone is only allowed when there are more stones around that site of the captured stone's color than there are of the mover's own color.
            
            Note: On boards with diagonals, diagonally adjacent stones are part of the count used to allow or disallow capture.
            
            At the end of the game, players count all their stones, or count the stones in their largest group, depending on the goal. Which stones belong to a given group are determined by orthogonal connections.
            
            In the case of a tie between the leading players, each pair of those players compares the size of their largest remaining group after any tied pairs have been removed. 
            
            This difference is added to the score of the player with the larger group in that pairing - (or to the score of other player in that pairing, in the case of underdog tie-breaking) 
            
            The winner of the game is decided by these amended scores.
        Ties may still remain.  Also ties between non-leading players are not resolved. Order 3 board Hex N+1 / N-1 Grid Score a point for each stone placed. While ignoring paired groups of equal size, if your group is larger, augment your score by the difference between your largest group and the largest group for every tied opponent. 2 players
(game "Windflowers"
    (players <HowMany:playerCount>)
    (equipment {
        "BoardUsed"
        (piece "Ball" Each)
    })
    (rules
        (start
            (set Score Each 0)
        )
        (play
            "Anemone" 
        )
        (end 
            (if 
                (all Passed)
                (byScore)
            )    
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Paintbucket"
    (players 2)
    (equipment {
        (board (square <Board>))
        (tile "Square" Each)
    })
    (rules
        (start {
            (place "Square1" (sites Phase 0))
            (place "Square2" (sites Phase 1))
            <Score:start>
        })
        (play
            (move Select
                (from (sites Occupied by:Next))
                (then <Score:running>)
            )
        )
        (end ("CaptureAll" Next Loss))
    )
)
PAINTBUCKET is a flipping game of elimination for two players, White and Black.Paintbucket was designed by Michael Amundsen and Alek Erickson in 2022.DEFINITION: A group is a maximal set of orthogonally adjacent like-colored pieces.
            GAMEPLAY: On your turn, flip an enemy group.
        OBJECTIVE: Eliminate the enemy pieces. A 6x6 board is currently selected A running count of your number of groups is show as a heuristic.

Construct a Ludii game based on the following description
Aw-li On-nam Ot-tjin is a mancala-style game played in Borneo, documented among the Penihing people, but also claimed to be played by other groups of people throughout Borneo. It is typically played on a wooden board (\Play starts with two counters in each hole. The game starts with 2 counters.
(game "Aw-li On-nam Ot-tjin" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 9
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start (set Count <Counters> to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(> (count at:(from)) 1)
                )
                (then 
                    (sow 
                        if:(= (count at:(to)) <Counters:num>)
                        apply:(fromTo 
                            (from (to)) 
                            (to (mapEntry (mover))) 
                            count:(count at:(to))
                        ) 
                    )
                )
            )
        )
        
        (end
            (if (no Moves Mover) {
                ("DrawIfNoMoves" Next)
                (if (is Mover P1) 
                    (byScore {
                        (score P1 ("KalahCount" P1)) 
                        (score P2 "PiecesOwnedByP1")
                    })
                )
                (if (is Mover P2) 
                    (byScore {
                        (score P1 "PiecesOwnedByP2") 
                        (score P2 ("KalahCount" P2))
                    })
                )
            })
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Daramuti" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "TrackCCW" "1,E,N,W" loop:True)
            (track "TrackCW" "7,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        (start { 
            (set Count 4 to:(sites Track)) 
            (set RememberValue "Playable" (union (sites Top) (sites Bottom)))
        })
        
        phases:{
        (phase "StartingMove" 
            (play
                (or
                    (move Select
                        (from
                            (sites Mover)
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (and
                                (sow
                                    "TrackCCW"
                                    apply:(if (= 1 (count at:(to)))
                                        (if (is Occupied ("OppositePitTwoRows" (to)))
                                            (fromTo
                                                (from ("OppositePitTwoRows" (to)))
                                                (to (mapEntry Mover))
                                                count:(count at:("OppositePitTwoRows" (to)))
                                            )
                                        )
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                    skipIf:(not (is In (to) ("PlayableSites")))
                                )
                                (set Var "Direction" 1)
                            )
                        )
                    )
                    (move Select
                        (from
                            (sites Mover)
                            if:(and (is Occupied (from)) (is In (from) ("PlayableSites")))
                        )
                        (then 
                            (and
                                (sow
                                    "TrackCW"
                                    apply:(if (= 1 (count at:(to)))
                                        (if (is Occupied ("OppositePitTwoRows" (to)))
                                            (fromTo
                                                (from ("OppositePitTwoRows" (to)))
                                                (to (mapEntry Mover))
                                                count:(count at:("OppositePitTwoRows" (to)))
                                            )
                                        )
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                    skipIf:(not (is In (to) ("PlayableSites")))
                                )
                                (set Var "Direction" 2)
                            )
                        )
                    )
                )
            )
            (nextPhase "Sowing")
        )
        
        (phase "Sowing" 
            (play
                (if (= 1 (var "Direction"))
                    (move Select
                        (from
                            (if (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay")})
                                (sites Mover)
                            )
                            if:(and { 
                                (is Occupied (from)) 
                                (is In (from) ("PlayableSites")) 
                                (not (is In (from) ("BlockingHoles")))
                                (if (not ("OnlySingleCounters"))
                                    (< 1 (count at:(from)))
                                )
                            })
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                apply:(if (= 1 (count at:(to)))
                                    (if (is Occupied ("OppositePitTwoRows" (to)))
                                        (fromTo
                                            (from ("OppositePitTwoRows" (to)))
                                            (to (mapEntry Mover))
                                            count:(count at:("OppositePitTwoRows" (to)))
                                        )
                                    )
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                )
                                skipIf:(not (is In (to) ("PlayableSites")))
                            )
                        )
                    )
                    (move Select
                        (from
                            (if (and (not (is Pending)) ("SameTurn"))
                                (sites {(var "Replay")})
                                (sites Mover)
                            )
                            if:(and { 
                                (is Occupied (from)) 
                                (is In (from) ("PlayableSites")) 
                                (not (is In (from) ("BlockingHoles")))
                                (if (not ("OnlySingleCounters"))
                                    (< 1 (count at:(from)))
                                )
                            })
                        )
                        (then 
                            (sow
                                "TrackCW"
                                apply:(if (= 1 (count at:(to)))
                                    (if (is Occupied ("OppositePitTwoRows" (to)))
                                        (fromTo
                                            (from ("OppositePitTwoRows" (to)))
                                            (to (mapEntry Mover))
                                            count:(count at:("OppositePitTwoRows" (to)))
                                        )
                                    )
                                    (and
                                        (moveAgain)
                                        (set Var "Replay" (to))
                                    )
                                )
                                skipIf:(not (is In (to) ("PlayableSites")))
                            )
                        )
                    )
                    (then
                        (if (no Moves Next) 
                            (and {
                                (forEach Site (sites P1)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry P1))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site (sites P2)
                                    (if (is Occupied (site))
                                        (fromTo
                                            (from (site))
                                            (to (mapEntry P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forget Value "Playable" All)
                                (forget Value "Blocked" All)
                                (if (< ("PiecesOwnedBy" P1) ("PiecesOwnedBy" P2))
                                    (and
                                        (set NextPlayer (player 2))
                                        (set Var "Winner" 2)
                                    )
                                    (and
                                        (set NextPlayer (player 1))
                                        (set Var "Winner" 1)
                                    )
                                )
                            })
                        )
                    )
                )
            )
            
            (end (if (no Moves Next)
                    {
                    (if (> 2 (count at:(mapEntry P1))) (result P2 Win))
                    (if (> 2 (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase (no Moves Next) "BetweenRounds")
        )
        
        (phase "BetweenRounds" 
            (play
                (if (and ("NewTurn") (!= (mover) (var "Winner")))
                    (or
                        (move
                            (from (mapEntry Mover))
                            (to ("RightMostEmpty") if:(is Empty (to)))
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (if (> 4 (count at:(last To)))
                                        (and
                                            (fromTo
                                                (from ("OppositePitTwoRows" (to)))
                                                (to (mapEntry Next))
                                                count:(- 4 (count at:(last To)))
                                            )
                                            (remember Value "Blocked" (last To))
                                        )
                                    )
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                    (set Var "Direction" 2)
                                })
                            )
                        )
                        (move
                            (from (mapEntry Mover))
                            (to ("LeftMostEmpty") if:(is Empty (to)))
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (if (> 4 (count at:(last To)))
                                        (and
                                            (fromTo
                                                (from ("OppositePitTwoRows" (to)))
                                                (to (mapEntry Next))
                                                count:(- 4 (count at:(last To)))
                                            )
                                            (remember Value "Blocked" (last To))
                                        )
                                    )
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                    (set Var "Direction" 1)
                                })
                            )
                        )
                    )
                    (if (!= (mover) (var "Winner"))
                        (move
                            (from (mapEntry Mover))
                            (to 
                                (if (= (var "Direction") 1)
                                    ("NextHole" (last To) "TrackCCW" 1) 
                                    ("NextHole" (last To) "TrackCW" 1) 
                                )
                                if:(is Empty (to))
                            )
                            count:(min 4 (count at:(mapEntry Mover)))
                            (then (and {
                                    (remember Value "Playable" (last To))
                                    (moveAgain)
                                    (if (= 0 (count at:(mapEntry Mover)))
                                        (set Pending)
                                    )
                                })
                            )
                        )
                        (move
                            (from (mapEntry Mover))
                            (to (sites Mover) if:(is Empty (to)))
                            count:4
                            (then (and
                                    (remember Value "Playable" (last To))
                                    (if (not (all Sites (sites Mover) if:(is Occupied (site))))
                                        (moveAgain)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing") 
        )
        }
    )
)
Daramuti is a two-row mancala-style board game from Sri Lanka.2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. Players sow beginning from holes their row. If the final counter falls into an empty hole, the contents of the opposite hole in the other row are captured. If the last counter falls into a hole with counters, these are picked up and sowing continues.  Throughout the game, singletons cannot be moved if a player has a hole with multiple counters, and a singleton in the front hole cannot be moved if there are other singletons in the player's row. The round ends when one player's holes are empty. 
            
            A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round. The player with empty holes begins play in the direction of the empty hole. Counters cannot be sown or captured from puta or naga holes. Play continues as before, but when the final counter falls into a puta or naga hole, the contents of the opposite hole in the other row are captured.
            
            When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters.
            
        Play continues until one player cannot sow at the beginning of a round. 

Construct a Ludii game based on the following description
Played by the Tiwa Puebloans in the Southwest United States. It is a game, with a similar board and starting position as Cercar la Liebre, but the goal is for the player with the greater number of stones to move to the opposite side of the board instead of blocking the other player from moving.One player has a single piece, the other has twelve, playing as jackrabbits. The player playing as the jackrabbits attempts to move all of their pieces to the opposite side of the board until they form the same configuration as the starting position on the opposite side. Pieces move orthogonally to accomplish this. The opponent's goal is to capture one of the jackrabbits by hopping over it. 
(game "Ko-app-paw-na" 
    (players 2) 
    (equipment { 
        (board (square 5) use:Vertex)
        (piece "Rabbit" P1 "StepToEmpty") 
        (piece "Counter" P2 (or "HopCapture" "StepToEmpty"))
        (regions P1 (union (expand (sites Top)) (sites {"A3" "E3"})))
    }) 
    (rules 
        (start { 
            (place "Rabbit1" (union (expand (sites Bottom)) (sites {"A3" "E3"})))
            (place "Counter2" (centrePoint))
        })
        
        (play (forEach Piece)) 
        
        (end {
            (if 
                (= (sites P1) (sites Occupied by:P1)) 
                (result P1 Win)
            )
            (if 
                (= (count Pieces P1) 11) 
                (result P2 Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Bouge Shodra is played by the Tuvinian people of Siberia. Though it falls under our classification as a hunt game, the game actually represents the herding of bulls into pens.5x5 intersecting lines, with diagonals in each 3x3 quadrant of the board. On one end, a square with diagonals, with one corner as the midpoint of one of the sides of the main board. On the opposite side, a triangle, with a line bisecting the base and another bisecting this line and intersecting with the other two sides of the triangle. The triangle's apex is the midpoint of the opposite side as the square. One player plays with two larger pieces, the Bulls, which start at the points where the triangle and square intersect with the main board. The other player plays with 24 smaller pieces. Eight of these begin on the points surrounding the central point of the board, the rest are in the hand. Players alternate turns. The Bulls move to an empty adjacent spot, the other player places one of the pieces from their hand onto the board. When all of these pieces are on the board, the player may move one of the pieces to an empty adjacent spot. The Bull may captured one of the smaller pieces my hopping over it onto an empty space. The goal of the Bulls is to capture all of the smaller pieces. The goal of the player with the smaller pieces is to corner the bulls so they cannot move. Doing so in the triangle and the square is a better win than cornering the Bulls on the main board. 
(game "Bouge Shodra"
    (players 2)
    (equipment {
        (board
            (merge
                ("AlquerqueGraphWithBottomTriangle")
                (rotate 45 (shift 1.5 6.2 (square 2 diagonals:Solid)))
            )
            use:Vertex
        )
        (hand P1)
        (piece "Marker" P1 "StepToEmpty")
        (piece "Bull" P2
            (or
                "StepToEmpty"
                "HopCapture"
            )
        )
    })
    
    (rules
        (start {
            (place "Bull2" (sites {"C3" "C7"}))
            (place "Marker1" (difference (expand (sites Centre)) (centrePoint)))
            (place "Marker1" (handSite P1) count:16)
        })
        phases:{
        (phase "Placement" P1
            (play (move (from (handSite P1)) (to (sites Empty))))
            (nextPhase Mover ("HandEmpty" P1) "Movement")
        )
        ("PhaseMovePiece" "Movement")
        }
        (end ("NoMovesP2NoPiecesP1"))
    )
)

Construct a Ludii game based on the following description
Paradis is a race game played by boys, men, and married women in Mali. Players attempt to reach Paradise, in the center of the board, three times.Nine concentric circles. Any number of players. Each player plays as one piece. Two nut shells, used as dice. The values are as follows: two round sides = 2; two hollow sides = 1; one of each side = 0. Players move their pieces from outside the circles into progressive rings until they reach Paradise at the center, at which point the piece goes back to the outside of the board. The first player to reach Paradise three times wins. The game involves 2 players.
(game "Paradis"
    (players <Player:num>)
    (equipment {
        (board 
            (concentric {<Player:num> <Player:num> <Player:num> <Player:num> <Player:num> <Player:num> <Player:num> <Player:num> <Player:num> <Player:num>})
            <Player:tracks>
            use:Vertex
        )
        ("StickDice" 2)
        (piece "Marker" Each
            (move
                (from (from))
                (to ("SiteToMoveOnTrack" ("ThrowValue"))
                    (apply 
                        (if (or
                                (and (= 1 ("ThrowValue")) (= (mapEntry "Center" Mover) (to)))
                                (and (= 2 ("ThrowValue")) (or (= (mapEntry "Center" Mover) (to)) (= (mapEntry "Center" Mover) ("SiteToMoveOnTrack" 1))))
                            )
                            (addScore Mover 1)
                        )
                    )
                )
            )
        )
        (map "Throw" {(pair 0 2) (pair 1 0) (pair 2 1)})
        <Player:center>
    })
    (rules
        <Player:start>
        (play 
            ("RollMove"
                (if (!= ("ThrowValue") 0) (forEach Piece))
            )
        )
        (end (if (= (score Mover) 3) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Mweiso is a four-row mancala-style board game commonly played in the Kagera province of Tanzania.4x8 board. Two counters in each hole. Opening play: Two players play simultaneously, lifting and sowing counters from their outer rows. Rules for sowing and capturing are the same as in the main phase of the game. Sowing cannot begin from the fourth or fifth hole from the left in the player's outer hole. Players play until both drop the final counter in an empty hole, the first to do so plays first in the main phase. Players then move alternately.  Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over. For capturing: Holes are in 'opposition' when one player has the front row hole occupied and the opponent has both of the holes opposite it occupied. If the last hole in a sowing is in opposition, the player takes the counters in both of the opponent's holes and places them in the empty hole from which the player lifted the counters. The player then sows the captured counters from this hole. Further captures in the sowing can occur in the same way. However, each player has two hole from which clockwise plays can be made: the leftmost hole in the outer row and the second from the left in the inner row. Clockwise moves can only be made from these holes if they immediately lead to a capture. When the captured counters are sown, starting from the same hole, they can also be sown clockwise if they lead to a capture. If they cannot lead to a capture, they are sown anti-clockwise. Another alternative the player has is that, if the player plays clockwise from one of these holes and therefore makes a capture, the captured counters may be placed in the hole and left there, and the player may play instead from the other hole from which clockwise captures are allowed in a clockwise direction, if it leads to a capture. The player may continue playing from this hole as above until the possibilities to move are exhausted, and then may move from any hole in an anti-clockwise direction. Multiple captures can only be made in a clockwise direction from these holes if it is made on the first sowing of the turn. Otherwise, only one clockwise capture can be made and sowing must proceed in an anti-clockwise direction. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses. A player may also win by capturing the counters from both of the opponent's end holes in the inner row in a single turn. 
(game "Mweiso" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "16,E,N1,W" loop:True P2)
            (track "TrackCW1" "7,W,N1,E" loop:True P1)
            (track "TrackCW2" "24,E,S1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))        
        (regions "Home" P2 (sites Track "TrackCCW2"))        
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) 
        (regions "Outer" P1 (difference (sites Bottom) (sites {3 4 })))          
        (regions "Outer" P2 (difference (sites Top) (sites {27 28})))           
        (map "LeftMostOuter" {(pair P1 0) (pair P2 31)})
        (map "SecondLeftInner" {(pair P1 9) (pair P2 22)})
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home"))))
        
        phases:{
        (phase "OuterPhase"
            (play
                (move Select
                    (from 
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover "Outer") 
                        )
                        if:(if ("SameTurn")
                            (< 0 (count at:(from)))
                            (< 1 (count at:(from)))
                        )
                    )
                    (then 
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:
                            (if (< 1 (count at:(to)))
                                (and
                                    (moveAgain)
                                    (if (and {
                                            (is Occupied ("OppositePit" (to)))
                                            (is Occupied ("OppositeOuterPit" (to)))
                                            (is In (to) (sites Mover "Inner"))
                                        })
                                        (and {
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (last From))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (fromTo
                                                (from ("OppositeOuterPit" (to)))
                                                (to (last From))
                                                count:(count at:("OppositeOuterPit" (to)))
                                            )
                                            (set Var "Replay" (from))
                                        })
                                        (set Var "Replay" (to))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            
            (nextPhase Mover (= 1 (count at:(last To afterConsequence:True))) "MainPhase")
        )
        
        (phase "MainPhase"
            (play
                (or
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)}) 
                            )
                            if:(and {
                                if:(if ("SameTurn")
                                    (< 0 (count at:(from)))
                                    (< 1 (count at:(from)))
                                )
                                (is In (from) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)}))
                                (is In ("NextHole" (from) "TrackCW" (count at:(from))) (sites Mover "Inner"))
                                (is Occupied ("OppositePit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                                (is Occupied ("OppositeOuterPit" ("NextHole" (from) "TrackCW" (count at:(from)))))
                            })
                        )
                        (then 
                            (sow
                                "TrackCW"
                                owner:(mover)
                                apply:
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and {
                                                (is Occupied ("OppositePit" (to)))
                                                (is Occupied ("OppositeOuterPit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            })
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                                (set Var "Replay" (from))
                                            })
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover) 
                            )
                            if:(if ("SameTurn")
                                (< 0 (count at:(from)))
                                (< 1 (count at:(from)))
                            )
                        )
                        (then 
                            (sow
                                "TrackCCW"
                                owner:(mover)
                                apply:
                                (if (< 1 (count at:(to)))
                                    (and
                                        (moveAgain)
                                        (if (and {
                                                (is Occupied ("OppositePit" (to)))
                                                (is Occupied ("OppositeOuterPit" (to)))
                                                (is In (to) (sites Mover "Inner"))
                                            })
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (fromTo
                                                    (from ("OppositeOuterPit" (to)))
                                                    (to (last From))
                                                    count:(count at:("OppositeOuterPit" (to)))
                                                )
                                                (set Var "Replay" (from))
                                            })
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end ("BlockWin"))
        )
        }
    )
)

Describe the mechanics of the following Ludii game
(game "Komikan" 
    (players 2) 
    (equipment { 
        (board
            (merge
                (scale 2 (square 5 diagonals:Alternating))
                (graph
                    vertices:{ {4 8} 
                    {3 9} {4 9} {5 9} {2 10} {3 10} {4 10} {5 10} {6 10} {1 11} {3 11} {4 11} {5 11} {7 11}
                    }
                    edges:{ {0 1} {0 2} {0 3} {1 4} {1 5} {1 2} {2 6} {2 3} {3 7} {3 8} {4 9} {4 5} {5 10} {5 6}
                    {6 11} {6 7} {7 12} {7 8} {8 13} {9 10} {10 11} {11 12} {12 13}
                    }
                )
            )
            use:Vertex
        )
        (piece "MountainLion" P1 
            (if "SameTurn" 
                (or 
                    (move Pass) 
                    ("HopSequenceCaptureAgain")
                ) 
                (or 
                    ("HopSequenceCapture") 
                    "StepToEmpty"
                ) 
            )
        )
        (piece "Dog" P2 N <Moves:dog>) 
    }) 
    (rules 
        (start { 
            (place "Dog2" (union (expand (sites Bottom)) (sites {"A3" "I3"})))
            (place "MountainLion1" (coord "E7"))
        })
        
        (play (forEach Piece)) 
        
        (end {
            (if (no Pieces P2) (result P1 Win))
            (if (no Moves P1) (result P2 Win))
            (if (no Moves P2) (result Mover Draw))
        })
    )
)
Komikan is a game played in South America, particularly well-known in Chile. It is first mentioned in a text by J. I. Molina in 1787, describing it as a game of Chess. Subsequent authors have doubted the identification of this game as Chess, and have largely agreed that it is indeed a hunt game popular among the Araucanians from the nineteenth century, also known as \One player has 12 dogs, the other one lion. The dogs may move one space forward, the lion may move one space in any direction, and may also hop over a dog to capture it. The lion may make multiple hops in one turn. The goal of the dogs is to block the lion from moving; the lion's goal is to capture all the dogs. The dogs moves forward.

Construct a Ludii game based on the following description
Chonka is a two-row mancala-style board game played in Colombo in Sri Lanka, and known by Tamil-speaking people as Pallankuli, though it is different from the Pallankuli known from India. It is typically played on a board with cowrie shells or tamarind seeds as counters.2x7 board, with two stores. Seven counters per hole. The first player may choose the direction of sowing, which must be maintained throughout the game. Sowing includes the player's store, which is the store following the last hole in the player's row, according to the direction of sowing. When the final counter of a sowing falls into an occupied hole, the counters in that hole are picked up and sowing continues. When the final counter of a sowing falls into an empty hole, that counter is captured along with any counters in the hole in the row opposite it. When the final counter falls into the player's store, the turn ends. The player who first captures half of the counters wins.
         Sowing occurs in CCW.
(game "Chonka" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns"
            {
            (track "Track1" <Track:directionP1> loop:True P1)
            (track "Track2" <Track:directionP2> loop:True P2)
            }
        )
        (piece "Seed" Shared) 
        (regions P1 (sites Bottom))     
        (regions P2 (sites Top))      
        <Track:stores> 
    }) 
    (rules 
        
        (start (set Count 7 to:(union (sites P1) (sites P2))))
        
        (play 
            (move Select 
                (from 
                    (if ("SameTurn") 
                        "LastHoleSowed" 
                        (sites Mover) 
                    ) 
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        apply:(if (!= (to) (mapEntry Mover))
                            (if (> (count at:(to)) 1)
                                (moveAgain)
                                (and
                                    (fromTo 
                                        (from ("OppositePitTwoRows" (to))) 
                                        (to (mapEntry Mover)) 
                                        count:(count at:("OppositePitTwoRows" (to)))
                                    ) 
                                    (fromTo 
                                        (from (to)) 
                                        (to (mapEntry Mover)) 
                                        count:(count at:(to))
                                    )
                                )
                            )
                        )
                        
                    )
                )
            )
        )
        
        (end
            (if (<= ("GoalNumCapturedCounters") (count at:(mapEntry Mover)))
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Gadis is a totally abstract game, which requires to play a special board consisting of three moving rings in a fixed frame.Initially, all pawns are placed on their starting positions in the outer sites of the circle.
            All pawns can move to an empty or enemy site adjacent to its position.
            Capture is mandatory. 
            
            A pawn can never move to one of the starting positions of its owner. 
            If a pawn is moving from a ring of the circle to another (except the outer ring), after moving, the player has to rotate the ring where moved the pawn.
            
        The game ends, when a player has no moves at its turn. The player with the most pieces on the starting positions of the opponent is winning. 
(game "Gadis"
    (players 2)
    (equipment {
        (board
            (remove
                (concentric {0 0 12 12 12 24})
                cells:{1}
            )
        )
        (piece "Pawn" Each)
        (regions P1 {45..56})
        (regions P2 {57 58 59 36..44})
        (regions "FirstCircle" {24..35})
        (regions "SecondCircle" {12..23})
        (regions "ThirdCircle" {1..11})
    })
    (rules
        (start {
            (place "Pawn1" (sites P1))
            (place "Pawn2" (sites P2))
        })
        (play 
            (if "SameTurn"
                ("Rotate")
                (priority {
                    (forEach Piece
                        (move Step 
                            (from if:(not (is In (from) (sites Next))))
                            Orthogonal
                            (to 
                                if:(and
                                    (is Enemy (who at:(to)))
                                    (not (is In (to) (sites Outer)))
                                )
                                (apply (remove (to)))
                            )
                        )
                    )
                    (forEach Piece
                        (move Step 
                            (from if:(not (is In (from) (sites Next))))
                            Orthogonal
                            (to 
                                if:(and
                                    (is Empty (to))
                                    (not (is In (to) (sites Mover)))
                                )
                            )
                        )
                    )
                    }
                    (then (if ("HasToRotate") (moveAgain)))
                )
            )
        )
        (end { 
            (if (no Moves Next)
                (byScore {
                    (score P1 ("PiecesOnNextStart" P1)) 
                    (score P2 ("PiecesOnNextStart" P2)) 
                })	
            )
        })
    )
)

Construct a Ludii game based on the following description
Ashere is a simple race game played by Yoruba children in the twentieth century.Seven concentric circles or squares. Four players. One piece per player. One player has a stick, which is hidden in their fist. The next player attempts to guess which hand holds the stick. If the player guessing guesses correctly, they enter their piece in the first circle or advances it to the next circle, and the stick is passed to them. If the guessing player guesses incorrectly, the player holding the stick moves their piece into the first circle or advances it to the next circle. The player with the stick keeps it until the next player guesses the hand holding the stick. The first player to reach the central circle wins.  
(game "Ashere"
    (players 4)
    (equipment {
        (board
            (concentric {4 4 4 4 4 4 4 4})
            {
            (track "Track1" {28 24 20 16 12 8 4 0} P1 directed:True)
            (track "Track2" {29 25 21 17 13 9 5 1} P2 directed:True)
            (track "Track3" {30 26 22 18 14 10 6 2} P3 directed:True)
            (track "Track4" {31 27 23 19 15 11 7 3} P4 directed:True)
            }
            use:Vertex
        )
        (piece "Marker" Each)
        (piece "Stick" Shared)
        (hand Each size:2)
    })
    (rules
        (start {
            (place "Marker1" 28)
            (place "Marker2" 29)
            (place "Marker3" 30)
            (place "Marker4" 31)
        })
        
        phases:{
        (phase "Hiding"
            (play
                (move Add
                    (piece (id "Stick" Shared))
                    (to Cell (sites Hand Mover))
                    (then (set Hidden Cell at:(last To) to:Next))
                )
            )
            (nextPhase "Guessing")
        )
        
        (phase "Guessing"
            (play
                (move Select
                    (from Cell (sites Hand Prev))
                    (then
                        (and
                            (if (is Empty (last To))
                                (and
                                    (fromTo 
                                        (from (where "Marker" Prev))
                                        (to ("NextSitePrev"))
                                    )
                                    (if (not (is In ("NextSitePrev") (sites Centre)))
                                        (set NextPlayer (player (prev)))
                                    )
                                )
                                (and {
                                    (moveAgain)
                                    (fromTo 
                                        (from (where "Marker" Mover))
                                        (to ("NextSite" from:(where "Marker" Mover)))
                                    )
                                })
                            )
                            (remove Cell (sites Hand Prev))
                        )
                    )
                )
            )
            (nextPhase "Hiding")
        )
        
        }
        
        (end 
            (if (!= (- (count Players) (count Active)) (count Sites in:(forEach (sites Centre) if:(is Occupied (site)))))
                {
                (if (and (is Active P1) (is In (where "Marker" P1) (sites Centre))) (result P1 Win))
                (if (and (is Active P2) (is In (where "Marker" P2) (sites Centre))) (result P2 Win))
                (if (and (is Active P3) (is In (where "Marker" P3) (sites Centre))) (result P3 Win))
                (if (and (is Active P4) (is In (where "Marker" P4) (sites Centre))) (result P4 Win))
                }
            )
        )
    )
)

Construct a Ludii game based on the following description
Sig is a word used for many games throughout North Africa. This game is from the Tunisian Sahara, and is very similar to other race games with captures such as Tab.4x13 board. Thirteen pieces per player, arranged on the outer rows of the board. Played with six sticks which function as dice. Pieces move according to the throws of the dice. Play progresses from left to right in the player's home row, and then from right to left in the second row, left to right in the third row, and then right to left in the opponent's row. A throw of 1 is required for each piece to being moving it. When a player's piece lands on a space occupied by a piece belonging to the opponent, the opponent's piece is captured. The player who captures all of the opponent's pieces wins.  
(game "Sig (Tozeur)"
    (players 2)
    (equipment {
        (board 
            (rectangle 4 13) 
            {
            (track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True)
            (track "Track2" "51,W,S1,E,S1,W,S1,E" P2 directed:True)
            }
            use:Vertex
        )
        (piece "Stick" Each 
            (if (or 
                    ("ActivatedPiece") 
                    (and (= (count Pips) 1) ("InactivePiece"))
                )
                (if ("IsNotOffBoard" "SiteToMoveOnTrack")
                    (if (or
                            (is In "SiteToMoveOnTrack" (sites Empty))
                            ("IsEnemyAt" "SiteToMoveOnTrack")
                        )
                        (move 
                            (from)
                            (to 
                                "SiteToMoveOnTrack" 
                                "CaptureEnemyPiece"
                            )
                        )
                    )
                    (then ("ActivatePiece"))
                )
            )
        )
        (regions "AllSites" (sites Board))
        ("StickDice" 6)  
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    })
    (rules 
        (start { 
            (place "Stick1" (sites Bottom) state:1)
            (place "Stick2" (sites Top) state:1)
        })
        (play ("RollMove" (forEach Piece)))
        (end {
            ("CaptureAll" Next)
            (if ("AllPieceInOpponentHome")
                (result Mover Draw)
            )
        })
    )
)

Construct a Ludii game based on the following description
Fergen Gobale is a two-row mancala-style board game from Ethiopia. It contains special neutral holes that can be captured in the course of play.2x6 board, divided in half and joined in the center with a single row of two holes. From the left, Five, five, three, three, five, and five counters in each hole of the double-row holes, four counters in the single row holes. Each player owns the row closest to them, but neither player controls the holes in the single row. Sowing begins from one of the holes in the player's row, and continues in an anti-clockwise direction. If the final counter lands in an occupied hole, these counters are picked up and sowing continues, unless the hole is in the single row, in which case the turn comes to an end. When the final counter falls in an empty hole in the player's row, the contents of the hole in the opponent's row adjacent to it are captured, along with the final counter of the sowing. However, if the hole from which the capture would be made contained three counters, these plus the final counter of the sowing are divided between the last hole of the sowing and the hole from which the capture would be made, i.e. two counters per each hole. The player then owns both of these holes, but cannot sow from them. The player also chooses at this point one of the holes in the single row to own, but the player still cannot begin sowing from it. Play continues until one player cannot play, and the players collect all of the counters from the holes they own. If one or both holes in the single row have not been claimed, the counters remain in them for the next round. The next round begins with the losing player filling as many holes in their row as possible, beginning from their left, according to the original starting number. After as many holes as possible are filled to the original capacity, the remaining  are placed in the next hole, or in an empty central hole. The opponent matches the arrangement in their own holes that are opposite the ones the other player can fill. If the losing player has fewer than five counters, they place one in each hole, starting from their left, and the opponent matches this arrangement. Play continues like this until one player has no more counters. 
(game "Fergen Gobale"
    (players 2)
    (equipment {
        (board 
            (merge {
                (rectangle 2 "Columns")
                (shift 5 0 (rectangle 2 3))
                (shift 3 0.5 (rectangle 1 2))
            })
            {
            (track "Track" "0,E,12,13,6,E,N,W,13,12,5,W" loop:True)
            (track "TrackFill" "0,E,6,E,N,W,5,W" loop:True)
            }
            use:Vertex
        )
        (piece "Seed" Shared)
        (regions "Home" P1 (sites Bottom)) 
        (regions "Home" P2 (sites Top))  
        (regions "Central" (sites Centre)) 
        (hand Each)
        (map "LeftMost" {(pair P1 0) (pair P2 11)})
        (map "CorrespondingHoles" {
            (pair 0 11) (pair 1 10) (pair 2 9) (pair 6 5) (pair 7 4) (pair 8 3) 
            (pair 5 6) (pair 4 7) (pair 3 8) (pair 9 2) (pair 10 1) (pair 11 0)
        })
        (map "InitialCount" {
            (pair 0 5) (pair 1 5) (pair 2 3) (pair 6 3) (pair 7 5) (pair 8 5)
            (pair 3 5) (pair 4 5) (pair 5 3) (pair 9 3) (pair 10 5) (pair 11 5)
        })
    })
    (rules
        (start {
            (set Count 5 to:(sites {"A1" "B1" "A2" "B2" "G2" "H2" "G1" "H1" "H2"}))
            (set Count 4 to:(sites {"D1" "E1"}))
            (set Count 3 to:(sites {"C1" "F1" "C2" "F2"}))
            (set RememberValue "Playable" (sites Board))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (if (is Pending)
                    (move Select
                        (from (sites "Central") if:(= 0 (state at:(from))))
                        (then
                            (set State at:(last To) (mover))
                        )
                    )
                    
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover "Home")
                            )
                            if:(and {(= 0 (state at:(from))) (is In (from) ("PlayableSites")) (is Occupied (from)) })
                        )
                        (then
                            (sow
                                "Track"
                                apply:(if (< 1 (count at:(to)))
                                    (if (and (= 0 (state at:(to))) (not (is In (to) (sites "Central"))))
                                        (and
                                            (moveAgain)
                                            (set Var "Replay" (to))
                                        )
                                    )
                                    (if (is In (to) (sites Mover "Home"))
                                        (if (= 3 (count at:("OppositePit" (to))))
                                            (and {
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (to))
                                                    count:1
                                                )
                                                (set State at:(to) (mover))
                                                (set State at:("OppositePit" (to)) (mover))
                                                (moveAgain)
                                                (set Pending)
                                            })
                                            (and
                                                (fromTo 
                                                    (from (to))
                                                    (to (handSite Mover))
                                                    count:1
                                                )
                                                (if (is Occupied ("OppositePit" (to)))
                                                    (fromTo 
                                                        (from ("OppositePit" (to)))
                                                        (to (handSite Mover))
                                                        count:(count at:("OppositePit" (to)))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                skipIf:(and (not (is In (to) (sites "Central"))) (not (is In (to) ("PlayableSites"))))
                            )
                        )
                    )
                    
                    (then
                        (if (or ("NoOccupiedFreeHoles" P1) ("NoOccupiedFreeHoles" P2))
                            (and {
                                (forEach Site 
                                    (sites Board)
                                    (if (or (and (= 0 (state at:(site))) (is In (site) (sites P1 "Home"))) (= (state at:(site)) 1))
                                        (fromTo
                                            (from (site))
                                            (to (handSite P1))
                                            count:(count at:(site))
                                        )
                                        (if (or (and (= 0 (state at:(site))) (is In (site) (sites P2 "Home"))) (= (state at:(site)) 2))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P2))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                )
                                (if (< ("NumCaptureSeeds" P1) ("NumCaptureSeeds" P2))
                                    (set NextPlayer (player 1))
                                    (set NextPlayer (player 2))
                                )
                                (if (or (> 5 ("NumCaptureSeeds" P1)) (> 5 ("NumCaptureSeeds" P2)))
                                    (set Var "PlaceOne" 1)
                                )
                                (forget Value "Playable" All)
                            })
                        )
                    )
                )
            )
            
            (end (if (or ("NoOccupiedFreeHoles" P1) ("NoOccupiedFreeHoles" P2))
                    {
                    (if (= 0 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase (or ("NoOccupiedFreeHoles" P1) ("NoOccupiedFreeHoles" P2)) "BetweenRounds")
            
        )
        
        (phase "BetweenRounds"
            (play
                (if (= 1 (var "PlaceOne"))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:1
                        (then
                            (and 
                                (remember Value "Playable" (last To))
                                (if (is Occupied (handSite Mover))
                                    (moveAgain)	
                                )
                            )
                        )
                    )
                    (if (<= (mapEntry "InitialCount" ("LeftMostEmpty")) (count Cell at:(handSite Mover)))
                        (move
                            (from (handSite Mover))
                            (to ("LeftMostEmpty"))
                            count:(mapEntry "InitialCount" ("LeftMostEmpty"))
                            (then
                                (and 
                                    (remember Value "Playable" (last To))
                                    (if (is Occupied (handSite Mover))
                                        (moveAgain)	
                                    )
                                )
                            )
                        )
                        (if (all Sites (sites Mover "Home") if:(is Occupied (site)))
                            (move
                                (from (handSite Mover))
                                (to (if (is Empty 12) 12 13))
                                count:(count Cell at:(handSite Mover))
                            )
                            (move
                                (from (handSite Mover))
                                (to ("LeftMostEmpty"))
                                count:(count Cell at:(handSite Mover))
                                (then (remember Value "Playable" (last To)))
                            )
                        )
                    )
                    (then
                        (if (is Empty (handSite Mover))
                            (and
                                (forEach Site (sites Mover "Home")
                                    (if (is Occupied (site))
                                        (and
                                            (remember Value "Playable" (mapEntry "CorrespondingHoles" (site)))
                                            (fromTo
                                                (from (handSite Next))
                                                (to (mapEntry "CorrespondingHoles" (site)))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                )
                                (set Var "PlaceOne" 0)
                            )
                        )
                    )
                )
            )
            (nextPhase (is Empty (handSite Mover)) "Sowing")
        )
        
        }
    )
)

Construct a Ludii game based on the following description
The Queah Game is a game from nineteenth century Liberia, the name of which has not been reported. It is typically played in a \Played on a board with two rows of five spaces forming an \ 
(game "Queah Game" 
    (players 2)
    (equipment {
        (board 
            (rotate 45
                (merge
                    (shift 1 -1 (rectangle 5 1))
                    (merge
                        (shift -1 1 (rectangle 1 5))
                        (square 3)
                    )
                )
            )
        )
        (piece "Stick" Each
            (or
                ("StepOrthogonalToEmpty")
                ("HopOrthogonalCapture")
            )
        )
        (hand Each)
    })
    (rules 
        (start {
            (place "Stick1" {"A1" "B2" "A3" "B4"})
            (place "Stick2" {"E5" "D4" "E3" "D2"})
            (place "Stick" "Hand" count:6)
        })
        (play
            (if (and 
                    ("HaveRemainingSticks") 
                    ("LessThanFourSticksOnBoard") 
                )
                ("ReplaceStick")
                (forEach Piece)
            )
        )
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Knightthrough is a Chess variant similar to Breakthrough, using knights instead of pawns.Pieces move as knights in Chess. The goal is to be the first player to reach the opposite side of the board from the starting position. 
(game "Knightthrough"
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        (piece "Knight" Each 
            (move Leap
                "KnightWalk"
                forward:True 
                (to if:(not ("IsFriendAt" (to))) (apply (remove (to))))
            )
        )
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Knight1" (expand (sites Bottom)))
            (place "Knight2" (expand (sites Top)))
        })
        
        (play (forEach Piece))
        
        (end ("ReachWin" (sites Mover) Mover))
    )
)

Construct a Ludii game based on the following description
Ssang-Ryouk (\The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and other the number on the other die, or by moving one piece the total number of both die. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
         
(game "Ssang-Ryouk"
    (players 2)
    (equipment {
        ("TableBoard" ("TableTracksOppositeWithHands2" End))
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die
                if:("DieNotUsed")
                (if (= End ("NextSiteFrom" (from) (pips)))
                    (if ("AllPiecesInFinalQuadrant")
                        (move Remove (from))
                    )
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NoEnemyOrOnlyOne" (to))
                            ("HittingCapture" (handSite Next))
                        )
                    )
                )
                (then ("ReplayNotAllDiceUsed"))
            )
        )
        (hand Each)
        (regions "FinalQuadrant" P1 (sites {18..23}))
        (regions "FinalQuadrant" P2 (sites {6..11}))
    })
    (rules 
        (start {
            (place Stack "Disc1" 6 count:5) (place Stack "Disc1" 4 count:3) 
            (place Stack "Disc1" 12 count:5) (place Stack "Disc1" 23 count:2)
            (place Stack "Disc2" 18 count:5) (place Stack "Disc2" 16 count:3) 
            (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 11 count:2)
        })
        (play 
            ("RollEachNewTurnMove"
                (priority {
                    ("EnterPieces")
                    (if (is Empty (handSite Mover)) (max Distance (forEach Piece top:True)))
                })
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Epoxy is a version of 'Shaka' (my ancestor game a few other games including my game Situ.) Shaka was a territorial lines-of-sight game based on out-of-sight entry, sliding moves, increasing stone contact, capture by enclosure and double-pass ending. Epoxy does not involve capture, and is a survival game. It is played on a special, 'perforated' triangular grid that makes the game more manageable than pure Shaka by limiting the lines of sight and movement. Both Epoxy and Situ improve the balance and opening stability of Shaka by using a '12* double-move protocol' (that is, after the first placement, players alternate taking double turns.)Epoxy differs from Situ in having no capture, but having movement. Movement is controlled by adjacency to the opponent's stones, effectively locking stones in place as they neighbour more and more opponent's stones. This creates territories that can be filled, as well as dead-zones for movement and/or placement. Due to this territorial nature, unlike Situ, turns may be partially passed, but a full pass is by definition a resignation.Territory equates to the availability of future placements when other movement is no longer possible, and the goal is to be the last to play.Use Options to select a board size.
            Goal: Be the last to play.
            
            Then the first player (Maroon) places a stone, after which the players alternate, taking up to two moves per turn.
            To move, either:
            
            1. Add a stone to an empty space that is not in line-of-sight of any opponent's stone. -Or,
            2. Slide a stone along a straight line to a new position, with the following restriction:
            
            Either
            -- A. The new location must have a greater number of opponent's stones adjacent to it, or
            -- B. The new location must have more sight-lines to opponent's stones than the old location, while keeping number of adjacent opponent's stones the same.  
            
            To avoid forfeiting the game, a player must move at least once on a turn.  The second move can be voluntarily skipped.
            The winner is last to play.
            
        The score shown is a count of the available moves at the beginning of a player's turn for use by the AI. Extra small board (39 nodes) as a filler game and for learning how to play
(game "Epoxy" 
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Ball" Each (move Slide))
    })
    (rules
        (start (set Score Each 0))
        (play 
            (or {
                ("Placement") 
                ("Movement" Mover) 
                (if
                    (and
                        (not (is Prev Next))
                        (< 0 (counter)) 
                    )
                    (move Pass)
                )
                }
                (then 
                    (if (is Prev Next)
                        (moveAgain)
                        ("ScoreTerritory")
                    ) 
                )
            )
        )
        (end "PassEnd")
    )
)

Construct a Ludii game based on the following description
Let's Catch the Lion is a simple version of Shogi. Both players have only four pieces – chick, giraffe, elephant and lion – and they're trying to either catch the opponent's lion or move their own lion to the other side. The board is just 3×4 squares, so the game is rather short, aimed mostly at getting children interested in Shogi – but even if you're an adult, the game is enjoyable.Each player starts the game with four pieces:
            
            - a Lion (king) in the center of the home row
            - a Giraffe (rook) to the right of the king
            - an Elephant (bishop) to the left of the king
            - a Chick (pawn) in front of the king
            
            Each piece moves as in standard shogi, but is limited to moving one square per turn. If the Chick advances to reach the final rank, it promotes to a Hen, which can move one square any way except diagonally backwards (like the gold general in shogi).
            
            As in shogi, if a Hen is captured, it may only be dropped back into play as a Chick. However, standard restrictions on where one may drop a Chick, such as not being allowed to give immediate checkmate, have two Chicks on a file, or drop the Chick on the final rank, do not apply. A chick dropped on the final rank, however, does not promote (and may make no further moves until it is recaptured).
            
        If the players play the same position three turns in a row, the game is a draw. 
(game "Let's Catch the Lion"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (rectangle 4 3))
        (tile "Giraffe" Each ("StepMove" Orthogonal))
        (tile "Elephant" Each ("StepMove" Diagonal))
        (tile "Chick" Each
            ("StepMove" 
                Forward 
                (then 
                    (if ("InLastRank" (last To)) 
                        ("Promote") 
                    )
                )
            )		
        )
        (tile "Chicken" Each ("StepMove" (directions {Forward Backward Rightward Leftward FL FR})))
        (tile "Lion" Each ("StepMove" Adjacent))
        (map "Captured" { 
            (pair (id "Giraffe" P1) (id "Giraffe" P2)) (pair (id "Giraffe" P2) (id "Giraffe" P1)) 
            (pair (id "Elephant" P1) (id "Elephant" P2)) (pair (id "Elephant" P2) (id "Elephant" P1)) 
            (pair (id "Chick" P1) (id "Chick" P2)) (pair (id "Chick" P2) (id "Chick" P1)) 
            (pair (id "Chicken" P1) (id "Chick" P2)) (pair (id "Chicken" P2) (id "Chick" P1)) 
        })
        (map "Where" {
            (pair (id "Giraffe" P1) (handSite P2)) (pair (id "Giraffe" P2) (handSite P1)) 
            (pair (id "Elephant" P1) (handSite P2 1)) (pair (id "Elephant" P2) (handSite P1 1)) 
            (pair (id "Chick" P1) (handSite P2 2)) (pair (id "Chick" P2) (handSite P1 2)) 
            (pair (id "Chicken" P1) (handSite P2 2)) (pair (id "Chicken" P2) (handSite P1 2)) 
        })
        
        (regions "LastRank" P1 (sites Top))
        (regions "LastRank" P2 (sites Bottom))
        
        (hand Each size:3)
    })
    (rules
        (start {
            (place "Giraffe1" coord:"C1") (place "Giraffe2" coord:"A4")
            (place "Chick1" coord:"B2") (place "Chick2" coord:"B3")
            (place "Lion1" coord:"B1") (place "Lion2" coord:"B4")
            (place "Elephant1" coord:"A1") (place "Elephant2" coord:"C4")
        })
        (play 
            (or 
                (move 
                    (from (sites Occupied by:Mover container:"Hand" components:{"Giraffe" "Chick" "Elephant"})) 
                    (to (sites Empty))
                ) 
                (forEach Piece) 
            )
        )
        (end { 
            (if (is Cycle)
                (result Mover Draw)
            )
            (if 
                (or 
                    ("IsOffBoard" (where "Lion" Next))
                    (is In (where "Lion" Mover) (sites Mover "LastRank"))
                ) 
                (result Mover Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Many variants on the concept of noughts and crosses exist. This version was created by Alan Parr. It is played on a 3x3 or 3x4 board with a supply of red, yellow, and green markers.The object is to get a line of three of the same color.
            
            On each turn, you may do ONE of the following:
            
            (1) Put a red counter in an empty square.
            (2) Replace a red counter with a yellow one.
        (3) Replace a yellow counter with a green one. The game is played on a 3x3 board.
(game "Traffic Lights" 
    (players 2) 
    (equipment { 
        (board <Board:size>) 
        (piece "Square" Shared)
        (piece "Triangle" Shared)
        (piece "Disc" Shared)
    }) 
    (rules 
        (play
            (or {
                (move Add (piece "Square") (to (sites Empty)))
                (move Select
                    (from (sites Occupied by:Shared component:"Square"))
                    (then
                        (promote (last To) (piece {"Triangle"}) Shared)
                    )
                )
                (move Select
                    (from (sites Occupied by:Shared component:"Triangle"))
                    (then
                        (promote (last To) (piece {"Disc"}) Shared)
                    )
                )
            })
        )
        (end ("Line3Win"))
    )
)

Construct a Ludii game based on the following description
Duene is  two-row mancala-style board game played by the Ewe people in what is now Togo and Ghana.2x6 board with two stores. Four counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole the counters are picked up and sowing continues, unless the hole contained three counters, causing it to contain four, in which case the counters are captured. An unbroken sequence of holes with four counters in them behind the hole from which the first capture was made are also captured. In addition, any holes which were sown into during the course of the turn which now contain four counters are captured by the owner of the row. Play continues until there are only eight counters left. The first player to make a capture with these eight counters captures them all. The player with the most counters wins. 
(game "Duene"
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))
        phases:{
        (phase "Playing"
            (play 
                (move Select 
                    (from 
                        (if ("SameTurn") 
                            ("LastHoleSowed") 
                            (sites Mover) 
                        ) 
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (do
                            (and
                                (set Var "From" (last From))
                                (sow 
                                    apply:(and
                                        (set Var "To" (to))
                                        (if (= (count at:(to)) 4)
                                            (fromTo 
                                                (from (to)) 
                                                (to (mapEntry (mover))) 
                                                count:(count at:(to))
                                            )
                                            (if (> (count at:(to)) 1)
                                                (moveAgain)
                                            )
                                        )
                                    )
                                    
                                    backtracking:(= (count at:(to)) 4)
                                )
                            )
                            next:(and {
                                (pass)
                                (forEach Site
                                    (forEach (sites Track from:(var "From") to:(var "To"))
                                        if:(and (is In (site) (sites P1)) (= 4 (count at:(site))))
                                    )
                                    (fromTo
                                        (from (site))
                                        (to (mapEntry P1)) 
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site
                                    (forEach (sites Track from:(var "From") to:(var "To"))
                                        if:(and (is In (site) (sites P2)) (= 4 (count at:(site))))
                                    )
                                    (fromTo
                                        (from (site))
                                        (to (mapEntry P2)) 
                                        count:(count at:(site))
                                    )
                                )
                            })
                        )
                    )
                )
            )
            (nextPhase (<= (count in:(sites Track)) 8) "EndGame")
        )
        (phase "EndGame"
            (play 
                (move Select 
                    (from 
                        (if ("SameTurn") 
                            ("LastHoleSowed") 
                            (sites Mover) 
                        ) 
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (sow 
                            apply:(if (= (count at:(to)) 4)
                                (forEach Site 
                                    (sites Track)
                                    (if (< 0 (count at:(site)))
                                        (fromTo 
                                            (from (site)) 
                                            (to (mapEntry (mover))) 
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (if (> (count at:(to)) 1)
                                    (moveAgain)
                                )
                            )
                            
                        )
                    )
                )
            )
        )
        }
        
        (end ("MancalaByScoreWhen" (all Sites (sites Track) if:(= 0 (count at:(site))))))
    )	
)

Construct a Ludii game based on the following description
Awithlaknan Mosona was played by the Zuni in New Mexico. Older Zuni men claimed it came there from Mexico. Zuni men described the game and were observed playing it by Matilda Coxe Stevenson. Nick Graham, a Zuni man, drew the board for Stuart Culin. Culin suggests there are two different versions based on the two boards he documented, but Stevenson is clear that the size of the board is not of a specific size.A series of three parallel lines are drawn, with diagonals connecting the outer lines at intervals, crossing each other at the central line. Eight in the outer rows, nine in the central. Pieces are moved along the intersections, and they are placed on the board on opposing sides, leaving the central spot empty. The first player moves to this spot along one of the lines, and the opponent jumps this pieces, thereby capturing it. 
(game "Awithlaknan Mosona" 
    (players 2) 
    (equipment { 
        (board
            (merge {
                (repeat 1 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 0} {0 0.5}}))
                (repeat 1 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 0} {0 -0.5}}))
                (repeat 7 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 0.5} {1 0.5}}))
                (repeat 7 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 -0.5} {1 -0.5}}))
                (shift (- 7 1) 0 (repeat 1 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {1 0.5} {1 0}})))
                (shift (- 7 1) 0 (repeat 1 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {1 0} {1 -0.5}})))
                (shift 0.5 0 (rectangle 1 7))
            })
            use:Vertex
        )
        (piece "Counter" Each 
            (or 
                ("HopCapture")
                ("StepToEmpty")
            )
        )
    }) 
    
    (rules 
        (start {
            (place "Counter1" (union (sites Bottom) (sites Direction from:(centrePoint) W)))
            (place "Counter2" (union (sites Direction from:(centrePoint) E) (sites Top)))
        })
        (play (forEach Piece))
        (end ("NoMoves" Loss))
    )
)

Describe the mechanics of the following Ludii game
(game "Selbia"
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 3 3)
        (hand Each)
        (piece "Marker" Each)
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        (play (move (from (handSite Mover)) (to (sites Empty))))
        (end ("Line3Win"))
    )
)
Selbia is an alignment game played in the Bordj Bou Arreridj region of Algeria in the early twentieth century.3x3 intersecting lines with diagonals in the square. Three pieces per player. Players alternate turns placing a piece on the board. The player who places three pieces in a row along one of the lines of the board wins.  

Construct a Ludii game based on the following description
Mahbouseh is a race game played in Southwest Asia, one of the different types which are called Tawulat ul-Zahr.The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. Each player's fifteen pieces begin on the first point of their track. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. When a piece lands on a space occupied by one of the opponent's piece, the opponent's piece may not move from that spot until the player's piece is moved from that spot. Two or more of the opponent's pieces may land on this space, but another of the player's pieces may not. When all of the player's pieces are on the final six points, they may be borne off the board. The player who bears off all of their pieces wins. The winning player's score equals the number of the opponent's pieces which are left on the board. Play continues until one player's score reaches 31.
             
(games (subgame "MahbousehSubgame" result:(score Mover)))

Construct a Ludii game based on the following description
FairKalah is a William Julius Champion's Kalah with fair initial states.The board has two rows of six play pits with a larger scoring pit on either end. Play begins with four seeds in each hole, with one or two seeds moved to make the initial position fair, i.e. two perfect players will draw. Each player controls the row nearest them. Play consists of choosing one of the player's non-empty play pits, removing the pieces from it, and sowing the pieces one per pit consecutively in a counterclockwise pattern including the player's own scoring pit but not the opponent's. If the last piece is placed in a player's empty pit, that piece and any opposite are captured and put in the player's scoring pit. If the last seed falls in the scoring pit, the player gets another turn. When one player has no pieces in any of their play pits, the game ends. The other player captures all of the other pieces, and the player with the most scored pieces wins. FairKalah board 1
(game "FairKalah" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns"
            (track "Track" "0,ESE,E,ENE,WNW,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 LastSite) (pair P2 FirstSite)}) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start {
            <Board:start>
        })
        
        (play 
            (move Select 
                (from 
                    (sites Mover) 
                    if:(> (count at:(from)) 0)
                ) 
                (then 
                    (sow
                        apply:(if (= (to) (mapEntry (mover)))
                            (moveAgain)
                            (if (and { 
                                    (is In (to) (sites Mover)) 
                                    (= (count at:(to)) 1) 
                                    (>= (count at:("OppositePit" (to))) 0)
                                })
                                (and 
                                    (fromTo 
                                        (from (to)) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:(to))
                                    ) 
                                    (fromTo 
                                        (from ("OppositePit" (to))) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:("OppositePit" (to)))
                                    ) 
                                ) 
                            )
                        )
                        skipIf:(= (to) (mapEntry (next)))
                    )
                )
            )
        )
        
        (end ("MancalaByScoreWhen"
                (or 
                    (= (count in:(sites Bottom)) 0)
                    (= (count in:(sites Top)) 0)
                )
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Nim" 
    (players 2) 
    (equipment { 
        (board (rectangle 1 <Size:board>)) 
        (piece "Marker" Neutral)
    }) 
    (rules
        (start  		
            <Size:piles>
        ) 
        
        (play 
            (if "SameTurn"
                (or
                    (move Select 
                        (from (last To))
                        (then 
                            (if (= (count at:(last To)) 1)
                                (remove (last To))
                                (and (set Count at:(last To) (- (count at:(last To)) 1)) (moveAgain)) 
                            )
                        ) 
                    )
                    (move Pass)
                )
                (move Select
                    (from (sites Occupied by:Neutral))
                    (then 
                        (if (= (count at:(last To)) 1)
                            (remove (last To))
                            (and (set Count at:(last To) (- (count at:(last To)) 1)) (moveAgain)) 
                        )
                    ) 
                )
            )
        ) 
        (end (if (no Moves Next) (result <Result> Win)))
    )
)
Nim is a game of uncertain origins. It is first mentioned by Luca Paccioli, an Italian mathematician in the early sixteenth or late fifteenth century. It is similar to other games worldwide, but multiple independent inventions may be possible, not necessarily the dispersion of a single game.Essentially, the game consists of a number of objects in \ The last mover loses. The game involves 3 piles.

Construct a Ludii game based on the following description
Tsaydithl is a race game played by the White Mountain Apache people of Arizona.Forty stones, placed in a circle with a larger space after every tenth stone. The spaces between the stones are the playing spaces. Two to four players, each with one counter. Three sticks, round on one side and flat on the other, used as dice. The throws are as follows: three round sides = 10; three flat sides up = 5; one round and two flat = 3; two round and one flat = 1 or 2. Players move from one of the wider spaces around the board in opposite directions. When a player lands on the same spot as the opponent's piece, the opponent's piece is sent back to the beginning. The first player to complete a circuit of the board wins.
         The game has 2 players.
(game "Tsaydithl"
    (players <Player:num>)
    (equipment {
        ("FortyStonesWithFourGapsBoard"
            {
            (track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True)
            (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)
            }
        )
        (piece "Stick" Each
            (or
                (if (= 2 ("ThrowValue"))
                    ("MoveOn" ("SiteToMoveOnSelectedTrack" (- ("ThrowValue") 1)))
                )
                ("MoveOn" ("SiteToMoveOnSelectedTrack" ("ThrowValue")))
            )
        )
        (regions "Gates" (sites {36..39}))
        (map "ThrowDiceValue" {(pair 0 5) (pair 1 3) (pair 2 2) (pair 3 10)})
        ("StickDice" 3)
        (hand Each)
    })
    (rules 
        <Player:startRules>
        (play 
            ("RollMove"
                (forEach Piece)
            )
        )	
        (end 
            (if 
                ("MadeACompleteCircuit")
                (result Mover Win)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "Tuk Tak"
    (players 2) 
    (equipment {
        (board (square 3))
        (hand Each)
        (piece "Marker" Each "StepToEmpty")
    }) 
    (rules 
        (start (place "Marker" "Hand" count:3))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end ("Line3Win"))
    )
)
Tuk Tak is a simple alignment game played in the Bengal region of India. It differs little from similar games known worldwide, and is generally played by children. 3x3 board, without the outer edges of the square. Three pieces per player. Players alternate turns placing the pieces on an empty space on the board. When all of the pieces have been placed, players move pieces to an adjacent empty space on the board. the first player to place all three of their pieces in an orthogonal or diagonal line wins.  

Construct a Ludii game based on the following description
Shatranj ar-Rumiya is a game known from Islamic manuscripts from the medieval period. It is similar to Shatranj but played on a circular board. The Name literally means \Circular board. Empty central circle, with four concentric rows of spaces, sixteen spaces per circle. Pieces are as follows: Rukh (x2), placed on two adjacent squares in the outer circle, move any number of spaces orthogonally; Asb (x2), placed in the two spaces adjacent to the Rukh in the next circle, move as Chess knights; Pil (x2): Placed in the two spaces adjacent to the Asb in the next circle in, move two spaces diagonally, jumping over the first space; Fres (x1): placed on the inner circle adjacent to the left Pil, moves one space diagonally; Shah (x1), placed to the right of the Fers, moves one space in any direction, Baidaq (x8), placed in each space flanking the other pieces, those on the left move clockwise, those on the right anti-clockwise, one space forward or one space diagonally forward to capture. No en passant, no promotion. When two Baidaq meet and neither can move, the opponent captures them. The opponent who can checkmate the opponent's Shah wins. Rules Murray.
(game "Shatranj ar-Rumiya" 
    (players 2) 
    (equipment { 
        (board 
            <Variant:board>
        )
        (piece "Pawn" Each
            (or {
                ("StepToEmpty" (if (= (state at:(from)) 0) CW CCW))
                (move 
                    (from)
                    (to 
                        (sites Around 
                            (sites To 
                                (move Step
                                    (if (= (state at:(from)) 0) CW CCW)
                                    (to if:True)
                                )
                            )
                            Orthogonal
                        )
                        if:(and 
                            (is Related Diagonal (from) (to))
                            ("IsEnemyAt" (to))
                        )
                    )
                )
                }
                (then 
                    (if (= (state at:(last To)) 0) 
                        (if ("IsPieceAt" "Pawn" Next (ahead (last To) CW))
                            (and 
                                (remove (last To))
                                (remove (ahead (last To) CW))
                            )
                        )
                        (if ("IsPieceAt" "Pawn" Next (ahead (last To) CCW))
                            (and 
                                (remove (last To))
                                (remove (ahead (last To) CCW))
                            )
                        )
                    )	
                )
            )
        )
        (piece "Rook" Each ("SlideCapture" Rotational))
        (piece "Knight" Each
            (forEach Direction 
                Orthogonal
                (to 
                    if:True 
                    (apply 
                        (forEach Direction 
                            (from (to)) 
                            Diagonal
                            (if (and 
                                    (not ("IsFriendAt" (to))) 
                                    (= 3 (count Steps Orthogonal (from) (to)))
                                )
                                (move 
                                    (from) 
                                    (to 
                                        (apply 
                                            if:("IsEnemyAt" (to))
                                            (remove (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                ) 
            )
        )
        (piece "Elephant" Each
            (move 
                (from)
                (to
                    (sites Around (sites Around (from) Diagonal) Diagonal)
                    if:(and 
                        (not ("IsFriendAt" (to))) 
                        (< 2 (count Steps Orthogonal (from) (to)))
                    )
                    (apply 
                        if:("IsEnemyAt" (to))
                        (remove (to))
                    )
                )
            )	
        )
        (piece "Queen" Each ("StepToNotFriend" Diagonal))
        ("ChessKing" "King_noCross")
    }) 
    (rules 
        <Variant:start>
        (play 
            (do
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        (end { 
            ("Checkmate" "King_noCross")
            <Variant:end>
        })
    )
)

Describe the mechanics of the following Ludii game
(game "4 Squared"
    (players 2)
    (equipment {
        (board 
            (merge {
                (square 5)
                (shift 5 0 (square 5))
                (shift 0 5 (square 5))
                (shift 5 5 (square 5))
            })
            use:Vertex
        )
        (piece "Ball" Each
            (if (is In (from) (sites "SW"))
                (or {
                    ("StepMove" S "H3")
                    ("StepMove" SE "H3")
                    ("StepMove" SW "H3")
                    ("StepMove" E "H3")
                    ("StepMove" W "H3")
                    ("StepMove" NE "H3")
                    ("StepMove" NW "H3")
                    ("StepMove" N "H3")
                    ("HopMove" S "H3")
                    ("HopMove" SE "H3")
                    ("HopMove" SW "H3")
                    ("HopMove" E "H3")
                    ("HopMove" W "H3")
                    ("HopMove" NE "H3")
                    ("HopMove" NW "H3")
                    ("HopMove" N "H3")
                })
                (if (is In (from) (sites "NW"))
                    (or {
                        ("StepMove" S "C3")
                        ("StepMove" SE "C3")
                        ("StepMove" SW "C3")
                        ("StepMove" E "C3")
                        ("StepMove" W "C3")
                        ("StepMove" NE "C3")
                        ("StepMove" NW "C3")
                        ("StepMove" N "C3")
                        ("HopMove" S "C3")
                        ("HopMove" SE "C3")
                        ("HopMove" SW "C3")
                        ("HopMove" E "C3")
                        ("HopMove" W "C3")
                        ("HopMove" NE "C3")
                        ("HopMove" NW "C3")
                        ("HopMove" N "C3")
                    })
                    (if (is In (from) (sites "NE"))
                        (or {
                            ("StepMove" S "C8")
                            ("StepMove" SE "C8")
                            ("StepMove" SW "C8")
                            ("StepMove" E "C8")
                            ("StepMove" W "C8")
                            ("StepMove" NE "C8")
                            ("StepMove" NW "C8")
                            ("StepMove" N "C8")
                            ("HopMove" S "C8")
                            ("HopMove" SE "C8")
                            ("HopMove" SW "C8")
                            ("HopMove" E "C8")
                            ("HopMove" W "C8")
                            ("HopMove" NE "C8")
                            ("HopMove" NW "C8")
                            ("HopMove" N "C8")
                        })
                        (if (is In (from) (sites "SE"))
                            (or {
                                ("StepMove" S "H8")
                                ("StepMove" SE "H8")
                                ("StepMove" SW "H8")
                                ("StepMove" E "H8")
                                ("StepMove" W "H8")
                                ("StepMove" NE "H8")
                                ("StepMove" NW "H8")
                                ("StepMove" N "H8")
                                ("HopMove" S "H8")
                                ("HopMove" SE "H8")
                                ("HopMove" SW "H8")
                                ("HopMove" E "H8")
                                ("HopMove" W "H8")
                                ("HopMove" NE "H8")
                                ("HopMove" NW "H8")
                                ("HopMove" N "H8")
                            })
                        )
                    )
                )
            )
        )
        (hand Each)
        (regions "SW" (expand origin:(coord "C3") steps:2 All))
        (regions "SE" (expand origin:(coord "H3") steps:2 All))
        (regions "NW" (expand origin:(coord "C8") steps:2 All))
        (regions "NE" (expand origin:(coord "H8") steps:2 All))
    })
    (rules
        (start (place "Ball" "Hand" count:15))
        (play
            (or
                (forEach Piece)
                (if (is Occupied (handSite Mover))
                    (move
                        (from (handSite Mover))
                        (to (sites Empty))
                    )
                )
            )
        )
        (end ("BlockWin"))
    )
)
The game is played on four boards (called here NW, SW, NE, SE according to their position). Both players start with 15 stones offboard (you can reduce the number for a shorter game).- BOARDS: The stones in each board are responsible for the moving possibilities of the stones in the next board (clockwise direction).
            E.g., board NW position determines the moves for board NE.
            
            - MOVE: Every stone allows the stones in the next board to move according to its position (using the red point as a reference point).
            E.g., A stone on b3, allows that player to move any stone in the next board one step to the left. A stone on e5 allows any stone in the next board to move two steps diagonally to the top right.
            A stone on a red point is useless for the moves in the next board .
            
            - TURN: On his turn a player must do one of two actions:
            Drop: The player drops a friendly stone on an empty cell. If there are no more offboard stones, he cannot choose this action.
            Move: The player moves a stone according to the moving rules. To move a stone there must be a friendly stone in the previous board.
            The move is only allowed if the moving stone stays in the same board.
            Stones jump. So if a stone moves from a5 to c5 (only possible if there is a friendly stone on e3 at the previous board) the status of b5 is irrelevant.
            The destination cell must be empty or occupied with an opponent stone, which is captured and removed from play.
            
        - GOAL: A player with no legal moves loses. 

Construct a Ludii game based on the following description
Ho-Bag Gonu is a Korean game with an uncertain history. It is a blockade game, similar to others found throughout Asia.Each player has three pieces.
            Players take turns moving a piece to an empty dot. 
            Players cannot return to their starting three dots.
            Pieces that move into the opponent’s starting three dots cannot exit them. 
        A player wins by blocking the other player from being able to move. 
(game "Ho-Bag Gonu" 
    (players 2) 
    (equipment { 
        (board 
            (add
                (merge
                    {
                    (rectangle 1 3)
                    (shift 1 1 (scale 0.5 (concentric {1 4})))
                    (shift 0 2 (rectangle 1 3))
                    }
                )
                edges:{{5 1} {9 7}}
            )
            use:Vertex
        )
        
        (piece "Disc" Each 
            (move Step 
                (to if:(or 
                        "MoveInTheEnemyHome"
                        "MoveSomewhereElseButInOurHome"
                    )
                ) 
            )
        ) 
        (regions "Home" P1 (sites {"A1" "C1" "E1"}))
        (regions "Home" P2 (sites {"A5" "C5" "E5"}))
    }) 
    (rules 
        (start {
            (place "Disc1" (sites P1))
            (place "Disc2" (sites P2))
        })
        (play (forEach Piece))
        (end ("NoMoves" Loss))
    )
)

Describe the mechanics of the following Ludii game
(game "MacBeth" 
    (players 2) 
    (equipment { 
        (board 
            (remove
                (hex 6)
                cells:{7 9 11 22 24 26 28 41 43 45 47 49 62 64 66 68 79 81 83}
            )
        )
        (piece "Disc" Neutral (flips 1 2))
    }) 
    (rules 
        
        <Rules:start> 
        
        phases:{ 
        <Rules:play>
        (phase "Playing" 
            (play (forEach Site 
                    (sites Empty)
                    (append 
                        "ReverseBoundedPieces" 
                        (then
                            (and
                                (set Score 
                                    P1 
                                    (count Sites in:(sites State 1))
                                )
                                (set Score 
                                    P2 
                                    (count Sites in:(sites State 2))
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end
            (if (all Passed)
                (byScore)
            )
        )
    )
)
MacBeth is a hexagonal translation of Reversi/Othello.  Players alternately place stones of their colour so as to cause custodial capture of lines of opposing pieces, which then flip to the player's colour.  The player who has the most stones on the board when no more moves are possible wins the game.Reversi is played on a hexhex-6 board with some cells removed. Pieces are double-sided, with each side distinct in some way from the other. Each side designates ownership of that pieces to a certain player when face-up. In Reversi Mode, play begins with the players taking turns placing pieces into the central six hexagons until they are full; in Othello mode, the central six hexagons are pre-filled with alternating Black and White discs. Then players may place their pieces next to an opponent's piece, as long as a straight line can be drawn between the new piece and an existing piece belonging to that player that goes through the opponent's piece. The opponent's pieces between the new piece and the old piece are then flipped and now belong to the player who just played. If a player cannot make a legal move, they pass. Play continues until the board is full or neither player can make a legal move. The player with the most pieces on the board wins. The pieces are placed on the board.

Construct a Ludii game based on the following description
Marelle Quadruple is an alignment game played in nineteenth century France.5x5 intersecting lines, with diagonals in the quadrants. Five pieces per player. Players alternate turns placing a piece on the board. Once all of the pieces are placed on the board, players alternate turns moving a piece to an empty adjacent spot on the board. The player who places all five of their pieces in a line wins. 
(game "Marelle Quadruple"
    (players 2) 
    (equipment {
        ("AlquerqueBoard" 5 5)
        (hand Each)
        (piece "Marker" Each "StepToEmpty")
    }) 
    (rules 
        (start (place "Marker" "Hand" count:5))
        
        phases:{
        (phase "Placement"
            (play (move (from (handSite Mover)) (to (sites Empty))))
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        (end (if (is Line 5) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Moruba is a four-row mancala-style board game played in South Africa.4x12 board. Four counters in each hole. Players alternate turns sowing the counters from one hole in an anti-clockwise direction. When the counters fall into a hole in their inner row, the contents of the opponent's opposite inner row hole are captured, as are any in the opponent's corresponding outer row hole, but only if counters were captured from the inner row hole. The player who captures the most counters wins. 
(game "Moruba" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "Track1" "0,E,N1,W" loop:True P1)
            (track "Track2" "24,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "Track1")) 
        (regions "Home" P2 (sites Track "Track2")) 
        (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) 
        (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) 
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 4 to:(union (sites P1 "Home") (sites P2 "Home")))
        )
        
        (play
            (move Select
                (from (sites Mover "Home") if:(> (count at:(from)) 0))
                (then 
                    (sow
                        "Track"
                        owner:(mover)
                        if:(and { 
                            (is In (to) (sites Mover "Inner")) 
                            (> (count at:("OppositePit" (to))) 0) 
                        })
                        apply:(and
                            (fromTo 
                                (from ("OppositePit" (to))) 
                                (to (handSite Mover)) 
                                count:(count at:("OppositePit" (to)))
                            )
                            (if (> (count at:("OppositeOuterPit" (to))) 0) 
                                (fromTo 
                                    (from ("OppositeOuterPit" (to))) 
                                    (to (handSite Mover)) 
                                    count:(count at:("OppositeOuterPit" (to)))
                                )
                            )
                        )
                    )
                )
            )	 
        )
        
        (end ("MancalaByScoreWhen" (no Moves Mover)))
    )
)

Construct a Ludii game based on the following description
A Hamiltonian cycle is a closed loop on a graph, where every node of the graph is visited exactly once. The goal of this puzzle is to colour edges such that the coloured edges form a Hamiltonian cycle.Colour edges of the graph, by selecting them, until they form a path that passes through every vertex exactly once and returns to its starting point.
         
(game "Hamiltonian Maze" 
    (players 1)
    (equipment { 
        (board <Board:type> use:Vertex)   
    })
    
    (rules 
        (play 
            (move Add
                (to
                    Edge 
                    (sites Empty Edge)
                )
            )
        ) 
        
        (end {
            (if
                (is Path Edge Mover length:(exact (count Sites "Board")) closed:True) 
                (result Mover Win)
            )
            (if 
                (is Path Edge Mover length:(max (count Moves)) closed:True) 		 
                (result Mover Loss)
            )   
        })    
    )
)

Describe the mechanics of the following Ludii game
(game "Chonpa" 
    (players 4) 
    (equipment { 
        ("PachisiBoard" 
            {
            (track "TrackNormal1" "64,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,54,E1,N8" P1 directed:True)
            (track "TrackPaired1" "57,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,54,E1,N8" P1 directed:True)
            (track "TrackNormal2" "22,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E8" P2 directed:True)
            (track "TrackPaired2" "36,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E8" P2 directed:True)
            (track "TrackNormal3" "85,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S8" P3 directed:True)
            (track "TrackPaired3" "92,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S8" P3 directed:True)
            (track "TrackNormal4" "31,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W8" P4 directed:True)
            (track "TrackPaired4" "17,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W8" P4 directed:True)
            }
        )
        (dice d:4 faces:{1 2 5 6} num:3)
        (piece "Pawn" Each ("PieceMove" "TrackNormal" "TrackPaired"))
    }) 
    (rules 
        (start {
            (set Team 1 {P1 P3})
            (set Team 2 {P2 P4})
            
            
            (place Stack "Pawn1" (sites {61 64}))
            (place Stack "Pawn2" (sites {21 22}))
            (place Stack "Pawn3" (sites {85 88}))
            (place Stack "Pawn4" (sites {31 32}))
            
            
            (place Stack "Pawn1" (sites {54 57}) state:1)
            (place Stack "Pawn2" (sites {35 36}) state:1)
            (place Stack "Pawn3" (sites {95 92}) state:1)
            (place Stack "Pawn4" (sites {17 18}) state:1)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (if (can Move ("Move"))
                    ("Move") 
                    (move Pass 
                        (then (and
                                ("StoreMovePair" 0)
                                ("StorePreviousPipsUsed" 0)
                            )
                        )
                    )
                )
            )
        )
        
        (end (if ("AllPiecesOnCentre" TeamMover) (result TeamMover Win)))
    )
)
Chonpa is a race game similar to others played throughout South Asia. This version was played in the Citrakoot Dham area of India. Four 3x8 rectangles, arranged in a cross. No marked squares. Four players, each with four pieces, which are black, yellow, green, and red. Yellow seated at the bottom, red to their right, black to the right of red, green to the right of black. Green and red play on a team against black and yellow. Three four-sided rectangular dice, each marked 1, 2, 5, and 6. Pieces begin on the board, with one each in the sixth and seventh space of the central row of the player's arm, (counting from the top of the row), and in the seventh and eighth spaces of the left row of the arm belonging to the player to the right. The latter two pieces must move as a pair, I.e., they must always be moved together, and can only do so when doubles are thrown. The other two pieces belonging to a player may move singly. Throws may be split up as a player sees fit, but the value of one die must be used it its entirety by a piece. Pieces move around the board in an anti-clockwise direction until they reach their central row, at which point they move up the central row to the central spot. They must enter the central space by an exact throw. When a player moves all of their pieces to the center, they continue to throw the dice, and use these throws to move their partner's pieces. When all of the team's pieces reach the center, that team wins. 

Construct a Ludii game based on the following description
Kisolo is a four-row mancala-style game board played by the Luba, Lulua and Songye people in the Democratic Republic of Congo. The game is often played multiple times, the score being kept with a handful of feathers. The loser is given one of the feathers, who gives them back to the opponent upon winning a subsequent game.4x7 board. Play begins with three counters in each hole of the outer rows. Players pick up all of the counters in one hole and sow them anti-clockwise. Holes with single counters can be chosen for sowing. When the final counter is sown, the counters in the following hole are picked up and sowing continues with those counters. If this hole is empty, play ends. Captures are made from the player's inner row at the beginning of a turn or a subsequent sowing within a turn. Counters are captured when a player's inner row has occupied holes. Counters in the opponent's holes opposite a player's occupied holes are captured: either from both of the opponent's rows or only the inner row if the corresponding hole in the outer row is empty. If the inner row is empty but the outer row is occupied, there is no capture, and when both rows are occupied they both must be captured. Captures are also made on a subsequent sowing within a turn, in the same manner as above but from the hole the next sowing begins, i.e., the one following the hole in which the last seed of the previous sowing is made. Captured counters are placed in the player's outer row opposite the hole from which the capture was made. Game is won when the opponent's outer row is emptied. At the initial state 3 seeds are in each outer hole.
(game "Kisolo" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" "14,E,N1,W" loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))          
        (regions "Home" P2 (sites Track "TrackCCW2"))          
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom)))  
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top)))   
        (regions "Outer" P1 (difference (sites Track "TrackCCW1") (sites P1 "Inner"))) 
        (regions "Outer" P2 (difference (sites Track "TrackCCW2") (sites P2 "Inner"))) 
        (piece "Seed" Shared)
    }) 
    (rules 
        
        (start {
            <Start:rules>
        })
        
        (play
            (if (and (or (= 0 (count MovesThisTurn)) (is In 1 (sites Pending))) (!= 0 (count Sites in:(("InnerPitsWithPossibleCapture")))))
                (move Select
                    (from ("InnerPitsWithPossibleCapture"))
                    (then 
                        (and {
                            (fromTo 
                                (from ("OppositePit" (last To)))
                                (to ("InnerPit" (last To)))
                            )
                            (if (is Occupied ("OppositeOuterPit" (last To)))
                                (fromTo 
                                    (from ("OppositeOuterPit" (last To)))
                                    (to ("InnerPit" (last To)))
                                )
                            )
                            (moveAgain)
                            }
                            (then
                                (if (!= 0 (count Sites in:(("InnerPitsWithPossibleCapture"))))
                                    (set Pending 1)
                                )
                            )
                        )
                    )
                )
                (move Select
                    (from 
                        (if (and (is In 2 (sites Pending)) ("SameTurn")) 
                            (sites {("NextHole" "LastHole")})
                            (sites Mover "Home") 
                        )
                        if:(> (count at:(from)) 0)
                    )
                    (then 
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (is Occupied ("NextHole" (to)))
                                (and { 
                                    (if (and (is In ("NextHole" (to)) (sites Mover "Inner")) (is Occupied ("OppositePit" ("NextHole" (to)))))
                                        (and
                                            (fromTo 
                                                (from ("OppositePit" ("NextHole" (to))))
                                                (to ("InnerPit" ("NextHole" (to))))
                                            )
                                            (if (is Occupied ("OppositeOuterPit" ("NextHole" (to))))
                                                (fromTo 
                                                    (from ("OppositeOuterPit" ("NextHole" (to))))
                                                    (to ("InnerPit" ("NextHole" (to))))
                                                )
                                            )		
                                        )
                                    )
                                    (moveAgain)
                                    (set Pending 2)
                                })
                            )
                        )
                    )
                )
            )
        )
        
        (end 
            (forEach Player
                if:("EmptyOuterRow" Player)
                (result Player Loss)
            )
        )
    )
)

Describe the mechanics of the following Ludii game
(game "20 Squares"
    (players 2) 
    (equipment { 
        (board 
            (merge 
                (rectangle 3 4) 
                (shift 0 1 (rectangle 1 12))
            )
            { 
            (track "Track1" "20,3,W,N1,E,End" P1 directed:True)
            (track "Track2" "21,12,W,S1,E,End" P2 directed:True)
            }
        )
        (dice facesByDie:{{1 2 3 4} {0 1}} num:2)
        (hand Each)
        (regions "Replay" (sites {"A1" "A3" "D2" "H2" "L2"}))
        
        (piece "UrPiece" Each
            (if ("IsEndTrack" ("MoveTo"))
                "RemoveAPiece"
                (if ("IsNotOffBoard" ("MoveTo"))	 			
                    (if (or
                            (is Empty ("MoveTo"))
                            (and 
                                (not ("IsFriendAt" ("MoveTo"))) 
                                (not (is In ("MoveTo") (sites "Replay")))
                            )
                        )
                        (move 
                            (from) 
                            (to 
                                ("MoveTo")
                                ("HittingCapture" (handSite (who at:(to))))
                            )
                            (then ("ReplayInMovingOn" (sites "Replay")))
                        )
                    )
                )
            )
        ) 
        
    }) 
    
    (rules 
        (start { 	
            (place "UrPiece1" (handSite P1) count:7)
            (place "UrPiece2" (handSite P2) count:7)
        })	
        
        (play ("RollMove" (or (forEach Piece) (forEach Piece container:(mover)))))
        
        (end ("EscapeWin"))
    )
)
20 Squares appears for the first time at the beginning of the second millennium BCE. It seems to be derived originally from the the Royal Game of Ur, becoming particularly popular in Iran, the Levant, Egypt, and Cyprus in addition to Mesopotamia during the Late Bronze Age (1700–1050 BCE), and continued being played in Mesopotamia into the Seleucid period, at least until the second century BCE.  It may have been called É Er-bé-et-ta, \Played on a 3x4 board with an extension of 8 in the middle row. Spaces are unmarked. Rules from Seleucid.

Describe the mechanics of the following Ludii game
(game "Selus (Massawa)" 
    (players 2) 
    (equipment { 
        (mancalaBoard 3 "Columns" store:None
            (track "Track" "0,E,N1,W2,17,W,S1,E2" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (union (sites Bottom) (difference (expand (sites Right) steps:2) (sites Top)))) 
        (regions P2 (union (sites Top) (difference (expand (sites Left) steps:2) (sites Bottom)))) 
        (map "LeftMostHole" {(pair P1 0) (pair P2 17)})
    }) 
    (rules 
        
        (start { 
            (set RememberValue "OwnedP1" (sites P1))
            (set RememberValue "OwnedP2" (sites P2))
            (set Count 3 to:(sites Track))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from 
                            (if (and (not (is Pending)) ("SameTurn"))
                                ("LastHoleSowed") 
                                ("OwnedHoles") 
                            )
                            if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))
                        )
                        
                        (then
                            (sow
                                apply:(if (< 1 (count at:(to)))
                                    (if (and (!= (mapEntry "LeftMostHole" Mover) (to)) (!= 0 (state at:(to))))
                                        (and {
                                            (if (or (= (mover) (state at:(to))) (= (mapEntry "LeftMostHole" Next) (to))) 
                                                (and
                                                    (moveAgain)
                                                    (set Pending)
                                                )
                                            )
                                            (fromTo
                                                (from (to))
                                                (to (handSite Mover))
                                                count:2
                                            )
                                            (set State at:(to) (state at:(to)))
                                        })
                                        (if (and {(< 2 (count Turns)) (= 0 (state at:(to))) (= 4 (count at:(to))) })
                                            (set State at:(to) (mover))	
                                            (moveAgain)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OnlyPiecesInMarked")
                            (and { 
                                (forEach Site ("SitesMarkedBy" 1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site ("SitesMarkedBy" 2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 3 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 3 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to (if ("NoEmptyHoleRow") (sites Board) (sites Mover)) if:(is Empty (to)))
                        count:3
                        (then
                            ("RemmemberOwnedHoles" (last To))
                        )
                    )
                    (if (= 2 (count Cell at:(handSite Mover)))
                        (move
                            (from (handSite Mover))
                            (to (if ("NoEmptyHoleRow") (sites Board) (sites Mover)) if:(is Empty (to)))
                            count:2
                            (then
                                (and
                                    (fromTo
                                        (from (handSite Next))
                                        (to (last To))
                                        count:1
                                    )
                                    ("RemmemberOwnedHoles" (last To))
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        }
    )
)
Selus is a three-row mancala-style board game played in Eritrea. It involves the capture of holes, which acumulate coutners, but players may also capture from these holes when sowing ends in that hole.3x6 board, three counters per hole. Each player owns the row of holes closest to them, as well as the right half of the central row, with respect to their perspective. Sowing occurs from left to right in the player's complete row, right to left in the player's half of the central row, then continuing from right to left in the opponent's outer row, left to right in the opponent's holes in the central row, and then continuing as before into the player's outer row. Players sow from any of their holes, and when the final counter lands in an occupied hole, they pick up the contents and continue sowing. When the final counter falls into an empty hole, the turn ends. After the first turn, players may capture a hole when the final counter of a sowing falls into a hole containing three counters, increasing it to four. The counters in a captured hole cannot be sown. When a player drops their final counter into an occupied captured hole, two counters are captured from it. If the player captured counters from one of the holes that they had created, they begin sowing again from another of their holes, but if the capture was from a hole captured by the opponent, the turn ends. The leftmost holes in each player's row are special: a player may under no circumstance capture counters from this hole in their row, but may do so from the opponent's, gaining another turn when they do so. Play continues until all of the counters are captured or all of the counters are accumulated in captured holes. A new round begins. Players then collect the counters in their captured holes. They count their takings by filling their holes with three counters each as in the beginning, and the player would own every hole they could fill with three counters. If the player has two counters remaining, they also gain another hole and the opponent surrenders their extra counter. Play continues until one player cannot fill any holes. 

Construct a Ludii game based on the following description
Pong Hau K'i is a blocking game documented during the nineteenth century East Asia, but medieval graffiti suggests that it may be even older.Pieces begin on opposite sides of the square. Players take turns moving the piece to an empty spot either orthogonally or diagonally, but one orthogonal direction is forbidden. The player who blocks the other player from being able to move wins. The piece are already placed on the board.
(game "Pong Hau K'i" 
    (players 2) 
    (equipment { 
        (board 
            (add
                (remove
                    ("AlquerqueGraph" 3 3)
                    vertices:{1 3 5 7}
                )
                edges:{{3 0} {0 1} {1 4}}
            )
            use:Vertex
        )
        (hand Each)
        (piece "Disc" Each "StepToEmpty")
    }) 
    
    (rules 
        (start <Rules:start>)
        <Rules:play>
        (end ("NoMoves" Loss)) 
    )
)

Describe the mechanics of the following Ludii game
(game "Buttons And Lights" 
    (players 1) 
    (equipment { 
        (board (rectangle 2 3)) 
        (piece "Light" Shared)
    }) 
    (rules
        (start (place "Light" (sites Top)))
        (play
            (move Select 
                (from (sites Bottom))
                (then
                    (if ("FirstButton")
                        ("ToggleLight")
                        (if ("SecondButton")
                            ("SwapTwoFirstLights")
                            ("SwapTwoLastLights")
                        )
                    )
                )
            )
        )
        (end { 
            (if (all Sites (sites Top) if:("LightOn")) (result Mover Win))
            (if (= 4 (counter)) (result Mover Loss))
        })
    )
)
Buttons And Lights is a planning puzzle.Three buttons and three lights. The first button toggles the first light. The second button interchanges first and second lights. The third button interchanges the second and third lights. All lights initially off. The goal is to get them all on. The game terminates when all three lights are on or after 6 steps, whichever comes first. 

Construct a Ludii game based on the following description
Çrand is a capturing game played in Mauritania. It is generally played in the sand with camel droppings and sticks as playing pieces. 9x9 intersecting lines, with diagonals drawn in the large square. Forty pieces per player, arranged on the points closest to the player and to the right of the central spot, with the central spot remaining empty. Players alternate turns moving their pieces forward along the lines of the board. They cannot move sideways or backwards, except to capture. A piece may capture an adjacent opponent's piece by hopping over it to an empty spot immediately on the opposite side of the opponent's piece, along the lines of the board. When a player's piece reaches the line on the opposite side of the board from which it started, it is promoted to Sultan, and it may move in all directions along the lines of the board and over any unobstructed distance. The player who captures all of the opponent's pieces wins.
         
(game "Crand"
    ("TwoPlayersNorthSouth")
    (equipment { 
        (board 
            (add
                (square 9)
                edges:{
                {0 10} {10 20} {20 30} {30 40} {40 50} {50 60} {60 70} {70 80}
                {72 64} {64 56} {56 48} {48 40} {40 32} {32 24} {16 24} {16 8}
                }
            )
            use:Vertex
        )
        (piece "Counter" Each
            (or
                ("StepToEmpty" (difference Forwards Diagonal))	
                "HopCapture"
                (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
            )
        )
        (piece "DoubleCounter" Each
            (or
                (move Slide)	
                "HopCapture"
            )		
        )
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    })
    (rules 
        (start {
            (place "Counter1" (union (sites {41..44}) (expand (sites Bottom) steps:3)))
            (place "Counter2" (union (sites {36..39}) (expand (sites Top) steps:3)))
        })
        (play (forEach Piece))
        (end ("CaptureAll" Next))
    )
)

Construct a Ludii game based on the following description
Set Dilth' is a race game played by White Mountain Apache women of Arizona. While it is similar to other race games in the region, in this game players must circle the board three times in order to win.Forty stones, arranged in a circle, with a larger gap after every tenth stone. The gaps between the stones are the playing spaces. Two to four players. One stick per player. Three sticks, each with one flat marked side and one round side, used as dice. The throws are as follows: one marked side up = 2; two marked sides up = 3; all marked sides up = 5; no marked sides up =10. Throws of 10 grant the player another throw. Each player starts at one of the larger gaps, and any players facing each other play on a team. Teams play in opposite directions: The player starting from the left or right space moves in a clockwise direction; the player(s) sitting at the top or bottom play anticlockwise). When a player's piece moves past or onto the space occupied by a piece belonging to the opposing team, the opposing team's piece is sent back to the starting space. The first team to circle the board three times wins.  The game has 2 players.
(game "Set Dilth'"
    (players <Player:num>)
    (equipment {
        ("FortyStonesWithFourGapsBoard"
            <Player:track>
        )
        (regions "AllSites" (sites Board))
        (map "Throw" {(pair 0 10) (pair 1 2) (pair 2 3) (pair 3 5)})
        (map "Start" {(pair 1 37) (pair 2 38) (pair 3 39) (pair 4 36)})
        (piece "Stick" Each ("Move"))
        ("StickDice" 3)
    })
    (rules 
        <Player:start>
        (play 
            ("RollMove" 
                (forEach Piece)
                (then 
                    (do
                        (if ("MadeACompleteCircuit") 
                            (addScore Mover 1) 
                            (then 
                                (if (= (score Mover) 3) 
                                    (remove (last To))
                                )
                            )
                        )
                        next:(if (and (!= 3 (score Mover)) (= 10 ("ThrowValue"))) (moveAgain))
                    )
                )
            )
        )
        (end (if (>= (score Mover) 4) (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Buf de Baldriac is a European Tables game played in Spain in the thirteenth century. It is recorded in Alfonso X's Libro de los Juegos.Played on a Tables board with sockets for the pieces instead of points. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die, another piece the value on another die, and another piece the value on the final die, by moving one piece the value of two of the die subsequently, and a second piece the value of the remaining die, or one piece the value of each die subsequently. Pieces begin off the board. Players must enter all of their pieces onto one half of the board (one player entering in the quadrant to their right and the other player's entering into the quadrant on their left), according to the throws of the dice. Once a player has entered all of their pieces, they move through all of the quadrants of the board toward the quadrant where the opponent entered their pieces. A piece landing on a space with a single opponent's piece sends the opponent's piece back to start, and it must be reentered. Once players enter all of their pieces into the final quadrant, they may bear off their pieces. They can do so by rolling a 6 to move from the sixth point, and so on down to 1. Throughout the game, a player must use the maximum number of moves presented by the dice. The first player to remove all of their pieces wins.
         
(game "Buffa de Baldrac"
    (players 2)
    (equipment {
        ("TableBoard" ("TableTracksOpposite" End))
        (dice d:6 num:3)
        (piece "Disc" Each
            (or
                (forEach Die 
                    combined:True 
                    if:(and
                        ("DieNotUsed")
                        (<= 0 ("NextSiteFrom" (from) (pips)))
                    )
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NoEnemyOrOnlyOne" (to))
                            ("HittingCapture" (handSite Next))
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
                (if ("AllPiecesInLastQuadrant")
                    (forEach Die 
                        combined:True 
                        if:(and
                            ("DieNotUsed")
                            ("IsEndTrack" ("NextSiteFrom" (from) (pips)))
                        )
                        (move Remove (from))
                        (then ("ReplayNotAllDiceUsed"))
                    )
                )
            )
        )
        (regions "FirstQuadrant" P1 (sites {0..5}))
        (regions "FirstQuadrant" P2 (sites {12..17}))
        (regions "LastQuadrant" P1 (sites {12..17}))
        (regions "LastQuadrant" P2 (sites {0..5}))
        (map "StartTrack" {(pair P1 0) (pair P2 12)})
        (hand Each)
    })
    (rules 
        (start {
            (place Stack "Disc1" (handSite P1) count:15)
            (place Stack "Disc2" (handSite P2) count:15)
        })
        
        (play 
            (max Moves 
                ("RollEachNewTurnMove"
                    (if (is Occupied (handSite Mover))
                        (forEach Die 
                            combined:True 
                            if:(and
                                ("DieNotUsed")
                                (is In ("NextSiteFrom" (mapEntry "StartTrack" (mover)) (- (pips) 1)) (sites Mover "FirstQuadrant"))
                            )
                            (move 
                                (from (handSite Mover))
                                (to 
                                    ("NextSiteFrom" (mapEntry "StartTrack" (mover)) (- (pips) 1))
                                    if:("NoEnemyOrOnlyOne" (to))
                                )
                            )
                            (then ("ReplayNotAllDiceUsed"))
                        )
                        (forEach Piece top:True)
                    )
                )
            )
        )
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Shiva is a game of alignment played by the Tiv people of Nigeria. It's a rare game of alignment that only allows rows of no more than three pieces.5x6 or 6x6 board. Twelve pieces per player. Players take turns placing pieces on the board. Once all the pieces are on the board, players may move one piece orthogonally one space during their turn. Players cannot create a line of more than three in an orthogonal direction, and cannot make a line of three during the placement phase. If three pieces are in an orthogonal line, they cannot be moved again. If a player makes three rows before the opponent makes one, it is an automatic win.
         The game is played on a 5x6 board.
(game "Shiva"
    (players 2)
    (equipment {
        (board (rectangle <Board:size>))
        (hand Each)
        (piece "Marker" Each
            (if 
                (not (is Line 3 Orthogonal through:(from)))
                ("StepToEmpty" Orthogonal (then 
                        (if (is Line 3 Orthogonal)
                            (if ("IsOffBoard" (value Player Mover))
                                (set Value Mover 1)
                                (set Value Mover (+ (value Player Mover) 1))
                            )
                        )
                    )
                )
            )
        )
    })
    (rules
        (start (place "Marker" "Hand" count:12))
        
        phases:{
        (phase "Placement"
            (play 
                (do 
                    (move (from (handSite Mover)) (to (sites Empty))) 
                    ifAfterwards:(not (is Line 3 Orthogonal))
                )
            )
            (nextPhase (and ("HandEmpty" P1) ("HandEmpty" P2)) "Movement")
        )
        
        (phase "Movement"
            (play 
                (do (forEach Piece)
                    ifAfterwards:(not (is Line 4 Orthogonal))
                )
            )
        )
        }
        
        (end (if (= (value Player Mover) 3) (result Mover Win)))
    )	
)

Construct a Ludii game based on the following description
Main Chator is a replacement capture game played throughout Malaysia and Indonesia. This version is played by the Batak people of Sumatra, which has a unique potential first move for the king piece. 8x8 board, with diagonals in every square. Pieces have special moves, as follows: Raja (king), moves one square in any direction, but on the first move, it may jump two squares or move as a knight, with the exception that it cannot jump two squares diagonally; Mantri (minister), moves orthogonally or diagonally any number of spaces; Gajah (x2); move diagonally any distance; Kuda (horse) x2, moves orthogonally one space then diagonal one space from there, jumping over any intervening pieces; Ter/Chemor (chariot) x2, moves orthogonally any distance; Bídaq (pawn) x8: moves one square forward or one square forward diagonally to capture. May move two spaces forward orthogonally if it is that piece's first move. Upon reaching the opposite edge of the board, the Bídaq moves in the opposite direction, reversing again if it reaches the opposite edge.  The Mantri is placed to the right of the Raja at the beginning of play. Castling occurs in two moves, the rook moving to the king and then the king jumping over the rook. Pieces are captured by moving onto a space occupied by an opponent's piece. If the Raja can be captured on its next turn, it is in check. The Raja cannot be in check at the end of its turn. When this is unavoidable, it is checkmate and the opponent wins. A stalemate is considered a draw. 
(game "Main Chator (Batak)"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (square 8))
        (piece "King_noCross"
            (or
                ("StepToNotFriend")	
                (if (not ("KingMovedBefore" (from)))
                    (or {
                        (move Hop
                            Orthogonal
                            (between
                                (exact 2)
                                if:True
                            )
                            (to 
                                if:(not ("IsFriendAt" (to))) 
                                (apply 
                                    (if ("IsEnemyAt" (to))
                                        (remove 
                                            (to) 
                                        )
                                    )
                                )
                            ) 
                        )
                        ("LeapCapture" "KnightWalk")
                        (if (is In (from) ("KingSites"))
                            (or
                                (if (and {
                                        (is Empty (ahead (from) steps:2 W))
                                        ("IsPieceAt" "Rook" Mover (ahead (from) W))
                                        (not ("RookMovedBefore" (ahead (from) W)))
                                    })
                                    (move
                                        (from)
                                        (to (ahead (from) steps:2 W))
                                    )
                                )
                                (if (and {
                                        (is Empty (ahead (from) steps:2 E))
                                        ("IsPieceAt" "Rook" Mover (ahead (from) E))
                                        (not ("RookMovedBefore" (ahead (from) E)))
                                    })
                                    (move
                                        (from)
                                        (to (ahead (from) steps:2 E))
                                    )
                                )
                            )
                        )
                        }
                        (then ("RememberKingMoved" (last To)))
                    )
                )
            )
        )
        ("ChessRook" "Rook" ~
            (then
                (if (and 
                        (not ("RookMovedBefore" (last To)))
                        (not (is In (last To) ("SitesNextToKing")))
                    )
                    ("RememberRookMoved" (last To))
                )
            )
        )
        ("ChessBishop" "Bishop_noCross")
        ("ChessKnight" "Knight")
        (piece "Pawn"
            (or {
                (if (and (= 0 (state at:(last To))) (is In (from) (sites Start (piece (what at:(from))))))
                    ("DoubleStepForwardToEmpty")
                )
                ("StepToEmpty" (if (= 1 (state at:(from))) Backward Forward))
                ("StepToEnemy" (directions {FR FL}))
                }
                (then
                    (if (is In (last To) (union (sites Bottom) (sites Top))) 
                        (if (= 0 (state at:(last To)))
                            (set State at:(last To) 1)
                            (set State at:(last To) 2)
                        )
                    )
                )
            )
        ) 
        ("ChessQueen" "Queen")
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"E1") (place "King_noCross1" coord:"D1") 
            (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8") 
        })
        
        (play 
            (do
                (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        
        (end {
            ("Checkmate" "King_noCross")
            ("DrawIfNoMoves" Next)
        })
    )
)

Construct a Ludii game based on the following description
Shatranj is the name for a replacement capture game, played throughout West and South Asia for centuries. This version, played on a 12x12 board, was played in the nineteenth and early twentieth centuries in Punjab.12x12 board. 24 pieces per player. Pieces begin on the board in the following arrangement, and with the following movements: Outer row, from left corner: Rukh: moves orthogonally any distance; Ghora: moves orthogonally one space and then diagonally another space, jumping over the first space; Dahja: moves orthogonally any distance; Ratha: moves orthogonally any distance; Fil: moves diagonally any distance; Wazir: moves diagonally or orthogonally any distance; Padshah: moves one space in any direction;  Fil, Ratha, Dahja, Ghora, Rukh. In the second row are twelve Paidal: moves one square forward orthogonally or one diagonally to capture. Players alternate turns moving a piece to a space on the board. If one of the opponent's pieces is on the space to which a player moves their piece, the opponent's piece is captured. If the Padshah can be captured on the opponent's next turn, it is in check. The Padshah cannot remain in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins.
         
(game "Shatranj (12x12)"
    (players 2) 
    (equipment { 
        (board (square 12)) 
        ("ChessPawn" "Pawn")
        ("ChessRook" "Rook")
        ("ChessRook" "Commoner")
        ("ChessRook" "Wazir")
        ("ChessKing" "King_noCross")
        ("ChessBishop" "Bishop_noCross")
        ("ChessKnight" "Knight")
        ("ChessQueen" "Queen")
    })
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 10))
            
            (place "Rook1" {"A1" "L1"}) (place "Knight1" {"B1" "K1"}) (place "Commoner1" {"C1" "J1"}) (place "Wazir1" {"D1" "I1"}) 
            (place "Bishop_noCross1" {"E1" "H1"}) (place "Queen1" coord:"F1") (place "King_noCross1" coord:"G1") 
            
            (place "Rook2" {"A12" "L12"}) (place "Knight2" {"B12" "K12"}) (place "Commoner2" {"C12" "J12"}) (place "Wazir2" {"D12" "I12"}) 
            (place "Bishop_noCross2" {"E12" "H12"}) (place "Queen2" coord:"G12") (place "King_noCross2" coord:"F12") 
        })
        
        (play 
            (do (forEach Piece) ifAfterwards:(not ("IsInCheck" "King_noCross" Mover)))
        )
        
        (end ("Checkmate" "King_noCross"))
    )
)

Describe the mechanics of the following Ludii game
(game "Saxun" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        ("ChessPawn" "Pawn") 
        ("ChessRook" "Rook") 
        ("ChessKing" "King_noCross") 
        ("ChessBishop" "Bishop_noCross") 
        ("ChessKnight" "Knight") 
        ("ChessQueen" "Queen") 
    }) 
    (rules 
        (start { 
            (place "Pawn1" {"F4" "G4" "H4" "B3" "C3" "D3" "E3" "A2"})
            (place "Pawn2" {"H7" "H6" "G6" "F6" "E6" "A5" "B5" "C5"})
            (place "Rook1" {"C2" "D1"}) (place "Knight1" {"B1" "H2"}) (place "Bishop_noCross1" {"E1" "F1"}) (place "Queen1" coord:"D2") (place "King_noCross1" coord:"C1") 
            (place "Rook2" {"C7" "B8"}) (place "Knight2" {"A7" "H8"}) (place "Bishop_noCross2" {"F7" "G7"}) (place "Queen2" coord:"B7") (place "King_noCross2" coord:"C8") 
        })
        
        (play 
            (do (forEach Piece)
                ifAfterwards:(not ("IsInCheck" "King_noCross" Mover))
            )
        )
        
        (end ("Checkmate" "King_noCross"))
    )
)
Sáxun is a game played by the Aleut peoples in what is now Alaska. Judging from the names of the pieces, it appears that the game was adopted from the Russians. It employs a unique starting position.8x8 checkered board. The pieces move as follows: Álix' (\ 

Describe the mechanics of the following Ludii game
(game "Yavalanchor" 
    (players 2) 
    (equipment { 
        (board (rotate 90 (hex 5))) 
        (piece "Marker" Each)
        (piece "Marker" Shared)
        (hand Shared)
    }) 
    
    (rules 
        (meta (swap))
        (start (place "Marker" (handSite Shared)))
        (play 
            (or
                (move Add 
                    (to 
                        (sites Around 
                            (sites Occupied by:Shared component:"Marker") 
                            if:(is Empty (to))
                        )
                    )
                ) 
                (move 
                    (from (handSite Shared)) 
                    (to (sites Empty)) 
                    copy:True
                )
            )
        )
        (end 
            (forEach Player
                if:(and 
                    (or 
                        (= (what at:(last To)) (id "Marker" Player)) 
                        (= (what at:(last To)) (id "Marker")) 
                    )
                    (is Line 5 whats:{(id "Marker" Player) (id "Marker")})
                )
                (result Player Win)
            )
        )
    )
)
Yavanalanchor is a Yavalath derivative invented by Néstor Romeral Andrés in 2012.Two players play, with white and black pieces, with neutral red pieces as well. Players take turns placing either a red counters on an empty space or a counter of their color on a space adjacent to a red one. Play continues until one player creates five in a row with only their color and red. The player that does so first wins. 

Construct a Ludii game based on the following description
Kakuro is a mathematical logic puzzle. Played on any size grid (usually 16x16), some of the squares are blacked out, leaving white squares in which play occurs.Each row and column is assigned a number. The player then places a number from 1 to 9 in each square so that it adds up to the assigned number in each row and column. Numbers cannot be duplicated in any row or column. 
(game "Kakuro" 
    (players 1) 
    (equipment {
        (board (rectangle <Challenge:size>) (values Cell (range 1 9)))
        (hints { <Challenge:hints> })
        (regions HintRegions) 
    }) 
    (rules 
        (play
            (satisfy {
                (is Sum (hint))
                (all Different)
            })
        )
        (end (if (is Solved) (result P1 Win)))
    )
)

Describe the mechanics of the following Ludii game
(game "Shui Yen Ho-Shang" 
    (players 2)
    (equipment {
        (board 
            (merge 
                (rotate 45 (shift 1.5 4.2 (square 2 diagonals:Solid)))
                (square 5 diagonals:Alternating)
            )
            use:Vertex
        )
        (piece "Marker" P1 "StepToEmpty")
        (piece "Marker" P2 
            (move Step 
                (to if:(is Empty (to)))
                (then 
                    ("InterveneCapture")
                )
            )
        )
    })
    
    (rules
        (start {
            (place "Marker2" coord:"C5")
            (place "Marker1" (difference (sites Outer) (sites {"B6" "C7" "D6"})))
        })
        (play (forEach Piece))
        (end {
            (if (no Pieces P1) (result P2 Win))
            (if (and (no Moves P2) (is In (where "Marker" P2) (sites {"C7"}))) (result P1 Win))
        })
    )
)
Shui Yen Ho-Shang is a hunt game from Sichuan, China. One player plays as a monk attempting to collect water, the other as the water trying to \5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a diamond intersects with the central point of that side, with diagonals drawn in the diamond. One player plays as the monk, placed at the intersection of the diamond and the main board. The other player plays as fifteen water pieces, placed on each point along the perimeter of the main board. Players take turns moving their pieces to one adjacent point following the lines on the board. The monk may capture two water pieces by moving to an empty space between two water pieces. The goal of the water pieces is to trap the monk on the far point of the diamond. The monk wins by capturing all of the water. 

Construct a Ludii game based on the following description
Dubblets is a Tables game played in early Modern England. Players begin with their pieces stacked on a Backgammon board, and must unstack them before bearing them off.2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Play occurs only in two quadrants of the board, opposite one another, a player's pieces only leaving their quadrant to bear off. Two pieces are stacked each on the first three points, and three are stacked in the second three points. Players use throws to unstack pieces on their points, unstacking one piece per die which corresponds to that point. Doubles allow the player to unstack or bear off a number of pieces equal to the total number of the throw.  When all of the pieces are unstacked, that player may begin bearing their pieces off. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The first player to bear off all their pieces wins.  
(game "Dubblets"
    (players 2)
    (equipment {
        ("TableBoard" 
            {
            (track "Track1" {0..5} P1 directed:True)
            (track "Track2" {12..17} P2 directed:True)
            }	
        )
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" ("NextSiteOnTrack" (pips)))
                    ("BearOff" (from))
                    (move 
                        (from) 
                        (to ("NextSiteOnTrack" (pips)))
                    )
                )
            )		
        )
        (hand Each)
        (map "StartTrack" {(pair P1 0) (pair P2 12)})
    })
    (rules 
        (start {
            (place Stack "Disc1" (sites {0..2}) count:2)
            (place Stack "Disc1" (sites {3..5}) count:3)
            (place Stack "Disc2" (sites {12..14}) count:2)
            (place Stack "Disc2" (sites {15..17}) count:3)
        })
        phases:{
        (phase "UnStacking" 
            (play 
                ("RollEachNewTurnMove"
                    (if (or (< 0 (var "Double")) (all DiceEqual)) 
                        (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips)))
                            next:(forEach Site (sites Occupied by:Mover)
                                (if ("PieceFullStacked" (site))
                                    (move Select
                                        (from (site))
                                        (then (if (= 3 (size Stack at:(last To))) ("UnstackHalf") ("UnstackFull")))
                                    )
                                    (if ("PieceHalfStacked" (site))
                                        (move Select
                                            (from (site))
                                            (then ("UnstackFull"))
                                        )
                                    )
                                )
                                (then
                                    (and
                                        (if (< 1 (var "Double")) (moveAgain))
                                        (set Var "Double" (- (var "Double") 1))
                                    )
                                )
                            )
                        )
                        (forEach Die 
                            if:("DieNotUsed")
                            (or
                                (if ("PieceFullStacked" "SiteToSelect")
                                    (move Select (from ("SiteToSelect"))
                                        (then 
                                            (and 
                                                (if (= 3 (size Stack at:(last To))) ("UnstackHalf") ("UnstackFull"))
                                                ("ReplayNotAllDiceUsed")
                                            )
                                        )
                                    )
                                )
                                (if ("PieceHalfStacked" "SiteToSelect")
                                    (move Select (from ("SiteToSelect"))
                                        (then 
                                            (and 
                                                ("UnstackFull")
                                                ("ReplayNotAllDiceUsed")
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ) 
            (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not ("PieceStacked" (site)))) "BearingOff")
        )
        (phase "BearingOff" 
            (play 
                (do 
                    (if ("NewTurn") (roll))
                    next:(if (or (< 0 (var "Double")) (all DiceEqual)) 
                        (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips)))
                            next:(forEach Site (sites Occupied by:Mover)
                                ("BearOff" (site))
                                (then
                                    (and
                                        (if (< 1 (var "Double")) (moveAgain))
                                        (set Var "Double" (- (var "Double") 1))
                                    )
                                )
                            )
                        )
                        (forEach Piece top:True)
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
            (end ("EscapeWin"))
        )
        }
    )
)

Construct a Ludii game based on the following description
Leyla is a two-row mancala-style game board played near Jigjiga, Ethiopia. It involves the capturing of holes, into which counters accumulate.2x6 board. Four counters in each hole. Sowing occurs in a clockwise direction. When the final counter of a sowing lands in an occupied hole, the contents of the hole are picked up and sowing continues. If this occupied hole is in the opponent's row and is made to contain four with the final counter, this hole and the one opposite it are captured, the counters remaining in the holes. Players may not sow from these holes. If on a subsequent turn the final counter of a sowing falls into an opponent's captured hole, one counter from the hole is captured, as well as the final counter of the sowing, and the turn ends. When the final counter of a sowing lands in an empty hole, the turn ends. Play continues until one of the players can no longer move, the opponent taking any remaining counters in free holes on their side of the board and each player taking the counters in their captured holes. A new round begins. Players attempt to fill their holes with four counters each. If a player has two extra counters, they may loan them to the other player, to be repaid when they can in a subsequent round. If a player has one extra counter, it is surrendered to the opponent. The player with more counter would only fill as many hole as the opponent is able to fill, retaining their extra counters for future rounds. Play continues until one player cannot fill any holes. 
(game "Leyla" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "5,W,N,E" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (hand Each)
    }) 
    (rules 
        
        (start (set Count 4 to:(sites Track)))
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select
                        (from
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                (sites Mover) 
                            )
                            if:(and (is Occupied (from)) (= 0 (state at:(from))))
                        )
                        (then
                            (sow
                                apply:(if (!= 0 (state at:(to)))
                                    (if (= (next) (state at:(to)))
                                        (and
                                            (fromTo
                                                (from (to))
                                                (to (handSite Mover))
                                                count:(min 2 (count at:(to)))
                                            )
                                            (set State at:(to) (next))
                                        )
                                    )
                                    (if (and 
                                            (is In (to) (sites Next))
                                            (= 4 (count at:(to)))
                                        )
                                        (and
                                            (set State at:(to) (mover))
                                            (set State at:("OppositePitTwoRows" (to)) (mover))
                                        )
                                        (if (< 1 (count at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("APlayerCanNotMove")
                            (and { 
                                (forEach Site 
                                    (sites P1)
                                    (if (= 0 (state at:(site)))
                                        (fromTo
                                            (from (site))
                                            (to (handSite P1))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site 
                                    (sites P2)
                                    (if (= 0 (state at:(site)))
                                        (fromTo
                                            (from (site))
                                            (to (handSite P2))
                                            count:(count at:(site))
                                        )
                                    )
                                )
                                (forEach Site 
                                    (sites Board)
                                    (if (= (state at:(site)) P1)
                                        (and
                                            (fromTo
                                                (from (site))
                                                (to (handSite P1))
                                                count:(count at:(site))
                                            )
                                            (set State at:(site) 0)
                                        )
                                        (if (= (state at:(site)) P2)
                                            (and
                                                (fromTo
                                                    (from (site))
                                                    (to (handSite P2))
                                                    count:(count at:(site))
                                                )
                                                (set State at:(site) 0)
                                            )
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )	
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 3 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
            
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 4 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to (sites Mover) if:(is Empty (to)))
                        count:4
                        (then
                            (if (= 1 (count Cell at:(handSite Mover)))
                                (fromTo
                                    (from (handSite Mover))
                                    (to (handSite Next))
                                    count:1
                                )
                                (if (= 2 (count Cell at:(handSite Mover)))
                                    (fromTo
                                        (from (handSite Next))
                                        (to (handSite Mover))
                                        count:2
                                    )
                                    (if (= 3 (count Cell at:(handSite Mover)))
                                        (fromTo
                                            (from (handSite Next))
                                            (to (handSite Mover))
                                            count:1
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase 
                (and
                    (= 
                        (count Sites in:(forEach (sites P1) if:(is Occupied (site)))) 
                        (count Sites in:(forEach (sites P2) if:(is Occupied (site))))
                    )
                    (or
                        (is Empty (handSite P1))
                        (is Empty (handSite P2))
                    )
                )		
            "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Challis Gutia (the game of forty pieces) is a game of leaping captures played in India.9x9 intersecting lines forming a square. Forty pieces per player, lined up on the intersections on the rows closest to them, and the right half of the central line. Players alternate turns moving pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to the empty spot immediately on the opposite side of it, following the lines of the board. Multiple captures are allowed. The player who captures all of the opponent's pieces wins. 
(game "Challis Ghutia" 
    (players 2) 
    (equipment { 
        (board
            (square 9)
            use:Vertex
        )
        (piece "Marker" Each 
            (or 
                ("HopSequenceCapture")
                ("StepToEmpty")
            )
        )
    }) 
    (rules 
        (start {
            (place "Marker1" (union (expand (sites Bottom) steps:3) (sites {"F5" "G5" "H5" "I5"})))
            (place "Marker2" (union (expand (sites Top) steps:3) (sites {"A5" "B5" "C5" "D5"})))
        })
        (play 
            (if "SameTurn"
                (or
                    ("HopSequenceCaptureAgain")	
                    (move Pass)
                )
                (forEach Piece)
            )
        )
        
        (end ("CaptureAll" Next))
    )
)

Describe the mechanics of the following Ludii game
(game "Jacquet" 
    (players 2) 
    (equipment { 
        ("BackgammonBoard" "BackgammonTracksSameDirectionOppositeCornersWithBars") 
        (dice num:2)
        (piece "Disc" Each) 
        (map {(pair 1 6) (pair 2 19)}) 
        (regions "Home" P1 { 13..18 }) 
        (regions "Home" P2 { 12..7 }) 
        (regions "OppositeQuadrant" P1 { 0..5 }) 
        (regions "OppositeQuadrant" P2 { 20..25 }) 
    })
    
    (rules
        (start { 
            (place Stack "Disc1" 13 count:15)
            (place Stack "Disc2" 12 count:15)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (forEach Die
                    replayDouble:True 
                    if:("DieNotUsed")
                    (forEach Site
                        (sites Occupied by:Mover)
                        (if (and ("CanEscape" ("NextSiteFrom" (site))) ("AllPieceInOpponentSide"))
                            ("RemoveAPiece")
                            (if (if (!= (site) "StartPos")
                                    True
                                    ("PieceInOpponentQuadrantOrNoPieceInTheBoard")
                                )
                                (move 
                                    (from (site))
                                    (to ("NextSiteFrom" (site))
                                        if:("NoEnemyOrOnlyOne" (to))
                                        ("HittingCapture" ("Bar" (next))) 
                                    )
                                )
                            )
                        )
                    )
                    (then ("ReplayNotAllDiceUsed"))
                )
            )
        )
        
        (end 
            (if ("AllPieceEscaped")
                (result Mover Win)
            )
        )
    )
)
Jacquet is a European Tables game played in nineteenth century France.2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Pieces begin on the leftmost point on their opponent's side of the board. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When doubles are thrown, the player plays the throw twice. Each player progresses in a clockwise direction around the board, to bear off upon reaching the final point on the opponent's side of the board. One piece must reach the opposite quadrant of the board from where it entered before the player may place more than one piece on a point. When a piece lands on a point occupied by a single opponent's piece, the opponent's piece is removed from the board and must enter the board again. When all of the player's pieces have entered the opposite quadrant from the one in which they entered, they may begin to bear off. The first player to bear off all their pieces wins. 

Construct a Ludii game based on the following description
Gabata is a name that is widely used for different mancala-style games in the northern Horn of Africa. This game, played near Aksum, it is a three-row game.3x6 board. Play begins with three counters per hole. Each player owns the row closest to them and the right half of the central row. Sowing occurs in the following direction: from left to right in the player's full row, right to left in the player's half of the central row, proceeding to the opponent's full row and sowing right to left, then left to right in the opponent's part of the central row, then proceeding back to the player's full row and proceeding as before. Sowing always begins from a player's own holes. A player can not sow from their left hand hole in their main row unless it has more than three counters, unless there is no other option. When the last counter falls into an empty hole, the turn ends. If the last counter falls into an occupied hole, the contents of that hole are picked up and sowing continues. A hole is captured by dropping the last counter of a sowing into an opponent's hole which contains three counters, making it have four counters, and becomes a wegue. Captures cannot be made until after the original three counters placed in the holes at the beginning of the game have been moved. Once a wegue is created, the player cannot sow from it. When the final counter of a sowing lands in a wegue owned by the opponent, the player captures two counters from it. Play continues until all of the counters are captured or all of the counters are accumulated in wegue. A new round begins. Players then collect the counters in their captured holes. They count their takings by filling their holes with three counters each as in the beginning, and the player would own every hole they could fill with three counters. If the player has two counters remaining, they also gain another hole and the opponent surrenders their extra counter. At the end of play, if a player captures the opponent's single remaining hole as a wegue, the player captured three counters from it, leaving one for the opponent to continue to play. Play continues until one player cannot fill any holes. 
(game "Gabata (Aksum)" 
    (players 2) 
    (equipment { 
        (mancalaBoard 3 "Columns" store:None
            (track "Track" "0,E,N1,W2,17,W,S1,E2" loop:True)
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (union (sites Bottom) (intersection (sites Row 1) (expand (sites Right) steps:2)))) 
        (regions P2 (union (sites Top) (intersection (sites Row 1) (expand (sites Left) steps:2))))  
        (map "LeftMost" {(pair P1 0) (pair P2 17)})
    }) 
    (rules 
        
        (start { 
            (set Count 3 to:(sites Track))
            (set RememberValue "OwnedP1" (union (sites Bottom) (intersection (sites Row 1) (expand (sites Right) steps:2))))
            (set RememberValue "OwnedP2" (union (sites Top) (intersection (sites Row 1) (expand (sites Left) steps:2))))
        })
        
        phases:{
        (phase "Sowing" 
            (play
                (or {
                    (move Select
                        (from 
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(and {
                                (if (!= (from) (mapEntry "LeftMost" Mover))
                                    True
                                    (if ("SameTurn")
                                        True
                                        (or 
                                            (< 3 (count at:(from)))
                                            (no Pieces All in:(forEach (difference ("OwnedHoles") (mapEntry "LeftMost" Mover)) if:(= 0 (state at:(site)))))
                                        )
                                    )
                                )
                                (< 0 (count at:(from))) 
                                (= 0 (state at:(from)))
                            })
                        )
                        (then
                            (sow
                                apply:(if (and { 
                                        (= 0 (state at:(to))) 
                                        (= 4 (count at:(to)))
                                        (is In (to) ("OpponentOwnedHoles"))
                                    })
                                    (set State at:(to) (mover))
                                    (if (< 1 (count at:(to)))
                                        (if (= 0 (state at:(to)))
                                            (and {
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            })
                                            (if (!= (mover) (state at:(to)))
                                                (and {
                                                    (fromTo
                                                        (from (to))
                                                        (to (handSite Mover))
                                                        count:(min 2 (count at:(to)))
                                                    )
                                                    (set State at:(to) (state at:(to)))
                                                })
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("OnlyPiecesInMarked")
                            (and { 
                                (forEach Site ("SitesMarkedBy" 1)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P1))
                                        count:(count at:(site))
                                    )
                                )
                                (forEach Site ("SitesMarkedBy" 2)
                                    (fromTo
                                        (from (site))
                                        (to (handSite P2))
                                        count:(count at:(site))
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (>= 1 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (>= 1 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 3 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:3
                        (then
                            (and {
                                ("RemmemberOwnedHoles" (last To))
                                (if (<= 3 (count Cell at:(handSite Mover)))
                                    (moveAgain)
                                    (if (= 2 (count Cell at:(handSite Mover)))
                                        (and {
                                            (fromTo 
                                                (from (handSite Mover))
                                                (to ("LeftMostEmpty"))
                                                count:2
                                            )
                                            (fromTo 
                                                (from (handSite Next))
                                                (to ("LeftMostEmpty"))
                                                count:1
                                            )
                                            ("RemmemberOwnedHoles" ("LeftMostEmpty"))
                                        })
                                    )
                                )
                            })
                        )
                    )
                )
            )
            (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Gabata is a term used for many mancala-style games in the Horn of Africa. This two-row version is played in the Ansaba region of Eritrea, and employs the simultaneous beginning phase that is seen among several games in the region.2x6 board. Three counters in each hole. The players begin the game simultaneously sowing first from their rightmost hole, racing to be the first one to drop the last counter of a sowing into an empty hole. This player then begins the next phase where they alternate play. Sowing occurs in an anti-clockwise direction. When the final counter falls into an occupied hole, the contents of this hole are picked up and sowing continues. When the final counter lands into an empty hole in the row belonging to the player, the counters in the opposite hole belonging to the opponent are captured, and the counter that triggered the capture is moved to the following hole. This could trigger the further capture of more of the opponent's counters if the hole in which the counter is placed was empty and the opponent's opposite hole contains counters. If the hole is occupied, sowing continues. If the hole is empty and the opposite hole is unoccupied or it is one of the opponent's holes, sowing ends. When one player can no longer play because the holes on their side are empty, the opponent captures the remaining counters on the board. A new round begins. The losing player places three counters in each hole, beginning on the rightmost hole. If the player has remaining counters but cannot fill their holes with three, they must distribute the remainder to fill as many of the remaining holes as possible with at least one counter. The winning player from the previous round then matches this starting configuration, keeping any surplus for use in future rounds. Play continues until one player has one or zero counters, the opponent being the winner. 
(game "Gabata (Ansaba)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 "Columns" store:None
            (track "Track" "0,E,N,W" loop:True)
        )
        (piece "Seed" Shared)
        (regions P1 (sites Bottom)) 
        (regions P2 (sites Top)) 
        (hand Each)
        (map "LeftMost" {(pair P1 0) (pair P2 11)})
        (map "CorrespondingHoles" {(pair 0 11) (pair 1 10) (pair 2 9) (pair 3 8) (pair 4 7) (pair 5 6) (pair 6 5) (pair 7 4) (pair 8 3) (pair 9 2) (pair 10 1) (pair 11 0)})
    }) 
    (rules 
        
        (start (set Count 3 to:(sites Track)))
        
        phases:{
        (phase "Sowing"
            (play   
                (or {
                    (move Select 
                        (from 
                            (if 
                                ("SameTurn") 
                                "LastHoleSowed" 
                                (sites Mover) 
                            ) 
                            if:(> (count at:(from)) 0)
                        )
                        (then 
                            (sow
                                apply:(if (> (count at:(to)) 1)
                                    (moveAgain)
                                    (if (is In (to) (sites Mover))
                                        (if (!= 0 (count at:("OppositePit" (to))))
                                            (and
                                                (fromTo
                                                    (from ("OppositePit" (to)))
                                                    (to (handSite Mover))
                                                    count:(count at:("OppositePit" (to)))
                                                )
                                                (moveAgain)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then 
                        (if ("OneRowIsEmpty")
                            (if ("NoPiecesInP1Side")
                                (and
                                    (forEach Site (sites Board)
                                        (if (< 0 (count at:(site)))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P2))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                    (if (>= 
                                            (count Cell at:(handSite P1))
                                            (+ 
                                                (count Cell at:(handSite P2))
                                                (count in:(sites Board))
                                            )
                                        )
                                        (set NextPlayer (player 2))
                                        (set NextPlayer (player 1))
                                    )
                                )
                                (and
                                    (forEach Site (sites Board)
                                        (if (< 0 (count at:(site)))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P1))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                    (if (>= 
                                            (count Cell at:(handSite P2))
                                            (+ 
                                                (count Cell at:(handSite P1))
                                                (count in:(sites Board))
                                            )
                                        )
                                        (set NextPlayer (player 1))
                                        (set NextPlayer (player 2))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 2 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 2 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 3 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:3
                    )
                    (move
                        (from (handSite Mover))
                        (to ("LeftMostEmpty"))
                        count:1
                    )
                    (then
                        (if (!= 0 (count Cell at:(handSite Mover)))		
                            (moveAgain)
                            (forEach Site (sites Mover)
                                (if (is Occupied (site))
                                    (fromTo
                                        (from (handSite Next))
                                        (to (mapEntry "CorrespondingHoles" (site)))
                                        count:(count at:(site))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (or (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
||Hus is a common name for four-row mancala-style board games that are popular throughout Namibia. This version is played by the Nama people, and was documented in the early twentieth century.4x16-22 board. Two counters in each player's outer row and the right half of the holes in the inner row. The opening move is stylized; each player must make one of the following moves on their first turn:
            
            Take counters from the hole that is two to the right of the center of the board in the outer row. Sow them to the right starting in the hole third from the center in the inner row;
            
            Take counters from the hole that is three to the right of the center of the board in the outer row. Sown them to the right starting from the hole second from the center in the inner row;
            
            Take counters from the hole next to the center of the board in the inner row. Sow them to the right;
            
            Take counters from the hole next to the left of the center of the board in the outer row. Sow them to the right starting from the hole next to the right of the center of the board.
            
        Players then sow from any of their holes in an anti-clockwise direction. If the last counter of a sowing lands in an empty hole, the turn ends. If the last counter falls into an occupied hole, the counters in that hole are picked up and sowing continues, unless the hole in the inner row on the opponent's side opposite the one the player last sowed into is occupied, in which case any counters in this hole and any in the opponent's opposite outer row hole are captured. The captured counters are then sown on the player's side of the board, starting with the hole following the one from which the capture was made. Sowing cannot occur from holes with single counters. The game ends when one player can no longer move. Each player has 16 holes on each row.
(game "Hus (Nama)" 
    (players 2) 
    
    (equipment { 
        (mancalaBoard 4 "Columns" store:None
            { 
            (track "TrackCCW1" "0,E,N1,W" loop:True P1)
            (track "TrackCCW2" <Board:CCW2> loop:True P2)
            }
        )
        (regions "Home" P1 (sites Track "TrackCCW1"))          
        (regions "Home" P2 (sites Track "TrackCCW2"))          
        (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom)))  
        (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top)))   
        (regions "Outer" P1 (difference (sites Track "TrackCCW1") (sites P1 "Inner"))) 
        (regions "Outer" P2 (difference (sites Track "TrackCCW2") (sites P2 "Inner"))) 
        (regions "HalfRightInner" P1 (sites {<Board:HalfRightInnerP1>}))     
        (regions "HalfRightInner" P2 (sites {<Board:HalfRightInnerP2>}))     
        (piece "Seed" Shared)
        (hand Each)
    }) 
    (rules 
        
        (start 
            (set Count 2 to:(union {(sites P1 "Outer") (sites P2 "Outer") (sites P1 "HalfRightInner") (sites P2 "HalfRightInner") })) 
        )
        
        phases:{
        (phase "OpeningP1" P1
            (play
                (or {
                    (move Select
                        (from (- (/ ("Columns") 2) 2))
                        (then
                            (and
                                (fromTo
                                    (from (last To))
                                    (to (+ (/ ("Columns") 2) 1))
                                    count:2
                                )
                                (sow
                                    (+ (/ ("Columns") 2) 1)
                                    count:2
                                    "TrackCCW"
                                    owner:(mover)
                                )
                            )
                        )
                    )
                    
                    (move Select
                        (from (+ (/ ("Columns") 2) 2))
                        (then
                            (and
                                (fromTo
                                    (from (last To))
                                    (to (+ (+ ("Columns") (/ ("Columns") 2)) 1))
                                )
                                (fromTo
                                    (from (last To))
                                    (to (+ (+ ("Columns") (/ ("Columns") 2)) 2))
                                )
                            )
                        )
                    )
                    
                    (move Select
                        (from (+ ("Columns") (/ ("Columns") 2)))
                        (then
                            (and
                                (fromTo
                                    (from (last To))
                                    (to (+ (+ ("Columns") (/ ("Columns") 2)) 1))
                                )
                                (fromTo
                                    (from (last To))
                                    (to (+ (+ ("Columns") (/ ("Columns") 2)) 2))
                                )
                            )
                        )
                    )
                    (move Select
                        (from (- (/ ("Columns") 2) 1))
                        (then
                            (sow
                                "TrackCCW"
                                owner:(mover)
                            )
                        )
                    )
                })
            )
            (nextPhase Mover "Sowing")
        )
        
        (phase "OpeningP2" P2
            (play
                (or {
                    (move Select
                        (from (+ (- (* 4 ("Columns")) (/ ("Columns") 2)) 1))
                        (then
                            (and
                                (fromTo
                                    (from (last To))
                                    (to (- (- (* 4 ("Columns")) (/ ("Columns") 2)) 2))
                                    count:2
                                )
                                (sow
                                    (- (- (* 4 ("Columns")) (/ ("Columns") 2)) 2)
                                    count:2
                                    "TrackCCW"
                                    owner:(mover)
                                )
                            )
                        )
                    )
                    (move Select
                        (from (- (- (* 4 ("Columns")) (/ ("Columns") 2)) 3))
                        (then
                            (and
                                (fromTo
                                    (from (last To))
                                    (to (- (- (* 3 ("Columns")) (/ ("Columns") 2)) 2))
                                )
                                (fromTo
                                    (from (last To))
                                    (to (- (- (* 3 ("Columns")) (/ ("Columns") 2)) 3))
                                )
                            )
                        )
                    )
                    (move Select
                        (from (- (- (* 3 ("Columns")) (/ ("Columns") 2)) 1))
                        (then
                            (and
                                (fromTo
                                    (from (last To))
                                    (to (- (- (* 3 ("Columns")) (/ ("Columns") 2)) 2))
                                )
                                (fromTo
                                    (from (last To))
                                    (to (- (- (* 3 ("Columns")) (/ ("Columns") 2)) 3))
                                )
                            )
                        )
                    )
                    (move Select
                        (from (- (* 4 ("Columns")) (/ ("Columns") 2)))
                        (then
                            (sow
                                "TrackCCW"
                                owner:(mover)
                            )
                        )
                    )
                })
            )
            (nextPhase Mover "Sowing")
        )
        
        (phase "Sowing"
            (play
                (move Select
                    (from
                        (if ("SameTurn")
                            (sites {(var "Replay")})
                            (sites Mover "Home")
                        )
                        if:(< 1 (count at:(from)))
                    )
                    (then
                        (sow
                            "TrackCCW"
                            owner:(mover)
                            apply:(if (< 1 (count at:(to)))
                                (if (is In (to) (sites Mover "Inner"))
                                    (if (is Occupied ("OppositePit" (to)))
                                        (and {
                                            (fromTo
                                                (from ("OppositePit" (to)))
                                                (to (to))
                                                count:(count at:("OppositePit" (to)))
                                            )
                                            (if (is Occupied ("OppositeOuterPit" (to)))
                                                (and 
                                                    (fromTo
                                                        (from ("OppositeOuterPit" (to)))
                                                        (to (to))
                                                        count:(count at:("OppositeOuterPit" (to)))
                                                    )
                                                    (sow
                                                        (to)
                                                        count:(+ (count at:("OppositeOuterPitOuter")) (count at:("OppositePitOuter")))
                                                        "TrackCCW"
                                                        owner:(mover)
                                                    )
                                                    
                                                )
                                                (sow
                                                    (to)
                                                    count:(count at:("OppositePit" (to)))
                                                    "TrackCCW"
                                                    owner:(mover)	
                                                )
                                            )
                                        })
                                        (and
                                            (moveAgain)	
                                            (set Var "Replay" (to))
                                        )
                                    )
                                    
                                    (if (is Occupied ("OppositePitOuter"))
                                        (and {
                                            (fromTo
                                                (from ("OppositePitOuter"))
                                                (to (to))
                                                count:(count at:("OppositePitOuter"))
                                            )
                                            (if (is Occupied ("OppositeOuterPitOuter"))
                                                (and
                                                    (fromTo
                                                        (from ("OppositeOuterPitOuter"))
                                                        (to (to))
                                                        count:(count at:("OppositeOuterPitOuter"))
                                                    )
                                                    (sow
                                                        (to)
                                                        count:(+ (count at:("OppositeOuterPitOuter")) (count at:("OppositePitOuter")))
                                                        "TrackCCW"
                                                        owner:(mover)	
                                                    )
                                                )
                                                (sow
                                                    (to)
                                                    count:(count at:("OppositePitOuter"))
                                                    "TrackCCW"
                                                    owner:(mover)	
                                                )
                                            )
                                        })
                                        (and
                                            (moveAgain)	
                                            (set Var "Replay" (to))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end "ForEachNonMoverNoMovesLoss")
        )
        }
        
    )
)

Construct a Ludii game based on the following description
Sig wa Duqqan is a race game played on the island of Djerba, Tunisia. This version is played on a spiral board, in which players attempt to reach the centre of the board. When players reach the centre, they may either play as the Ghoula, which drags opponents' pieces to the start, or to force their opponents to move backwards.86 spaces in a spiral track. Any number of players, each having one piece, which starts on the first space in the outer ring of the spiral. A lump of charcoal, the Ghoula, also is placed on this space. Four sticks, with one green side and one white side, used as dice. The throws are as follows: One white side up = 1, this throw is known as \ The game has 2 players.
(game "Sig wa Duqqan (Houmt Taourit)"
    (players <Player:number>)
    (equipment {
        (board 
            (spiral turns:5 sites:86) 
            {
            (track "Track" {85..5} directed:True)
            (track "ExtensionTrack" {4..0} directed:True)
            (track "GhoulaTrack" {86..5} directed:True)
            (track "ReverseGhoulaTrack" {5..85} directed:True)
            }
            use:Vertex
        )
        ("StickDice" 4)
        (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)})
        (piece "Stick" Each
            (if (= (from) ("EndTrack"))
                (if (= (state at:(from) level:(level)) 7)
                    (move 
                        (from (from) level:(level))
                        (to ("BeginningExtensionTrack"))
                    )
                    (if ("Sig")
                        (move Select
                            (from (from) level:(level))
                            (then 
                                (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo))))
                            )
                        )
                    )
                )
                (if (is In (from) (sites Track "Track"))
                    (move
                        (from (from) level:(level))
                        (to
                            ("SiteToMoveOnTrack" "Track" ("ThrowValue"))
                            if:True
                        )
                    )
                    (if (is In (from) (sites Track "ExtensionTrack"))
                        (or {
                            (if (and (!= (from) ("Central")) ("Sig"))
                                (move
                                    (from (from) level:(level))
                                    (to ("SiteToMoveOnTrack" "ExtensionTrack" 1))
                                )
                            )
                            (if (= (from) ("Central"))
                                (move Pass
                                    (then
                                        (and
                                            (if (= 0 ("ThrowValue"))
                                                (set Var 6)
                                                (set Var ("ThrowValue"))
                                            )
                                            (moveAgain)
                                        )
                                    )
                                )
                                (if (= 3 ("ThrowValue"))
                                    (move Pass
                                        (then
                                            (and
                                                (set Var 3)
                                                (moveAgain)
                                            )
                                        )
                                    )
                                )
                            )
                        })
                    )
                )
            )
            maxState:7		
        )
        (piece "Ghoula" Neutral)
        (hand P1 size:1)
    })
    (rules 
        (start {
            (place Stack "Ghoula0" ("ExternalSite"))
            (place Stack items:<Player:init> 85)
        })
        (play 
            (do (if (<= (var) 0) (roll)) 
                next:(if (> (var) 0)
                    ("MoveGhoula")
                    (if (!= 0 ("ThrowValue")) (forEach Piece))
                )
                (then
                    (if ("IsSpecialThrow")
                        (moveAgain)
                    )
                )
            )
        )
        (end {
            (forEach Player
                if:(no Pieces Player) 
                (result Player Loss)
            )
            (forEach Player
                if:("GhoulaPhaseDone")
                (result Player Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Moo is a game with leaping captured played in Hawai'i during the nineteenth century.8x8 board, every other square marked with an X in a checkered pattern. Twelve pieces per player, positioned on the first three rows closest to the player on the marked squares. Players alternate turns moving a piece diagonally forward. A player may capture an opponent's piece by hopping over it to an empty spot on the opposite side of it along the lines. Multiple captures are allowed, if possible. When a player's piece reaches the opposite edge of the board from which it started, it becomes a king. It may move over any distance, diagonally, and may capture by leaping any distance over any number of opponent's pieces, capturing all of them in that line. The king cannot take in multiple directions in one turn. The first player to capture all of the opponent's pieces wins.
         
(game "Moo" 
    ("TwoPlayersNorthSouth")
    ("DraughtsEquipment" (square 8) ~ (regions "MarkedCell" (sites Phase 0))) 
    (rules 
        ("BlackCellsSetup" 3)
        
        (play 
            (if "SameTurn"
                (or
                    (if "IsUnpromoted"
                        ("HopMan" (last To)
                            (then 
                                ("ReplayIfCanMove" ("HopMan" (last To)) 
                                    ("PromoteIfReach" (sites Next) "DoubleCounter")
                                ) 
                            ) 
                        )
                        ("HopKingAgain")
                    )
                    (move Pass)
                )
                (or 
                    (forEach Piece "Counter"
                        (or
                            ("HopMan" (from) 
                                (then 
                                    ("ReplayIfCanMove" ("HopMan" (last To)) 
                                        ("PromoteIfReach" (sites Next) "DoubleCounter")
                                    ) 
                                ) 
                            )
                            ("StepToEmpty" (directions {FR FL}))
                            (then ("PromoteIfReach" (sites Next) "DoubleCounter"))
                        )
                    )
                    (forEach Piece "DoubleCounter" 
                        (or
                            ("HopKing")
                            (move Slide Diagonal)
                        )
                    )
                )
            )
        ) 
        
        (end ("CaptureAll" Next)) 
    )
)

Construct a Ludii game based on the following description
Barca is a recent commercial chess variant. The game was invented by Andrew Caldwell, and appeared in 2011.The game is played on a 10x10 board. Four of the squares are marked and are considered to contain a watering hole.
            Each player has two elephants, two lions and two mice.
            
            Pieces do not take other pieces. Their movement is as follows: mice move like rooks, lions move like bishops, and elephants move like queens.
            
            Like their chess counterparts, the pieces cannot jump over other pieces.
            
            A mouse is afraid of a lion of the opponent; a lion is afraid of an elephant of the opponent, and an elephant is afraid of a mouse of the opponent.
            
            An animal may not move to a square that is adjacent (horizontally, vertically or diagonally) to an animal it is afraid of. In addition, if an animal is adjacent to an animal that it is afraid of, then it must be moved by its owner, i.e., the owner may not move another animal.
            
            In the special case that more than one animal is adjacent to an animal it is afraid of, the owner may choose which animal to move.
            
        One wins the game by occupying three of the watering holes with own pieces. 
(game "Barca" 
    (players 2) 
    (equipment { 
        (board (square 10)) 
        (piece "Mouse" Each ("MouseMove"))
        (piece "Elephant" Each ("ElephantMove"))
        (piece "Lion" Each ("LionMove"))
        (regions "Water" (sites {"D4" "D7" "G4" "G7"}))
    }) 
    (rules
        (start {
            (place "Elephant1" (sites {"E1" "F1"}))
            (place "Lion1" (sites {"D2" "G2"}))
            (place "Mouse1" (sites {"E2" "F2"}))
            (place "Elephant2" (sites {"E10" "F10"}))
            (place "Lion2" (sites {"D9" "G9"}))
            (place "Mouse2" (sites {"E9" "F9"}))
        })
        
        (play
            (priority {
                (and {
                    (forEach Piece "Mouse" (if ("IsAround" "Lion") ("MouseMove")))
                    (forEach Piece "Elephant" (if ("IsAround" "Mouse") ("ElephantMove")))
                    (forEach Piece "Lion" (if ("IsAround" "Elephant") ("LionMove")))
                })
                (forEach Piece)
            })
        )
        
        (end (if ("ThreePiecesInWater") (result Mover Win)))
    )
)

Construct a Ludii game based on the following description
Rio Kadalis is a two-row mancala-style board game played in Ethiopia and Somalia. It shares characteristics of similar games from the Horn of Africa, such as the capture of any holes containing four counters.2x6 board. Four counters per hole. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, these counters are picked up and the sowing continues. During sowing, the contents of any hole made to contain four counters are captured by the player in whose row the hole is located, except when this is the final counter of a sowing, in which case the player who is sowing captures these counters. When the sowing ends in an empty hole, the turn ends. Play continues until one player cannot move, and the other player captures the remaining counters. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, but not if there are one or two extra. Play continues in several rounds like this until one player captures all the holes. 
(game "Rio Kadalis"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6 store:None
            {
            (track "TrackCCW" "0,E,N,W" loop:True)
            (track "TrackCW" "5,W,N,E" loop:True)
            }
        )
        (piece "Seed" Shared)
        (hand Each)
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map "RightMost" {(pair P1 5) (pair P2 6)})
    }) 
    (rules 
        (start { 
            (set Count 4 to:(sites Track)) 
            (set RememberValue "OwnedP1" (sites Bottom))
            (set RememberValue "OwnedP2" (sites Top))
        })
        
        phases:{
        (phase "Sowing"
            (play
                (or {
                    (move Select 
                        (from
                            (if ("SameTurn")
                                (sites {(var "Replay")})
                                ("OwnedHoles") 
                            )
                            if:(is Occupied (from))
                        )
                        (then
                            (do
                                (set Var "NumSowed" (count at:(last To)))
                                next:(sow
                                    "TrackCCW"
                                    apply:(if (= 4 (count at:(to)))
                                        (fromTo
                                            (from (to))
                                            (to (handSite Mover))
                                            count:4
                                        )
                                        (if (< 1 (count at:(to)))
                                            (and
                                                (moveAgain)
                                                (set Var "Replay" (to))
                                            )
                                        )
                                    )
                                )
                                (then
                                    (and
                                        (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1)))
                                            (if (= 4 (count at:(site)))
                                                (fromTo
                                                    (from (site))
                                                    (to (if (is In (to) (sites (values Remembered "OwnedP1"))) (handSite P1) (handSite P2)))
                                                    count:4
                                                )
                                            )
                                        )
                                        (set Var "NumSowed" 0)
                                    )
                                )
                            )
                        )
                    )
                    }
                    (then
                        (if ("APlayerCanNotMove")
                            (and { 
                                (if (no Moves P1)
                                    (forEach Site (sites Board)
                                        (if (is Occupied (site))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P1))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                    (forEach Site (sites Board)
                                        (if (is Occupied (site))
                                            (fromTo
                                                (from (site))
                                                (to (handSite P2))
                                                count:(count at:(site))
                                            )
                                        )
                                    )
                                )
                                (forget Value "OwnedP1" All)
                                (forget Value "OwnedP2" All)
                            })
                        )
                    )
                )
            )
            
            (end (if ("NoPieceOnBoard")
                    {
                    (if (> 3 (count Cell at:(handSite P1))) (result P2 Win))
                    (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))
                    }
                )
            )
            
            (nextPhase ("NoPieceOnBoard") "BetweenRounds")
        )
        
        (phase "BetweenRounds"
            (play
                (if (<= 3 (count Cell at:(handSite Mover)))
                    (move
                        (from (handSite Mover))
                        (to ("RightMostEmpty"))
                        count:(if (>= (count Cell at:(handSite Mover)) 4) 4 3)
                        (then
                            ("RemmemberOwnedHoles" (last To))
                        )
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
Currierspiel is an enlarged form of Chess played in medieval and early modern Germany. It was particularly popular and long-lived in the village of Ströbeck.8x12 board. Each player begins with a complement of pieces, each with their own powers of movement as follows: King (x1): may move one space in any direction; Queen (x1): moves one space diagonally, may leap two spaces diagonally on its first move over any intervening pieces; Man (x1): moves one space in any direction; Fool (x1): moves orthogonally one space; Courier (x2): moves diagonally any distance; Bishop (x2): moves diagonally two spaces, jumping over any intervening pieces; Knight (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Rook (x2): moves orthogonally any distance; Pawns (x12): move forward one space or diagonally forward one space to capture. Only the Rooks' and Queens' pawns may move forward two spaces for their first move. Each player must move the Rooks' Pawns and Queens' Pawn in this way in their first three moves. A piece is captured when an opponent's piece moves onto its space. The King is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's turn. When the king cannot move out of check, it is checkmated and the opponent wins. 
(game "Currierspiel"
    ("TwoPlayersNorthSouth") 
    (equipment {
        (board (rectangle 8 12))
        (regions "StartingPawnRookQueen" P1 (sites {"A2" "G2" "L2"}))
        (regions "StartingPawnRookQueen" P2 (sites {"A7" "G7" "L7"}))
        ("ChessKing" "King")
        (piece "Queen" Each 
            (or
                ("StepToNotFriend" Diagonal)
                (if (= 1 (state at:(from)))
                    (move Hop 
                        (between 
                            if:True
                        )
                        (to if:(not ("IsFriendAt" (to)))
                            (apply (remove (to)))
                        )
                    )
                    (then (set State at:(last To) 0))
                )
            )
        )
        ("ChessKing" "Mann")
        (piece "Fool" Each ("StepToNotFriend" Orthogonal))
        ("ChessBishop" "Ferz") 
        (piece "Bishop" Each
            (move Hop 
                (between 
                    if:True
                )
                (to if:(not ("IsFriendAt" (to)))
                    (apply (remove (to)))
                )
            )
        )
        ("ChessKnight" "Knight")
        ("ChessRook" "Rook")
        ("ChessPawn" "Pawn")
    })
    (rules 
        (start {
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "L1"}) (place "Knight1" {"B1" "K1"}) (place "Ferz1" {"C1" "J1"}) (place "Bishop1" {"D1" "I1"}) (place "Queen1" coord:"G1" state:1) (place "Fool1" coord:"H1") (place "Mann1" coord:"E1") (place "King1" coord:"F1") 
            (place "Rook2" {"A8" "L8"}) (place "Knight2" {"B8" "K8"}) (place "Ferz2" {"C8" "J8"}) (place "Bishop2" {"D8" "I8"}) (place "Queen2" coord:"G8" state:1) (place "Fool2" coord:"H8") (place "Mann2" coord:"E8") (place "King2" coord:"F8") 
        })
        
        phases:
        {
        (phase "Opening" 
            (play 
                (forEach Site 
                    (intersection (sites Occupied by:Mover) (sites Mover))
                    (move 
                        (from (site))
                        (to (ahead (site) steps:2 Forward))
                    )
                )
            )
            (nextPhase Mover (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Mover)))) "Playing")
        )
        (phase "Playing" 
            (play 
                (do 
                    (forEach Piece) 
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        }
        
        (end ("Checkmate" "King"))
    )
)

Describe the mechanics of the following Ludii game
(game "ArdRi" 
    (players 2) 
    (equipment { 
        (board (square 7)) 
        
        (piece "Thrall" P1 
            (move Step
                Orthogonal 
                (to if:"EmptyButNotTheCentre") 
                (then 
                    (or { 
                        ("CustodialCapturePieceType" "Thrall2" Orthogonal (max 1))
                        (<Capture:type>
                            (between 
                                <Capture:distance> 
                                if:(= (what at:(between)) (id "Jarl2")) 
                                "JarlIsCaptured"
                            )
                            (to 
                                if:(or 
                                    ("IsFriendAt" (to)) 
                                    (is In (to) (sites Centre))
                                )
                            )
                        )
                    })
                )
            )
        )
        (piece "Thrall" P2 
            (move Step
                Orthogonal 
                (to if:"EmptyButNotTheCentre") 
                (then ("CustodialCapturePieceType" "Thrall1" Orthogonal (max 1)))
            )
        )
        (piece "Jarl" P2 
            ("StepToEmpty" Orthogonal 
                (then ("CustodialCapturePieceType" "Thrall1" Orthogonal (max 1)))
            )
        )
    }) 
    (rules 
        (start { 
            (place "Thrall1" {"C1" "D1" "E1" "D2" "A3" "A4" "A5" "B4" "G3" "G4" "G5" "F4" "D6" "C7" "D7" "E7"})
            (place "Thrall2" (difference (expand (sites Centre)) (sites Centre)))
            (place "Jarl2" (centrePoint))
        })
        
        (play (forEach Piece)) 
        
        (end {
            ("PieceTypeReachWin" "Jarl2" (sites Outer) P2)
            (if "JarlWasCaptured" (result P1 Win))
        })
    )
)
ArdRi is purported to be a Scottish tafl game played on a 7x7 grid. It is claimed to be a traditional Scottish game by various sites online, but the validity of this assertion is in question.Pieces move one space orthogonally. Pieces are captured through the custodial capture move, but a piece moving in between two other pieces is not automatically captured. The goal of the player with the king is to reach the edge of the board. The goal of the other player is to capture the king. The game is played with the common rules.

Construct a Ludii game based on the following description
Signum is a drawless connection game for the hexhex board in the vein of Global Connection, but without markings on the board or an initial position. Signum was invented by Michael Amundsen in May 2022.Play: Players take turns placing one stone of their color on any empty hex.
            
            Goal: When the board is full, the game is over and the player with the higher score is the winner.
            
            Scoring: Each stone is worth 1 point for its owner if it is part of a group connecting opposite sides of the board, and -1 point otherwise.
            
        The scoring trick that gave the game its name – namely that each stone is worth either +1 point or -1 point – was (unbeknownst to the inventor of Signum) discovered by Brian Wittmann (the inventor of Loops) 9 years earlier. The score is currently updated after each move. (This makes the AI weaker.) A size 4 board is currently selected
(game "Signum"
    (players 2)
    (equipment {
        (board (hex <Size>))
        (piece "Disc" Each)
    })
    (rules
        (meta (swap))
        (play
            (move Add
                (to (sites Empty))
                <Score>
            )
        )
        (end 
            (if (is Full) 
                (byScore {
                    (score P1 ("ScoreOf" P1))
                    (score P2 ("ScoreOf" P2))
                })
            )
        )
    )
)

Construct a Ludii game based on the following description
Bagh Bandi is a hunt game played in the Lower Bengal region of South Asia. In it, two tigers attempt to capture 32 goats, and the goats attempt to trap the tigers.5x5 intersecting lines, with diagonals drawn in the four quadrants of the board. Two triangles, their apices intersecting the main board at opposite midpoints. The bast of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. One player plays as two tigers, which can be placed anywhere on the board, and the other player plays as 32 goats, which begin on the four central points of the quadrants of the square board, eight per stack. Players alternate turns moving a piece to an empty adjacent spot along the lines. The goats move one at a time from their stacks, and cannot be restacked once they have been moved. The tiger may capture a goat by hopping over it to an empty spot immediately on the opposite side of an adjacent goat. Multiple captures in one turn are allowed, but a tiger cannot hop over a stack of goats and hop over it again in the opposite direction. When tigers hop over a stack of goats, only one goat is captured. The goats win by blocking the tigers from being able to move; the tigers win by capturing all the goats. 
(game "Bagh Bandi" 
    (players 2) 
    (equipment { 
        ("AlquerqueBoardWithBottomAndTopTriangles")
        (piece "Goat" P2 "StepToEmpty")
        (piece "Tiger" P1 
            (or
                ("StepToEmpty")
                ("HopCapture"
                    ~
                    ~
                    ("CaptureAgain")
                )
            )
        )
        (regions "CentralSites" (sites {6 8 16 18}))
        (hand P1)
    }) 
    (rules 
        (start {
            (place Stack "Tiger1" (handSite P1) count:2)
            (place Stack "Goat2" 6 count:8)
            (place Stack "Goat2" 8 count:8)
            (place Stack "Goat2" 16 count:8)
            (place Stack "Goat2" 18 count:8)
        })
        phases:{
        (phase "Placement" P1 
            (play 
                (move 
                    (from (handSite P1)) 
                    (to (sites Empty)) 
                    (then (if ("HandOccupied" Mover) (moveAgain)))
                )
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        (phase "Movement" 
            (play 
                (if ("SameTurn")
                    (or 
                        ("HopCapture" 
                            (from (last To)) 
                            (difference Orthogonal OppositeDirection)
                            ("CaptureAgain")
                        )
                        (move Pass)
                    )
                    (forEach Piece top:True)
                )
            )
        )
        }
        
        (end ("NoMovesP1NoPiecesP2"))
    )
)

Construct a Ludii game based on the following description
Todas Tablas is a race game from medieval Spain that is related to other European Tables games, and which most closely resembles modern Backgammon.2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Fifteen pieces per player. The starting position is as such, number the points from the origin of each player's track: point six: five pieces; point 8: three pieces; point 13: five pieces; point 24: two pieces. Two dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When a player's piece lands on a spot occupied by a single piece belonging to the opponent, the opponent's piece is sent back to the quadrant in which that player started with two pieces. Players bear off their pieces at the end of their track. The first player to bear off all their pieces wins. 
(game "Todas Tablas"
    (players 2)
    (equipment {
        ("TableBoard" "TableTracksOpposite2")
        (dice d:6 num:2)
        (piece "Disc" Each
            (forEach Die 
                if:("DieNotUsed")
                (if ("IsOffBoard" ("NextSiteFrom" (from) (pips)))
                    (move Remove (from))
                    (move 
                        (from (from))
                        (to 
                            ("NextSiteFrom" (from) (pips))
                            if:("NoEnemyOrOnlyOne" (to))
                            ("HittingCapture" ("GoBack" Next))
                        )
                    )
                )
                (then ("ReplayNotAllDiceUsed"))
            )
        )
        (regions "StartQuadrant" P1 (sites {6..11}))
        (regions "StartQuadrant" P2 (sites {18..23}))
    })
    (rules 
        (start {
            (place Stack "Disc1" 6 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 12 count:5) (place Stack "Disc1" 23 count:2)
            (place Stack "Disc2" 18 count:5) (place Stack "Disc2" 16 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 11 count:2)
        })
        
        (play 
            ("RollEachNewTurnMove"
                (forEach Piece)
            )
        )
        
        (end ("EscapeWin"))
    )
)

Construct a Ludii game based on the following description
Sungka is a two-row mancala-style board game from the Philippines. It is similar to many other games throughout Southeast Asia, which have similar playing mechanisms and similar names.2x7 board, with two stores. Each player owns the store to their left. Seven counters per hole. Players take counters from one hole and sow them in a clockwise direction starting in the next hole from which the counters were taken. Players include their own store when sowing but ignore their opponent's store. If last counter falls into an empty hole, move ends. If it is on the player's side, the counters in the opponent's hole opposite are taken and added to the player's store. If the last counter falls into the player's store, the player may sow counters from another hole on their side. If the last counter drops into an occupied hole on either side of the board, the counters are picked up and sowing continues until the last counter drops into an empty hole. When all of the counters are in the players' stores, a new round begins. Players fill their holes with the counters in their store. Any holes which cannot be filled with seven counters are out of play for this round; any extra counters go back in the store. Play continues until one player cannot fill any holes, and the opponent wins. 
(game "Sungka" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 "Columns"
            (track "Track" "7,W,WNW,ENE,E,ESE" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count "Columns" to:(union (sites P1) (sites P2))))		
        
        phases:{
        (phase "Sowing"
            (play 
                (move Select 
                    (from 
                        (if 
                            (and 
                                ("SameTurn") 
                                (not ("WasInStore"))
                            ) 
                            "LastHoleSowed" 
                            (sites Mover)
                        )
                        if:(< 0 (count at:(from)))
                    )
                    (then 
                        (sow 
                            apply:(if ("SowingEndInMyStore")
                                (and
                                    (moveAgain)
                                    ("LastCounterInTheStore")
                                )
                                (if (and {(is In (to) (sites Mover)) (= (count at:(to)) 1) (< 0 (count at:"OppositePit"))})
                                    (fromTo 
                                        (from "OppositePit") 
                                        (to (mapEntry (mover))) 
                                        count:(count at:"OppositePit")
                                    )
                                    (if (> (count at:(to)) 1)
                                        (and
                                            (moveAgain)
                                            ("StoreLastHoleSowed")
                                        )
                                    )
                                )
                            )
                            skipIf:(= (to) (mapEntry Next))
                        )
                    )
                )
            )
            (end (if (all Passed)
                    {
                    (if (> 7 (count at:(mapEntry P1))) (result P2 Win))
                    (if (> 7 (count at:(mapEntry P2))) (result P1 Win))
                    }
                )
            )
            (nextPhase (all Passed) "BetweenRounds")
        )
        (phase "BetweenRounds"
            (play
                (if (<= 7 (count at:(mapEntry Mover)))
                    (move
                        (from (mapEntry Mover))
                        (to (intersection (sites Empty) (sites Mover)))
                        count:7
                    )
                )
            )
            (nextPhase (all Passed) "Sowing")
        )
        }
    )
)

Construct a Ludii game based on the following description
OddEvenTree is a graph theory game. It is played on an undirected, cyclic, and edge-weighted graph.One player takes the Odd role, and the other player takes the even role. Initially, the board graph is coloured with a neutral colour. Players take turns removing colour from a coloured edge. The odd player gets a score of each turn, which is equal to the cost of the last removed edge. Play ends when the coloured graph has no cycle.  If the odd player has odd score he wins, otherwise, the second player wins. The game is played on the Graph1.
(game "OddEvenTree" 
    (players 2) 
    (equipment { 
        (board <Board:type> use:Edge) 
        (piece "Marker" Neutral) 
    }) 
    (rules
        (start
            <Board:start>
        )
        
        (play
            (move Remove (sites Occupied by:Neutral on:Edge)
                (then 
                    (and
                        (remove Edge (last To))
                        (addScore {P1 P2} {(cost Edge at:(last To)) (- 0 (cost Edge at:(last To)))})
                    )
                )
            )
        )
        (end 
            (if (is Tree Neutral) 
                (if 
                    (is Odd (score P1)) 
                    (result P1 Win)
                )
                (result P2 Win)
            ) 
        )
    )
)

Construct a Ludii game based on the following description
Les Pendus is a game of alignment from France. It comes in a three-in-a-row variant and a five-in-a-row variant. It is unknown how old these games are in France, but the boards on which they are played have been common since the Roman (three-in-a-row) or medieval (five-in-a-row) period.3x3 board with diagonals. Three pieces per player. Players take turns placing their pieces. Once all pieces have been placed, they may move a piece to any unoccupied spot. The first player to align their three pieces in a row along one of lines on the board is the winner. The board is 3x3 and the winning conditions is a 3 in a row.
(game "Les Pendus"
    (players 2) 
    
    (equipment { 
        (board (square <Board:size> diagonals:Alternating) use:Vertex) 
        (hand Each)
        (piece "Marker" Each 
            (move
                (from) 
                (to (sites Empty)) 
            )
        ) 
    })
    
    (rules 
        (start (place "Marker" "Hand" count:<Board:size>))
        
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        
        ("PhaseMovePiece" "Movement")
        }
        
        (end 
            (if 
                (is Line <Board:size>)
                (result Mover Win)
            )
        )
    )
)

Construct a Ludii game based on the following description
Windir is a graph theory game based on the graph-theoretic concept of regular graphs. A regular graph is a graph where every vertex has the same number of neighbours; i.e. every vertex has the same degree. This game has two versions: an addition and a deletion version. In the addition version, the graph is initially uncoloured. Players alternate turns, colouring an uncoloured edge in a common colour. However, in the deletion version, the game starts with all the edges coloured. At each turn, a player chooses to remove the colour of an edge. In both versions, the current player loses by turning the coloured graph into a regular graph.
         The game is played on the Graph1. The players play on Addition version.
(game "Windir" 
    (players 2)
    (equipment { 
        (board <Board:type> use:Edge)
        (piece "Marker" Neutral) 
    }) 
    
    (rules  	
        
        <Version:play>
        
        (end 
            (if (is RegularGraph Neutral) (result Mover Loss))
        )
    )
)

Construct a Ludii game based on the following description
BlooGo is a Go variant inspired by the game Blooms by Nick Bentley.  In BlooGo, suicide is allowed, no passing is allowed, and the first player to capture a certain number of enemy stones wins.Played on a square grid. The board begins empty. One player plays as Black, the other as White. Players alternate turns placing a piece of their colour on the board; Black plays first. Passing is not allowed. After a move, all opposing pieces without liberties are captured (a stone or group of stones has no liberties if all adjacent points to that stone are occupied).  Stones cannot be placed to recreate a previous position. The game ends when one player captures a number of stones equal to a winning threshold agreed upon at the start of the game.  Despite not having an explicit territorial goal, this variant produces final positions quite reminiscent of standard Go. The game is played on a 9x9 board 1 capture to win.
(game "BlooGo" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Ball" Each)
    })
    
    (rules 
        (meta (no Repeat))
        (play 
            (move Add
                (to (sites Empty))
                (then 
                    "RemoveSurrounded"
                )
            )
        )
        
        (end {
            (if
                (>= (score Mover) <CapThreshold>)
                (result Mover Win)
            )
        })
    )
)

Construct a Ludii game based on the following description
Millieu is a 3-D Morris game based loosely on the game OutFoxThe goal is to be the last to complete a turn - this almost always occurs by the opponent running out of pieces.The game uses 2 sets of 9 common pieces combining all combinations of 3 attributes in 2 dimensions (color + shape). Each player has their own set in-hand in the beginning, but the pieces are no longer owned once in play. Moves follow a place-then-must-slide-an-adjacent-piece protocol. All turns must be fully completed.Captures are made by forming mills, and allow a player to restock their hand. A mill is an orthogonal line of 3 uniquely different pieces that share one common attribute. When a player forms a mill, they must remove one of the 2 inactive pieces in that mill back into their own hand for re-use.To win, the first player must either make one more capture than the opponent, or rarely, prevent the other player from placing a piece by leaving no slide moves available. This suggests the game, as it stands, has a second player advantage. - However much opening play testing will be needed to determine if the perceived advantage is real...Goal:
            The last player to complete a turn wins - typically when the opponent runs out of pieces in their hand.
            
            Each player starts with a full set of 9 pieces: each combination of shape and color. Pieces once played are not owned, but may be recaptured during the game for reuse.
            
            The game starts with a placement by the first player.
            Thereafter, each turn has a placement followed by a movement, and one or more required piece recaptures if available.
            
            -- 1. Placement:
            The first step in every turn is a placement to an empty point next to at least one existing piece that can slide.
            
            -- 2. Movement:
            The player must choose on piece next to the newly placed piece and slide it orthogonally one or two points to a new position. The piece can only move to empty points, never crossing a piece in play.
            
            -- 3. Capture:
            Either (or both) of the first two actions can form one or more 'mills'.
            
            A mill is an orthogonal line of three uniquely different piece types that all share one common attribute - either color or shape.
            
            The player completes their turn by destroying every mill on the board by removing one of the 2 unmoved pieces that it contains. (Newly added and moved pieces may not be removed.)
            
        A turn is not complete until all the applicable actions have been performed. A player may not make a move that would bring their hand size to more than 9 pieces. 
(game "Millieu"
    (players 2)
    (equipment {
        (board (remove (rectangle 9 3) cells:{4 5 10 11}) use:Vertex)
        (hand Each size:9)
        (piece "Disc" Shared maxState:3)
        (piece "Square" Shared maxState:3)
        (piece "Hex" Shared maxState:3)
    })
    (rules
        (start {
            (place "Disc" (handSite P1 0) state:3)
            (place "Disc" (handSite P1 1) state:1)
            (place "Disc" (handSite P1 2) state:2)
            (place "Square" (handSite P1 3) state:3)
            (place "Square" (handSite P1 4) state:1)
            (place "Square" (handSite P1 5) state:2)
            (place "Hex" (handSite P1 6) state:3)
            (place "Hex" (handSite P1 7) state:1)
            (place "Hex" (handSite P1 8) state:2)
            
            (place "Disc" (handSite P2 0) state:3)
            (place "Disc" (handSite P2 1) state:1)
            (place "Disc" (handSite P2 2) state:2)
            (place "Square" (handSite P2 3) state:3)
            (place "Square" (handSite P2 4) state:1)
            (place "Square" (handSite P2 5) state:2)
            (place "Hex" (handSite P2 6) state:3)
            (place "Hex" (handSite P2 7) state:1)
            (place "Hex" (handSite P2 8) state:2)
            
            (set Score Each 9)
        })
        (play
            (if
                (> 0 (counter))
                ("FirstPlacement")
                
                
                (if ("NewTurn") 
                    ("FirstAction") 
                    (if
                        (= 0 (count Sites in:(sites Pending)))
                        ("SlideAdjacent") 
                        ("DestroyEachMillsByCapturingAStaticPiece")
                        ("ThenIfMillsAddSites2PendingAndMoveAgain")
                    )
                )
                (then (set Score Mover (count Pieces in:(sites Hand Mover))))
            )
        )
        (end
            (if
                (no Moves Mover)
                (result Mover Loss)
            )
        )
    )
)

Construct a Ludii game based on the following description
Omny is a system of connection games that originated as a generalization of Mark Steere's Gyre. It includes Y as one of its many variations. Luis Bolaños Mures invented Omny in 2017.Omny is played on the cells of any hexagonal grid where some or all of the cells are designated star cells. Players take turns placing a stone of one's own color on an empty cell. A group is a set of connected stones of the same color. A cut of a group X is any set of connected cells (empty or occupied by either player) including no stones in X. You win by making a group such that none of its cuts include more than half the cells of the board. For serious play it is advised to play with a balance rule in force.
            
        In Misère Omny you lose if you make a group whose cuts each contain no more than half of the star cells. A hex board is currently selected A size 3 board is currently selected The currently selected star cells are all the cells on the board. The pie rule is currently in force The standard win condition is currently selected.
(game "Omny"
    (players 2)
    (equipment {
        (board (hex <Shape> <Size>))
        (piece "Disc" Each)
    })
    (rules
        (play
            (if
                (= 1 (var))
                (or
                    (move Swap Players P1 P2)
                    (move Add (to (sites Empty)) (then (set Var 0)))
                )
                (move Add
                    (to (sites Empty))
                    <Balance>
                )
            ) 
        )
        (end 
            (if 
                (>=
                    (count Sites 
                        in:("StarCells")
                    )
                    (max
                        (results
                            from:(difference
                                (sites Board)
                                (sites Group at:(last To))
                            )
                            to:2 
                            (* (to)
                                (count Sites
                                    in:(intersection
                                        ("StarCells")
                                        (sites Group at:(from)
                                            if:(not
                                                (is In
                                                    (to)
                                                    (sites Group at:(last To))
                                                )
                                            )
                                        )
                                    )
                                )
                            ) 
                        )
                    )
                )
                (result Mover <Result>)
            )
        )
    )
)

Construct a Ludii game based on the following description
A chess variant played on a board made of hexagons invented by Dave McCooey and Richard Honeycutt.Mini Hexchess is played on a hexagonal board with each side having length 5, and each space oriented horizontally. The board has 37 spaces.
            
            Piece Movement:
            * Kings, Rooks, Bishops, and Knights move as in Glinski Chess.
            - Kings step one space in any of the 12 directions. They do not castle.
            - Rooks slide in any of the 6 adjacent directions.
            - Bishops slide in any of the 6 'diagonal' directions.
            - Knights move two spaces in any adjacent direction, then one space in another direction.
            * There are no Queens in Mini Hexchess.
            * Pawns can advance one space forward without capturing. Pawns can never advance more than one space. Pawns capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). There is no en passant capture. On reaching the farthest rank in a given file, Pawns are promoted to a Rook, Bishop, or Knight. Note that a Pawn cannot be promoted to a Queen, since there are no Queens in Mini Hexchess.
            
        The game ends on a checkmate or stalemate. 
(game "Mini Hexchess"
    ("TwoPlayersNorthSouth")
    (equipment {
        (board (rotate 90 (hex 4)))
        
        (piece "King" Each ("KingCaptureStep" All ~))
        (piece "Queen" Each ("SlideCapture" ~ ~ (then (set Counter))))
        (piece "Rook" Each ("SlideCapture" Orthogonal ~ (then (set Counter))))
        (piece "Bishop" Each ("SlideCapture" Diagonal ~ (then (set Counter))))
        ("ChessKnight" "Knight" (then (set Counter)))
        
        (piece "Pawn" Each
            (or {
                "StepForwardToEmpty"
                ("StepToEnemy" ("Directions" {NNW NNE} {SSW SSE}))
                }
                (then
                    (and
                        (if (is In (last To) (sites Mover "PromotionZone"))
                            (moveAgain)
                        )
                        (set Counter)
                    )
                )
            )
        )
        
        (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE)))
        (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE)))
        
        (regions "Region-Dark" (sites Phase 2))
        (regions "Region-Light" (sites Phase 1))
        (regions "Region-Medium" (sites Phase 0))
    })
    
    (rules
        (start {
            (place "King1" coord:"B2")
            (place "Rook1" coord:"B1")
            (place "Bishop1" coord:"A1")
            (place "Knight1" coord:"A2")
            
            (place "King2" coord:"F6")
            (place "Rook2" coord:"F7")
            (place "Bishop2" coord:"G7")
            (place "Knight2" coord:"G6")
            
            (place "Pawn1" {"A3" "B3" "C3" "C2" "C1"})
            (place "Pawn2" {"E7" "E6" "E5" "F5" "G5"})
        })
        phases:{
        (phase "Movement"
            (play
                (if ("SameTurn")
                    ("PromoteTo" (piece {"Rook" "Bishop" "Knight"}))
                    (do (forEach Piece)
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
            )
            (end {
                ("Checkmate" "King")
                (if (or
                        (no Moves Mover)
                        (= (counter) 100)
                    )
                    (result Mover Draw)
                )
            })
        )
        }
    )
)

Construct a Ludii game based on the following description
Epelle is a simple game of alignment played by the Urhobo people of Nigeria.3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Players each have three pieces, initially placed on the sides closest to the player. Players move the pieces to an adjacent unoccupied intersection along the lines. The goal is to make three in a row which cannot be in the starting position. 
(game "Epelle"
    (players 2) 
    (equipment { 
        ("AlquerqueBoard" 3)
        (piece "Marker" Each "StepToEmpty")
        (regions P1 (sites Bottom))
        (regions P2 (sites Top))
    }) 
    (rules 
        (start { 
            (place "Marker1" (sites P1)) 
            (place "Marker2" (sites P2)) 
        })
        (play (forEach Piece))
        
        (end 
            (if 
                (and 
                    "NotAllPieceInHome"
                    (is Line 3)
                ) 
                (result Mover Win)
            )
        ) 
    )
)

Construct a Ludii game based on the following description
Equi-based games are games that share the following properties:
            - Scoring based on 2 kinds of pieces:
            -- Mobile pieces (discs) that can move and jump, and that penalise one's score.
            -- Territory pieces (cell shaped - hexes or squares) are stationary and give you points, but can only be placed at locations surrounded by equal numbers of one's own pieces and enemy pieces. 
            - Turns based on the sequence of disc movement, followed by piece placement. 
            (This allows the player to move to create an environment for placing a Territory piece.)
            - Game ends when neither player has placed a piece, or when neither can take a turn. 
            
            This creates a lot of complexity in a small board, but retains simple to understand tactical elements and emergent strategies.
            The game trials tend to fill the board, but some variants have traps that can end the game sooner.
            
            Mutators:
            - how 'surrounding' is defined,
            - where the Discs can be placed,
            - the pieces' relative values,
            - what pieces can be jumped and whether jumps are forced,
            - what happens to each kind of piece when jumped, (including removal, transformation of type and/or ownership),
            - whether placement is mandatory,
            - what restrictions are placed on disc placement, 
            - how the game ends, (no move available / no player has made a placement on their preceding turn)
            - number of players.
            
            These yield Equi, Equiversi, and multiplayer Hops-a-Daisy which is different enough to be considered an entirely separate game.
            
            In the work-in-progress (WIP) version of Equi (Dec 2020), the influencing neighbor pieces were found along 'lines of sight', and included only those pieces that were at the same distance as the nearest of them. This had a high perceptual cost in play, and proved unnecessary because it only makes a difference in the opening stages of the game, which already has a high degree of chaos. Thus the current implementation is limited to using a comparison of directly adjacent piece counts.
            
            The WIP version also had otional placement with special limitations not discussed here, to reduce cycling. 
            
            Equiversi - an evolution of the WIP (Jan 2021) intended to be easier to play and have less cycling issues.
            It has forced opponent hops, but no friendly hops, hopped enemies change ownership but not type, optional placement (game ends if neither player places, last to place loses in a tie), Hex placement based on 'adjacent neighbor' counts, Discs placed at non-Hex locations that don't force jumps, but only if there was no previous Disc movement in the same turn. Game ends when no preceding player has placed on their last turn.
            
            A second evolution, (Jan 2021) was to explore the concept of allowing a choice of Disc values. A value of 0 is the simplest, leading to Equiversi-2, which additionally allows freindly hops again, and relaxes Disc placements to made be anywhere, but only if there was no previous Disc movement in the same turn. This creates a territorial game, as narrow blocked-in areas will not be fillable, and playing a Disc into larger blocked in areas will usually be advantageous for the owner of the walls.
            
            Both these frequently feature tactical endings in which a player times a favorable score ocsillation with a depletion of placement oprtunities for the opponent after forcing him to jump.
            
            The latest Equi, (Nov 2022) implemented here, eliminates such suprise endings and focuses on the tactical trade-off of mobility vs score found in the original while avoiding the possibility of ties and playing with fewer moves on the same sized board. The capture-conversion applies to all pieces converting every type to freindly Territory. Forced placemnt can force adding Discs, and new scoring values incentivise sacrificing the Discs for points or trapping the opponent's Discs. In general it gives a spread of values to different capture combos, similar in effect to the (1, -1) piece value system without type change found in the WIP version. It has 'adjacent neighbor' based placement rules, forced hopping of enemy pieces and optional friendly hops, all hopped pieces become friendly Territory pieces, Territory value +1, Discs penalise (-3), No passing, Mandatory placement every turn, Hex placement based on neighbor counts, discs only where Hexes are not allowed, suicide placements are OK, Game ends when placement cannot be made. 
            
            Since this version ends with a full board and all pieces have odd values; on a board with odd cells there cannot be a tied score.
            
            The game can also be played with the same rules on orthogonal square grids and square+diagonal grids.
            
            Evolution to Hops-a-Daisy:            
            Nothing in the game prohibits a multi-player implementation, except that king-making could be an issue, and the definition for the Hex placement must be refined as to whose pieces are being compared.  Since the Multiplayer game is a totally different experience aimed at casual, chaotic play, it is implemented separately as an entirely different game on the site. The defaults for that game involve more elaborate piece mutations as a result of the jumps, as well.
            
        These games also inspired Refugia, with different placement restrictions, single piece types, and ownership changes taking place in stages, which has been implemented separately on Ludii.Equi is a 2-player strategy game in the Equi game system.
                It may be played:
                -- on a hex grid using hexagonal Territory pieces or
                -- on a square grid using square Territory pieces or 
                -- on a square plus diagonal grid using square Territory pieces.
                
                It also uses Discs or counters as mobile pieces. 
                
                The goal is to maximize your score when the board is full. 
                
                Black starts by placing a black hex anywhere on the empty board, except for a corner. Turns then alternate.
                
                A turn has two parts: first 'The Move', and then 'The Required Placement'.
                
                The Move:
                Only Discs may move. 
                
                A Disc may either:
            - A) move one step to an empty adjacent space, or 
        - B) jump across a single piece belonging to either player onto the empty space directly behind it. 
        -- As soon as any piece is jumped, the jumped piece is converted into a friendly Territory piece.
        -- Multiple consecutive jumps using the same piece are allowed, but no piece can be jumped more than once on the same turn.
        -- If the active Disc lands next to any enemy pieces which it can jump, it must immediately jump one of them.
        
        Forced Movement: 
        If at the beginning of the turn, any enemy pieces can be jumped, the turn must start by jumping one.
        Otherwise, choosing to move a Disc is optional.
        
        The Required Placement:
        Placement is mandatory, may use either type, depending on location, (and is separate from the conversions due to jumping.)
        
        The placement must be made to an empty space on the board (possibly the place that Disc moved from.)
        The type of piece that gets placed depends on the number of pieces on the adjacent locations at the time of placement:
        -- If there are no adjacent pieces, or if the number of adjacent pieces is the same for each player, then a Territory piece is placed. 
        -- Otherwise, a Disc must be placed there.
        
        The game ends when neither player has placed a piece on their previous turn.
        You score 1 point for each of your Territory pieces and deduct 3 points for each Disc.
        
On a board with an odd number of cells there are no ties. Board & size: Hexhex with edges alternating 3 and 4 All hopped pieces change type, Hopped enemies also change ownership An adjacent Enemy must be hopped, a Friend may be. Disc placement is not allowed if Disc movement was taken. Part or all of a turn may be passed except when there are forced jumps. End when neither player places. Place Discs at any Empty location Territory score is 1 Discs penalty is 0
(game "Equi Game System"
    (players 2)
    (equipment {
        (board <Board:size> use:Vertex)
        (piece "Disc" Each)
        (piece <Board:piece> Each)
    })
    (rules 
        (start (set Score Each 0)) 
        (play
            <ChosenHop:prioritySetting>
        )
        (end 
            {
            (if
                (and 
                    {
                    <Passing:endImplication>
                    (= 1 (var "FirstNoPlace")) 
                    (= (score Mover) (score Next))
                    }
                )
                (result P1 Win)
            )
            
            (if
                (and 
                    {
                    <Passing:endImplication>
                    (= 2 (var "FirstNoPlace")) 
                    (= (score Mover) (score Next))
                    }
                )
                (result P2 Win)
            )
            
            (if
                (and
                    <Passing:endImplication>
                    (!= (score Mover) (score Next))
                )
                (byScore)
            )
            
            }
            
        )
    )
)

Construct a Ludii game based on the following description
Whyo is a two-row mancala-style board game played in Oron, Nigeria. The name is reportedly taken from the English \Two rows of six holes with two stores. Four counters in each hole. Players sow in an anti-clockwise direction from a hole in their row. Sowing ends when the last counter falls into a hole, making it contain four counters, which are taken. Sowing also ends when the last counter falls into an empty hole. Sowing continues in any other scenario by picking up the contents of the hole where the last counter was dropped and continuing to sow. The game ends when one player can no longer move. The remaining counters are taken by the last player that was able to move and put into the store. A new round begins: The winner of the previous round now owns seven holes - the six in his row and the next hole in the opponent's row. Player takes fours from the extra hole. 
(game "Whyo"
    (players 2) 
    
    (equipment { 
        (mancalaBoard 2 6
            (track "TrackCCW" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      
        (regions P2 (sites Top))      
        (piece "Seed" Shared)
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) 
    }) 
    (rules 
        (start (set Count 4 to:(sites Track)))
        
        (play 
            (move Select 
                (from 
                    (if ("SameTurn") 
                        "LastHoleSowed" 
                        (if (= (score P1) 1)
                            (if (is Mover P1)
                                (union (sites Mover) (sites {12}))
                                (difference (sites Mover) (sites {12}))
                            )
                            (if (= (score P2) 1)
                                (if (is Mover P2)
                                    (union (sites Mover) (sites {1}))
                                    (difference (sites Mover) (sites {1}))
                                )
                                (sites Mover)
                            )
                        )
                    )
                    if:(> (count at:(from)) 0)
                )
                (then 
                    (sow
                        apply:(if (= (count at:(to)) 4)
                            (fromTo 
                                (from (to)) 
                                (to (mapEntry Mover)) 
                                count:(count at:(to))
                            )
                            (if (< (count at:(to)) 1)
                                (moveAgain)
                            )
                        )
                        (then
                            (if (no Moves Next)
                                (and 
                                    (forEach Site (union (sites P1) (sites P2))
                                        (if (> (count at:(site)) 0)
                                            (fromTo 
                                                (from (site))
                                                (to (mapEntry Mover)) 
                                                count:(count at:(site))
                                            )
                                        )
                                        (then
                                            (and {
                                                (if (< ("PiecesOwnedBy" P1) ("PiecesOwnedBy" P2))
                                                    (addScore P2 1)
                                                )
                                                (if (< ("PiecesOwnedBy" P2) ("PiecesOwnedBy" P1))
                                                    (addScore P1 1)
                                                )
                                                (if (< (var) 0)
                                                    (and { 
                                                        (forEach Site (sites Board)
                                                            (if (> (count at:(site)) 0)
                                                                (remove (site))
                                                            )
                                                        )
                                                        (forEach Site (union (sites P1) (sites P2))
                                                            (add (piece (id "Seed" Shared)) (to (site)) count:4)
                                                        )
                                                    })
                                                )
                                            })
                                        )
                                    )
                                    (set Var (+ (var) 1))
                                )
                            )
                        )
                    )
                )
            )		
        )
        
        (end
            (if (= (var) 1)
                (byScore)
            )
        )
    )
)

Construct a Ludii game based on the following description
Gonnect was invented by João Pedro Neto in 2000. It is played with a Go board and pieces, with the goal of creating a group that connects two opposite sides of the board.All the rules of Go apply, except that passing is not allowed. A player loses if he has no legal move. A player wins if they successfully connect two opposite sides of the board. The game is played on a 9x9 board
(game "Gonnect" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each)
        (regions P1 {(sites Side N) (sites Side S) })
        (regions P2 {(sites Side W) (sites Side E) })
    })
    
    (rules 
        (meta {
            (swap)
            (no Repeat)
        })
        (play 
            (do
                (move Add
                    (to (sites Empty))
                    (then ("EncloseCapture" Orthogonal))
                )
                ifAfterwards:("HasFreedom" Orthogonal)
            )
        )
        
        (end {
            (if (is Connected Mover) (result Mover Win))
            ("BlockWin")
        }) 
    )
)

Describe the mechanics of the following Ludii game
(game "Quick Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (rectangle 6 5)) 
        
        (piece "Pawn" Each 
            (or {
                "StepForwardToEmpty" 
                "CaptureForwardDiagonal"
                }
                (then
                    (and
                        (if (and (is In (last To) (sites Mover "Promotion")) (can Move ("PromoteMove" (last To))))
                            (moveAgain)
                        )
                        (set Counter)
                    )
                )
            )
        )
        
        (piece "Rook" Each 
            (move Slide 
                Orthogonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "King" Each 
            (move Step 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "Bishop" Each 
            (move Slide 
                Diagonal 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "Knight" Each 
            (move Leap 
                "KnightWalk" 
                (to 
                    if:(not ("IsFriendAt" (to))) 
                    "CaptureToPieceAndResetCounter"
                ) 
            )
        )
        (piece "Queen" Each 
            (move Slide 
                (to 
                    if:("IsEnemyAt" (to)) 
                    "CaptureToPieceAndResetCounter"
                ) 
            ) 
        )
        
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 4))
            <Start:rule>
        })
        
        (play 
            (if "SameTurn"
                ("PromoteMove" (last To))
                (do 
                    (forEach Piece)
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
                (then
                    (if
                        (= 19 (counter))
                        (and
                            (forEach Player
                                (forEach Site (sites Occupied by:Player)
                                    (if (= (what at:(site)) (id "Pawn" Player))
                                        (addScore Player 1)
                                        (if (= (what at:(site)) (id "Rook" Player))
                                            (addScore Player 5)
                                            (if (= (what at:(site)) (id "Queen" Player))
                                                (addScore Player 9)
                                                (if (!= (what at:(site)) (id "King" Player))
                                                    (addScore Player 3)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (set Var "NoEnoughCapture" 1)
                        )
                    )
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (no Moves Mover) (result Mover Draw))
            (if (= (var "NoEnoughCapture") 1) (byScore)) 
        })
    )
)
This game was invented by Joe Miccio in 1991. It is published by Amerigames International, endorsed by Chess Life, and popular on schools in the United States as a game for learning purposes. Sets for this game should be easily available in the United States, and possibly other countries.The following rules are additionally used to the chess rules:
            - Pawns can only advance one space on their first move. There is no en passant capturing.
            - A pawn can only promote to a captured piece.
            - There is no castling.
        - If 20 moves are played without a capture or promotion, the player with the most `points' on the board wins. (Pawn=1 pt., Bishop/Knight=3, Rook=5, Queen = 9.) The game starts like in the encyclopedia of Chess Variants.

Construct a Ludii game based on the following description
Hackenbush is a two-player game, invented by the mathematician John Horton Conway. It may be played on any configuration of coloured line segments connected to one another by their end points and to a ground line. The game starts in drawing a ground line and several line segments such that each line segment is connected to the ground. Any number of segments may meet at a point, and thus there may be multiple paths to ground. Every turn, the current player selects any line segment to be removed. Every line segment no longer connected to the ground by any path falls. The first player who is unable to move loses. In addition to the standard Hackenbush, there are two variants; HackenbushR-B and HackenbushR-G-B. For the Hackenbush version, all the lines are in the same colour (green). At each turn, the current player selects a coloured line to be removed, also removing any other line segments that become disconnected from the ground as a result. The game is over when there are no green edges in the graph. The second version is the Red-Blue version; HackenbushR-B. There is one red player, and one blue player. The players can remove only edges of their own colour. The last version is HackenbushR-G-B; there is a graph with red, green, and blue edges. Players may remove edges of their own colour, as well as the shared colour. For all the versions of Hackenbush, if the current player has no move, then the opposing player wins.  The game is played on the Graph1. The players play on Hackenbush version.
(game "Hackenbush" 
    (players 2) 
    (equipment { 
        (board <Board:type> use:Edge)
        (piece "Marker" Each) 
        (piece "Disc" Shared) 
        (piece "Cross" Neutral) 
        (regions All (expand (sites Bottom)))  
    }) 
    
    (rules
        (start {
            (set Neutral Edge ("Ground")) 
            <Version:start>
        })  
        (play
            (move
                Remove <Version:play>     
                (then		   		
                    (forEach Site 
                        (sites Incident Edge of:Edge at:(last To)) 
                        (if
                            ("NotConnectedToTheGround")
                            ("RemoveCutBranch")
                        )
                    )
                )
            )
        )
        (end      
            (if (no Moves Mover) (result Next Win))   
        )
    )
)

